import { ad as commonjsGlobal$1, ae as commonjsRequire$1, aK as getAugmentedNamespace } from "./index.cce5ef5a.js";
import { S as Selection$2, r as root$3, c as array$5, e as define$1, f as extend$1, R as Rgb$1, C as Color$1, g as rgbConvert$1, h as constant$f, j as interpolateNumber$1, k as color$1, l as interpolateRgb$1, m as interpolateString$1, n as nogamma$1, o as hue$2, s as select$1 } from "./transform.11eec644.js";
import { J as lighten, K as adjust$1, L as invert, N as rgba$1, O as darken } from "./Editor.5fe21e51.js";
import { i as initRange$1, m as min$3, a as max$4, o as ordinal$1 } from "./ordinal.f87dfb70.js";
import "./account.9b7625d0.js";
function selectAll$1(selector2) {
  return typeof selector2 === "string" ? new Selection$2([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection$2([array$5(selector2)], root$3);
}
const radians$1 = Math.PI / 180;
const degrees$2 = 180 / Math.PI;
const K$1 = 18, Xn$1 = 0.96422, Yn$1 = 1, Zn$1 = 0.82521, t0$3 = 4 / 29, t1$3 = 6 / 29, t2$1 = 3 * t1$3 * t1$3, t3$1 = t1$3 * t1$3 * t1$3;
function labConvert$1(o) {
  if (o instanceof Lab$1)
    return new Lab$1(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl$1)
    return hcl2lab$1(o);
  if (!(o instanceof Rgb$1))
    o = rgbConvert$1(o);
  var r = rgb2lrgb$1(o.r), g = rgb2lrgb$1(o.g), b = rgb2lrgb$1(o.b), y2 = xyz2lab$1((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn$1), x2, z;
  if (r === g && g === b)
    x2 = z = y2;
  else {
    x2 = xyz2lab$1((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn$1);
    z = xyz2lab$1((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn$1);
  }
  return new Lab$1(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function lab$2(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert$1(l) : new Lab$1(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab$1(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define$1(Lab$1, lab$2, extend$1(Color$1, {
  brighter(k2) {
    return new Lab$1(this.l + K$1 * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker(k2) {
    return new Lab$1(this.l - K$1 * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn$1 * lab2xyz$1(x2);
    y2 = Yn$1 * lab2xyz$1(y2);
    z = Zn$1 * lab2xyz$1(z);
    return new Rgb$1(
      lrgb2rgb$1(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb$1(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb$1(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab$1(t) {
  return t > t3$1 ? Math.pow(t, 1 / 3) : t / t2$1 + t0$3;
}
function lab2xyz$1(t) {
  return t > t1$3 ? t * t * t : t2$1 * (t - t0$3);
}
function lrgb2rgb$1(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb$1(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert$1(o) {
  if (o instanceof Hcl$1)
    return new Hcl$1(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab$1))
    o = labConvert$1(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl$1(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * degrees$2;
  return new Hcl$1(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function hcl$4(h, c2, l, opacity) {
  return arguments.length === 1 ? hclConvert$1(h) : new Hcl$1(h, c2, l, opacity == null ? 1 : opacity);
}
function Hcl$1(h, c2, l, opacity) {
  this.h = +h;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab$1(o) {
  if (isNaN(o.h))
    return new Lab$1(o.l, 0, 0, o.opacity);
  var h = o.h * radians$1;
  return new Lab$1(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define$1(Hcl$1, hcl$4, extend$1(Color$1, {
  brighter(k2) {
    return new Hcl$1(this.h, this.c, this.l + K$1 * (k2 == null ? 1 : k2), this.opacity);
  },
  darker(k2) {
    return new Hcl$1(this.h, this.c, this.l - K$1 * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb() {
    return hcl2lab$1(this).rgb();
  }
}));
function numberArray$1(a2, b) {
  if (!b)
    b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t) + b[i] * t;
    return c2;
  };
}
function isNumberArray$1(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray$1(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = interpolate$2(a2[i], b[i]);
  for (; i < nb; ++i)
    c2[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x2[i](t);
    return c2;
  };
}
function date$3(a2, b) {
  var d = new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}
function object$2(a2, b) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = interpolate$2(a2[k2], b[k2]);
    } else {
      c2[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i)
      c2[k2] = i[k2](t);
    return c2;
  };
}
function interpolate$2(a2, b) {
  var t = typeof b, c2;
  return b == null || t === "boolean" ? constant$f(b) : (t === "number" ? interpolateNumber$1 : t === "string" ? (c2 = color$1(b)) ? (b = c2, interpolateRgb$1) : interpolateString$1 : b instanceof color$1 ? interpolateRgb$1 : b instanceof Date ? date$3 : isNumberArray$1(b) ? numberArray$1 : Array.isArray(b) ? genericArray$1 : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$2 : interpolateNumber$1)(a2, b);
}
function interpolateRound$1(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}
function hcl$3(hue2) {
  return function(start2, end2) {
    var h = hue2((start2 = hcl$4(start2)).h, (end2 = hcl$4(end2)).h), c2 = nogamma$1(start2.c, end2.c), l = nogamma$1(start2.l, end2.l), opacity = nogamma$1(start2.opacity, end2.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c2(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
const interpolateHcl = hcl$3(hue$2);
function ascending$4(a2, b) {
  return a2 == null || b == null ? NaN : a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function descending$4(a2, b) {
  return a2 == null || b == null ? NaN : b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function bisector$1(f) {
  let compare1, compare2, delta;
  if (f.length !== 2) {
    compare1 = ascending$4;
    compare2 = (d, x2) => ascending$4(f(d), x2);
    delta = (d, x2) => f(d) - x2;
  } else {
    compare1 = f === ascending$4 || f === descending$4 ? f : zero$1;
    compare2 = f;
    delta = f;
  }
  function left2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right2(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center2(a2, x2, lo = 0, hi = a2.length) {
    const i = left2(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left: left2, center: center2, right: right2 };
}
function zero$1() {
  return 0;
}
function number$7(x2) {
  return x2 === null ? NaN : +x2;
}
const ascendingBisect$1 = bisector$1(ascending$4);
const bisectRight$1 = ascendingBisect$1.right;
bisector$1(number$7).center;
const bisect = bisectRight$1;
var e10$1 = Math.sqrt(50), e5$1 = Math.sqrt(10), e2$1 = Math.sqrt(2);
function ticks$1(start2, stop, count2) {
  var reverse2, i = -1, n, ticks2, step2;
  stop = +stop, start2 = +start2, count2 = +count2;
  if (start2 === stop && count2 > 0)
    return [start2];
  if (reverse2 = stop < start2)
    n = start2, start2 = stop, stop = n;
  if ((step2 = tickIncrement$1(start2, stop, count2)) === 0 || !isFinite(step2))
    return [];
  if (step2 > 0) {
    let r0 = Math.round(start2 / step2), r1 = Math.round(stop / step2);
    if (r0 * step2 < start2)
      ++r0;
    if (r1 * step2 > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) * step2;
  } else {
    step2 = -step2;
    let r0 = Math.round(start2 * step2), r1 = Math.round(stop * step2);
    if (r0 / step2 < start2)
      ++r0;
    if (r1 / step2 > stop)
      --r1;
    ticks2 = new Array(n = r1 - r0 + 1);
    while (++i < n)
      ticks2[i] = (r0 + i) / step2;
  }
  if (reverse2)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement$1(start2, stop, count2) {
  var step2 = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step2) / Math.LN10), error = step2 / Math.pow(10, power);
  return power >= 0 ? (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10$1 ? 10 : error >= e5$1 ? 5 : error >= e2$1 ? 2 : 1);
}
function tickStep$1(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10$1)
    step1 *= 10;
  else if (error >= e5$1)
    step1 *= 5;
  else if (error >= e2$1)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$6(x2) {
  return +x2;
}
var unit$1 = [0, 1];
function identity$d(x2) {
  return x2;
}
function normalize$3(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constants(isNaN(b) ? NaN : 0.5);
}
function clamper$1(a2, b) {
  var t;
  if (a2 > b)
    t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap$1(domain, range2, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize$3(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize$3(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap$1(domain, range2, interpolate2) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize$3(domain[i], domain[i + 1]);
    r[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisect(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy$3(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$4() {
  var domain = unit$1, range2 = unit$1, interpolate2 = interpolate$2, transform2, untransform, unknown, clamp = identity$d, piecewise2, output, input;
  function rescale() {
    var n = Math.min(domain.length, range2.length);
    if (clamp !== identity$d)
      clamp = clamper$1(domain[0], domain[n - 1]);
    piecewise2 = n > 2 ? polymap$1 : bimap$1;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform2), range2, interpolate2)))(transform2(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform2), interpolateNumber$1)))(y2)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = Array.from(_2, number$6), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = Array.from(_2), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return range2 = Array.from(_2), interpolate2 = interpolateRound$1, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? true : identity$d, rescale()) : clamp !== identity$d;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, rescale()) : interpolate2;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t, u) {
    transform2 = t, untransform = u;
    return rescale();
  };
}
function continuous$1() {
  return transformer$4()(identity$d, identity$d);
}
function formatDecimal$1(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts$1(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent$2(x2) {
  return x2 = formatDecimalParts$1(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup$1(grouping, thousands) {
  return function(value, width2) {
    var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
    while (i > 0 && g > 0) {
      if (length2 + g + 1 > width2)
        g = Math.max(1, width2 - length2);
      t.push(value.substring(i -= g, i + g));
      if ((length2 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals$1(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re$1 = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier$1(specifier) {
  if (!(match = re$1.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier$1({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier$1.prototype = FormatSpecifier$1.prototype;
function FormatSpecifier$1(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier$1.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim$1(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent$1;
function formatPrefixAuto$1(x2, p) {
  var d = formatDecimalParts$1(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent$1 = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts$1(x2, Math.max(0, p + i - 1))[0];
}
function formatRounded$1(x2, p) {
  var d = formatDecimalParts$1(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes$1 = {
  "%": (x2, p) => (x2 * 100).toFixed(p),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal$1,
  "e": (x2, p) => x2.toExponential(p),
  "f": (x2, p) => x2.toFixed(p),
  "g": (x2, p) => x2.toPrecision(p),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p) => formatRounded$1(x2 * 100, p),
  "r": formatRounded$1,
  "s": formatPrefixAuto$1,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$c(x2) {
  return x2;
}
var map$4 = Array.prototype.map, prefixes$1 = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$3(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$c : formatGroup$1(map$4.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$c : formatNumerals$1(map$4.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "\u2212" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier$1(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes$1[type2])
      precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes$1[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2)
          value = formatTrim$1(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes$1[8 + prefixExponent$1 / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding2;
          break;
        case "=":
          value = valuePrefix + padding2 + value + valueSuffix;
          break;
        case "^":
          value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
          break;
        default:
          value = padding2 + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier$1(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent$2(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes$1[8 + e / 3];
    return function(value2) {
      return f(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$3;
var format$2;
var formatPrefix$1;
defaultLocale$3({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$3(definition) {
  locale$3 = formatLocale$3(definition);
  format$2 = locale$3.format;
  formatPrefix$1 = locale$3.formatPrefix;
  return locale$3;
}
function precisionFixed$1(step2) {
  return Math.max(0, -exponent$2(Math.abs(step2)));
}
function precisionPrefix$1(step2, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent$2(value) / 3))) * 3 - exponent$2(Math.abs(step2)));
}
function precisionRound$1(step2, max2) {
  step2 = Math.abs(step2), max2 = Math.abs(max2) - step2;
  return Math.max(0, exponent$2(max2) - exponent$2(step2)) + 1;
}
function tickFormat$1(start2, stop, count2, specifier) {
  var step2 = tickStep$1(start2, stop, count2), precision;
  specifier = formatSpecifier$1(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix$1(step2, value)))
        specifier.precision = precision;
      return formatPrefix$1(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound$1(step2, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed$1(step2)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$2(specifier);
}
function linearish$1(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks$1(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat$1(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain();
    var i0 = 0;
    var i1 = d.length - 1;
    var start2 = d[i0];
    var stop = d[i1];
    var prestep;
    var step2;
    var maxIter = 10;
    if (stop < start2) {
      step2 = start2, start2 = stop, stop = step2;
      step2 = i0, i0 = i1, i1 = step2;
    }
    while (maxIter-- > 0) {
      step2 = tickIncrement$1(start2, stop, count2);
      if (step2 === prestep) {
        d[i0] = start2;
        d[i1] = stop;
        return domain(d);
      } else if (step2 > 0) {
        start2 = Math.floor(start2 / step2) * step2;
        stop = Math.ceil(stop / step2) * step2;
      } else if (step2 < 0) {
        start2 = Math.ceil(start2 * step2) / step2;
        stop = Math.floor(stop * step2) / step2;
      } else {
        break;
      }
      prestep = step2;
    }
    return scale;
  };
  return scale;
}
function linear$3() {
  var scale = continuous$1();
  scale.copy = function() {
    return copy$3(scale, linear$3());
  };
  initRange$1.apply(scale, arguments);
  return linearish$1(scale);
}
function nice$1(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x02 = domain[i0], x12 = domain[i1], t;
  if (x12 < x02) {
    t = i0, i0 = i1, i1 = t;
    t = x02, x02 = x12, x12 = t;
  }
  domain[i0] = interval2.floor(x02);
  domain[i1] = interval2.ceil(x12);
  return domain;
}
var t0$2 = new Date(), t1$2 = new Date();
function newInterval$1(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step2) {
    return offseti(date2 = new Date(+date2), step2 == null ? 1 : Math.floor(step2)), date2;
  };
  interval2.range = function(start2, stop, step2) {
    var range2 = [], previous;
    start2 = interval2.ceil(start2);
    step2 = step2 == null ? 1 : Math.floor(step2);
    if (!(start2 < stop) || !(step2 > 0))
      return range2;
    do
      range2.push(previous = new Date(+start2)), offseti(start2, step2), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval$1(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step2) {
      if (date2 >= date2) {
        if (step2 < 0)
          while (++step2 <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step2 >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = function(start2, end2) {
      t0$2.setTime(+start2), t1$2.setTime(+end2);
      floori(t0$2), floori(t1$2);
      return Math.floor(count2(t0$2, t1$2));
    };
    interval2.every = function(step2) {
      step2 = Math.floor(step2);
      return !isFinite(step2) || !(step2 > 0) ? null : !(step2 > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step2 === 0;
      } : function(d) {
        return interval2.count(0, d) % step2 === 0;
      });
    };
  }
  return interval2;
}
var millisecond$1 = newInterval$1(function() {
}, function(date2, step2) {
  date2.setTime(+date2 + step2);
}, function(start2, end2) {
  return end2 - start2;
});
millisecond$1.every = function(k2) {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond$1;
  return newInterval$1(function(date2) {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, function(date2, step2) {
    date2.setTime(+date2 + step2 * k2);
  }, function(start2, end2) {
    return (end2 - start2) / k2;
  });
};
const millisecond$2 = millisecond$1;
millisecond$1.range;
const durationSecond$2 = 1e3;
const durationMinute$2 = durationSecond$2 * 60;
const durationHour$2 = durationMinute$2 * 60;
const durationDay$2 = durationHour$2 * 24;
const durationWeek$2 = durationDay$2 * 7;
const durationMonth$1 = durationDay$2 * 30;
const durationYear$1 = durationDay$2 * 365;
var second$1 = newInterval$1(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationSecond$2);
}, function(start2, end2) {
  return (end2 - start2) / durationSecond$2;
}, function(date2) {
  return date2.getUTCSeconds();
});
const utcSecond$1 = second$1;
second$1.range;
var minute$1 = newInterval$1(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$2);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$2);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$2;
}, function(date2) {
  return date2.getMinutes();
});
const timeMinute$1 = minute$1;
minute$1.range;
var hour$1 = newInterval$1(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$2 - date2.getMinutes() * durationMinute$2);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$2);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$2;
}, function(date2) {
  return date2.getHours();
});
const timeHour$1 = hour$1;
hour$1.range;
var day$1 = newInterval$1(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step2) => date2.setDate(date2.getDate() + step2),
  (start2, end2) => (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$2) / durationDay$2,
  (date2) => date2.getDate() - 1
);
const timeDay$1 = day$1;
day$1.range;
function weekday$1(i) {
  return newInterval$1(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setDate(date2.getDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$2) / durationWeek$2;
  });
}
var sunday$1 = weekday$1(0);
var monday$1 = weekday$1(1);
var tuesday$1 = weekday$1(2);
var wednesday$1 = weekday$1(3);
var thursday$1 = weekday$1(4);
var friday$1 = weekday$1(5);
var saturday$1 = weekday$1(6);
sunday$1.range;
monday$1.range;
tuesday$1.range;
wednesday$1.range;
thursday$1.range;
friday$1.range;
saturday$1.range;
var month$1 = newInterval$1(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setMonth(date2.getMonth() + step2);
}, function(start2, end2) {
  return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
const timeMonth$1 = month$1;
month$1.range;
var year$1 = newInterval$1(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setFullYear(date2.getFullYear() + step2);
}, function(start2, end2) {
  return end2.getFullYear() - start2.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year$1.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval$1(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setFullYear(date2.getFullYear() + step2 * k2);
  });
};
const timeYear$1 = year$1;
year$1.range;
var utcMinute$2 = newInterval$1(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$2);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$2;
}, function(date2) {
  return date2.getUTCMinutes();
});
const utcMinute$3 = utcMinute$2;
utcMinute$2.range;
var utcHour$2 = newInterval$1(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$2);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$2;
}, function(date2) {
  return date2.getUTCHours();
});
const utcHour$3 = utcHour$2;
utcHour$2.range;
var utcDay$2 = newInterval$1(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCDate(date2.getUTCDate() + step2);
}, function(start2, end2) {
  return (end2 - start2) / durationDay$2;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
const utcDay$3 = utcDay$2;
utcDay$2.range;
function utcWeekday$1(i) {
  return newInterval$1(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCDate(date2.getUTCDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2) / durationWeek$2;
  });
}
var utcSunday$1 = utcWeekday$1(0);
var utcMonday$1 = utcWeekday$1(1);
var utcTuesday$1 = utcWeekday$1(2);
var utcWednesday$1 = utcWeekday$1(3);
var utcThursday$1 = utcWeekday$1(4);
var utcFriday$1 = utcWeekday$1(5);
var utcSaturday$1 = utcWeekday$1(6);
utcSunday$1.range;
utcMonday$1.range;
utcTuesday$1.range;
utcWednesday$1.range;
utcThursday$1.range;
utcFriday$1.range;
utcSaturday$1.range;
var utcMonth$2 = newInterval$1(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCMonth(date2.getUTCMonth() + step2);
}, function(start2, end2) {
  return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
const utcMonth$3 = utcMonth$2;
utcMonth$2.range;
var utcYear$2 = newInterval$1(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step2);
}, function(start2, end2) {
  return end2.getUTCFullYear() - start2.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear$2.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval$1(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step2 * k2);
  });
};
const utcYear$3 = utcYear$2;
utcYear$2.range;
function ticker(year2, month2, week, day2, hour2, minute2) {
  const tickIntervals = [
    [utcSecond$1, 1, durationSecond$2],
    [utcSecond$1, 5, 5 * durationSecond$2],
    [utcSecond$1, 15, 15 * durationSecond$2],
    [utcSecond$1, 30, 30 * durationSecond$2],
    [minute2, 1, durationMinute$2],
    [minute2, 5, 5 * durationMinute$2],
    [minute2, 15, 15 * durationMinute$2],
    [minute2, 30, 30 * durationMinute$2],
    [hour2, 1, durationHour$2],
    [hour2, 3, 3 * durationHour$2],
    [hour2, 6, 6 * durationHour$2],
    [hour2, 12, 12 * durationHour$2],
    [day2, 1, durationDay$2],
    [day2, 2, 2 * durationDay$2],
    [week, 1, durationWeek$2],
    [month2, 1, durationMonth$1],
    [month2, 3, 3 * durationMonth$1],
    [year2, 1, durationYear$1]
  ];
  function ticks2(start2, stop, count2) {
    const reverse2 = stop < start2;
    if (reverse2)
      [start2, stop] = [stop, start2];
    const interval2 = count2 && typeof count2.range === "function" ? count2 : tickInterval(start2, stop, count2);
    const ticks3 = interval2 ? interval2.range(start2, +stop + 1) : [];
    return reverse2 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start2, stop, count2) {
    const target = Math.abs(stop - start2) / count2;
    const i = bisector$1(([, , step3]) => step3).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year2.every(tickStep$1(start2 / durationYear$1, stop / durationYear$1, count2));
    if (i === 0)
      return millisecond$2.every(Math.max(tickStep$1(start2, stop, count2), 1));
    const [t, step2] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t.every(step2);
  }
  return [ticks2, tickInterval];
}
ticker(utcYear$3, utcMonth$3, utcSunday$1, utcDay$3, utcHour$3, utcMinute$3);
const [timeTicks, timeTickInterval] = ticker(timeYear$1, timeMonth$1, sunday$1, timeDay$1, timeHour$1, timeMinute$1);
function localDate$1(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate$1(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate$1(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale$2(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe$1(locale_periods), periodLookup = formatLookup$1(locale_periods), weekdayRe = formatRe$1(locale_weekdays), weekdayLookup = formatLookup$1(locale_weekdays), shortWeekdayRe = formatRe$1(locale_shortWeekdays), shortWeekdayLookup = formatLookup$1(locale_shortWeekdays), monthRe = formatRe$1(locale_months), monthLookup = formatLookup$1(locale_months), shortMonthRe = formatRe$1(locale_shortMonths), shortMonthLookup = formatLookup$1(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth$1,
    "e": formatDayOfMonth$1,
    "f": formatMicroseconds$1,
    "g": formatYearISO$1,
    "G": formatFullYearISO$1,
    "H": formatHour24$1,
    "I": formatHour12$1,
    "j": formatDayOfYear$1,
    "L": formatMilliseconds$1,
    "m": formatMonthNumber$1,
    "M": formatMinutes$1,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp$1,
    "s": formatUnixTimestampSeconds$1,
    "S": formatSeconds$1,
    "u": formatWeekdayNumberMonday$1,
    "U": formatWeekNumberSunday$1,
    "V": formatWeekNumberISO$1,
    "w": formatWeekdayNumberSunday$1,
    "W": formatWeekNumberMonday$1,
    "x": null,
    "X": null,
    "y": formatYear$2,
    "Y": formatFullYear$1,
    "Z": formatZone$1,
    "%": formatLiteralPercent$1
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth$1,
    "e": formatUTCDayOfMonth$1,
    "f": formatUTCMicroseconds$1,
    "g": formatUTCYearISO$1,
    "G": formatUTCFullYearISO$1,
    "H": formatUTCHour24$1,
    "I": formatUTCHour12$1,
    "j": formatUTCDayOfYear$1,
    "L": formatUTCMilliseconds$1,
    "m": formatUTCMonthNumber$1,
    "M": formatUTCMinutes$1,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp$1,
    "s": formatUnixTimestampSeconds$1,
    "S": formatUTCSeconds$1,
    "u": formatUTCWeekdayNumberMonday$1,
    "U": formatUTCWeekNumberSunday$1,
    "V": formatUTCWeekNumberISO$1,
    "w": formatUTCWeekdayNumberSunday$1,
    "W": formatUTCWeekNumberMonday$1,
    "x": null,
    "X": null,
    "y": formatUTCYear$1,
    "Y": formatUTCFullYear$1,
    "Z": formatUTCZone$1,
    "%": formatLiteralPercent$1
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth$1,
    "e": parseDayOfMonth$1,
    "f": parseMicroseconds$1,
    "g": parseYear$1,
    "G": parseFullYear$1,
    "H": parseHour24$1,
    "I": parseHour24$1,
    "j": parseDayOfYear$1,
    "L": parseMilliseconds$1,
    "m": parseMonthNumber$1,
    "M": parseMinutes$1,
    "p": parsePeriod,
    "q": parseQuarter$1,
    "Q": parseUnixTimestamp$1,
    "s": parseUnixTimestampSeconds$1,
    "S": parseSeconds$1,
    "u": parseWeekdayNumberMonday$1,
    "U": parseWeekNumberSunday$1,
    "V": parseWeekNumberISO$1,
    "w": parseWeekdayNumberSunday$1,
    "W": parseWeekNumberMonday$1,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear$1,
    "Y": parseFullYear$1,
    "Z": parseZone$1,
    "%": parseLiteralPercent$1
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads$1[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2])
            c2 = format2(date2, pad2);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate$1(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate$1(newDate$1(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday$1.ceil(week) : utcMonday$1(week);
          week = utcDay$3.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate$1(newDate$1(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday$1.ceil(week) : monday$1(week);
          week = timeDay$1.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate$1(newDate$1(d.y, 0, 1)).getUTCDay() : localDate$1(newDate$1(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate$1(d);
      }
      return localDate$1(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c2, parse2;
    while (i < n) {
      if (j >= m)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads$1 ? specifier.charAt(i++) : c2];
        if (!parse2 || (j = parse2(d, string, j)) < 0)
          return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads$1 = { "-": "", "_": " ", "0": "0" }, numberRe$1 = /^\s*\d+/, percentRe$1 = /^%/, requoteRe$1 = /[\\^$*+?|[\]().{}]/g;
function pad$2(value, fill, width2) {
  var sign2 = value < 0 ? "-" : "", string = (sign2 ? -value : value) + "", length2 = string.length;
  return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string : string);
}
function requote$1(s2) {
  return s2.replace(requoteRe$1, "\\$&");
}
function formatRe$1(names) {
  return new RegExp("^(?:" + names.map(requote$1).join("|") + ")", "i");
}
function formatLookup$1(names) {
  return new Map(names.map((name2, i) => [name2.toLowerCase(), i]));
}
function parseWeekdayNumberSunday$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone$1(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent$1(d, string, i) {
  var n = percentRe$1.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds$1(d, string, i) {
  var n = numberRe$1.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth$1(d, p) {
  return pad$2(d.getDate(), p, 2);
}
function formatHour24$1(d, p) {
  return pad$2(d.getHours(), p, 2);
}
function formatHour12$1(d, p) {
  return pad$2(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear$1(d, p) {
  return pad$2(1 + timeDay$1.count(timeYear$1(d), d), p, 3);
}
function formatMilliseconds$1(d, p) {
  return pad$2(d.getMilliseconds(), p, 3);
}
function formatMicroseconds$1(d, p) {
  return formatMilliseconds$1(d, p) + "000";
}
function formatMonthNumber$1(d, p) {
  return pad$2(d.getMonth() + 1, p, 2);
}
function formatMinutes$1(d, p) {
  return pad$2(d.getMinutes(), p, 2);
}
function formatSeconds$1(d, p) {
  return pad$2(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday$1(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday$1(d, p) {
  return pad$2(sunday$1.count(timeYear$1(d) - 1, d), p, 2);
}
function dISO$1(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday$1(d) : thursday$1.ceil(d);
}
function formatWeekNumberISO$1(d, p) {
  d = dISO$1(d);
  return pad$2(thursday$1.count(timeYear$1(d), d) + (timeYear$1(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday$1(d) {
  return d.getDay();
}
function formatWeekNumberMonday$1(d, p) {
  return pad$2(monday$1.count(timeYear$1(d) - 1, d), p, 2);
}
function formatYear$2(d, p) {
  return pad$2(d.getFullYear() % 100, p, 2);
}
function formatYearISO$1(d, p) {
  d = dISO$1(d);
  return pad$2(d.getFullYear() % 100, p, 2);
}
function formatFullYear$1(d, p) {
  return pad$2(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO$1(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday$1(d) : thursday$1.ceil(d);
  return pad$2(d.getFullYear() % 1e4, p, 4);
}
function formatZone$1(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad$2(z / 60 | 0, "0", 2) + pad$2(z % 60, "0", 2);
}
function formatUTCDayOfMonth$1(d, p) {
  return pad$2(d.getUTCDate(), p, 2);
}
function formatUTCHour24$1(d, p) {
  return pad$2(d.getUTCHours(), p, 2);
}
function formatUTCHour12$1(d, p) {
  return pad$2(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear$1(d, p) {
  return pad$2(1 + utcDay$3.count(utcYear$3(d), d), p, 3);
}
function formatUTCMilliseconds$1(d, p) {
  return pad$2(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds$1(d, p) {
  return formatUTCMilliseconds$1(d, p) + "000";
}
function formatUTCMonthNumber$1(d, p) {
  return pad$2(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes$1(d, p) {
  return pad$2(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds$1(d, p) {
  return pad$2(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday$1(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday$1(d, p) {
  return pad$2(utcSunday$1.count(utcYear$3(d) - 1, d), p, 2);
}
function UTCdISO$1(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday$1(d) : utcThursday$1.ceil(d);
}
function formatUTCWeekNumberISO$1(d, p) {
  d = UTCdISO$1(d);
  return pad$2(utcThursday$1.count(utcYear$3(d), d) + (utcYear$3(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday$1(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday$1(d, p) {
  return pad$2(utcMonday$1.count(utcYear$3(d) - 1, d), p, 2);
}
function formatUTCYear$1(d, p) {
  return pad$2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO$1(d, p) {
  d = UTCdISO$1(d);
  return pad$2(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear$1(d, p) {
  return pad$2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO$1(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday$1(d) : utcThursday$1.ceil(d);
  return pad$2(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone$1() {
  return "+0000";
}
function formatLiteralPercent$1() {
  return "%";
}
function formatUnixTimestamp$1(d) {
  return +d;
}
function formatUnixTimestampSeconds$1(d) {
  return Math.floor(+d / 1e3);
}
var locale$2;
var timeFormat$1;
defaultLocale$2({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale$2(definition) {
  locale$2 = formatLocale$2(definition);
  timeFormat$1 = locale$2.format;
  locale$2.parse;
  locale$2.utcFormat;
  locale$2.utcParse;
  return locale$2;
}
function date$2(t) {
  return new Date(t);
}
function number$5(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar$1(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2) {
  var scale = continuous$1(), invert2 = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? domain(Array.from(_2, number$5)) : domain().map(date$2);
  };
  scale.ticks = function(interval2) {
    var d = domain();
    return ticks2(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2) {
    var d = domain();
    if (!interval2 || typeof interval2.range !== "function")
      interval2 = tickInterval(d[0], d[d.length - 1], interval2 == null ? 10 : interval2);
    return interval2 ? domain(nice$1(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy$3(scale, calendar$1(ticks2, tickInterval, year2, month2, week, day2, hour2, minute2, second2, format2));
  };
  return scale;
}
function time$2() {
  return initRange$1.apply(calendar$1(timeTicks, timeTickInterval, timeYear$1, timeMonth$1, sunday$1, timeDay$1, timeHour$1, timeMinute$1, utcSecond$1, timeFormat$1).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
var moment_min = { exports: {} };
(function(module2, exports2) {
  !function(e, t) {
    module2.exports = t();
  }(commonjsGlobal$1, function() {
    var H;
    function f() {
      return H.apply(null, arguments);
    }
    function a2(e3) {
      return e3 instanceof Array || "[object Array]" === Object.prototype.toString.call(e3);
    }
    function F(e3) {
      return null != e3 && "[object Object]" === Object.prototype.toString.call(e3);
    }
    function c2(e3, t4) {
      return Object.prototype.hasOwnProperty.call(e3, t4);
    }
    function L(e3) {
      if (Object.getOwnPropertyNames)
        return 0 === Object.getOwnPropertyNames(e3).length;
      for (var t4 in e3)
        if (c2(e3, t4))
          return;
      return 1;
    }
    function o(e3) {
      return void 0 === e3;
    }
    function u(e3) {
      return "number" == typeof e3 || "[object Number]" === Object.prototype.toString.call(e3);
    }
    function V(e3) {
      return e3 instanceof Date || "[object Date]" === Object.prototype.toString.call(e3);
    }
    function G(e3, t4) {
      for (var n2 = [], s3 = e3.length, i2 = 0; i2 < s3; ++i2)
        n2.push(t4(e3[i2], i2));
      return n2;
    }
    function E2(e3, t4) {
      for (var n2 in t4)
        c2(t4, n2) && (e3[n2] = t4[n2]);
      return c2(t4, "toString") && (e3.toString = t4.toString), c2(t4, "valueOf") && (e3.valueOf = t4.valueOf), e3;
    }
    function l(e3, t4, n2, s3) {
      return Pt(e3, t4, n2, s3, true).utc();
    }
    function m(e3) {
      return null == e3._pf && (e3._pf = { empty: false, unusedTokens: [], unusedInput: [], overflow: -2, charsLeftOver: 0, nullInput: false, invalidEra: null, invalidMonth: null, invalidFormat: false, userInvalidated: false, iso: false, parsedDateParts: [], era: null, meridiem: null, rfc2822: false, weekdayMismatch: false }), e3._pf;
    }
    function A5(e3) {
      if (null == e3._isValid) {
        var t4 = m(e3), n2 = j.call(t4.parsedDateParts, function(e4) {
          return null != e4;
        }), n2 = !isNaN(e3._d.getTime()) && t4.overflow < 0 && !t4.empty && !t4.invalidEra && !t4.invalidMonth && !t4.invalidWeekday && !t4.weekdayMismatch && !t4.nullInput && !t4.invalidFormat && !t4.userInvalidated && (!t4.meridiem || t4.meridiem && n2);
        if (e3._strict && (n2 = n2 && 0 === t4.charsLeftOver && 0 === t4.unusedTokens.length && void 0 === t4.bigHour), null != Object.isFrozen && Object.isFrozen(e3))
          return n2;
        e3._isValid = n2;
      }
      return e3._isValid;
    }
    function I(e3) {
      var t4 = l(NaN);
      return null != e3 ? E2(m(t4), e3) : m(t4).userInvalidated = true, t4;
    }
    var j = Array.prototype.some || function(e3) {
      for (var t4 = Object(this), n2 = t4.length >>> 0, s3 = 0; s3 < n2; s3++)
        if (s3 in t4 && e3.call(this, t4[s3], s3, t4))
          return true;
      return false;
    }, Z = f.momentProperties = [], z = false;
    function $(e3, t4) {
      var n2, s3, i2, r2 = Z.length;
      if (o(t4._isAMomentObject) || (e3._isAMomentObject = t4._isAMomentObject), o(t4._i) || (e3._i = t4._i), o(t4._f) || (e3._f = t4._f), o(t4._l) || (e3._l = t4._l), o(t4._strict) || (e3._strict = t4._strict), o(t4._tzm) || (e3._tzm = t4._tzm), o(t4._isUTC) || (e3._isUTC = t4._isUTC), o(t4._offset) || (e3._offset = t4._offset), o(t4._pf) || (e3._pf = m(t4)), o(t4._locale) || (e3._locale = t4._locale), 0 < r2)
        for (n2 = 0; n2 < r2; n2++)
          o(i2 = t4[s3 = Z[n2]]) || (e3[s3] = i2);
      return e3;
    }
    function q(e3) {
      $(this, e3), this._d = new Date(null != e3._d ? e3._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), false === z && (z = true, f.updateOffset(this), z = false);
    }
    function h(e3) {
      return e3 instanceof q || null != e3 && null != e3._isAMomentObject;
    }
    function B2(e3) {
      false === f.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + e3);
    }
    function e(r2, a3) {
      var o2 = true;
      return E2(function() {
        if (null != f.deprecationHandler && f.deprecationHandler(null, r2), o2) {
          for (var e3, t4, n2 = [], s3 = arguments.length, i2 = 0; i2 < s3; i2++) {
            if (e3 = "", "object" == typeof arguments[i2]) {
              for (t4 in e3 += "\n[" + i2 + "] ", arguments[0])
                c2(arguments[0], t4) && (e3 += t4 + ": " + arguments[0][t4] + ", ");
              e3 = e3.slice(0, -2);
            } else
              e3 = arguments[i2];
            n2.push(e3);
          }
          B2(r2 + "\nArguments: " + Array.prototype.slice.call(n2).join("") + "\n" + new Error().stack), o2 = false;
        }
        return a3.apply(this, arguments);
      }, a3);
    }
    var J = {};
    function Q(e3, t4) {
      null != f.deprecationHandler && f.deprecationHandler(e3, t4), J[e3] || (B2(t4), J[e3] = true);
    }
    function d(e3) {
      return "undefined" != typeof Function && e3 instanceof Function || "[object Function]" === Object.prototype.toString.call(e3);
    }
    function X3(e3, t4) {
      var n2, s3 = E2({}, e3);
      for (n2 in t4)
        c2(t4, n2) && (F(e3[n2]) && F(t4[n2]) ? (s3[n2] = {}, E2(s3[n2], e3[n2]), E2(s3[n2], t4[n2])) : null != t4[n2] ? s3[n2] = t4[n2] : delete s3[n2]);
      for (n2 in e3)
        c2(e3, n2) && !c2(t4, n2) && F(e3[n2]) && (s3[n2] = E2({}, s3[n2]));
      return s3;
    }
    function K2(e3) {
      null != e3 && this.set(e3);
    }
    f.suppressDeprecationWarnings = false, f.deprecationHandler = null;
    var ee = Object.keys || function(e3) {
      var t4, n2 = [];
      for (t4 in e3)
        c2(e3, t4) && n2.push(t4);
      return n2;
    };
    function r(e3, t4, n2) {
      var s3 = "" + Math.abs(e3);
      return (0 <= e3 ? n2 ? "+" : "" : "-") + Math.pow(10, Math.max(0, t4 - s3.length)).toString().substr(1) + s3;
    }
    var te = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, ne = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, se = {}, ie = {};
    function s2(e3, t4, n2, s3) {
      var i2 = "string" == typeof s3 ? function() {
        return this[s3]();
      } : s3;
      e3 && (ie[e3] = i2), t4 && (ie[t4[0]] = function() {
        return r(i2.apply(this, arguments), t4[1], t4[2]);
      }), n2 && (ie[n2] = function() {
        return this.localeData().ordinal(i2.apply(this, arguments), e3);
      });
    }
    function re2(e3, t4) {
      return e3.isValid() ? (t4 = ae(t4, e3.localeData()), se[t4] = se[t4] || function(s3) {
        for (var e4, i2 = s3.match(te), t5 = 0, r2 = i2.length; t5 < r2; t5++)
          ie[i2[t5]] ? i2[t5] = ie[i2[t5]] : i2[t5] = (e4 = i2[t5]).match(/\[[\s\S]/) ? e4.replace(/^\[|\]$/g, "") : e4.replace(/\\/g, "");
        return function(e6) {
          for (var t6 = "", n2 = 0; n2 < r2; n2++)
            t6 += d(i2[n2]) ? i2[n2].call(e6, s3) : i2[n2];
          return t6;
        };
      }(t4), se[t4](e3)) : e3.localeData().invalidDate();
    }
    function ae(e3, t4) {
      var n2 = 5;
      function s3(e4) {
        return t4.longDateFormat(e4) || e4;
      }
      for (ne.lastIndex = 0; 0 <= n2 && ne.test(e3); )
        e3 = e3.replace(ne, s3), ne.lastIndex = 0, --n2;
      return e3;
    }
    var oe = {};
    function t(e3, t4) {
      var n2 = e3.toLowerCase();
      oe[n2] = oe[n2 + "s"] = oe[t4] = e3;
    }
    function _2(e3) {
      return "string" == typeof e3 ? oe[e3] || oe[e3.toLowerCase()] : void 0;
    }
    function ue(e3) {
      var t4, n2, s3 = {};
      for (n2 in e3)
        c2(e3, n2) && (t4 = _2(n2)) && (s3[t4] = e3[n2]);
      return s3;
    }
    var le = {};
    function n(e3, t4) {
      le[e3] = t4;
    }
    function he(e3) {
      return e3 % 4 == 0 && e3 % 100 != 0 || e3 % 400 == 0;
    }
    function y2(e3) {
      return e3 < 0 ? Math.ceil(e3) || 0 : Math.floor(e3);
    }
    function g(e3) {
      var e3 = +e3, t4 = 0;
      return t4 = 0 != e3 && isFinite(e3) ? y2(e3) : t4;
    }
    function de(t4, n2) {
      return function(e3) {
        return null != e3 ? (fe(this, t4, e3), f.updateOffset(this, n2), this) : ce(this, t4);
      };
    }
    function ce(e3, t4) {
      return e3.isValid() ? e3._d["get" + (e3._isUTC ? "UTC" : "") + t4]() : NaN;
    }
    function fe(e3, t4, n2) {
      e3.isValid() && !isNaN(n2) && ("FullYear" === t4 && he(e3.year()) && 1 === e3.month() && 29 === e3.date() ? (n2 = g(n2), e3._d["set" + (e3._isUTC ? "UTC" : "") + t4](n2, e3.month(), We(n2, e3.month()))) : e3._d["set" + (e3._isUTC ? "UTC" : "") + t4](n2));
    }
    var i = /\d/, w2 = /\d\d/, me = /\d{3}/, _e = /\d{4}/, ye = /[+-]?\d{6}/, p = /\d\d?/, ge = /\d\d\d\d?/, we = /\d\d\d\d\d\d?/, pe = /\d{1,3}/, ke = /\d{1,4}/, ve = /[+-]?\d{1,6}/, Me = /\d+/, De = /[+-]?\d+/, Se = /Z|[+-]\d\d:?\d\d/gi, Ye = /Z|[+-]\d\d(?::?\d\d)?/gi, k2 = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
    function v(e3, n2, s3) {
      be[e3] = d(n2) ? n2 : function(e4, t4) {
        return e4 && s3 ? s3 : n2;
      };
    }
    function Oe(e3, t4) {
      return c2(be, e3) ? be[e3](t4._strict, t4._locale) : new RegExp(M2(e3.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(e4, t5, n2, s3, i2) {
        return t5 || n2 || s3 || i2;
      })));
    }
    function M2(e3) {
      return e3.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    var be = {}, xe = {};
    function D2(e3, n2) {
      var t4, s3, i2 = n2;
      for ("string" == typeof e3 && (e3 = [e3]), u(n2) && (i2 = function(e4, t5) {
        t5[n2] = g(e4);
      }), s3 = e3.length, t4 = 0; t4 < s3; t4++)
        xe[e3[t4]] = i2;
    }
    function Te(e3, i2) {
      D2(e3, function(e4, t4, n2, s3) {
        n2._w = n2._w || {}, i2(e4, n2._w, n2, s3);
      });
    }
    var S, Y3 = 0, O = 1, b = 2, x2 = 3, T = 4, N = 5, Ne = 6, Pe = 7, Re = 8;
    function We(e3, t4) {
      if (isNaN(e3) || isNaN(t4))
        return NaN;
      var n2 = (t4 % (n2 = 12) + n2) % n2;
      return e3 += (t4 - n2) / 12, 1 == n2 ? he(e3) ? 29 : 28 : 31 - n2 % 7 % 2;
    }
    S = Array.prototype.indexOf || function(e3) {
      for (var t4 = 0; t4 < this.length; ++t4)
        if (this[t4] === e3)
          return t4;
      return -1;
    }, s2("M", ["MM", 2], "Mo", function() {
      return this.month() + 1;
    }), s2("MMM", 0, 0, function(e3) {
      return this.localeData().monthsShort(this, e3);
    }), s2("MMMM", 0, 0, function(e3) {
      return this.localeData().months(this, e3);
    }), t("month", "M"), n("month", 8), v("M", p), v("MM", p, w2), v("MMM", function(e3, t4) {
      return t4.monthsShortRegex(e3);
    }), v("MMMM", function(e3, t4) {
      return t4.monthsRegex(e3);
    }), D2(["M", "MM"], function(e3, t4) {
      t4[O] = g(e3) - 1;
    }), D2(["MMM", "MMMM"], function(e3, t4, n2, s3) {
      s3 = n2._locale.monthsParse(e3, s3, n2._strict);
      null != s3 ? t4[O] = s3 : m(n2).invalidMonth = e3;
    });
    var Ce = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), Ue = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), He = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, Fe = k2, Le = k2;
    function Ve(e3, t4) {
      var n2;
      if (e3.isValid()) {
        if ("string" == typeof t4) {
          if (/^\d+$/.test(t4))
            t4 = g(t4);
          else if (!u(t4 = e3.localeData().monthsParse(t4)))
            return;
        }
        n2 = Math.min(e3.date(), We(e3.year(), t4)), e3._d["set" + (e3._isUTC ? "UTC" : "") + "Month"](t4, n2);
      }
    }
    function Ge(e3) {
      return null != e3 ? (Ve(this, e3), f.updateOffset(this, true), this) : ce(this, "Month");
    }
    function Ee() {
      function e3(e4, t5) {
        return t5.length - e4.length;
      }
      for (var t4, n2 = [], s3 = [], i2 = [], r2 = 0; r2 < 12; r2++)
        t4 = l([2e3, r2]), n2.push(this.monthsShort(t4, "")), s3.push(this.months(t4, "")), i2.push(this.months(t4, "")), i2.push(this.monthsShort(t4, ""));
      for (n2.sort(e3), s3.sort(e3), i2.sort(e3), r2 = 0; r2 < 12; r2++)
        n2[r2] = M2(n2[r2]), s3[r2] = M2(s3[r2]);
      for (r2 = 0; r2 < 24; r2++)
        i2[r2] = M2(i2[r2]);
      this._monthsRegex = new RegExp("^(" + i2.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + s3.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + n2.join("|") + ")", "i");
    }
    function Ae(e3) {
      return he(e3) ? 366 : 365;
    }
    s2("Y", 0, 0, function() {
      var e3 = this.year();
      return e3 <= 9999 ? r(e3, 4) : "+" + e3;
    }), s2(0, ["YY", 2], 0, function() {
      return this.year() % 100;
    }), s2(0, ["YYYY", 4], 0, "year"), s2(0, ["YYYYY", 5], 0, "year"), s2(0, ["YYYYYY", 6, true], 0, "year"), t("year", "y"), n("year", 1), v("Y", De), v("YY", p, w2), v("YYYY", ke, _e), v("YYYYY", ve, ye), v("YYYYYY", ve, ye), D2(["YYYYY", "YYYYYY"], Y3), D2("YYYY", function(e3, t4) {
      t4[Y3] = 2 === e3.length ? f.parseTwoDigitYear(e3) : g(e3);
    }), D2("YY", function(e3, t4) {
      t4[Y3] = f.parseTwoDigitYear(e3);
    }), D2("Y", function(e3, t4) {
      t4[Y3] = parseInt(e3, 10);
    }), f.parseTwoDigitYear = function(e3) {
      return g(e3) + (68 < g(e3) ? 1900 : 2e3);
    };
    var Ie = de("FullYear", true);
    function je(e3, t4, n2, s3, i2, r2, a3) {
      var o2;
      return e3 < 100 && 0 <= e3 ? (o2 = new Date(e3 + 400, t4, n2, s3, i2, r2, a3), isFinite(o2.getFullYear()) && o2.setFullYear(e3)) : o2 = new Date(e3, t4, n2, s3, i2, r2, a3), o2;
    }
    function Ze(e3) {
      var t4;
      return e3 < 100 && 0 <= e3 ? ((t4 = Array.prototype.slice.call(arguments))[0] = e3 + 400, t4 = new Date(Date.UTC.apply(null, t4)), isFinite(t4.getUTCFullYear()) && t4.setUTCFullYear(e3)) : t4 = new Date(Date.UTC.apply(null, arguments)), t4;
    }
    function ze(e3, t4, n2) {
      n2 = 7 + t4 - n2;
      return n2 - (7 + Ze(e3, 0, n2).getUTCDay() - t4) % 7 - 1;
    }
    function $e(e3, t4, n2, s3, i2) {
      var r2, t4 = 1 + 7 * (t4 - 1) + (7 + n2 - s3) % 7 + ze(e3, s3, i2), n2 = t4 <= 0 ? Ae(r2 = e3 - 1) + t4 : t4 > Ae(e3) ? (r2 = e3 + 1, t4 - Ae(e3)) : (r2 = e3, t4);
      return { year: r2, dayOfYear: n2 };
    }
    function qe(e3, t4, n2) {
      var s3, i2, r2 = ze(e3.year(), t4, n2), r2 = Math.floor((e3.dayOfYear() - r2 - 1) / 7) + 1;
      return r2 < 1 ? s3 = r2 + P(i2 = e3.year() - 1, t4, n2) : r2 > P(e3.year(), t4, n2) ? (s3 = r2 - P(e3.year(), t4, n2), i2 = e3.year() + 1) : (i2 = e3.year(), s3 = r2), { week: s3, year: i2 };
    }
    function P(e3, t4, n2) {
      var s3 = ze(e3, t4, n2), t4 = ze(e3 + 1, t4, n2);
      return (Ae(e3) - s3 + t4) / 7;
    }
    s2("w", ["ww", 2], "wo", "week"), s2("W", ["WW", 2], "Wo", "isoWeek"), t("week", "w"), t("isoWeek", "W"), n("week", 5), n("isoWeek", 5), v("w", p), v("ww", p, w2), v("W", p), v("WW", p, w2), Te(["w", "ww", "W", "WW"], function(e3, t4, n2, s3) {
      t4[s3.substr(0, 1)] = g(e3);
    });
    function Be(e3, t4) {
      return e3.slice(t4, 7).concat(e3.slice(0, t4));
    }
    s2("d", 0, "do", "day"), s2("dd", 0, 0, function(e3) {
      return this.localeData().weekdaysMin(this, e3);
    }), s2("ddd", 0, 0, function(e3) {
      return this.localeData().weekdaysShort(this, e3);
    }), s2("dddd", 0, 0, function(e3) {
      return this.localeData().weekdays(this, e3);
    }), s2("e", 0, 0, "weekday"), s2("E", 0, 0, "isoWeekday"), t("day", "d"), t("weekday", "e"), t("isoWeekday", "E"), n("day", 11), n("weekday", 11), n("isoWeekday", 11), v("d", p), v("e", p), v("E", p), v("dd", function(e3, t4) {
      return t4.weekdaysMinRegex(e3);
    }), v("ddd", function(e3, t4) {
      return t4.weekdaysShortRegex(e3);
    }), v("dddd", function(e3, t4) {
      return t4.weekdaysRegex(e3);
    }), Te(["dd", "ddd", "dddd"], function(e3, t4, n2, s3) {
      s3 = n2._locale.weekdaysParse(e3, s3, n2._strict);
      null != s3 ? t4.d = s3 : m(n2).invalidWeekday = e3;
    }), Te(["d", "e", "E"], function(e3, t4, n2, s3) {
      t4[s3] = g(e3);
    });
    var Je = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), Qe = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Xe = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), Ke = k2, et = k2, tt = k2;
    function nt() {
      function e3(e4, t5) {
        return t5.length - e4.length;
      }
      for (var t4, n2, s3, i2 = [], r2 = [], a3 = [], o2 = [], u2 = 0; u2 < 7; u2++)
        s3 = l([2e3, 1]).day(u2), t4 = M2(this.weekdaysMin(s3, "")), n2 = M2(this.weekdaysShort(s3, "")), s3 = M2(this.weekdays(s3, "")), i2.push(t4), r2.push(n2), a3.push(s3), o2.push(t4), o2.push(n2), o2.push(s3);
      i2.sort(e3), r2.sort(e3), a3.sort(e3), o2.sort(e3), this._weekdaysRegex = new RegExp("^(" + o2.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + a3.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + r2.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + i2.join("|") + ")", "i");
    }
    function st() {
      return this.hours() % 12 || 12;
    }
    function it(e3, t4) {
      s2(e3, 0, 0, function() {
        return this.localeData().meridiem(this.hours(), this.minutes(), t4);
      });
    }
    function rt(e3, t4) {
      return t4._meridiemParse;
    }
    s2("H", ["HH", 2], 0, "hour"), s2("h", ["hh", 2], 0, st), s2("k", ["kk", 2], 0, function() {
      return this.hours() || 24;
    }), s2("hmm", 0, 0, function() {
      return "" + st.apply(this) + r(this.minutes(), 2);
    }), s2("hmmss", 0, 0, function() {
      return "" + st.apply(this) + r(this.minutes(), 2) + r(this.seconds(), 2);
    }), s2("Hmm", 0, 0, function() {
      return "" + this.hours() + r(this.minutes(), 2);
    }), s2("Hmmss", 0, 0, function() {
      return "" + this.hours() + r(this.minutes(), 2) + r(this.seconds(), 2);
    }), it("a", true), it("A", false), t("hour", "h"), n("hour", 13), v("a", rt), v("A", rt), v("H", p), v("h", p), v("k", p), v("HH", p, w2), v("hh", p, w2), v("kk", p, w2), v("hmm", ge), v("hmmss", we), v("Hmm", ge), v("Hmmss", we), D2(["H", "HH"], x2), D2(["k", "kk"], function(e3, t4, n2) {
      e3 = g(e3);
      t4[x2] = 24 === e3 ? 0 : e3;
    }), D2(["a", "A"], function(e3, t4, n2) {
      n2._isPm = n2._locale.isPM(e3), n2._meridiem = e3;
    }), D2(["h", "hh"], function(e3, t4, n2) {
      t4[x2] = g(e3), m(n2).bigHour = true;
    }), D2("hmm", function(e3, t4, n2) {
      var s3 = e3.length - 2;
      t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3)), m(n2).bigHour = true;
    }), D2("hmmss", function(e3, t4, n2) {
      var s3 = e3.length - 4, i2 = e3.length - 2;
      t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3, 2)), t4[N] = g(e3.substr(i2)), m(n2).bigHour = true;
    }), D2("Hmm", function(e3, t4, n2) {
      var s3 = e3.length - 2;
      t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3));
    }), D2("Hmmss", function(e3, t4, n2) {
      var s3 = e3.length - 4, i2 = e3.length - 2;
      t4[x2] = g(e3.substr(0, s3)), t4[T] = g(e3.substr(s3, 2)), t4[N] = g(e3.substr(i2));
    });
    k2 = de("Hours", true);
    var at, ot = { calendar: { sameDay: "[Today at] LT", nextDay: "[Tomorrow at] LT", nextWeek: "dddd [at] LT", lastDay: "[Yesterday at] LT", lastWeek: "[Last] dddd [at] LT", sameElse: "L" }, longDateFormat: { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, invalidDate: "Invalid date", ordinal: "%d", dayOfMonthOrdinalParse: /\d{1,2}/, relativeTime: { future: "in %s", past: "%s ago", s: "a few seconds", ss: "%d seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", w: "a week", ww: "%d weeks", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }, months: Ce, monthsShort: Ue, week: { dow: 0, doy: 6 }, weekdays: Je, weekdaysMin: Xe, weekdaysShort: Qe, meridiemParse: /[ap]\.?m?\.?/i }, R = {}, ut = {};
    function lt(e3) {
      return e3 && e3.toLowerCase().replace("_", "-");
    }
    function ht(e3) {
      for (var t4, n2, s3, i2, r2 = 0; r2 < e3.length; ) {
        for (t4 = (i2 = lt(e3[r2]).split("-")).length, n2 = (n2 = lt(e3[r2 + 1])) ? n2.split("-") : null; 0 < t4; ) {
          if (s3 = dt(i2.slice(0, t4).join("-")))
            return s3;
          if (n2 && n2.length >= t4 && function(e4, t5) {
            for (var n3 = Math.min(e4.length, t5.length), s4 = 0; s4 < n3; s4 += 1)
              if (e4[s4] !== t5[s4])
                return s4;
            return n3;
          }(i2, n2) >= t4 - 1)
            break;
          t4--;
        }
        r2++;
      }
      return at;
    }
    function dt(t4) {
      var e3;
      if (void 0 === R[t4] && true && module2 && module2.exports && null != t4.match("^[^/\\\\]*$"))
        try {
          e3 = at._abbr, commonjsRequire$1("./locale/" + t4), ct(e3);
        } catch (e4) {
          R[t4] = null;
        }
      return R[t4];
    }
    function ct(e3, t4) {
      return e3 && ((t4 = o(t4) ? mt(e3) : ft(e3, t4)) ? at = t4 : "undefined" != typeof console && console.warn && console.warn("Locale " + e3 + " not found. Did you forget to load it?")), at._abbr;
    }
    function ft(e3, t4) {
      if (null === t4)
        return delete R[e3], null;
      var n2, s3 = ot;
      if (t4.abbr = e3, null != R[e3])
        Q("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), s3 = R[e3]._config;
      else if (null != t4.parentLocale)
        if (null != R[t4.parentLocale])
          s3 = R[t4.parentLocale]._config;
        else {
          if (null == (n2 = dt(t4.parentLocale)))
            return ut[t4.parentLocale] || (ut[t4.parentLocale] = []), ut[t4.parentLocale].push({ name: e3, config: t4 }), null;
          s3 = n2._config;
        }
      return R[e3] = new K2(X3(s3, t4)), ut[e3] && ut[e3].forEach(function(e4) {
        ft(e4.name, e4.config);
      }), ct(e3), R[e3];
    }
    function mt(e3) {
      var t4;
      if (!(e3 = e3 && e3._locale && e3._locale._abbr ? e3._locale._abbr : e3))
        return at;
      if (!a2(e3)) {
        if (t4 = dt(e3))
          return t4;
        e3 = [e3];
      }
      return ht(e3);
    }
    function _t(e3) {
      var t4 = e3._a;
      return t4 && -2 === m(e3).overflow && (t4 = t4[O] < 0 || 11 < t4[O] ? O : t4[b] < 1 || t4[b] > We(t4[Y3], t4[O]) ? b : t4[x2] < 0 || 24 < t4[x2] || 24 === t4[x2] && (0 !== t4[T] || 0 !== t4[N] || 0 !== t4[Ne]) ? x2 : t4[T] < 0 || 59 < t4[T] ? T : t4[N] < 0 || 59 < t4[N] ? N : t4[Ne] < 0 || 999 < t4[Ne] ? Ne : -1, m(e3)._overflowDayOfYear && (t4 < Y3 || b < t4) && (t4 = b), m(e3)._overflowWeeks && -1 === t4 && (t4 = Pe), m(e3)._overflowWeekday && -1 === t4 && (t4 = Re), m(e3).overflow = t4), e3;
    }
    var yt = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, gt = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, wt = /Z|[+-]\d\d(?::?\d\d)?/, pt = [["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/], ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/], ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/], ["GGGG-[W]WW", /\d{4}-W\d\d/, false], ["YYYY-DDD", /\d{4}-\d{3}/], ["YYYY-MM", /\d{4}-\d\d/, false], ["YYYYYYMMDD", /[+-]\d{10}/], ["YYYYMMDD", /\d{8}/], ["GGGG[W]WWE", /\d{4}W\d{3}/], ["GGGG[W]WW", /\d{4}W\d{2}/, false], ["YYYYDDD", /\d{7}/], ["YYYYMM", /\d{6}/, false], ["YYYY", /\d{4}/, false]], kt = [["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/], ["HH:mm:ss", /\d\d:\d\d:\d\d/], ["HH:mm", /\d\d:\d\d/], ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/], ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/], ["HHmmss", /\d\d\d\d\d\d/], ["HHmm", /\d\d\d\d/], ["HH", /\d\d/]], vt = /^\/?Date\((-?\d+)/i, Mt = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Dt = { UT: 0, GMT: 0, EDT: -240, EST: -300, CDT: -300, CST: -360, MDT: -360, MST: -420, PDT: -420, PST: -480 };
    function St(e3) {
      var t4, n2, s3, i2, r2, a3, o2 = e3._i, u2 = yt.exec(o2) || gt.exec(o2), o2 = pt.length, l2 = kt.length;
      if (u2) {
        for (m(e3).iso = true, t4 = 0, n2 = o2; t4 < n2; t4++)
          if (pt[t4][1].exec(u2[1])) {
            i2 = pt[t4][0], s3 = false !== pt[t4][2];
            break;
          }
        if (null == i2)
          e3._isValid = false;
        else {
          if (u2[3]) {
            for (t4 = 0, n2 = l2; t4 < n2; t4++)
              if (kt[t4][1].exec(u2[3])) {
                r2 = (u2[2] || " ") + kt[t4][0];
                break;
              }
            if (null == r2)
              return void (e3._isValid = false);
          }
          if (s3 || null == r2) {
            if (u2[4]) {
              if (!wt.exec(u2[4]))
                return void (e3._isValid = false);
              a3 = "Z";
            }
            e3._f = i2 + (r2 || "") + (a3 || ""), Tt(e3);
          } else
            e3._isValid = false;
        }
      } else
        e3._isValid = false;
    }
    function Yt(e3, t4, n2, s3, i2, r2) {
      e3 = [function(e4) {
        e4 = parseInt(e4, 10);
        {
          if (e4 <= 49)
            return 2e3 + e4;
          if (e4 <= 999)
            return 1900 + e4;
        }
        return e4;
      }(e3), Ue.indexOf(t4), parseInt(n2, 10), parseInt(s3, 10), parseInt(i2, 10)];
      return r2 && e3.push(parseInt(r2, 10)), e3;
    }
    function Ot(e3) {
      var t4, n2, s3, i2, r2 = Mt.exec(e3._i.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, ""));
      r2 ? (t4 = Yt(r2[4], r2[3], r2[2], r2[5], r2[6], r2[7]), n2 = r2[1], s3 = t4, i2 = e3, n2 && Qe.indexOf(n2) !== new Date(s3[0], s3[1], s3[2]).getDay() ? (m(i2).weekdayMismatch = true, i2._isValid = false) : (e3._a = t4, e3._tzm = (n2 = r2[8], s3 = r2[9], i2 = r2[10], n2 ? Dt[n2] : s3 ? 0 : 60 * (((n2 = parseInt(i2, 10)) - (s3 = n2 % 100)) / 100) + s3), e3._d = Ze.apply(null, e3._a), e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), m(e3).rfc2822 = true)) : e3._isValid = false;
    }
    function bt(e3, t4, n2) {
      return null != e3 ? e3 : null != t4 ? t4 : n2;
    }
    function xt(e3) {
      var t4, n2, s3, i2, r2, a3, o2, u2, l2, h2, d2, c3 = [];
      if (!e3._d) {
        for (s3 = e3, i2 = new Date(f.now()), n2 = s3._useUTC ? [i2.getUTCFullYear(), i2.getUTCMonth(), i2.getUTCDate()] : [i2.getFullYear(), i2.getMonth(), i2.getDate()], e3._w && null == e3._a[b] && null == e3._a[O] && (null != (i2 = (s3 = e3)._w).GG || null != i2.W || null != i2.E ? (u2 = 1, l2 = 4, r2 = bt(i2.GG, s3._a[Y3], qe(W(), 1, 4).year), a3 = bt(i2.W, 1), ((o2 = bt(i2.E, 1)) < 1 || 7 < o2) && (h2 = true)) : (u2 = s3._locale._week.dow, l2 = s3._locale._week.doy, d2 = qe(W(), u2, l2), r2 = bt(i2.gg, s3._a[Y3], d2.year), a3 = bt(i2.w, d2.week), null != i2.d ? ((o2 = i2.d) < 0 || 6 < o2) && (h2 = true) : null != i2.e ? (o2 = i2.e + u2, (i2.e < 0 || 6 < i2.e) && (h2 = true)) : o2 = u2), a3 < 1 || a3 > P(r2, u2, l2) ? m(s3)._overflowWeeks = true : null != h2 ? m(s3)._overflowWeekday = true : (d2 = $e(r2, a3, o2, u2, l2), s3._a[Y3] = d2.year, s3._dayOfYear = d2.dayOfYear)), null != e3._dayOfYear && (i2 = bt(e3._a[Y3], n2[Y3]), (e3._dayOfYear > Ae(i2) || 0 === e3._dayOfYear) && (m(e3)._overflowDayOfYear = true), h2 = Ze(i2, 0, e3._dayOfYear), e3._a[O] = h2.getUTCMonth(), e3._a[b] = h2.getUTCDate()), t4 = 0; t4 < 3 && null == e3._a[t4]; ++t4)
          e3._a[t4] = c3[t4] = n2[t4];
        for (; t4 < 7; t4++)
          e3._a[t4] = c3[t4] = null == e3._a[t4] ? 2 === t4 ? 1 : 0 : e3._a[t4];
        24 === e3._a[x2] && 0 === e3._a[T] && 0 === e3._a[N] && 0 === e3._a[Ne] && (e3._nextDay = true, e3._a[x2] = 0), e3._d = (e3._useUTC ? Ze : je).apply(null, c3), r2 = e3._useUTC ? e3._d.getUTCDay() : e3._d.getDay(), null != e3._tzm && e3._d.setUTCMinutes(e3._d.getUTCMinutes() - e3._tzm), e3._nextDay && (e3._a[x2] = 24), e3._w && void 0 !== e3._w.d && e3._w.d !== r2 && (m(e3).weekdayMismatch = true);
      }
    }
    function Tt(e3) {
      if (e3._f === f.ISO_8601)
        St(e3);
      else if (e3._f === f.RFC_2822)
        Ot(e3);
      else {
        e3._a = [], m(e3).empty = true;
        for (var t4, n2, s3, i2, r2, a3 = "" + e3._i, o2 = a3.length, u2 = 0, l2 = ae(e3._f, e3._locale).match(te) || [], h2 = l2.length, d2 = 0; d2 < h2; d2++)
          n2 = l2[d2], (t4 = (a3.match(Oe(n2, e3)) || [])[0]) && (0 < (s3 = a3.substr(0, a3.indexOf(t4))).length && m(e3).unusedInput.push(s3), a3 = a3.slice(a3.indexOf(t4) + t4.length), u2 += t4.length), ie[n2] ? (t4 ? m(e3).empty = false : m(e3).unusedTokens.push(n2), s3 = n2, r2 = e3, null != (i2 = t4) && c2(xe, s3) && xe[s3](i2, r2._a, r2, s3)) : e3._strict && !t4 && m(e3).unusedTokens.push(n2);
        m(e3).charsLeftOver = o2 - u2, 0 < a3.length && m(e3).unusedInput.push(a3), e3._a[x2] <= 12 && true === m(e3).bigHour && 0 < e3._a[x2] && (m(e3).bigHour = void 0), m(e3).parsedDateParts = e3._a.slice(0), m(e3).meridiem = e3._meridiem, e3._a[x2] = function(e4, t5, n3) {
          if (null == n3)
            return t5;
          return null != e4.meridiemHour ? e4.meridiemHour(t5, n3) : null != e4.isPM ? ((e4 = e4.isPM(n3)) && t5 < 12 && (t5 += 12), t5 = e4 || 12 !== t5 ? t5 : 0) : t5;
        }(e3._locale, e3._a[x2], e3._meridiem), null !== (o2 = m(e3).era) && (e3._a[Y3] = e3._locale.erasConvertYear(o2, e3._a[Y3])), xt(e3), _t(e3);
      }
    }
    function Nt(e3) {
      var t4, n2, s3, i2 = e3._i, r2 = e3._f;
      if (e3._locale = e3._locale || mt(e3._l), null === i2 || void 0 === r2 && "" === i2)
        return I({ nullInput: true });
      if ("string" == typeof i2 && (e3._i = i2 = e3._locale.preparse(i2)), h(i2))
        return new q(_t(i2));
      if (V(i2))
        e3._d = i2;
      else if (a2(r2))
        !function(e4) {
          var t5, n3, s4, i3, r3, a3, o2 = false, u2 = e4._f.length;
          if (0 === u2)
            return m(e4).invalidFormat = true, e4._d = new Date(NaN);
          for (i3 = 0; i3 < u2; i3++)
            r3 = 0, a3 = false, t5 = $({}, e4), null != e4._useUTC && (t5._useUTC = e4._useUTC), t5._f = e4._f[i3], Tt(t5), A5(t5) && (a3 = true), r3 = (r3 += m(t5).charsLeftOver) + 10 * m(t5).unusedTokens.length, m(t5).score = r3, o2 ? r3 < s4 && (s4 = r3, n3 = t5) : (null == s4 || r3 < s4 || a3) && (s4 = r3, n3 = t5, a3 && (o2 = true));
          E2(e4, n3 || t5);
        }(e3);
      else if (r2)
        Tt(e3);
      else if (o(r2 = (i2 = e3)._i))
        i2._d = new Date(f.now());
      else
        V(r2) ? i2._d = new Date(r2.valueOf()) : "string" == typeof r2 ? (n2 = i2, null !== (t4 = vt.exec(n2._i)) ? n2._d = new Date(+t4[1]) : (St(n2), false === n2._isValid && (delete n2._isValid, Ot(n2), false === n2._isValid && (delete n2._isValid, n2._strict ? n2._isValid = false : f.createFromInputFallback(n2))))) : a2(r2) ? (i2._a = G(r2.slice(0), function(e4) {
          return parseInt(e4, 10);
        }), xt(i2)) : F(r2) ? (t4 = i2)._d || (s3 = void 0 === (n2 = ue(t4._i)).day ? n2.date : n2.day, t4._a = G([n2.year, n2.month, s3, n2.hour, n2.minute, n2.second, n2.millisecond], function(e4) {
          return e4 && parseInt(e4, 10);
        }), xt(t4)) : u(r2) ? i2._d = new Date(r2) : f.createFromInputFallback(i2);
      return A5(e3) || (e3._d = null), e3;
    }
    function Pt(e3, t4, n2, s3, i2) {
      var r2 = {};
      return true !== t4 && false !== t4 || (s3 = t4, t4 = void 0), true !== n2 && false !== n2 || (s3 = n2, n2 = void 0), (F(e3) && L(e3) || a2(e3) && 0 === e3.length) && (e3 = void 0), r2._isAMomentObject = true, r2._useUTC = r2._isUTC = i2, r2._l = n2, r2._i = e3, r2._f = t4, r2._strict = s3, (i2 = new q(_t(Nt(i2 = r2))))._nextDay && (i2.add(1, "d"), i2._nextDay = void 0), i2;
    }
    function W(e3, t4, n2, s3) {
      return Pt(e3, t4, n2, s3, false);
    }
    f.createFromInputFallback = e("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(e3) {
      e3._d = new Date(e3._i + (e3._useUTC ? " UTC" : ""));
    }), f.ISO_8601 = function() {
    }, f.RFC_2822 = function() {
    };
    ge = e("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e3 = W.apply(null, arguments);
      return this.isValid() && e3.isValid() ? e3 < this ? this : e3 : I();
    }), we = e("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
      var e3 = W.apply(null, arguments);
      return this.isValid() && e3.isValid() ? this < e3 ? this : e3 : I();
    });
    function Rt(e3, t4) {
      var n2, s3;
      if (!(t4 = 1 === t4.length && a2(t4[0]) ? t4[0] : t4).length)
        return W();
      for (n2 = t4[0], s3 = 1; s3 < t4.length; ++s3)
        t4[s3].isValid() && !t4[s3][e3](n2) || (n2 = t4[s3]);
      return n2;
    }
    var Wt = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
    function Ct(e3) {
      var e3 = ue(e3), t4 = e3.year || 0, n2 = e3.quarter || 0, s3 = e3.month || 0, i2 = e3.week || e3.isoWeek || 0, r2 = e3.day || 0, a3 = e3.hour || 0, o2 = e3.minute || 0, u2 = e3.second || 0, l2 = e3.millisecond || 0;
      this._isValid = function(e4) {
        var t5, n3, s4 = false, i3 = Wt.length;
        for (t5 in e4)
          if (c2(e4, t5) && (-1 === S.call(Wt, t5) || null != e4[t5] && isNaN(e4[t5])))
            return false;
        for (n3 = 0; n3 < i3; ++n3)
          if (e4[Wt[n3]]) {
            if (s4)
              return false;
            parseFloat(e4[Wt[n3]]) !== g(e4[Wt[n3]]) && (s4 = true);
          }
        return true;
      }(e3), this._milliseconds = +l2 + 1e3 * u2 + 6e4 * o2 + 1e3 * a3 * 60 * 60, this._days = +r2 + 7 * i2, this._months = +s3 + 3 * n2 + 12 * t4, this._data = {}, this._locale = mt(), this._bubble();
    }
    function Ut(e3) {
      return e3 instanceof Ct;
    }
    function Ht(e3) {
      return e3 < 0 ? -1 * Math.round(-1 * e3) : Math.round(e3);
    }
    function Ft(e3, n2) {
      s2(e3, 0, 0, function() {
        var e4 = this.utcOffset(), t4 = "+";
        return e4 < 0 && (e4 = -e4, t4 = "-"), t4 + r(~~(e4 / 60), 2) + n2 + r(~~e4 % 60, 2);
      });
    }
    Ft("Z", ":"), Ft("ZZ", ""), v("Z", Ye), v("ZZ", Ye), D2(["Z", "ZZ"], function(e3, t4, n2) {
      n2._useUTC = true, n2._tzm = Vt(Ye, e3);
    });
    var Lt = /([\+\-]|\d\d)/gi;
    function Vt(e3, t4) {
      var t4 = (t4 || "").match(e3);
      return null === t4 ? null : 0 === (t4 = 60 * (e3 = ((t4[t4.length - 1] || []) + "").match(Lt) || ["-", 0, 0])[1] + g(e3[2])) ? 0 : "+" === e3[0] ? t4 : -t4;
    }
    function Gt(e3, t4) {
      var n2;
      return t4._isUTC ? (t4 = t4.clone(), n2 = (h(e3) || V(e3) ? e3 : W(e3)).valueOf() - t4.valueOf(), t4._d.setTime(t4._d.valueOf() + n2), f.updateOffset(t4, false), t4) : W(e3).local();
    }
    function Et(e3) {
      return -Math.round(e3._d.getTimezoneOffset());
    }
    function At() {
      return !!this.isValid() && (this._isUTC && 0 === this._offset);
    }
    f.updateOffset = function() {
    };
    var It = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, jt = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
    function C2(e3, t4) {
      var n2, s3 = e3, i2 = null;
      return Ut(e3) ? s3 = { ms: e3._milliseconds, d: e3._days, M: e3._months } : u(e3) || !isNaN(+e3) ? (s3 = {}, t4 ? s3[t4] = +e3 : s3.milliseconds = +e3) : (i2 = It.exec(e3)) ? (n2 = "-" === i2[1] ? -1 : 1, s3 = { y: 0, d: g(i2[b]) * n2, h: g(i2[x2]) * n2, m: g(i2[T]) * n2, s: g(i2[N]) * n2, ms: g(Ht(1e3 * i2[Ne])) * n2 }) : (i2 = jt.exec(e3)) ? (n2 = "-" === i2[1] ? -1 : 1, s3 = { y: Zt(i2[2], n2), M: Zt(i2[3], n2), w: Zt(i2[4], n2), d: Zt(i2[5], n2), h: Zt(i2[6], n2), m: Zt(i2[7], n2), s: Zt(i2[8], n2) }) : null == s3 ? s3 = {} : "object" == typeof s3 && ("from" in s3 || "to" in s3) && (t4 = function(e4, t5) {
        var n3;
        if (!e4.isValid() || !t5.isValid())
          return { milliseconds: 0, months: 0 };
        t5 = Gt(t5, e4), e4.isBefore(t5) ? n3 = zt(e4, t5) : ((n3 = zt(t5, e4)).milliseconds = -n3.milliseconds, n3.months = -n3.months);
        return n3;
      }(W(s3.from), W(s3.to)), (s3 = {}).ms = t4.milliseconds, s3.M = t4.months), i2 = new Ct(s3), Ut(e3) && c2(e3, "_locale") && (i2._locale = e3._locale), Ut(e3) && c2(e3, "_isValid") && (i2._isValid = e3._isValid), i2;
    }
    function Zt(e3, t4) {
      e3 = e3 && parseFloat(e3.replace(",", "."));
      return (isNaN(e3) ? 0 : e3) * t4;
    }
    function zt(e3, t4) {
      var n2 = {};
      return n2.months = t4.month() - e3.month() + 12 * (t4.year() - e3.year()), e3.clone().add(n2.months, "M").isAfter(t4) && --n2.months, n2.milliseconds = +t4 - +e3.clone().add(n2.months, "M"), n2;
    }
    function $t(s3, i2) {
      return function(e3, t4) {
        var n2;
        return null === t4 || isNaN(+t4) || (Q(i2, "moment()." + i2 + "(period, number) is deprecated. Please use moment()." + i2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), n2 = e3, e3 = t4, t4 = n2), qt(this, C2(e3, t4), s3), this;
      };
    }
    function qt(e3, t4, n2, s3) {
      var i2 = t4._milliseconds, r2 = Ht(t4._days), t4 = Ht(t4._months);
      e3.isValid() && (s3 = null == s3 || s3, t4 && Ve(e3, ce(e3, "Month") + t4 * n2), r2 && fe(e3, "Date", ce(e3, "Date") + r2 * n2), i2 && e3._d.setTime(e3._d.valueOf() + i2 * n2), s3 && f.updateOffset(e3, r2 || t4));
    }
    C2.fn = Ct.prototype, C2.invalid = function() {
      return C2(NaN);
    };
    Ce = $t(1, "add"), Je = $t(-1, "subtract");
    function Bt(e3) {
      return "string" == typeof e3 || e3 instanceof String;
    }
    function Jt(e3) {
      return h(e3) || V(e3) || Bt(e3) || u(e3) || function(t4) {
        var e4 = a2(t4), n2 = false;
        e4 && (n2 = 0 === t4.filter(function(e6) {
          return !u(e6) && Bt(t4);
        }).length);
        return e4 && n2;
      }(e3) || function(e4) {
        var t4, n2, s3 = F(e4) && !L(e4), i2 = false, r2 = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"], a3 = r2.length;
        for (t4 = 0; t4 < a3; t4 += 1)
          n2 = r2[t4], i2 = i2 || c2(e4, n2);
        return s3 && i2;
      }(e3) || null == e3;
    }
    function Qt(e3, t4) {
      if (e3.date() < t4.date())
        return -Qt(t4, e3);
      var n2 = 12 * (t4.year() - e3.year()) + (t4.month() - e3.month()), s3 = e3.clone().add(n2, "months"), t4 = t4 - s3 < 0 ? (t4 - s3) / (s3 - e3.clone().add(n2 - 1, "months")) : (t4 - s3) / (e3.clone().add(1 + n2, "months") - s3);
      return -(n2 + t4) || 0;
    }
    function Xt(e3) {
      return void 0 === e3 ? this._locale._abbr : (null != (e3 = mt(e3)) && (this._locale = e3), this);
    }
    f.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", f.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
    Xe = e("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(e3) {
      return void 0 === e3 ? this.localeData() : this.locale(e3);
    });
    function Kt() {
      return this._locale;
    }
    var en = 126227808e5;
    function tn(e3, t4) {
      return (e3 % t4 + t4) % t4;
    }
    function nn(e3, t4, n2) {
      return e3 < 100 && 0 <= e3 ? new Date(e3 + 400, t4, n2) - en : new Date(e3, t4, n2).valueOf();
    }
    function sn(e3, t4, n2) {
      return e3 < 100 && 0 <= e3 ? Date.UTC(e3 + 400, t4, n2) - en : Date.UTC(e3, t4, n2);
    }
    function rn(e3, t4) {
      return t4.erasAbbrRegex(e3);
    }
    function an() {
      for (var e3 = [], t4 = [], n2 = [], s3 = [], i2 = this.eras(), r2 = 0, a3 = i2.length; r2 < a3; ++r2)
        t4.push(M2(i2[r2].name)), e3.push(M2(i2[r2].abbr)), n2.push(M2(i2[r2].narrow)), s3.push(M2(i2[r2].name)), s3.push(M2(i2[r2].abbr)), s3.push(M2(i2[r2].narrow));
      this._erasRegex = new RegExp("^(" + s3.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t4.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e3.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + n2.join("|") + ")", "i");
    }
    function on(e3, t4) {
      s2(0, [e3, e3.length], 0, t4);
    }
    function un(e3, t4, n2, s3, i2) {
      var r2;
      return null == e3 ? qe(this, s3, i2).year : (r2 = P(e3, s3, i2), function(e4, t5, n3, s4, i3) {
        e4 = $e(e4, t5, n3, s4, i3), t5 = Ze(e4.year, 0, e4.dayOfYear);
        return this.year(t5.getUTCFullYear()), this.month(t5.getUTCMonth()), this.date(t5.getUTCDate()), this;
      }.call(this, e3, t4 = r2 < t4 ? r2 : t4, n2, s3, i2));
    }
    s2("N", 0, 0, "eraAbbr"), s2("NN", 0, 0, "eraAbbr"), s2("NNN", 0, 0, "eraAbbr"), s2("NNNN", 0, 0, "eraName"), s2("NNNNN", 0, 0, "eraNarrow"), s2("y", ["y", 1], "yo", "eraYear"), s2("y", ["yy", 2], 0, "eraYear"), s2("y", ["yyy", 3], 0, "eraYear"), s2("y", ["yyyy", 4], 0, "eraYear"), v("N", rn), v("NN", rn), v("NNN", rn), v("NNNN", function(e3, t4) {
      return t4.erasNameRegex(e3);
    }), v("NNNNN", function(e3, t4) {
      return t4.erasNarrowRegex(e3);
    }), D2(["N", "NN", "NNN", "NNNN", "NNNNN"], function(e3, t4, n2, s3) {
      s3 = n2._locale.erasParse(e3, s3, n2._strict);
      s3 ? m(n2).era = s3 : m(n2).invalidEra = e3;
    }), v("y", Me), v("yy", Me), v("yyy", Me), v("yyyy", Me), v("yo", function(e3, t4) {
      return t4._eraYearOrdinalRegex || Me;
    }), D2(["y", "yy", "yyy", "yyyy"], Y3), D2(["yo"], function(e3, t4, n2, s3) {
      var i2;
      n2._locale._eraYearOrdinalRegex && (i2 = e3.match(n2._locale._eraYearOrdinalRegex)), n2._locale.eraYearOrdinalParse ? t4[Y3] = n2._locale.eraYearOrdinalParse(e3, i2) : t4[Y3] = parseInt(e3, 10);
    }), s2(0, ["gg", 2], 0, function() {
      return this.weekYear() % 100;
    }), s2(0, ["GG", 2], 0, function() {
      return this.isoWeekYear() % 100;
    }), on("gggg", "weekYear"), on("ggggg", "weekYear"), on("GGGG", "isoWeekYear"), on("GGGGG", "isoWeekYear"), t("weekYear", "gg"), t("isoWeekYear", "GG"), n("weekYear", 1), n("isoWeekYear", 1), v("G", De), v("g", De), v("GG", p, w2), v("gg", p, w2), v("GGGG", ke, _e), v("gggg", ke, _e), v("GGGGG", ve, ye), v("ggggg", ve, ye), Te(["gggg", "ggggg", "GGGG", "GGGGG"], function(e3, t4, n2, s3) {
      t4[s3.substr(0, 2)] = g(e3);
    }), Te(["gg", "GG"], function(e3, t4, n2, s3) {
      t4[s3] = f.parseTwoDigitYear(e3);
    }), s2("Q", 0, "Qo", "quarter"), t("quarter", "Q"), n("quarter", 7), v("Q", i), D2("Q", function(e3, t4) {
      t4[O] = 3 * (g(e3) - 1);
    }), s2("D", ["DD", 2], "Do", "date"), t("date", "D"), n("date", 9), v("D", p), v("DD", p, w2), v("Do", function(e3, t4) {
      return e3 ? t4._dayOfMonthOrdinalParse || t4._ordinalParse : t4._dayOfMonthOrdinalParseLenient;
    }), D2(["D", "DD"], b), D2("Do", function(e3, t4) {
      t4[b] = g(e3.match(p)[0]);
    });
    ke = de("Date", true);
    s2("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), t("dayOfYear", "DDD"), n("dayOfYear", 4), v("DDD", pe), v("DDDD", me), D2(["DDD", "DDDD"], function(e3, t4, n2) {
      n2._dayOfYear = g(e3);
    }), s2("m", ["mm", 2], 0, "minute"), t("minute", "m"), n("minute", 14), v("m", p), v("mm", p, w2), D2(["m", "mm"], T);
    var ln, _e = de("Minutes", false), ve = (s2("s", ["ss", 2], 0, "second"), t("second", "s"), n("second", 15), v("s", p), v("ss", p, w2), D2(["s", "ss"], N), de("Seconds", false));
    for (s2("S", 0, 0, function() {
      return ~~(this.millisecond() / 100);
    }), s2(0, ["SS", 2], 0, function() {
      return ~~(this.millisecond() / 10);
    }), s2(0, ["SSS", 3], 0, "millisecond"), s2(0, ["SSSS", 4], 0, function() {
      return 10 * this.millisecond();
    }), s2(0, ["SSSSS", 5], 0, function() {
      return 100 * this.millisecond();
    }), s2(0, ["SSSSSS", 6], 0, function() {
      return 1e3 * this.millisecond();
    }), s2(0, ["SSSSSSS", 7], 0, function() {
      return 1e4 * this.millisecond();
    }), s2(0, ["SSSSSSSS", 8], 0, function() {
      return 1e5 * this.millisecond();
    }), s2(0, ["SSSSSSSSS", 9], 0, function() {
      return 1e6 * this.millisecond();
    }), t("millisecond", "ms"), n("millisecond", 16), v("S", pe, i), v("SS", pe, w2), v("SSS", pe, me), ln = "SSSS"; ln.length <= 9; ln += "S")
      v(ln, Me);
    function hn(e3, t4) {
      t4[Ne] = g(1e3 * ("0." + e3));
    }
    for (ln = "S"; ln.length <= 9; ln += "S")
      D2(ln, hn);
    ye = de("Milliseconds", false), s2("z", 0, 0, "zoneAbbr"), s2("zz", 0, 0, "zoneName");
    i = q.prototype;
    function dn(e3) {
      return e3;
    }
    i.add = Ce, i.calendar = function(e3, t4) {
      1 === arguments.length && (arguments[0] ? Jt(arguments[0]) ? (e3 = arguments[0], t4 = void 0) : function(e4) {
        for (var t5 = F(e4) && !L(e4), n3 = false, s3 = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"], i2 = 0; i2 < s3.length; i2 += 1)
          n3 = n3 || c2(e4, s3[i2]);
        return t5 && n3;
      }(arguments[0]) && (t4 = arguments[0], e3 = void 0) : t4 = e3 = void 0);
      var e3 = e3 || W(), n2 = Gt(e3, this).startOf("day"), n2 = f.calendarFormat(this, n2) || "sameElse", t4 = t4 && (d(t4[n2]) ? t4[n2].call(this, e3) : t4[n2]);
      return this.format(t4 || this.localeData().calendar(n2, this, W(e3)));
    }, i.clone = function() {
      return new q(this);
    }, i.diff = function(e3, t4, n2) {
      var s3, i2, r2;
      if (!this.isValid())
        return NaN;
      if (!(s3 = Gt(e3, this)).isValid())
        return NaN;
      switch (i2 = 6e4 * (s3.utcOffset() - this.utcOffset()), t4 = _2(t4)) {
        case "year":
          r2 = Qt(this, s3) / 12;
          break;
        case "month":
          r2 = Qt(this, s3);
          break;
        case "quarter":
          r2 = Qt(this, s3) / 3;
          break;
        case "second":
          r2 = (this - s3) / 1e3;
          break;
        case "minute":
          r2 = (this - s3) / 6e4;
          break;
        case "hour":
          r2 = (this - s3) / 36e5;
          break;
        case "day":
          r2 = (this - s3 - i2) / 864e5;
          break;
        case "week":
          r2 = (this - s3 - i2) / 6048e5;
          break;
        default:
          r2 = this - s3;
      }
      return n2 ? r2 : y2(r2);
    }, i.endOf = function(e3) {
      var t4, n2;
      if (void 0 === (e3 = _2(e3)) || "millisecond" === e3 || !this.isValid())
        return this;
      switch (n2 = this._isUTC ? sn : nn, e3) {
        case "year":
          t4 = n2(this.year() + 1, 0, 1) - 1;
          break;
        case "quarter":
          t4 = n2(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
          break;
        case "month":
          t4 = n2(this.year(), this.month() + 1, 1) - 1;
          break;
        case "week":
          t4 = n2(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
          break;
        case "isoWeek":
          t4 = n2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
          break;
        case "day":
        case "date":
          t4 = n2(this.year(), this.month(), this.date() + 1) - 1;
          break;
        case "hour":
          t4 = this._d.valueOf(), t4 += 36e5 - tn(t4 + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5) - 1;
          break;
        case "minute":
          t4 = this._d.valueOf(), t4 += 6e4 - tn(t4, 6e4) - 1;
          break;
        case "second":
          t4 = this._d.valueOf(), t4 += 1e3 - tn(t4, 1e3) - 1;
          break;
      }
      return this._d.setTime(t4), f.updateOffset(this, true), this;
    }, i.format = function(e3) {
      return e3 = e3 || (this.isUtc() ? f.defaultFormatUtc : f.defaultFormat), e3 = re2(this, e3), this.localeData().postformat(e3);
    }, i.from = function(e3, t4) {
      return this.isValid() && (h(e3) && e3.isValid() || W(e3).isValid()) ? C2({ to: this, from: e3 }).locale(this.locale()).humanize(!t4) : this.localeData().invalidDate();
    }, i.fromNow = function(e3) {
      return this.from(W(), e3);
    }, i.to = function(e3, t4) {
      return this.isValid() && (h(e3) && e3.isValid() || W(e3).isValid()) ? C2({ from: this, to: e3 }).locale(this.locale()).humanize(!t4) : this.localeData().invalidDate();
    }, i.toNow = function(e3) {
      return this.to(W(), e3);
    }, i.get = function(e3) {
      return d(this[e3 = _2(e3)]) ? this[e3]() : this;
    }, i.invalidAt = function() {
      return m(this).overflow;
    }, i.isAfter = function(e3, t4) {
      return e3 = h(e3) ? e3 : W(e3), !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t4 = _2(t4) || "millisecond") ? this.valueOf() > e3.valueOf() : e3.valueOf() < this.clone().startOf(t4).valueOf());
    }, i.isBefore = function(e3, t4) {
      return e3 = h(e3) ? e3 : W(e3), !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t4 = _2(t4) || "millisecond") ? this.valueOf() < e3.valueOf() : this.clone().endOf(t4).valueOf() < e3.valueOf());
    }, i.isBetween = function(e3, t4, n2, s3) {
      return e3 = h(e3) ? e3 : W(e3), t4 = h(t4) ? t4 : W(t4), !!(this.isValid() && e3.isValid() && t4.isValid()) && (("(" === (s3 = s3 || "()")[0] ? this.isAfter(e3, n2) : !this.isBefore(e3, n2)) && (")" === s3[1] ? this.isBefore(t4, n2) : !this.isAfter(t4, n2)));
    }, i.isSame = function(e3, t4) {
      var e3 = h(e3) ? e3 : W(e3);
      return !(!this.isValid() || !e3.isValid()) && ("millisecond" === (t4 = _2(t4) || "millisecond") ? this.valueOf() === e3.valueOf() : (e3 = e3.valueOf(), this.clone().startOf(t4).valueOf() <= e3 && e3 <= this.clone().endOf(t4).valueOf()));
    }, i.isSameOrAfter = function(e3, t4) {
      return this.isSame(e3, t4) || this.isAfter(e3, t4);
    }, i.isSameOrBefore = function(e3, t4) {
      return this.isSame(e3, t4) || this.isBefore(e3, t4);
    }, i.isValid = function() {
      return A5(this);
    }, i.lang = Xe, i.locale = Xt, i.localeData = Kt, i.max = we, i.min = ge, i.parsingFlags = function() {
      return E2({}, m(this));
    }, i.set = function(e3, t4) {
      if ("object" == typeof e3)
        for (var n2 = function(e4) {
          var t5, n3 = [];
          for (t5 in e4)
            c2(e4, t5) && n3.push({ unit: t5, priority: le[t5] });
          return n3.sort(function(e6, t6) {
            return e6.priority - t6.priority;
          }), n3;
        }(e3 = ue(e3)), s3 = n2.length, i2 = 0; i2 < s3; i2++)
          this[n2[i2].unit](e3[n2[i2].unit]);
      else if (d(this[e3 = _2(e3)]))
        return this[e3](t4);
      return this;
    }, i.startOf = function(e3) {
      var t4, n2;
      if (void 0 === (e3 = _2(e3)) || "millisecond" === e3 || !this.isValid())
        return this;
      switch (n2 = this._isUTC ? sn : nn, e3) {
        case "year":
          t4 = n2(this.year(), 0, 1);
          break;
        case "quarter":
          t4 = n2(this.year(), this.month() - this.month() % 3, 1);
          break;
        case "month":
          t4 = n2(this.year(), this.month(), 1);
          break;
        case "week":
          t4 = n2(this.year(), this.month(), this.date() - this.weekday());
          break;
        case "isoWeek":
          t4 = n2(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
          break;
        case "day":
        case "date":
          t4 = n2(this.year(), this.month(), this.date());
          break;
        case "hour":
          t4 = this._d.valueOf(), t4 -= tn(t4 + (this._isUTC ? 0 : 6e4 * this.utcOffset()), 36e5);
          break;
        case "minute":
          t4 = this._d.valueOf(), t4 -= tn(t4, 6e4);
          break;
        case "second":
          t4 = this._d.valueOf(), t4 -= tn(t4, 1e3);
          break;
      }
      return this._d.setTime(t4), f.updateOffset(this, true), this;
    }, i.subtract = Je, i.toArray = function() {
      var e3 = this;
      return [e3.year(), e3.month(), e3.date(), e3.hour(), e3.minute(), e3.second(), e3.millisecond()];
    }, i.toObject = function() {
      var e3 = this;
      return { years: e3.year(), months: e3.month(), date: e3.date(), hours: e3.hours(), minutes: e3.minutes(), seconds: e3.seconds(), milliseconds: e3.milliseconds() };
    }, i.toDate = function() {
      return new Date(this.valueOf());
    }, i.toISOString = function(e3) {
      if (!this.isValid())
        return null;
      var t4 = (e3 = true !== e3) ? this.clone().utc() : this;
      return t4.year() < 0 || 9999 < t4.year() ? re2(t4, e3 ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : d(Date.prototype.toISOString) ? e3 ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", re2(t4, "Z")) : re2(t4, e3 ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ");
    }, i.inspect = function() {
      if (!this.isValid())
        return "moment.invalid(/* " + this._i + " */)";
      var e3, t4 = "moment", n2 = "";
      return this.isLocal() || (t4 = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", n2 = "Z"), t4 = "[" + t4 + '("]', e3 = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", this.format(t4 + e3 + "-MM-DD[T]HH:mm:ss.SSS" + (n2 + '[")]'));
    }, "undefined" != typeof Symbol && null != Symbol.for && (i[Symbol.for("nodejs.util.inspect.custom")] = function() {
      return "Moment<" + this.format() + ">";
    }), i.toJSON = function() {
      return this.isValid() ? this.toISOString() : null;
    }, i.toString = function() {
      return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
    }, i.unix = function() {
      return Math.floor(this.valueOf() / 1e3);
    }, i.valueOf = function() {
      return this._d.valueOf() - 6e4 * (this._offset || 0);
    }, i.creationData = function() {
      return { input: this._i, format: this._f, locale: this._locale, isUTC: this._isUTC, strict: this._strict };
    }, i.eraName = function() {
      for (var e3, t4 = this.localeData().eras(), n2 = 0, s3 = t4.length; n2 < s3; ++n2) {
        if (e3 = this.clone().startOf("day").valueOf(), t4[n2].since <= e3 && e3 <= t4[n2].until)
          return t4[n2].name;
        if (t4[n2].until <= e3 && e3 <= t4[n2].since)
          return t4[n2].name;
      }
      return "";
    }, i.eraNarrow = function() {
      for (var e3, t4 = this.localeData().eras(), n2 = 0, s3 = t4.length; n2 < s3; ++n2) {
        if (e3 = this.clone().startOf("day").valueOf(), t4[n2].since <= e3 && e3 <= t4[n2].until)
          return t4[n2].narrow;
        if (t4[n2].until <= e3 && e3 <= t4[n2].since)
          return t4[n2].narrow;
      }
      return "";
    }, i.eraAbbr = function() {
      for (var e3, t4 = this.localeData().eras(), n2 = 0, s3 = t4.length; n2 < s3; ++n2) {
        if (e3 = this.clone().startOf("day").valueOf(), t4[n2].since <= e3 && e3 <= t4[n2].until)
          return t4[n2].abbr;
        if (t4[n2].until <= e3 && e3 <= t4[n2].since)
          return t4[n2].abbr;
      }
      return "";
    }, i.eraYear = function() {
      for (var e3, t4, n2 = this.localeData().eras(), s3 = 0, i2 = n2.length; s3 < i2; ++s3)
        if (e3 = n2[s3].since <= n2[s3].until ? 1 : -1, t4 = this.clone().startOf("day").valueOf(), n2[s3].since <= t4 && t4 <= n2[s3].until || n2[s3].until <= t4 && t4 <= n2[s3].since)
          return (this.year() - f(n2[s3].since).year()) * e3 + n2[s3].offset;
      return this.year();
    }, i.year = Ie, i.isLeapYear = function() {
      return he(this.year());
    }, i.weekYear = function(e3) {
      return un.call(this, e3, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }, i.isoWeekYear = function(e3) {
      return un.call(this, e3, this.isoWeek(), this.isoWeekday(), 1, 4);
    }, i.quarter = i.quarters = function(e3) {
      return null == e3 ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (e3 - 1) + this.month() % 3);
    }, i.month = Ge, i.daysInMonth = function() {
      return We(this.year(), this.month());
    }, i.week = i.weeks = function(e3) {
      var t4 = this.localeData().week(this);
      return null == e3 ? t4 : this.add(7 * (e3 - t4), "d");
    }, i.isoWeek = i.isoWeeks = function(e3) {
      var t4 = qe(this, 1, 4).week;
      return null == e3 ? t4 : this.add(7 * (e3 - t4), "d");
    }, i.weeksInYear = function() {
      var e3 = this.localeData()._week;
      return P(this.year(), e3.dow, e3.doy);
    }, i.weeksInWeekYear = function() {
      var e3 = this.localeData()._week;
      return P(this.weekYear(), e3.dow, e3.doy);
    }, i.isoWeeksInYear = function() {
      return P(this.year(), 1, 4);
    }, i.isoWeeksInISOWeekYear = function() {
      return P(this.isoWeekYear(), 1, 4);
    }, i.date = ke, i.day = i.days = function(e3) {
      if (!this.isValid())
        return null != e3 ? this : NaN;
      var t4, n2, s3 = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
      return null != e3 ? (t4 = e3, n2 = this.localeData(), e3 = "string" != typeof t4 ? t4 : isNaN(t4) ? "number" == typeof (t4 = n2.weekdaysParse(t4)) ? t4 : null : parseInt(t4, 10), this.add(e3 - s3, "d")) : s3;
    }, i.weekday = function(e3) {
      if (!this.isValid())
        return null != e3 ? this : NaN;
      var t4 = (this.day() + 7 - this.localeData()._week.dow) % 7;
      return null == e3 ? t4 : this.add(e3 - t4, "d");
    }, i.isoWeekday = function(e3) {
      return this.isValid() ? null != e3 ? (t4 = e3, n2 = this.localeData(), n2 = "string" == typeof t4 ? n2.weekdaysParse(t4) % 7 || 7 : isNaN(t4) ? null : t4, this.day(this.day() % 7 ? n2 : n2 - 7)) : this.day() || 7 : null != e3 ? this : NaN;
      var t4, n2;
    }, i.dayOfYear = function(e3) {
      var t4 = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
      return null == e3 ? t4 : this.add(e3 - t4, "d");
    }, i.hour = i.hours = k2, i.minute = i.minutes = _e, i.second = i.seconds = ve, i.millisecond = i.milliseconds = ye, i.utcOffset = function(e3, t4, n2) {
      var s3, i2 = this._offset || 0;
      if (!this.isValid())
        return null != e3 ? this : NaN;
      if (null == e3)
        return this._isUTC ? i2 : Et(this);
      if ("string" == typeof e3) {
        if (null === (e3 = Vt(Ye, e3)))
          return this;
      } else
        Math.abs(e3) < 16 && !n2 && (e3 *= 60);
      return !this._isUTC && t4 && (s3 = Et(this)), this._offset = e3, this._isUTC = true, null != s3 && this.add(s3, "m"), i2 !== e3 && (!t4 || this._changeInProgress ? qt(this, C2(e3 - i2, "m"), 1, false) : this._changeInProgress || (this._changeInProgress = true, f.updateOffset(this, true), this._changeInProgress = null)), this;
    }, i.utc = function(e3) {
      return this.utcOffset(0, e3);
    }, i.local = function(e3) {
      return this._isUTC && (this.utcOffset(0, e3), this._isUTC = false, e3 && this.subtract(Et(this), "m")), this;
    }, i.parseZone = function() {
      var e3;
      return null != this._tzm ? this.utcOffset(this._tzm, false, true) : "string" == typeof this._i && (null != (e3 = Vt(Se, this._i)) ? this.utcOffset(e3) : this.utcOffset(0, true)), this;
    }, i.hasAlignedHourOffset = function(e3) {
      return !!this.isValid() && (e3 = e3 ? W(e3).utcOffset() : 0, (this.utcOffset() - e3) % 60 == 0);
    }, i.isDST = function() {
      return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
    }, i.isLocal = function() {
      return !!this.isValid() && !this._isUTC;
    }, i.isUtcOffset = function() {
      return !!this.isValid() && this._isUTC;
    }, i.isUtc = At, i.isUTC = At, i.zoneAbbr = function() {
      return this._isUTC ? "UTC" : "";
    }, i.zoneName = function() {
      return this._isUTC ? "Coordinated Universal Time" : "";
    }, i.dates = e("dates accessor is deprecated. Use date instead.", ke), i.months = e("months accessor is deprecated. Use month instead", Ge), i.years = e("years accessor is deprecated. Use year instead", Ie), i.zone = e("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", function(e3, t4) {
      return null != e3 ? (this.utcOffset(e3 = "string" != typeof e3 ? -e3 : e3, t4), this) : -this.utcOffset();
    }), i.isDSTShifted = e("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", function() {
      if (!o(this._isDSTShifted))
        return this._isDSTShifted;
      var e3, t4 = {};
      return $(t4, this), (t4 = Nt(t4))._a ? (e3 = (t4._isUTC ? l : W)(t4._a), this._isDSTShifted = this.isValid() && 0 < function(e4, t5, n2) {
        for (var s3 = Math.min(e4.length, t5.length), i2 = Math.abs(e4.length - t5.length), r2 = 0, a3 = 0; a3 < s3; a3++)
          (n2 && e4[a3] !== t5[a3] || !n2 && g(e4[a3]) !== g(t5[a3])) && r2++;
        return r2 + i2;
      }(t4._a, e3.toArray())) : this._isDSTShifted = false, this._isDSTShifted;
    });
    w2 = K2.prototype;
    function cn(e3, t4, n2, s3) {
      var i2 = mt(), s3 = l().set(s3, t4);
      return i2[n2](s3, e3);
    }
    function fn(e3, t4, n2) {
      if (u(e3) && (t4 = e3, e3 = void 0), e3 = e3 || "", null != t4)
        return cn(e3, t4, n2, "month");
      for (var s3 = [], i2 = 0; i2 < 12; i2++)
        s3[i2] = cn(e3, i2, n2, "month");
      return s3;
    }
    function mn(e3, t4, n2, s3) {
      t4 = ("boolean" == typeof e3 ? u(t4) && (n2 = t4, t4 = void 0) : (t4 = e3, e3 = false, u(n2 = t4) && (n2 = t4, t4 = void 0)), t4 || "");
      var i2, r2 = mt(), a3 = e3 ? r2._week.dow : 0, o2 = [];
      if (null != n2)
        return cn(t4, (n2 + a3) % 7, s3, "day");
      for (i2 = 0; i2 < 7; i2++)
        o2[i2] = cn(t4, (i2 + a3) % 7, s3, "day");
      return o2;
    }
    w2.calendar = function(e3, t4, n2) {
      return d(e3 = this._calendar[e3] || this._calendar.sameElse) ? e3.call(t4, n2) : e3;
    }, w2.longDateFormat = function(e3) {
      var t4 = this._longDateFormat[e3], n2 = this._longDateFormat[e3.toUpperCase()];
      return t4 || !n2 ? t4 : (this._longDateFormat[e3] = n2.match(te).map(function(e4) {
        return "MMMM" === e4 || "MM" === e4 || "DD" === e4 || "dddd" === e4 ? e4.slice(1) : e4;
      }).join(""), this._longDateFormat[e3]);
    }, w2.invalidDate = function() {
      return this._invalidDate;
    }, w2.ordinal = function(e3) {
      return this._ordinal.replace("%d", e3);
    }, w2.preparse = dn, w2.postformat = dn, w2.relativeTime = function(e3, t4, n2, s3) {
      var i2 = this._relativeTime[n2];
      return d(i2) ? i2(e3, t4, n2, s3) : i2.replace(/%d/i, e3);
    }, w2.pastFuture = function(e3, t4) {
      return d(e3 = this._relativeTime[0 < e3 ? "future" : "past"]) ? e3(t4) : e3.replace(/%s/i, t4);
    }, w2.set = function(e3) {
      var t4, n2;
      for (n2 in e3)
        c2(e3, n2) && (d(t4 = e3[n2]) ? this[n2] = t4 : this["_" + n2] = t4);
      this._config = e3, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source);
    }, w2.eras = function(e3, t4) {
      for (var n2, s3 = this._eras || mt("en")._eras, i2 = 0, r2 = s3.length; i2 < r2; ++i2) {
        switch (typeof s3[i2].since) {
          case "string":
            n2 = f(s3[i2].since).startOf("day"), s3[i2].since = n2.valueOf();
            break;
        }
        switch (typeof s3[i2].until) {
          case "undefined":
            s3[i2].until = 1 / 0;
            break;
          case "string":
            n2 = f(s3[i2].until).startOf("day").valueOf(), s3[i2].until = n2.valueOf();
            break;
        }
      }
      return s3;
    }, w2.erasParse = function(e3, t4, n2) {
      var s3, i2, r2, a3, o2, u2 = this.eras();
      for (e3 = e3.toUpperCase(), s3 = 0, i2 = u2.length; s3 < i2; ++s3)
        if (r2 = u2[s3].name.toUpperCase(), a3 = u2[s3].abbr.toUpperCase(), o2 = u2[s3].narrow.toUpperCase(), n2)
          switch (t4) {
            case "N":
            case "NN":
            case "NNN":
              if (a3 === e3)
                return u2[s3];
              break;
            case "NNNN":
              if (r2 === e3)
                return u2[s3];
              break;
            case "NNNNN":
              if (o2 === e3)
                return u2[s3];
              break;
          }
        else if (0 <= [r2, a3, o2].indexOf(e3))
          return u2[s3];
    }, w2.erasConvertYear = function(e3, t4) {
      var n2 = e3.since <= e3.until ? 1 : -1;
      return void 0 === t4 ? f(e3.since).year() : f(e3.since).year() + (t4 - e3.offset) * n2;
    }, w2.erasAbbrRegex = function(e3) {
      return c2(this, "_erasAbbrRegex") || an.call(this), e3 ? this._erasAbbrRegex : this._erasRegex;
    }, w2.erasNameRegex = function(e3) {
      return c2(this, "_erasNameRegex") || an.call(this), e3 ? this._erasNameRegex : this._erasRegex;
    }, w2.erasNarrowRegex = function(e3) {
      return c2(this, "_erasNarrowRegex") || an.call(this), e3 ? this._erasNarrowRegex : this._erasRegex;
    }, w2.months = function(e3, t4) {
      return e3 ? (a2(this._months) ? this._months : this._months[(this._months.isFormat || He).test(t4) ? "format" : "standalone"])[e3.month()] : a2(this._months) ? this._months : this._months.standalone;
    }, w2.monthsShort = function(e3, t4) {
      return e3 ? (a2(this._monthsShort) ? this._monthsShort : this._monthsShort[He.test(t4) ? "format" : "standalone"])[e3.month()] : a2(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
    }, w2.monthsParse = function(e3, t4, n2) {
      var s3, i2;
      if (this._monthsParseExact)
        return function(e4, t5, n3) {
          var s4, i3, r2, e4 = e4.toLocaleLowerCase();
          if (!this._monthsParse)
            for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], s4 = 0; s4 < 12; ++s4)
              r2 = l([2e3, s4]), this._shortMonthsParse[s4] = this.monthsShort(r2, "").toLocaleLowerCase(), this._longMonthsParse[s4] = this.months(r2, "").toLocaleLowerCase();
          return n3 ? "MMM" === t5 ? -1 !== (i3 = S.call(this._shortMonthsParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._longMonthsParse, e4)) ? i3 : null : "MMM" === t5 ? -1 !== (i3 = S.call(this._shortMonthsParse, e4)) || -1 !== (i3 = S.call(this._longMonthsParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._longMonthsParse, e4)) || -1 !== (i3 = S.call(this._shortMonthsParse, e4)) ? i3 : null;
        }.call(this, e3, t4, n2);
      for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), s3 = 0; s3 < 12; s3++) {
        if (i2 = l([2e3, s3]), n2 && !this._longMonthsParse[s3] && (this._longMonthsParse[s3] = new RegExp("^" + this.months(i2, "").replace(".", "") + "$", "i"), this._shortMonthsParse[s3] = new RegExp("^" + this.monthsShort(i2, "").replace(".", "") + "$", "i")), n2 || this._monthsParse[s3] || (i2 = "^" + this.months(i2, "") + "|^" + this.monthsShort(i2, ""), this._monthsParse[s3] = new RegExp(i2.replace(".", ""), "i")), n2 && "MMMM" === t4 && this._longMonthsParse[s3].test(e3))
          return s3;
        if (n2 && "MMM" === t4 && this._shortMonthsParse[s3].test(e3))
          return s3;
        if (!n2 && this._monthsParse[s3].test(e3))
          return s3;
      }
    }, w2.monthsRegex = function(e3) {
      return this._monthsParseExact ? (c2(this, "_monthsRegex") || Ee.call(this), e3 ? this._monthsStrictRegex : this._monthsRegex) : (c2(this, "_monthsRegex") || (this._monthsRegex = Le), this._monthsStrictRegex && e3 ? this._monthsStrictRegex : this._monthsRegex);
    }, w2.monthsShortRegex = function(e3) {
      return this._monthsParseExact ? (c2(this, "_monthsRegex") || Ee.call(this), e3 ? this._monthsShortStrictRegex : this._monthsShortRegex) : (c2(this, "_monthsShortRegex") || (this._monthsShortRegex = Fe), this._monthsShortStrictRegex && e3 ? this._monthsShortStrictRegex : this._monthsShortRegex);
    }, w2.week = function(e3) {
      return qe(e3, this._week.dow, this._week.doy).week;
    }, w2.firstDayOfYear = function() {
      return this._week.doy;
    }, w2.firstDayOfWeek = function() {
      return this._week.dow;
    }, w2.weekdays = function(e3, t4) {
      return t4 = a2(this._weekdays) ? this._weekdays : this._weekdays[e3 && true !== e3 && this._weekdays.isFormat.test(t4) ? "format" : "standalone"], true === e3 ? Be(t4, this._week.dow) : e3 ? t4[e3.day()] : t4;
    }, w2.weekdaysMin = function(e3) {
      return true === e3 ? Be(this._weekdaysMin, this._week.dow) : e3 ? this._weekdaysMin[e3.day()] : this._weekdaysMin;
    }, w2.weekdaysShort = function(e3) {
      return true === e3 ? Be(this._weekdaysShort, this._week.dow) : e3 ? this._weekdaysShort[e3.day()] : this._weekdaysShort;
    }, w2.weekdaysParse = function(e3, t4, n2) {
      var s3, i2;
      if (this._weekdaysParseExact)
        return function(e4, t5, n3) {
          var s4, i3, r2, e4 = e4.toLocaleLowerCase();
          if (!this._weekdaysParse)
            for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], s4 = 0; s4 < 7; ++s4)
              r2 = l([2e3, 1]).day(s4), this._minWeekdaysParse[s4] = this.weekdaysMin(r2, "").toLocaleLowerCase(), this._shortWeekdaysParse[s4] = this.weekdaysShort(r2, "").toLocaleLowerCase(), this._weekdaysParse[s4] = this.weekdays(r2, "").toLocaleLowerCase();
          return n3 ? "dddd" === t5 ? -1 !== (i3 = S.call(this._weekdaysParse, e4)) ? i3 : null : "ddd" === t5 ? -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) ? i3 : null : "dddd" === t5 ? -1 !== (i3 = S.call(this._weekdaysParse, e4)) || -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) || -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) ? i3 : null : "ddd" === t5 ? -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) || -1 !== (i3 = S.call(this._weekdaysParse, e4)) || -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) ? i3 : null : -1 !== (i3 = S.call(this._minWeekdaysParse, e4)) || -1 !== (i3 = S.call(this._weekdaysParse, e4)) || -1 !== (i3 = S.call(this._shortWeekdaysParse, e4)) ? i3 : null;
        }.call(this, e3, t4, n2);
      for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), s3 = 0; s3 < 7; s3++) {
        if (i2 = l([2e3, 1]).day(s3), n2 && !this._fullWeekdaysParse[s3] && (this._fullWeekdaysParse[s3] = new RegExp("^" + this.weekdays(i2, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[s3] = new RegExp("^" + this.weekdaysShort(i2, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[s3] = new RegExp("^" + this.weekdaysMin(i2, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[s3] || (i2 = "^" + this.weekdays(i2, "") + "|^" + this.weekdaysShort(i2, "") + "|^" + this.weekdaysMin(i2, ""), this._weekdaysParse[s3] = new RegExp(i2.replace(".", ""), "i")), n2 && "dddd" === t4 && this._fullWeekdaysParse[s3].test(e3))
          return s3;
        if (n2 && "ddd" === t4 && this._shortWeekdaysParse[s3].test(e3))
          return s3;
        if (n2 && "dd" === t4 && this._minWeekdaysParse[s3].test(e3))
          return s3;
        if (!n2 && this._weekdaysParse[s3].test(e3))
          return s3;
      }
    }, w2.weekdaysRegex = function(e3) {
      return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysStrictRegex : this._weekdaysRegex) : (c2(this, "_weekdaysRegex") || (this._weekdaysRegex = Ke), this._weekdaysStrictRegex && e3 ? this._weekdaysStrictRegex : this._weekdaysRegex);
    }, w2.weekdaysShortRegex = function(e3) {
      return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (c2(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = et), this._weekdaysShortStrictRegex && e3 ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
    }, w2.weekdaysMinRegex = function(e3) {
      return this._weekdaysParseExact ? (c2(this, "_weekdaysRegex") || nt.call(this), e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (c2(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = tt), this._weekdaysMinStrictRegex && e3 ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
    }, w2.isPM = function(e3) {
      return "p" === (e3 + "").toLowerCase().charAt(0);
    }, w2.meridiem = function(e3, t4, n2) {
      return 11 < e3 ? n2 ? "pm" : "PM" : n2 ? "am" : "AM";
    }, ct("en", { eras: [{ since: "0001-01-01", until: 1 / 0, offset: 1, name: "Anno Domini", narrow: "AD", abbr: "AD" }, { since: "0000-12-31", until: -1 / 0, offset: 1, name: "Before Christ", narrow: "BC", abbr: "BC" }], dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function(e3) {
      var t4 = e3 % 10;
      return e3 + (1 === g(e3 % 100 / 10) ? "th" : 1 == t4 ? "st" : 2 == t4 ? "nd" : 3 == t4 ? "rd" : "th");
    } }), f.lang = e("moment.lang is deprecated. Use moment.locale instead.", ct), f.langData = e("moment.langData is deprecated. Use moment.localeData instead.", mt);
    var _n = Math.abs;
    function yn(e3, t4, n2, s3) {
      t4 = C2(t4, n2);
      return e3._milliseconds += s3 * t4._milliseconds, e3._days += s3 * t4._days, e3._months += s3 * t4._months, e3._bubble();
    }
    function gn(e3) {
      return e3 < 0 ? Math.floor(e3) : Math.ceil(e3);
    }
    function wn(e3) {
      return 4800 * e3 / 146097;
    }
    function pn(e3) {
      return 146097 * e3 / 4800;
    }
    function kn(e3) {
      return function() {
        return this.as(e3);
      };
    }
    pe = kn("ms"), me = kn("s"), Ce = kn("m"), we = kn("h"), ge = kn("d"), Je = kn("w"), k2 = kn("M"), _e = kn("Q"), ve = kn("y");
    function vn(e3) {
      return function() {
        return this.isValid() ? this._data[e3] : NaN;
      };
    }
    var ye = vn("milliseconds"), ke = vn("seconds"), Ie = vn("minutes"), w2 = vn("hours"), Mn = vn("days"), Dn = vn("months"), Sn = vn("years");
    var Yn2 = Math.round, On = { ss: 44, s: 45, m: 45, h: 22, d: 26, w: null, M: 11 };
    function bn(e3, t4, n2, s3) {
      var i2 = C2(e3).abs(), r2 = Yn2(i2.as("s")), a3 = Yn2(i2.as("m")), o2 = Yn2(i2.as("h")), u2 = Yn2(i2.as("d")), l2 = Yn2(i2.as("M")), h2 = Yn2(i2.as("w")), i2 = Yn2(i2.as("y")), r2 = (r2 <= n2.ss ? ["s", r2] : r2 < n2.s && ["ss", r2]) || a3 <= 1 && ["m"] || a3 < n2.m && ["mm", a3] || o2 <= 1 && ["h"] || o2 < n2.h && ["hh", o2] || u2 <= 1 && ["d"] || u2 < n2.d && ["dd", u2];
      return (r2 = (r2 = null != n2.w ? r2 || h2 <= 1 && ["w"] || h2 < n2.w && ["ww", h2] : r2) || l2 <= 1 && ["M"] || l2 < n2.M && ["MM", l2] || i2 <= 1 && ["y"] || ["yy", i2])[2] = t4, r2[3] = 0 < +e3, r2[4] = s3, function(e4, t5, n3, s4, i3) {
        return i3.relativeTime(t5 || 1, !!n3, e4, s4);
      }.apply(null, r2);
    }
    var xn = Math.abs;
    function Tn(e3) {
      return (0 < e3) - (e3 < 0) || +e3;
    }
    function Nn() {
      if (!this.isValid())
        return this.localeData().invalidDate();
      var e3, t4, n2, s3, i2, r2, a3, o2 = xn(this._milliseconds) / 1e3, u2 = xn(this._days), l2 = xn(this._months), h2 = this.asSeconds();
      return h2 ? (e3 = y2(o2 / 60), t4 = y2(e3 / 60), o2 %= 60, e3 %= 60, n2 = y2(l2 / 12), l2 %= 12, s3 = o2 ? o2.toFixed(3).replace(/\.?0+$/, "") : "", i2 = Tn(this._months) !== Tn(h2) ? "-" : "", r2 = Tn(this._days) !== Tn(h2) ? "-" : "", a3 = Tn(this._milliseconds) !== Tn(h2) ? "-" : "", (h2 < 0 ? "-" : "") + "P" + (n2 ? i2 + n2 + "Y" : "") + (l2 ? i2 + l2 + "M" : "") + (u2 ? r2 + u2 + "D" : "") + (t4 || e3 || o2 ? "T" : "") + (t4 ? a3 + t4 + "H" : "") + (e3 ? a3 + e3 + "M" : "") + (o2 ? a3 + s3 + "S" : "")) : "P0D";
    }
    var U = Ct.prototype;
    return U.isValid = function() {
      return this._isValid;
    }, U.abs = function() {
      var e3 = this._data;
      return this._milliseconds = _n(this._milliseconds), this._days = _n(this._days), this._months = _n(this._months), e3.milliseconds = _n(e3.milliseconds), e3.seconds = _n(e3.seconds), e3.minutes = _n(e3.minutes), e3.hours = _n(e3.hours), e3.months = _n(e3.months), e3.years = _n(e3.years), this;
    }, U.add = function(e3, t4) {
      return yn(this, e3, t4, 1);
    }, U.subtract = function(e3, t4) {
      return yn(this, e3, t4, -1);
    }, U.as = function(e3) {
      if (!this.isValid())
        return NaN;
      var t4, n2, s3 = this._milliseconds;
      if ("month" === (e3 = _2(e3)) || "quarter" === e3 || "year" === e3)
        switch (t4 = this._days + s3 / 864e5, n2 = this._months + wn(t4), e3) {
          case "month":
            return n2;
          case "quarter":
            return n2 / 3;
          case "year":
            return n2 / 12;
        }
      else
        switch (t4 = this._days + Math.round(pn(this._months)), e3) {
          case "week":
            return t4 / 7 + s3 / 6048e5;
          case "day":
            return t4 + s3 / 864e5;
          case "hour":
            return 24 * t4 + s3 / 36e5;
          case "minute":
            return 1440 * t4 + s3 / 6e4;
          case "second":
            return 86400 * t4 + s3 / 1e3;
          case "millisecond":
            return Math.floor(864e5 * t4) + s3;
          default:
            throw new Error("Unknown unit " + e3);
        }
    }, U.asMilliseconds = pe, U.asSeconds = me, U.asMinutes = Ce, U.asHours = we, U.asDays = ge, U.asWeeks = Je, U.asMonths = k2, U.asQuarters = _e, U.asYears = ve, U.valueOf = function() {
      return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * g(this._months / 12) : NaN;
    }, U._bubble = function() {
      var e3 = this._milliseconds, t4 = this._days, n2 = this._months, s3 = this._data;
      return 0 <= e3 && 0 <= t4 && 0 <= n2 || e3 <= 0 && t4 <= 0 && n2 <= 0 || (e3 += 864e5 * gn(pn(n2) + t4), n2 = t4 = 0), s3.milliseconds = e3 % 1e3, e3 = y2(e3 / 1e3), s3.seconds = e3 % 60, e3 = y2(e3 / 60), s3.minutes = e3 % 60, e3 = y2(e3 / 60), s3.hours = e3 % 24, t4 += y2(e3 / 24), n2 += e3 = y2(wn(t4)), t4 -= gn(pn(e3)), e3 = y2(n2 / 12), n2 %= 12, s3.days = t4, s3.months = n2, s3.years = e3, this;
    }, U.clone = function() {
      return C2(this);
    }, U.get = function(e3) {
      return e3 = _2(e3), this.isValid() ? this[e3 + "s"]() : NaN;
    }, U.milliseconds = ye, U.seconds = ke, U.minutes = Ie, U.hours = w2, U.days = Mn, U.weeks = function() {
      return y2(this.days() / 7);
    }, U.months = Dn, U.years = Sn, U.humanize = function(e3, t4) {
      if (!this.isValid())
        return this.localeData().invalidDate();
      var n2 = false, s3 = On;
      return "object" == typeof e3 && (t4 = e3, e3 = false), "boolean" == typeof e3 && (n2 = e3), "object" == typeof t4 && (s3 = Object.assign({}, On, t4), null != t4.s && null == t4.ss && (s3.ss = t4.s - 1)), e3 = this.localeData(), t4 = bn(this, !n2, s3, e3), n2 && (t4 = e3.pastFuture(+this, t4)), e3.postformat(t4);
    }, U.toISOString = Nn, U.toString = Nn, U.toJSON = Nn, U.locale = Xt, U.localeData = Kt, U.toIsoString = e("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", Nn), U.lang = Xe, s2("X", 0, 0, "unix"), s2("x", 0, 0, "valueOf"), v("x", De), v("X", /[+-]?\d+(\.\d{1,3})?/), D2("X", function(e3, t4, n2) {
      n2._d = new Date(1e3 * parseFloat(e3));
    }), D2("x", function(e3, t4, n2) {
      n2._d = new Date(g(e3));
    }), f.version = "2.29.4", H = W, f.fn = i, f.min = function() {
      return Rt("isBefore", [].slice.call(arguments, 0));
    }, f.max = function() {
      return Rt("isAfter", [].slice.call(arguments, 0));
    }, f.now = function() {
      return Date.now ? Date.now() : +new Date();
    }, f.utc = l, f.unix = function(e3) {
      return W(1e3 * e3);
    }, f.months = function(e3, t4) {
      return fn(e3, t4, "months");
    }, f.isDate = V, f.locale = ct, f.invalid = I, f.duration = C2, f.isMoment = h, f.weekdays = function(e3, t4, n2) {
      return mn(e3, t4, n2, "weekdays");
    }, f.parseZone = function() {
      return W.apply(null, arguments).parseZone();
    }, f.localeData = mt, f.isDuration = Ut, f.monthsShort = function(e3, t4) {
      return fn(e3, t4, "monthsShort");
    }, f.weekdaysMin = function(e3, t4, n2) {
      return mn(e3, t4, n2, "weekdaysMin");
    }, f.defineLocale = ft, f.updateLocale = function(e3, t4) {
      var n2, s3;
      return null != t4 ? (s3 = ot, null != R[e3] && null != R[e3].parentLocale ? R[e3].set(X3(R[e3]._config, t4)) : (t4 = X3(s3 = null != (n2 = dt(e3)) ? n2._config : s3, t4), null == n2 && (t4.abbr = e3), (s3 = new K2(t4)).parentLocale = R[e3], R[e3] = s3), ct(e3)) : null != R[e3] && (null != R[e3].parentLocale ? (R[e3] = R[e3].parentLocale, e3 === ct() && ct(e3)) : null != R[e3] && delete R[e3]), R[e3];
    }, f.locales = function() {
      return ee(R);
    }, f.weekdaysShort = function(e3, t4, n2) {
      return mn(e3, t4, n2, "weekdaysShort");
    }, f.normalizeUnits = _2, f.relativeTimeRounding = function(e3) {
      return void 0 === e3 ? Yn2 : "function" == typeof e3 && (Yn2 = e3, true);
    }, f.relativeTimeThreshold = function(e3, t4) {
      return void 0 !== On[e3] && (void 0 === t4 ? On[e3] : (On[e3] = t4, "s" === e3 && (On.ss = t4 - 1), true));
    }, f.calendarFormat = function(e3, t4) {
      return (e3 = e3.diff(t4, "days", true)) < -6 ? "sameElse" : e3 < -1 ? "lastWeek" : e3 < 0 ? "lastDay" : e3 < 1 ? "sameDay" : e3 < 2 ? "nextDay" : e3 < 7 ? "nextWeek" : "sameElse";
    }, f.prototype = i, f.HTML5_FMT = { DATETIME_LOCAL: "YYYY-MM-DDTHH:mm", DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss", DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS", DATE: "YYYY-MM-DD", TIME: "HH:mm", TIME_SECONDS: "HH:mm:ss", TIME_MS: "HH:mm:ss.SSS", WEEK: "GGGG-[W]WW", MONTH: "YYYY-MM" }, f;
  });
})(moment_min);
const moment = moment_min.exports;
var dist = {};
Object.defineProperty(dist, "__esModule", { value: true });
var sanitizeUrl_1 = dist.sanitizeUrl = void 0;
var invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
var htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
var htmlTabEntityRegex = /&tab;/gi;
var ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
var urlSchemeRegex = /^.+(:|&colon;)/gim;
var relativeFirstCharacters = [".", "/"];
function isRelativeUrlWithoutProtocol(url) {
  return relativeFirstCharacters.indexOf(url[0]) > -1;
}
function decodeHtmlCharacters(str) {
  str = str.replace(htmlTabEntityRegex, "&#9;");
  return str.replace(htmlEntitiesRegex, function(match, dec) {
    return String.fromCharCode(dec);
  });
}
function sanitizeUrl(url) {
  var sanitizedUrl = decodeHtmlCharacters(url || "").replace(ctrlCharactersRegex, "").trim();
  if (!sanitizedUrl) {
    return "about:blank";
  }
  if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
    return sanitizedUrl;
  }
  var urlSchemeParseResults = sanitizedUrl.match(urlSchemeRegex);
  if (!urlSchemeParseResults) {
    return sanitizedUrl;
  }
  var urlScheme = urlSchemeParseResults[0];
  if (invalidProtocolRegex.test(urlScheme)) {
    return "about:blank";
  }
  return sanitizedUrl;
}
sanitizeUrl_1 = dist.sanitizeUrl = sanitizeUrl;
function identity$b(x2) {
  return x2;
}
var top$1 = 1, right$1 = 2, bottom$1 = 3, left$1 = 4, epsilon$7 = 1e-6;
function translateX$1(x2) {
  return "translate(" + x2 + ",0)";
}
function translateY$1(y2) {
  return "translate(0," + y2 + ")";
}
function number$4(scale) {
  return (d) => +scale(d);
}
function center$2(scale, offset) {
  offset = Math.max(0, scale.bandwidth() - offset * 2) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return (d) => +scale(d) + offset;
}
function entering$1() {
  return !this.__axis;
}
function axis$1(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, offset = typeof window !== "undefined" && window.devicePixelRatio > 1 ? 0 : 0.5, k2 = orient === top$1 || orient === left$1 ? -1 : 1, x2 = orient === left$1 || orient === right$1 ? "x" : "y", transform2 = orient === top$1 || orient === bottom$1 ? translateX$1 : translateY$1;
  function axis2(context) {
    var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$b : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + offset, range1 = +range2[range2.length - 1] + offset, position2 = (scale.bandwidth ? center$2 : number$4)(scale.copy(), offset), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k2 * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k2 * spacing).attr("dy", orient === top$1 ? "0em" : orient === bottom$1 ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$7).attr("transform", function(d) {
        return isFinite(d = position2(d)) ? transform2(d + offset) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$7).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2((p && isFinite(p = p(d)) ? p : position2(d)) + offset);
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left$1 || orient === right$1 ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H" + offset + "V" + range1 + "H" + k2 * tickSizeOuter : "M" + offset + "," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V" + offset + "H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + "," + offset + "H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position2(d) + offset);
    });
    line2.attr(x2 + "2", k2 * tickSizeInner);
    text2.attr(x2, k2 * spacing).text(format2);
    selection2.filter(entering$1).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right$1 ? "start" : orient === left$1 ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_2) {
    return arguments.length ? (scale = _2, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = Array.from(arguments), axis2;
  };
  axis2.tickArguments = function(_2) {
    return arguments.length ? (tickArguments = _2 == null ? [] : Array.from(_2), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_2) {
    return arguments.length ? (tickValues = _2 == null ? null : Array.from(_2), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_2) {
    return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_2) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_2) {
    return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_2) {
    return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_2) {
    return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
  };
  axis2.offset = function(_2) {
    return arguments.length ? (offset = +_2, axis2) : offset;
  };
  return axis2;
}
function axisTop$1(scale) {
  return axis$1(top$1, scale);
}
function axisBottom$1(scale) {
  return axis$1(bottom$1, scale);
}
const pi$6 = Math.PI, tau$6 = 2 * pi$6, epsilon$6 = 1e-6, tauEpsilon$1 = tau$6 - epsilon$6;
function Path$1() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path$1() {
  return new Path$1();
}
Path$1.prototype = path$1.prototype = {
  constructor: Path$1,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x12, y12, x2, y2) {
    this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._ += "C" + +x12 + "," + +y12 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x12, y12, x2, y2, r) {
    x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
    var x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else if (!(l01_2 > epsilon$6))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$6) || !r) {
      this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else {
      var x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$6 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon$6) {
        this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x2 + dx, y02 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x02 + "," + y02;
    } else if (Math.abs(this._x1 - x02) > epsilon$6 || Math.abs(this._y1 - y02) > epsilon$6) {
      this._ += "L" + x02 + "," + y02;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau$6 + tau$6;
    if (da > tauEpsilon$1) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x02) + "," + (this._y1 = y02);
    } else if (da > epsilon$6) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi$6) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w2, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w2 + "v" + +h + "h" + -w2 + "Z";
  },
  toString: function() {
    return this._;
  }
};
function constant$e(x2) {
  return function constant2() {
    return x2;
  };
}
const abs$3 = Math.abs;
const atan2$2 = Math.atan2;
const cos$3 = Math.cos;
const max$3 = Math.max;
const min$2 = Math.min;
const sin$3 = Math.sin;
const sqrt$3 = Math.sqrt;
const epsilon$5 = 1e-12;
const pi$5 = Math.PI;
const halfPi$4 = pi$5 / 2;
const tau$5 = 2 * pi$5;
function acos$2(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$5 : Math.acos(x2);
}
function asin$2(x2) {
  return x2 >= 1 ? halfPi$4 : x2 <= -1 ? -halfPi$4 : Math.asin(x2);
}
function arcInnerRadius$1(d) {
  return d.innerRadius;
}
function arcOuterRadius$1(d) {
  return d.outerRadius;
}
function arcStartAngle$1(d) {
  return d.startAngle;
}
function arcEndAngle$1(d) {
  return d.endAngle;
}
function arcPadAngle$1(d) {
  return d && d.padAngle;
}
function intersect$3(x02, y02, x12, y12, x2, y2, x3, y3) {
  var x10 = x12 - x02, y10 = y12 - y02, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$5)
    return;
  t = (x32 * (y02 - y2) - y32 * (x02 - x2)) / t;
  return [x02 + t * x10, y02 + t * y10];
}
function cornerTangents$1(x02, y02, x12, y12, r1, rc, cw) {
  var x01 = x02 - x12, y01 = y02 - y12, lo = (cw ? rc : -rc) / sqrt$3(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y02 + oy, x10 = x12 + ox, y10 = y12 + oy, x002 = (x11 + x10) / 2, y002 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt$3(max$3(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x002, dy0 = cy0 - y002, dx1 = cx1 - x002, dy1 = cy1 - y002;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc$1() {
  var innerRadius = arcInnerRadius$1, outerRadius = arcOuterRadius$1, cornerRadius = constant$e(0), padRadius = null, startAngle = arcStartAngle$1, endAngle = arcEndAngle$1, padAngle = arcPadAngle$1, context = null;
  function arc2() {
    var buffer2, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi$4, a1 = endAngle.apply(this, arguments) - halfPi$4, da = abs$3(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer2 = path$1();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon$5))
      context.moveTo(0, 0);
    else if (da > tau$5 - epsilon$5) {
      context.moveTo(r1 * cos$3(a0), r1 * sin$3(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$5) {
        context.moveTo(r0 * cos$3(a1), r0 * sin$3(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$5 && (padRadius ? +padRadius.apply(this, arguments) : sqrt$3(r0 * r0 + r1 * r1)), rc = min$2(abs$3(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$5) {
        var p02 = asin$2(rp / r0 * sin$3(ap)), p1 = asin$2(rp / r1 * sin$3(ap));
        if ((da0 -= p02 * 2) > epsilon$5)
          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$5)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos$3(a01), y01 = r1 * sin$3(a01), x10 = r0 * cos$3(a10), y10 = r0 * sin$3(a10);
      if (rc > epsilon$5) {
        var x11 = r1 * cos$3(a11), y11 = r1 * sin$3(a11), x002 = r0 * cos$3(a00), y002 = r0 * sin$3(a00), oc;
        if (da < pi$5 && (oc = intersect$3(x01, y01, x002, y002, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin$3(acos$2((ax * bx + ay * by) / (sqrt$3(ax * ax + ay * ay) * sqrt$3(bx * bx + by * by))) / 2), lc = sqrt$3(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min$2(rc, (r0 - lc) / (kc - 1));
          rc1 = min$2(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon$5))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon$5) {
        t02 = cornerTangents$1(x002, y002, x01, y01, r1, rc1, cw);
        t12 = cornerTangents$1(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2$2(t02.y01, t02.x01), atan2$2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2$2(t02.y01, t02.x01), atan2$2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r1, atan2$2(t02.cy + t02.y11, t02.cx + t02.x11), atan2$2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context.arc(t12.cx, t12.cy, rc1, atan2$2(t12.y11, t12.x11), atan2$2(t12.y01, t12.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon$5) || !(da0 > epsilon$5))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon$5) {
        t02 = cornerTangents$1(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents$1(x01, y01, x002, y002, r0, -rc0, cw);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2$2(t02.y01, t02.x01), atan2$2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2$2(t02.y01, t02.x01), atan2$2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r0, atan2$2(t02.cy + t02.y11, t02.cx + t02.x11), atan2$2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context.arc(t12.cx, t12.cy, rc0, atan2$2(t12.y11, t12.x11), atan2$2(t12.y01, t12.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  arc2.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi$5 / 2;
    return [cos$3(a2) * r, sin$3(a2) * r];
  };
  arc2.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : padRadius;
  };
  arc2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : startAngle;
  };
  arc2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : endAngle;
  };
  arc2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$e(+_2), arc2) : padAngle;
  };
  arc2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc2) : context;
  };
  return arc2;
}
function array$4(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear$1(context) {
  this._context = context;
}
Linear$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear$1(context) {
  return new Linear$1(context);
}
function x$5(p) {
  return p[0];
}
function y$5(p) {
  return p[1];
}
function line$2(x2, y2) {
  var defined = constant$e(true), context = null, curve = curveLinear$1, output = null;
  x2 = typeof x2 === "function" ? x2 : x2 === void 0 ? x$5 : constant$e(x2);
  y2 = typeof y2 === "function" ? y2 : y2 === void 0 ? y$5 : constant$e(y2);
  function line2(data) {
    var i, n = (data = array$4(data)).length, d, defined0 = false, buffer2;
    if (context == null)
      output = curve(buffer2 = path$1());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  line2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$e(+_2), line2) : x2;
  };
  line2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$e(+_2), line2) : y2;
  };
  line2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$e(!!_2), line2) : defined;
  };
  line2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
  };
  return line2;
}
function descending$3(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function identity$a(d) {
  return d;
}
function pie$1() {
  var value = identity$a, sortValues = descending$3, sort2 = null, startAngle = constant$e(0), endAngle = constant$e(tau$5), padAngle = constant$e(0);
  function pie2(data) {
    var i, n = (data = array$4(data)).length, j, k2, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau$5, Math.max(-tau$5, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index2[i] = i] = +value(data[i], i, data)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null)
      index2.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
    else if (sort2 != null)
      index2.sort(function(i2, j2) {
        return sort2(data[i2], data[j2]);
      });
    for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j = index2[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : value;
  };
  pie2.sortValues = function(_2) {
    return arguments.length ? (sortValues = _2, sort2 = null, pie2) : sortValues;
  };
  pie2.sort = function(_2) {
    return arguments.length ? (sort2 = _2, sortValues = null, pie2) : sort2;
  };
  pie2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : startAngle;
  };
  pie2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : endAngle;
  };
  pie2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$e(+_2), pie2) : padAngle;
  };
  return pie2;
}
function noop$4() {
}
function point$8(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis$1(context) {
  this._context = context;
}
Basis$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$8(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$8(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context) {
  return new Basis$1(context);
}
function BasisClosed$1(context) {
  this._context = context;
}
BasisClosed$1.prototype = {
  areaStart: noop$4,
  areaEnd: noop$4,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$8(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context) {
  return new BasisClosed$1(context);
}
function BasisOpen$1(context) {
  this._context = context;
}
BasisOpen$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x02 = (this._x0 + 4 * this._x1 + x2) / 6, y02 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x02, y02) : this._context.moveTo(x02, y02);
        break;
      case 3:
        this._point = 4;
      default:
        point$8(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context) {
  return new BasisOpen$1(context);
}
function LinearClosed$1(context) {
  this._context = context;
}
LinearClosed$1.prototype = {
  areaStart: noop$4,
  areaEnd: noop$4,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context) {
  return new LinearClosed$1(context);
}
function sign$2(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3$1(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign$2(s0) + sign$2(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2$1(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point$7(that, t02, t12) {
  var x02 = that._x0, y02 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x02) / 3;
  that._context.bezierCurveTo(x02 + dx, y02 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX$1(context) {
  this._context = context;
}
MonotoneX$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$7(this, this._t0, slope2$1(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$7(this, slope2$1(this, t12 = slope3$1(this, x2, y2)), t12);
        break;
      default:
        point$7(this, this._t0, t12 = slope3$1(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY$1(context) {
  this._context = new ReflectContext$1(context);
}
(MonotoneY$1.prototype = Object.create(MonotoneX$1.prototype)).point = function(x2, y2) {
  MonotoneX$1.prototype.point.call(this, y2, x2);
};
function ReflectContext$1(context) {
  this._context = context;
}
ReflectContext$1.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
  }
};
function monotoneX$1(context) {
  return new MonotoneX$1(context);
}
function monotoneY$1(context) {
  return new MonotoneY$1(context);
}
function Natural$1(context) {
  this._context = context;
}
Natural$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints$1(x2), py = controlPoints$1(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints$1(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function curveNatural(context) {
  return new Natural$1(context);
}
function Step$1(context, t) {
  this._context = context;
  this._t = t;
}
Step$1.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context) {
  return new Step$1(context, 0.5);
}
function stepBefore$1(context) {
  return new Step$1(context, 0);
}
function stepAfter$1(context) {
  return new Step$1(context, 1);
}
/*! @license DOMPurify 2.4.0 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/2.4.0/LICENSE */
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a2 = [null];
      a2.push.apply(a2, args2);
      var Constructor = Function.bind.apply(Parent2, a2);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
var hasOwnProperty$2 = Object.hasOwnProperty, setPrototypeOf = Object.setPrototypeOf, isFrozen = Object.isFrozen, getPrototypeOf = Object.getPrototypeOf, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var freeze = Object.freeze, seal = Object.seal, create$2 = Object.create;
var _ref = typeof Reflect !== "undefined" && Reflect, apply$1 = _ref.apply, construct = _ref.construct;
if (!apply$1) {
  apply$1 = function apply2(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!freeze) {
  freeze = function freeze2(x2) {
    return x2;
  };
}
if (!seal) {
  seal = function seal2(x2) {
    return x2;
  };
}
if (!construct) {
  construct = function construct2(Func, args) {
    return _construct(Func, _toConsumableArray(args));
  };
}
var arrayForEach = unapply(Array.prototype.forEach);
var arrayPop = unapply(Array.prototype.pop);
var arrayPush = unapply(Array.prototype.push);
var stringToLowerCase = unapply(String.prototype.toLowerCase);
var stringMatch = unapply(String.prototype.match);
var stringReplace = unapply(String.prototype.replace);
var stringIndexOf = unapply(String.prototype.indexOf);
var stringTrim = unapply(String.prototype.trim);
var regExpTest = unapply(RegExp.prototype.test);
var typeErrorCreate = unconstruct(TypeError);
function unapply(func) {
  return function(thisArg) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply$1(func, thisArg, args);
  };
}
function unconstruct(func) {
  return function() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
function addToSet(set2, array2, transformCaseFunc) {
  transformCaseFunc = transformCaseFunc ? transformCaseFunc : stringToLowerCase;
  if (setPrototypeOf) {
    setPrototypeOf(set2, null);
  }
  var l = array2.length;
  while (l--) {
    var element = array2[l];
    if (typeof element === "string") {
      var lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        if (!isFrozen(array2)) {
          array2[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set2[element] = true;
  }
  return set2;
}
function clone$1(object2) {
  var newObject = create$2(null);
  var property;
  for (property in object2) {
    if (apply$1(hasOwnProperty$2, object2, [property])) {
      newObject[property] = object2[property];
    }
  }
  return newObject;
}
function lookupGetter(object2, prop) {
  while (object2 !== null) {
    var desc = getOwnPropertyDescriptor(object2, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === "function") {
        return unapply(desc.value);
      }
    }
    object2 = getPrototypeOf(object2);
  }
  function fallbackValue(element) {
    console.warn("fallback value for", element);
    return null;
  }
  return fallbackValue;
}
var html$1 = freeze(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]);
var svg$1 = freeze(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]);
var svgFilters = freeze(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]);
var svgDisallowed = freeze(["animate", "color-profile", "cursor", "discard", "fedropshadow", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]);
var mathMl$1 = freeze(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover"]);
var mathMlDisallowed = freeze(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]);
var text$1 = freeze(["#text"]);
var html$2 = freeze(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "xmlns", "slot"]);
var svg$2 = freeze(["accent-height", "accumulate", "additive", "alignment-baseline", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]);
var mathMl = freeze(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]);
var xml$1 = freeze(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]);
var MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm);
var ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
var DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]/);
var ARIA_ATTR = seal(/^aria-[\-\w]+$/);
var IS_ALLOWED_URI = seal(
  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
);
var IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
var ATTR_WHITESPACE = seal(
  /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
);
var DOCTYPE_NAME = seal(/^html$/i);
var getGlobal = function getGlobal2() {
  return typeof window === "undefined" ? null : window;
};
var _createTrustedTypesPolicy = function _createTrustedTypesPolicy2(trustedTypes, document2) {
  if (_typeof(trustedTypes) !== "object" || typeof trustedTypes.createPolicy !== "function") {
    return null;
  }
  var suffix = null;
  var ATTR_NAME = "data-tt-policy-suffix";
  if (document2.currentScript && document2.currentScript.hasAttribute(ATTR_NAME)) {
    suffix = document2.currentScript.getAttribute(ATTR_NAME);
  }
  var policyName = "dompurify" + (suffix ? "#" + suffix : "");
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML: function createHTML(html2) {
        return html2;
      },
      createScriptURL: function createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_2) {
    console.warn("TrustedTypes policy " + policyName + " could not be created.");
    return null;
  }
};
function createDOMPurify() {
  var window2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getGlobal();
  var DOMPurify = function DOMPurify2(root2) {
    return createDOMPurify(root2);
  };
  DOMPurify.version = "2.4.0";
  DOMPurify.removed = [];
  if (!window2 || !window2.document || window2.document.nodeType !== 9) {
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  var originalDocument = window2.document;
  var document2 = window2.document;
  var DocumentFragment = window2.DocumentFragment, HTMLTemplateElement = window2.HTMLTemplateElement, Node2 = window2.Node, Element = window2.Element, NodeFilter = window2.NodeFilter, _window$NamedNodeMap = window2.NamedNodeMap, NamedNodeMap = _window$NamedNodeMap === void 0 ? window2.NamedNodeMap || window2.MozNamedAttrMap : _window$NamedNodeMap, HTMLFormElement = window2.HTMLFormElement, DOMParser2 = window2.DOMParser, trustedTypes = window2.trustedTypes;
  var ElementPrototype = Element.prototype;
  var cloneNode = lookupGetter(ElementPrototype, "cloneNode");
  var getNextSibling = lookupGetter(ElementPrototype, "nextSibling");
  var getChildNodes = lookupGetter(ElementPrototype, "childNodes");
  var getParentNode = lookupGetter(ElementPrototype, "parentNode");
  if (typeof HTMLTemplateElement === "function") {
    var template = document2.createElement("template");
    if (template.content && template.content.ownerDocument) {
      document2 = template.content.ownerDocument;
    }
  }
  var trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, originalDocument);
  var emptyHTML = trustedTypesPolicy ? trustedTypesPolicy.createHTML("") : "";
  var _document = document2, implementation = _document.implementation, createNodeIterator = _document.createNodeIterator, createDocumentFragment = _document.createDocumentFragment, getElementsByTagName = _document.getElementsByTagName;
  var importNode = originalDocument.importNode;
  var documentMode = {};
  try {
    documentMode = clone$1(document2).documentMode ? document2.documentMode : {};
  } catch (_2) {
  }
  var hooks = {};
  DOMPurify.isSupported = typeof getParentNode === "function" && implementation && typeof implementation.createHTMLDocument !== "undefined" && documentMode !== 9;
  var MUSTACHE_EXPR$1 = MUSTACHE_EXPR, ERB_EXPR$1 = ERB_EXPR, DATA_ATTR$1 = DATA_ATTR, ARIA_ATTR$1 = ARIA_ATTR, IS_SCRIPT_OR_DATA$1 = IS_SCRIPT_OR_DATA, ATTR_WHITESPACE$1 = ATTR_WHITESPACE;
  var IS_ALLOWED_URI$1 = IS_ALLOWED_URI;
  var ALLOWED_TAGS = null;
  var DEFAULT_ALLOWED_TAGS = addToSet({}, [].concat(_toConsumableArray(html$1), _toConsumableArray(svg$1), _toConsumableArray(svgFilters), _toConsumableArray(mathMl$1), _toConsumableArray(text$1)));
  var ALLOWED_ATTR = null;
  var DEFAULT_ALLOWED_ATTR = addToSet({}, [].concat(_toConsumableArray(html$2), _toConsumableArray(svg$2), _toConsumableArray(mathMl), _toConsumableArray(xml$1)));
  var CUSTOM_ELEMENT_HANDLING = Object.seal(Object.create(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  var FORBID_TAGS = null;
  var FORBID_ATTR = null;
  var ALLOW_ARIA_ATTR = true;
  var ALLOW_DATA_ATTR = true;
  var ALLOW_UNKNOWN_PROTOCOLS = false;
  var SAFE_FOR_TEMPLATES = false;
  var WHOLE_DOCUMENT = false;
  var SET_CONFIG = false;
  var FORCE_BODY = false;
  var RETURN_DOM = false;
  var RETURN_DOM_FRAGMENT = false;
  var RETURN_TRUSTED_TYPE = false;
  var SANITIZE_DOM = true;
  var SANITIZE_NAMED_PROPS = false;
  var SANITIZE_NAMED_PROPS_PREFIX = "user-content-";
  var KEEP_CONTENT = true;
  var IN_PLACE = false;
  var USE_PROFILES = {};
  var FORBID_CONTENTS = null;
  var DEFAULT_FORBID_CONTENTS = addToSet({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
  var DATA_URI_TAGS = null;
  var DEFAULT_DATA_URI_TAGS = addToSet({}, ["audio", "video", "img", "source", "image", "track"]);
  var URI_SAFE_ATTRIBUTES = null;
  var DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]);
  var MATHML_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
  var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
  var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
  var NAMESPACE = HTML_NAMESPACE;
  var IS_EMPTY_INPUT = false;
  var PARSER_MEDIA_TYPE;
  var SUPPORTED_PARSER_MEDIA_TYPES = ["application/xhtml+xml", "text/html"];
  var DEFAULT_PARSER_MEDIA_TYPE = "text/html";
  var transformCaseFunc;
  var CONFIG = null;
  var formElement = document2.createElement("form");
  var isRegexOrFunction = function isRegexOrFunction2(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  var _parseConfig = function _parseConfig2(cfg) {
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    if (!cfg || _typeof(cfg) !== "object") {
      cfg = {};
    }
    cfg = clone$1(cfg);
    PARSER_MEDIA_TYPE = SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? PARSER_MEDIA_TYPE = DEFAULT_PARSER_MEDIA_TYPE : PARSER_MEDIA_TYPE = cfg.PARSER_MEDIA_TYPE;
    transformCaseFunc = PARSER_MEDIA_TYPE === "application/xhtml+xml" ? function(x2) {
      return x2;
    } : stringToLowerCase;
    ALLOWED_TAGS = "ALLOWED_TAGS" in cfg ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = "ALLOWED_ATTR" in cfg ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    URI_SAFE_ATTRIBUTES = "ADD_URI_SAFE_ATTR" in cfg ? addToSet(
      clone$1(DEFAULT_URI_SAFE_ATTRIBUTES),
      cfg.ADD_URI_SAFE_ATTR,
      transformCaseFunc
    ) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = "ADD_DATA_URI_TAGS" in cfg ? addToSet(
      clone$1(DEFAULT_DATA_URI_TAGS),
      cfg.ADD_DATA_URI_TAGS,
      transformCaseFunc
    ) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = "FORBID_CONTENTS" in cfg ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = "FORBID_TAGS" in cfg ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : {};
    FORBID_ATTR = "FORBID_ATTR" in cfg ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : {};
    USE_PROFILES = "USE_PROFILES" in cfg ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false;
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false;
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false;
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false;
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false;
    RETURN_DOM = cfg.RETURN_DOM || false;
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false;
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false;
    FORCE_BODY = cfg.FORCE_BODY || false;
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false;
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false;
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false;
    IN_PLACE = cfg.IN_PLACE || false;
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI$1;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === "boolean") {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, _toConsumableArray(text$1));
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html$2);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml$1);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg$2);
        addToSet(ALLOWED_ATTR, xml$1);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml$1);
      }
    }
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone$1(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone$1(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone$1(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    if (KEEP_CONTENT) {
      ALLOWED_TAGS["#text"] = true;
    }
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ["html", "head", "body"]);
    }
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ["tbody"]);
      delete FORBID_TAGS.tbody;
    }
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  var MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ["mi", "mo", "mn", "ms", "mtext"]);
  var HTML_INTEGRATION_POINTS = addToSet({}, ["foreignobject", "desc", "title", "annotation-xml"]);
  var COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ["title", "style", "font", "a", "script"]);
  var ALL_SVG_TAGS = addToSet({}, svg$1);
  addToSet(ALL_SVG_TAGS, svgFilters);
  addToSet(ALL_SVG_TAGS, svgDisallowed);
  var ALL_MATHML_TAGS = addToSet({}, mathMl$1);
  addToSet(ALL_MATHML_TAGS, mathMlDisallowed);
  var _checkValidNamespace = function _checkValidNamespace2(element) {
    var parent = getParentNode(element);
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: HTML_NAMESPACE,
        tagName: "template"
      };
    }
    var tagName = stringToLowerCase(element.tagName);
    var parentTagName = stringToLowerCase(parent.tagName);
    if (element.namespaceURI === SVG_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "svg";
      }
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === "svg" && (parentTagName === "annotation-xml" || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === "math";
      }
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === "math" && HTML_INTEGRATION_POINTS[parentTagName];
      }
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    return false;
  };
  var _forceRemove = function _forceRemove2(node2) {
    arrayPush(DOMPurify.removed, {
      element: node2
    });
    try {
      node2.parentNode.removeChild(node2);
    } catch (_2) {
      try {
        node2.outerHTML = emptyHTML;
      } catch (_3) {
        node2.remove();
      }
    }
  };
  var _removeAttribute = function _removeAttribute2(name2, node2) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: node2.getAttributeNode(name2),
        from: node2
      });
    } catch (_2) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: node2
      });
    }
    node2.removeAttribute(name2);
    if (name2 === "is" && !ALLOWED_ATTR[name2]) {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(node2);
        } catch (_2) {
        }
      } else {
        try {
          node2.setAttribute(name2, "");
        } catch (_2) {
        }
      }
    }
  };
  var _initDocument = function _initDocument2(dirty) {
    var doc;
    var leadingWhitespace;
    if (FORCE_BODY) {
      dirty = "<remove></remove>" + dirty;
    } else {
      var matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === "application/xhtml+xml") {
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + "</body></html>";
    }
    var dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser2().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_2) {
      }
    }
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, "template", null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? "" : dirtyPayload;
      } catch (_2) {
      }
    }
    var body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document2.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? "html" : "body")[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  var _createIterator = function _createIterator2(root2) {
    return createNodeIterator.call(
      root2.ownerDocument || root2,
      root2,
      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT,
      null,
      false
    );
  };
  var _isClobbered = function _isClobbered2(elm) {
    return elm instanceof HTMLFormElement && (typeof elm.nodeName !== "string" || typeof elm.textContent !== "string" || typeof elm.removeChild !== "function" || !(elm.attributes instanceof NamedNodeMap) || typeof elm.removeAttribute !== "function" || typeof elm.setAttribute !== "function" || typeof elm.namespaceURI !== "string" || typeof elm.insertBefore !== "function");
  };
  var _isNode = function _isNode2(object2) {
    return _typeof(Node2) === "object" ? object2 instanceof Node2 : object2 && _typeof(object2) === "object" && typeof object2.nodeType === "number" && typeof object2.nodeName === "string";
  };
  var _executeHook = function _executeHook2(entryPoint, currentNode, data) {
    if (!hooks[entryPoint]) {
      return;
    }
    arrayForEach(hooks[entryPoint], function(hook) {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  };
  var _sanitizeElements = function _sanitizeElements2(currentNode) {
    var content;
    _executeHook("beforeSanitizeElements", currentNode, null);
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if (regExpTest(/[\u0080-\uFFFF]/, currentNode.nodeName)) {
      _forceRemove(currentNode);
      return true;
    }
    var tagName = transformCaseFunc(currentNode.nodeName);
    _executeHook("uponSanitizeElement", currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    if (currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && (!_isNode(currentNode.content) || !_isNode(currentNode.content.firstElementChild)) && regExpTest(/<[/\w]/g, currentNode.innerHTML) && regExpTest(/<[/\w]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    if (tagName === "select" && regExpTest(/<template/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      if (!FORBID_TAGS[tagName] && _basicCustomElementTest(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName))
          return false;
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName))
          return false;
      }
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        var parentNode = getParentNode(currentNode) || currentNode.parentNode;
        var childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          var childCount = childNodes.length;
          for (var i = childCount - 1; i >= 0; --i) {
            parentNode.insertBefore(cloneNode(childNodes[i], true), getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    if ((tagName === "noscript" || tagName === "noembed") && regExpTest(/<\/no(script|embed)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === 3) {
      content = currentNode.textContent;
      content = stringReplace(content, MUSTACHE_EXPR$1, " ");
      content = stringReplace(content, ERB_EXPR$1, " ");
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    _executeHook("afterSanitizeElements", currentNode, null);
    return false;
  };
  var _isValidAttribute = function _isValidAttribute2(lcTag, lcName, value) {
    if (SANITIZE_DOM && (lcName === "id" || lcName === "name") && (value in document2 || value in formElement)) {
      return false;
    }
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR$1, lcName))
      ;
    else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR$1, lcName))
      ;
    else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (_basicCustomElementTest(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || lcName === "is" && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value)))
        ;
      else {
        return false;
      }
    } else if (URI_SAFE_ATTRIBUTES[lcName])
      ;
    else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if ((lcName === "src" || lcName === "xlink:href" || lcName === "href") && lcTag !== "script" && stringIndexOf(value, "data:") === 0 && DATA_URI_TAGS[lcTag])
      ;
    else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA$1, stringReplace(value, ATTR_WHITESPACE$1, "")))
      ;
    else if (!value)
      ;
    else {
      return false;
    }
    return true;
  };
  var _basicCustomElementTest = function _basicCustomElementTest2(tagName) {
    return tagName.indexOf("-") > 0;
  };
  var _sanitizeAttributes = function _sanitizeAttributes2(currentNode) {
    var attr;
    var value;
    var lcName;
    var l;
    _executeHook("beforeSanitizeAttributes", currentNode, null);
    var attributes = currentNode.attributes;
    if (!attributes) {
      return;
    }
    var hookEvent = {
      attrName: "",
      attrValue: "",
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR
    };
    l = attributes.length;
    while (l--) {
      attr = attributes[l];
      var _attr = attr, name2 = _attr.name, namespaceURI = _attr.namespaceURI;
      value = name2 === "value" ? attr.value : stringTrim(attr.value);
      lcName = transformCaseFunc(name2);
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = void 0;
      _executeHook("uponSanitizeAttribute", currentNode, hookEvent);
      value = hookEvent.attrValue;
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      _removeAttribute(name2, currentNode);
      if (!hookEvent.keepAttr) {
        continue;
      }
      if (regExpTest(/\/>/i, value)) {
        _removeAttribute(name2, currentNode);
        continue;
      }
      if (SAFE_FOR_TEMPLATES) {
        value = stringReplace(value, MUSTACHE_EXPR$1, " ");
        value = stringReplace(value, ERB_EXPR$1, " ");
      }
      var lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        continue;
      }
      if (SANITIZE_NAMED_PROPS && (lcName === "id" || lcName === "name")) {
        _removeAttribute(name2, currentNode);
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      if (trustedTypesPolicy && _typeof(trustedTypes) === "object" && typeof trustedTypes.getAttributeType === "function") {
        if (namespaceURI)
          ;
        else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case "TrustedHTML":
              value = trustedTypesPolicy.createHTML(value);
              break;
            case "TrustedScriptURL":
              value = trustedTypesPolicy.createScriptURL(value);
              break;
          }
        }
      }
      try {
        if (namespaceURI) {
          currentNode.setAttributeNS(namespaceURI, name2, value);
        } else {
          currentNode.setAttribute(name2, value);
        }
        arrayPop(DOMPurify.removed);
      } catch (_2) {
      }
    }
    _executeHook("afterSanitizeAttributes", currentNode, null);
  };
  var _sanitizeShadowDOM = function _sanitizeShadowDOM2(fragment) {
    var shadowNode;
    var shadowIterator = _createIterator(fragment);
    _executeHook("beforeSanitizeShadowDOM", fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      _executeHook("uponSanitizeShadowNode", shadowNode, null);
      if (_sanitizeElements(shadowNode)) {
        continue;
      }
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM2(shadowNode.content);
      }
      _sanitizeAttributes(shadowNode);
    }
    _executeHook("afterSanitizeShadowDOM", fragment, null);
  };
  DOMPurify.sanitize = function(dirty) {
    var cfg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var body;
    var importedNode;
    var currentNode;
    var oldNode;
    var returnNode;
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = "<!-->";
    }
    if (typeof dirty !== "string" && !_isNode(dirty)) {
      if (typeof dirty.toString !== "function") {
        throw typeErrorCreate("toString is not a function");
      } else {
        dirty = dirty.toString();
        if (typeof dirty !== "string") {
          throw typeErrorCreate("dirty is not a string, aborting");
        }
      }
    }
    if (!DOMPurify.isSupported) {
      if (_typeof(window2.toStaticHTML) === "object" || typeof window2.toStaticHTML === "function") {
        if (typeof dirty === "string") {
          return window2.toStaticHTML(dirty);
        }
        if (_isNode(dirty)) {
          return window2.toStaticHTML(dirty.outerHTML);
        }
      }
      return dirty;
    }
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    DOMPurify.removed = [];
    if (typeof dirty === "string") {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      if (dirty.nodeName) {
        var tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate("root node is forbidden and cannot be sanitized in-place");
        }
      }
    } else if (dirty instanceof Node2) {
      body = _initDocument("<!---->");
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === 1 && importedNode.nodeName === "BODY") {
        body = importedNode;
      } else if (importedNode.nodeName === "HTML") {
        body = importedNode;
      } else {
        body.appendChild(importedNode);
      }
    } else {
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && dirty.indexOf("<") === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      body = _initDocument(dirty);
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : "";
      }
    }
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    var nodeIterator = _createIterator(IN_PLACE ? dirty : body);
    while (currentNode = nodeIterator.nextNode()) {
      if (currentNode.nodeType === 3 && currentNode === oldNode) {
        continue;
      }
      if (_sanitizeElements(currentNode)) {
        continue;
      }
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
      _sanitizeAttributes(currentNode);
      oldNode = currentNode;
    }
    oldNode = null;
    if (IN_PLACE) {
      return dirty;
    }
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot) {
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    var serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    if (WHOLE_DOCUMENT && ALLOWED_TAGS["!doctype"] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = "<!DOCTYPE " + body.ownerDocument.doctype.name + ">\n" + serializedHTML;
    }
    if (SAFE_FOR_TEMPLATES) {
      serializedHTML = stringReplace(serializedHTML, MUSTACHE_EXPR$1, " ");
      serializedHTML = stringReplace(serializedHTML, ERB_EXPR$1, " ");
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function(cfg) {
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function() {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function(tag, attr, value) {
    if (!CONFIG) {
      _parseConfig({});
    }
    var lcTag = transformCaseFunc(tag);
    var lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function(entryPoint, hookFunction) {
    if (typeof hookFunction !== "function") {
      return;
    }
    hooks[entryPoint] = hooks[entryPoint] || [];
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function(entryPoint) {
    if (hooks[entryPoint]) {
      return arrayPop(hooks[entryPoint]);
    }
  };
  DOMPurify.removeHooks = function(entryPoint) {
    if (hooks[entryPoint]) {
      hooks[entryPoint] = [];
    }
  };
  DOMPurify.removeAllHooks = function() {
    hooks = {};
  };
  return DOMPurify;
}
var purify = createDOMPurify();
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var abs$2 = Math.abs;
var from = String.fromCharCode;
function trim(value) {
  return value.trim();
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search) {
  return value.indexOf(search);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end2) {
  return value.slice(begin, end2);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array2) {
  return array2.push(value), value;
}
var line$1 = 1;
var column = 1;
var length$3 = 0;
var position$2 = 0;
var character = 0;
var characters = "";
function node(value, root2, parent, type2, props, children, length2) {
  return { value, root: root2, parent, type: type2, props, children, line: line$1, column, length: length2, return: "" };
}
function char() {
  return character;
}
function prev() {
  character = position$2 > 0 ? charat(characters, --position$2) : 0;
  if (column--, character === 10)
    column = 1, line$1--;
  return character;
}
function next() {
  character = position$2 < length$3 ? charat(characters, position$2++) : 0;
  if (column++, character === 10)
    column = 1, line$1++;
  return character;
}
function peek() {
  return charat(characters, position$2);
}
function caret() {
  return position$2;
}
function slice$7(begin, end2) {
  return substr(characters, begin, end2);
}
function token(type2) {
  switch (type2) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line$1 = column = 1, length$3 = strlen(characters = value), position$2 = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type2) {
  return trim(slice$7(position$2 - 1, delimiter(type2 === 91 ? type2 + 2 : type2 === 40 ? type2 + 1 : type2)));
}
function whitespace(type2) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type2) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count2) {
  while (--count2 && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice$7(index2, caret() + (count2 < 6 && peek() == 32 && next() == 32));
}
function delimiter(type2) {
  while (next())
    switch (character) {
      case type2:
        return position$2;
      case 34:
      case 39:
        if (type2 !== 34 && type2 !== 39)
          delimiter(character);
        break;
      case 40:
        if (type2 === 41)
          delimiter(type2);
        break;
      case 92:
        next();
        break;
    }
  return position$2;
}
function commenter(type2, index2) {
  while (next())
    if (type2 + character === 47 + 10)
      break;
    else if (type2 + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice$7(index2, position$2 - 1) + "*" + from(type2 === 47 ? type2 : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice$7(index2, position$2);
}
function compile(value) {
  return dealloc(parse$2("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$2(value, root2, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type2 = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type2;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
            ampersand = -1;
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root2, parent), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset:
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            append(reference = ruleset(characters2, root2, parent, index2, offset, rules, points, type2, props = [], children = [], length2), rulesets);
            if (character2 === 123)
              if (offset === 0)
                parse$2(characters2, root2, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 109:
                  case 115:
                    parse$2(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type2, rules, props = [], length2), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$2(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset = property = 0, variable = ampersand = 1, type2 = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand = offset > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset = length2 = strlen(type2 = characters2 += identifier(caret())), character2++;
            break;
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root2, parent, index2, offset, rules, points, type2, props, children, length2) {
  var post = offset - 1;
  var rule = offset === 0 ? rules : [""];
  var size = sizeof(rule);
  for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs$2(j = points[i])), z = value; x2 < size; ++x2)
      if (z = trim(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z;
  return node(value, root2, parent, offset === 0 ? RULESET : type2, props, children, length2);
}
function comment(value, root2, parent) {
  return node(value, root2, parent, COMMENT, from(char()), substr(value, 2, -2), 0);
}
function declaration(value, root2, parent, length2) {
  return node(value, root2, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2);
}
function serialize(children, callback) {
  var output = "";
  var length2 = sizeof(children);
  for (var i = 0; i < length2; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      element.value = element.props.join(",");
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
var _listCacheClear$1;
var hasRequired_listCacheClear;
function require_listCacheClear() {
  if (hasRequired_listCacheClear)
    return _listCacheClear$1;
  hasRequired_listCacheClear = 1;
  function listCacheClear2() {
    this.__data__ = [];
    this.size = 0;
  }
  _listCacheClear$1 = listCacheClear2;
  return _listCacheClear$1;
}
var eq_1$1;
var hasRequiredEq$1;
function requireEq$1() {
  if (hasRequiredEq$1)
    return eq_1$1;
  hasRequiredEq$1 = 1;
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1$1 = eq2;
  return eq_1$1;
}
var _assocIndexOf$1;
var hasRequired_assocIndexOf;
function require_assocIndexOf() {
  if (hasRequired_assocIndexOf)
    return _assocIndexOf$1;
  hasRequired_assocIndexOf = 1;
  var eq2 = requireEq$1();
  function assocIndexOf2(array2, key) {
    var length2 = array2.length;
    while (length2--) {
      if (eq2(array2[length2][0], key)) {
        return length2;
      }
    }
    return -1;
  }
  _assocIndexOf$1 = assocIndexOf2;
  return _assocIndexOf$1;
}
var _listCacheDelete$1;
var hasRequired_listCacheDelete;
function require_listCacheDelete() {
  if (hasRequired_listCacheDelete)
    return _listCacheDelete$1;
  hasRequired_listCacheDelete = 1;
  var assocIndexOf2 = require_assocIndexOf();
  var arrayProto2 = Array.prototype;
  var splice2 = arrayProto2.splice;
  function listCacheDelete2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index2 == lastIndex) {
      data.pop();
    } else {
      splice2.call(data, index2, 1);
    }
    --this.size;
    return true;
  }
  _listCacheDelete$1 = listCacheDelete2;
  return _listCacheDelete$1;
}
var _listCacheGet$1;
var hasRequired_listCacheGet;
function require_listCacheGet() {
  if (hasRequired_listCacheGet)
    return _listCacheGet$1;
  hasRequired_listCacheGet = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheGet2(key) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    return index2 < 0 ? void 0 : data[index2][1];
  }
  _listCacheGet$1 = listCacheGet2;
  return _listCacheGet$1;
}
var _listCacheHas$1;
var hasRequired_listCacheHas;
function require_listCacheHas() {
  if (hasRequired_listCacheHas)
    return _listCacheHas$1;
  hasRequired_listCacheHas = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheHas2(key) {
    return assocIndexOf2(this.__data__, key) > -1;
  }
  _listCacheHas$1 = listCacheHas2;
  return _listCacheHas$1;
}
var _listCacheSet$1;
var hasRequired_listCacheSet;
function require_listCacheSet() {
  if (hasRequired_listCacheSet)
    return _listCacheSet$1;
  hasRequired_listCacheSet = 1;
  var assocIndexOf2 = require_assocIndexOf();
  function listCacheSet2(key, value) {
    var data = this.__data__, index2 = assocIndexOf2(data, key);
    if (index2 < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index2][1] = value;
    }
    return this;
  }
  _listCacheSet$1 = listCacheSet2;
  return _listCacheSet$1;
}
var _ListCache$1;
var hasRequired_ListCache;
function require_ListCache() {
  if (hasRequired_ListCache)
    return _ListCache$1;
  hasRequired_ListCache = 1;
  var listCacheClear2 = require_listCacheClear(), listCacheDelete2 = require_listCacheDelete(), listCacheGet2 = require_listCacheGet(), listCacheHas2 = require_listCacheHas(), listCacheSet2 = require_listCacheSet();
  function ListCache2(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  ListCache2.prototype.clear = listCacheClear2;
  ListCache2.prototype["delete"] = listCacheDelete2;
  ListCache2.prototype.get = listCacheGet2;
  ListCache2.prototype.has = listCacheHas2;
  ListCache2.prototype.set = listCacheSet2;
  _ListCache$1 = ListCache2;
  return _ListCache$1;
}
var _stackClear;
var hasRequired_stackClear;
function require_stackClear() {
  if (hasRequired_stackClear)
    return _stackClear;
  hasRequired_stackClear = 1;
  var ListCache2 = require_ListCache();
  function stackClear() {
    this.__data__ = new ListCache2();
    this.size = 0;
  }
  _stackClear = stackClear;
  return _stackClear;
}
var _stackDelete;
var hasRequired_stackDelete;
function require_stackDelete() {
  if (hasRequired_stackDelete)
    return _stackDelete;
  hasRequired_stackDelete = 1;
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  _stackDelete = stackDelete;
  return _stackDelete;
}
var _stackGet;
var hasRequired_stackGet;
function require_stackGet() {
  if (hasRequired_stackGet)
    return _stackGet;
  hasRequired_stackGet = 1;
  function stackGet(key) {
    return this.__data__.get(key);
  }
  _stackGet = stackGet;
  return _stackGet;
}
var _stackHas;
var hasRequired_stackHas;
function require_stackHas() {
  if (hasRequired_stackHas)
    return _stackHas;
  hasRequired_stackHas = 1;
  function stackHas(key) {
    return this.__data__.has(key);
  }
  _stackHas = stackHas;
  return _stackHas;
}
var _freeGlobal$1;
var hasRequired_freeGlobal$1;
function require_freeGlobal$1() {
  if (hasRequired_freeGlobal$1)
    return _freeGlobal$1;
  hasRequired_freeGlobal$1 = 1;
  var freeGlobal = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
  _freeGlobal$1 = freeGlobal;
  return _freeGlobal$1;
}
var _root$1;
var hasRequired_root$1;
function require_root$1() {
  if (hasRequired_root$1)
    return _root$1;
  hasRequired_root$1 = 1;
  var freeGlobal = require_freeGlobal$1();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal || freeSelf || Function("return this")();
  _root$1 = root2;
  return _root$1;
}
var _Symbol$1;
var hasRequired_Symbol$1;
function require_Symbol$1() {
  if (hasRequired_Symbol$1)
    return _Symbol$1;
  hasRequired_Symbol$1 = 1;
  var root2 = require_root$1();
  var Symbol2 = root2.Symbol;
  _Symbol$1 = Symbol2;
  return _Symbol$1;
}
var _getRawTag$1;
var hasRequired_getRawTag$1;
function require_getRawTag$1() {
  if (hasRequired_getRawTag$1)
    return _getRawTag$1;
  hasRequired_getRawTag$1 = 1;
  var Symbol2 = require_Symbol$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var nativeObjectToString = objectProto2.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag$1 = getRawTag;
  return _getRawTag$1;
}
var _objectToString$1;
var hasRequired_objectToString$1;
function require_objectToString$1() {
  if (hasRequired_objectToString$1)
    return _objectToString$1;
  hasRequired_objectToString$1 = 1;
  var objectProto2 = Object.prototype;
  var nativeObjectToString = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString$1 = objectToString;
  return _objectToString$1;
}
var _baseGetTag$1;
var hasRequired_baseGetTag$1;
function require_baseGetTag$1() {
  if (hasRequired_baseGetTag$1)
    return _baseGetTag$1;
  hasRequired_baseGetTag$1 = 1;
  var Symbol2 = require_Symbol$1(), getRawTag = require_getRawTag$1(), objectToString = require_objectToString$1();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag$1 = baseGetTag;
  return _baseGetTag$1;
}
var isObject_1$1;
var hasRequiredIsObject$1;
function requireIsObject$1() {
  if (hasRequiredIsObject$1)
    return isObject_1$1;
  hasRequiredIsObject$1 = 1;
  function isObject(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1$1 = isObject;
  return isObject_1$1;
}
var isFunction_1$1;
var hasRequiredIsFunction$1;
function requireIsFunction$1() {
  if (hasRequiredIsFunction$1)
    return isFunction_1$1;
  hasRequiredIsFunction$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isObject = requireIsObject$1();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1$1 = isFunction;
  return isFunction_1$1;
}
var _coreJsData$1;
var hasRequired_coreJsData$1;
function require_coreJsData$1() {
  if (hasRequired_coreJsData$1)
    return _coreJsData$1;
  hasRequired_coreJsData$1 = 1;
  var root2 = require_root$1();
  var coreJsData = root2["__core-js_shared__"];
  _coreJsData$1 = coreJsData;
  return _coreJsData$1;
}
var _isMasked$1;
var hasRequired_isMasked$1;
function require_isMasked$1() {
  if (hasRequired_isMasked$1)
    return _isMasked$1;
  hasRequired_isMasked$1 = 1;
  var coreJsData = require_coreJsData$1();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked$1 = isMasked;
  return _isMasked$1;
}
var _toSource$1;
var hasRequired_toSource$1;
function require_toSource$1() {
  if (hasRequired_toSource$1)
    return _toSource$1;
  hasRequired_toSource$1 = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource$1 = toSource;
  return _toSource$1;
}
var _baseIsNative$1;
var hasRequired_baseIsNative$1;
function require_baseIsNative$1() {
  if (hasRequired_baseIsNative$1)
    return _baseIsNative$1;
  hasRequired_baseIsNative$1 = 1;
  var isFunction = requireIsFunction$1(), isMasked = require_isMasked$1(), isObject = requireIsObject$1(), toSource = require_toSource$1();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative$1 = baseIsNative;
  return _baseIsNative$1;
}
var _getValue$1;
var hasRequired_getValue$1;
function require_getValue$1() {
  if (hasRequired_getValue$1)
    return _getValue$1;
  hasRequired_getValue$1 = 1;
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  _getValue$1 = getValue;
  return _getValue$1;
}
var _getNative$1;
var hasRequired_getNative$1;
function require_getNative$1() {
  if (hasRequired_getNative$1)
    return _getNative$1;
  hasRequired_getNative$1 = 1;
  var baseIsNative = require_baseIsNative$1(), getValue = require_getValue$1();
  function getNative2(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative$1 = getNative2;
  return _getNative$1;
}
var _Map$1;
var hasRequired_Map;
function require_Map() {
  if (hasRequired_Map)
    return _Map$1;
  hasRequired_Map = 1;
  var getNative2 = require_getNative$1(), root2 = require_root$1();
  var Map2 = getNative2(root2, "Map");
  _Map$1 = Map2;
  return _Map$1;
}
var _nativeCreate$1;
var hasRequired_nativeCreate;
function require_nativeCreate() {
  if (hasRequired_nativeCreate)
    return _nativeCreate$1;
  hasRequired_nativeCreate = 1;
  var getNative2 = require_getNative$1();
  var nativeCreate2 = getNative2(Object, "create");
  _nativeCreate$1 = nativeCreate2;
  return _nativeCreate$1;
}
var _hashClear$1;
var hasRequired_hashClear;
function require_hashClear() {
  if (hasRequired_hashClear)
    return _hashClear$1;
  hasRequired_hashClear = 1;
  var nativeCreate2 = require_nativeCreate();
  function hashClear2() {
    this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
    this.size = 0;
  }
  _hashClear$1 = hashClear2;
  return _hashClear$1;
}
var _hashDelete$1;
var hasRequired_hashDelete;
function require_hashDelete() {
  if (hasRequired_hashDelete)
    return _hashDelete$1;
  hasRequired_hashDelete = 1;
  function hashDelete2(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  _hashDelete$1 = hashDelete2;
  return _hashDelete$1;
}
var _hashGet$1;
var hasRequired_hashGet;
function require_hashGet() {
  if (hasRequired_hashGet)
    return _hashGet$1;
  hasRequired_hashGet = 1;
  var nativeCreate2 = require_nativeCreate();
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function hashGet2(key) {
    var data = this.__data__;
    if (nativeCreate2) {
      var result = data[key];
      return result === HASH_UNDEFINED2 ? void 0 : result;
    }
    return hasOwnProperty2.call(data, key) ? data[key] : void 0;
  }
  _hashGet$1 = hashGet2;
  return _hashGet$1;
}
var _hashHas$1;
var hasRequired_hashHas;
function require_hashHas() {
  if (hasRequired_hashHas)
    return _hashHas$1;
  hasRequired_hashHas = 1;
  var nativeCreate2 = require_nativeCreate();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function hashHas2(key) {
    var data = this.__data__;
    return nativeCreate2 ? data[key] !== void 0 : hasOwnProperty2.call(data, key);
  }
  _hashHas$1 = hashHas2;
  return _hashHas$1;
}
var _hashSet$1;
var hasRequired_hashSet;
function require_hashSet() {
  if (hasRequired_hashSet)
    return _hashSet$1;
  hasRequired_hashSet = 1;
  var nativeCreate2 = require_nativeCreate();
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function hashSet2(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate2 && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
  }
  _hashSet$1 = hashSet2;
  return _hashSet$1;
}
var _Hash$1;
var hasRequired_Hash;
function require_Hash() {
  if (hasRequired_Hash)
    return _Hash$1;
  hasRequired_Hash = 1;
  var hashClear2 = require_hashClear(), hashDelete2 = require_hashDelete(), hashGet2 = require_hashGet(), hashHas2 = require_hashHas(), hashSet2 = require_hashSet();
  function Hash2(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  Hash2.prototype.clear = hashClear2;
  Hash2.prototype["delete"] = hashDelete2;
  Hash2.prototype.get = hashGet2;
  Hash2.prototype.has = hashHas2;
  Hash2.prototype.set = hashSet2;
  _Hash$1 = Hash2;
  return _Hash$1;
}
var _mapCacheClear$1;
var hasRequired_mapCacheClear;
function require_mapCacheClear() {
  if (hasRequired_mapCacheClear)
    return _mapCacheClear$1;
  hasRequired_mapCacheClear = 1;
  var Hash2 = require_Hash(), ListCache2 = require_ListCache(), Map2 = require_Map();
  function mapCacheClear2() {
    this.size = 0;
    this.__data__ = {
      "hash": new Hash2(),
      "map": new (Map2 || ListCache2)(),
      "string": new Hash2()
    };
  }
  _mapCacheClear$1 = mapCacheClear2;
  return _mapCacheClear$1;
}
var _isKeyable$1;
var hasRequired_isKeyable;
function require_isKeyable() {
  if (hasRequired_isKeyable)
    return _isKeyable$1;
  hasRequired_isKeyable = 1;
  function isKeyable2(value) {
    var type2 = typeof value;
    return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
  }
  _isKeyable$1 = isKeyable2;
  return _isKeyable$1;
}
var _getMapData$1;
var hasRequired_getMapData;
function require_getMapData() {
  if (hasRequired_getMapData)
    return _getMapData$1;
  hasRequired_getMapData = 1;
  var isKeyable2 = require_isKeyable();
  function getMapData2(map2, key) {
    var data = map2.__data__;
    return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  _getMapData$1 = getMapData2;
  return _getMapData$1;
}
var _mapCacheDelete$1;
var hasRequired_mapCacheDelete;
function require_mapCacheDelete() {
  if (hasRequired_mapCacheDelete)
    return _mapCacheDelete$1;
  hasRequired_mapCacheDelete = 1;
  var getMapData2 = require_getMapData();
  function mapCacheDelete2(key) {
    var result = getMapData2(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  _mapCacheDelete$1 = mapCacheDelete2;
  return _mapCacheDelete$1;
}
var _mapCacheGet$1;
var hasRequired_mapCacheGet;
function require_mapCacheGet() {
  if (hasRequired_mapCacheGet)
    return _mapCacheGet$1;
  hasRequired_mapCacheGet = 1;
  var getMapData2 = require_getMapData();
  function mapCacheGet2(key) {
    return getMapData2(this, key).get(key);
  }
  _mapCacheGet$1 = mapCacheGet2;
  return _mapCacheGet$1;
}
var _mapCacheHas$1;
var hasRequired_mapCacheHas;
function require_mapCacheHas() {
  if (hasRequired_mapCacheHas)
    return _mapCacheHas$1;
  hasRequired_mapCacheHas = 1;
  var getMapData2 = require_getMapData();
  function mapCacheHas2(key) {
    return getMapData2(this, key).has(key);
  }
  _mapCacheHas$1 = mapCacheHas2;
  return _mapCacheHas$1;
}
var _mapCacheSet$1;
var hasRequired_mapCacheSet;
function require_mapCacheSet() {
  if (hasRequired_mapCacheSet)
    return _mapCacheSet$1;
  hasRequired_mapCacheSet = 1;
  var getMapData2 = require_getMapData();
  function mapCacheSet2(key, value) {
    var data = getMapData2(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  _mapCacheSet$1 = mapCacheSet2;
  return _mapCacheSet$1;
}
var _MapCache$1;
var hasRequired_MapCache;
function require_MapCache() {
  if (hasRequired_MapCache)
    return _MapCache$1;
  hasRequired_MapCache = 1;
  var mapCacheClear2 = require_mapCacheClear(), mapCacheDelete2 = require_mapCacheDelete(), mapCacheGet2 = require_mapCacheGet(), mapCacheHas2 = require_mapCacheHas(), mapCacheSet2 = require_mapCacheSet();
  function MapCache2(entries2) {
    var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
    this.clear();
    while (++index2 < length2) {
      var entry = entries2[index2];
      this.set(entry[0], entry[1]);
    }
  }
  MapCache2.prototype.clear = mapCacheClear2;
  MapCache2.prototype["delete"] = mapCacheDelete2;
  MapCache2.prototype.get = mapCacheGet2;
  MapCache2.prototype.has = mapCacheHas2;
  MapCache2.prototype.set = mapCacheSet2;
  _MapCache$1 = MapCache2;
  return _MapCache$1;
}
var _stackSet;
var hasRequired_stackSet;
function require_stackSet() {
  if (hasRequired_stackSet)
    return _stackSet;
  hasRequired_stackSet = 1;
  var ListCache2 = require_ListCache(), Map2 = require_Map(), MapCache2 = require_MapCache();
  var LARGE_ARRAY_SIZE = 200;
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache2) {
      var pairs2 = data.__data__;
      if (!Map2 || pairs2.length < LARGE_ARRAY_SIZE - 1) {
        pairs2.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache2(pairs2);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  _stackSet = stackSet;
  return _stackSet;
}
var _Stack;
var hasRequired_Stack;
function require_Stack() {
  if (hasRequired_Stack)
    return _Stack;
  hasRequired_Stack = 1;
  var ListCache2 = require_ListCache(), stackClear = require_stackClear(), stackDelete = require_stackDelete(), stackGet = require_stackGet(), stackHas = require_stackHas(), stackSet = require_stackSet();
  function Stack(entries2) {
    var data = this.__data__ = new ListCache2(entries2);
    this.size = data.size;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  _Stack = Stack;
  return _Stack;
}
var _arrayEach$1;
var hasRequired_arrayEach$1;
function require_arrayEach$1() {
  if (hasRequired_arrayEach$1)
    return _arrayEach$1;
  hasRequired_arrayEach$1 = 1;
  function arrayEach(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (iteratee(array2[index2], index2, array2) === false) {
        break;
      }
    }
    return array2;
  }
  _arrayEach$1 = arrayEach;
  return _arrayEach$1;
}
var _defineProperty$1;
var hasRequired_defineProperty$1;
function require_defineProperty$1() {
  if (hasRequired_defineProperty$1)
    return _defineProperty$1;
  hasRequired_defineProperty$1 = 1;
  var getNative2 = require_getNative$1();
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  _defineProperty$1 = defineProperty;
  return _defineProperty$1;
}
var _baseAssignValue$1;
var hasRequired_baseAssignValue$1;
function require_baseAssignValue$1() {
  if (hasRequired_baseAssignValue$1)
    return _baseAssignValue$1;
  hasRequired_baseAssignValue$1 = 1;
  var defineProperty = require_defineProperty$1();
  function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  _baseAssignValue$1 = baseAssignValue;
  return _baseAssignValue$1;
}
var _assignValue$1;
var hasRequired_assignValue$1;
function require_assignValue$1() {
  if (hasRequired_assignValue$1)
    return _assignValue$1;
  hasRequired_assignValue$1 = 1;
  var baseAssignValue = require_baseAssignValue$1(), eq2 = requireEq$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignValue$1 = assignValue;
  return _assignValue$1;
}
var _copyObject;
var hasRequired_copyObject;
function require_copyObject() {
  if (hasRequired_copyObject)
    return _copyObject;
  hasRequired_copyObject = 1;
  var assignValue = require_assignValue$1(), baseAssignValue = require_baseAssignValue$1();
  function copyObject(source, props, object2, customizer) {
    var isNew = !object2;
    object2 || (object2 = {});
    var index2 = -1, length2 = props.length;
    while (++index2 < length2) {
      var key = props[index2];
      var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object2, key, newValue);
      } else {
        assignValue(object2, key, newValue);
      }
    }
    return object2;
  }
  _copyObject = copyObject;
  return _copyObject;
}
var _baseTimes$1;
var hasRequired_baseTimes$1;
function require_baseTimes$1() {
  if (hasRequired_baseTimes$1)
    return _baseTimes$1;
  hasRequired_baseTimes$1 = 1;
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes$1 = baseTimes;
  return _baseTimes$1;
}
var isObjectLike_1$1;
var hasRequiredIsObjectLike$1;
function requireIsObjectLike$1() {
  if (hasRequiredIsObjectLike$1)
    return isObjectLike_1$1;
  hasRequiredIsObjectLike$1 = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1$1 = isObjectLike;
  return isObjectLike_1$1;
}
var _baseIsArguments$1;
var hasRequired_baseIsArguments$1;
function require_baseIsArguments$1() {
  if (hasRequired_baseIsArguments$1)
    return _baseIsArguments$1;
  hasRequired_baseIsArguments$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isObjectLike = requireIsObjectLike$1();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments$1 = baseIsArguments;
  return _baseIsArguments$1;
}
var isArguments_1$1;
var hasRequiredIsArguments$1;
function requireIsArguments$1() {
  if (hasRequiredIsArguments$1)
    return isArguments_1$1;
  hasRequiredIsArguments$1 = 1;
  var baseIsArguments = require_baseIsArguments$1(), isObjectLike = requireIsObjectLike$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1$1 = isArguments;
  return isArguments_1$1;
}
var isArray_1$1;
var hasRequiredIsArray$1;
function requireIsArray$1() {
  if (hasRequiredIsArray$1)
    return isArray_1$1;
  hasRequiredIsArray$1 = 1;
  var isArray = Array.isArray;
  isArray_1$1 = isArray;
  return isArray_1$1;
}
var isBuffer$1 = { exports: {} };
var stubFalse_1$1;
var hasRequiredStubFalse$1;
function requireStubFalse$1() {
  if (hasRequiredStubFalse$1)
    return stubFalse_1$1;
  hasRequiredStubFalse$1 = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1$1 = stubFalse;
  return stubFalse_1$1;
}
var hasRequiredIsBuffer$1;
function requireIsBuffer$1() {
  if (hasRequiredIsBuffer$1)
    return isBuffer$1.exports;
  hasRequiredIsBuffer$1 = 1;
  (function(module2, exports2) {
    var root2 = require_root$1(), stubFalse = requireStubFalse$1();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer2;
  })(isBuffer$1, isBuffer$1.exports);
  return isBuffer$1.exports;
}
var _isIndex$1;
var hasRequired_isIndex$1;
function require_isIndex$1() {
  if (hasRequired_isIndex$1)
    return _isIndex$1;
  hasRequired_isIndex$1 = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex$1 = isIndex;
  return _isIndex$1;
}
var isLength_1$1;
var hasRequiredIsLength$1;
function requireIsLength$1() {
  if (hasRequiredIsLength$1)
    return isLength_1$1;
  hasRequiredIsLength$1 = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1$1 = isLength;
  return isLength_1$1;
}
var _baseIsTypedArray$1;
var hasRequired_baseIsTypedArray$1;
function require_baseIsTypedArray$1() {
  if (hasRequired_baseIsTypedArray$1)
    return _baseIsTypedArray$1;
  hasRequired_baseIsTypedArray$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isLength = requireIsLength$1(), isObjectLike = requireIsObjectLike$1();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray$1 = baseIsTypedArray;
  return _baseIsTypedArray$1;
}
var _baseUnary$1;
var hasRequired_baseUnary$1;
function require_baseUnary$1() {
  if (hasRequired_baseUnary$1)
    return _baseUnary$1;
  hasRequired_baseUnary$1 = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary$1 = baseUnary;
  return _baseUnary$1;
}
var _nodeUtil$1 = { exports: {} };
var hasRequired_nodeUtil$1;
function require_nodeUtil$1() {
  if (hasRequired_nodeUtil$1)
    return _nodeUtil$1.exports;
  hasRequired_nodeUtil$1 = 1;
  (function(module2, exports2) {
    var freeGlobal = require_freeGlobal$1();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  })(_nodeUtil$1, _nodeUtil$1.exports);
  return _nodeUtil$1.exports;
}
var isTypedArray_1$1;
var hasRequiredIsTypedArray$1;
function requireIsTypedArray$1() {
  if (hasRequiredIsTypedArray$1)
    return isTypedArray_1$1;
  hasRequiredIsTypedArray$1 = 1;
  var baseIsTypedArray = require_baseIsTypedArray$1(), baseUnary = require_baseUnary$1(), nodeUtil = require_nodeUtil$1();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1$1 = isTypedArray;
  return isTypedArray_1$1;
}
var _arrayLikeKeys$1;
var hasRequired_arrayLikeKeys$1;
function require_arrayLikeKeys$1() {
  if (hasRequired_arrayLikeKeys$1)
    return _arrayLikeKeys$1;
  hasRequired_arrayLikeKeys$1 = 1;
  var baseTimes = require_baseTimes$1(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isIndex = require_isIndex$1(), isTypedArray = requireIsTypedArray$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys$1 = arrayLikeKeys;
  return _arrayLikeKeys$1;
}
var _isPrototype$1;
var hasRequired_isPrototype$1;
function require_isPrototype$1() {
  if (hasRequired_isPrototype$1)
    return _isPrototype$1;
  hasRequired_isPrototype$1 = 1;
  var objectProto2 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  _isPrototype$1 = isPrototype;
  return _isPrototype$1;
}
var _overArg$1;
var hasRequired_overArg$1;
function require_overArg$1() {
  if (hasRequired_overArg$1)
    return _overArg$1;
  hasRequired_overArg$1 = 1;
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg$1 = overArg;
  return _overArg$1;
}
var _nativeKeys$1;
var hasRequired_nativeKeys$1;
function require_nativeKeys$1() {
  if (hasRequired_nativeKeys$1)
    return _nativeKeys$1;
  hasRequired_nativeKeys$1 = 1;
  var overArg = require_overArg$1();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys$1 = nativeKeys;
  return _nativeKeys$1;
}
var _baseKeys$1;
var hasRequired_baseKeys$1;
function require_baseKeys$1() {
  if (hasRequired_baseKeys$1)
    return _baseKeys$1;
  hasRequired_baseKeys$1 = 1;
  var isPrototype = require_isPrototype$1(), nativeKeys = require_nativeKeys$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys$1 = baseKeys;
  return _baseKeys$1;
}
var isArrayLike_1$1;
var hasRequiredIsArrayLike$1;
function requireIsArrayLike$1() {
  if (hasRequiredIsArrayLike$1)
    return isArrayLike_1$1;
  hasRequiredIsArrayLike$1 = 1;
  var isFunction = requireIsFunction$1(), isLength = requireIsLength$1();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  isArrayLike_1$1 = isArrayLike;
  return isArrayLike_1$1;
}
var keys_1$1;
var hasRequiredKeys$1;
function requireKeys$1() {
  if (hasRequiredKeys$1)
    return keys_1$1;
  hasRequiredKeys$1 = 1;
  var arrayLikeKeys = require_arrayLikeKeys$1(), baseKeys = require_baseKeys$1(), isArrayLike = requireIsArrayLike$1();
  function keys2(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  keys_1$1 = keys2;
  return keys_1$1;
}
var _baseAssign;
var hasRequired_baseAssign;
function require_baseAssign() {
  if (hasRequired_baseAssign)
    return _baseAssign;
  hasRequired_baseAssign = 1;
  var copyObject = require_copyObject(), keys2 = requireKeys$1();
  function baseAssign(object2, source) {
    return object2 && copyObject(source, keys2(source), object2);
  }
  _baseAssign = baseAssign;
  return _baseAssign;
}
var _nativeKeysIn$1;
var hasRequired_nativeKeysIn$1;
function require_nativeKeysIn$1() {
  if (hasRequired_nativeKeysIn$1)
    return _nativeKeysIn$1;
  hasRequired_nativeKeysIn$1 = 1;
  function nativeKeysIn(object2) {
    var result = [];
    if (object2 != null) {
      for (var key in Object(object2)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn$1 = nativeKeysIn;
  return _nativeKeysIn$1;
}
var _baseKeysIn$1;
var hasRequired_baseKeysIn$1;
function require_baseKeysIn$1() {
  if (hasRequired_baseKeysIn$1)
    return _baseKeysIn$1;
  hasRequired_baseKeysIn$1 = 1;
  var isObject = requireIsObject$1(), isPrototype = require_isPrototype$1(), nativeKeysIn = require_nativeKeysIn$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeysIn(object2) {
    if (!isObject(object2)) {
      return nativeKeysIn(object2);
    }
    var isProto = isPrototype(object2), result = [];
    for (var key in object2) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn$1 = baseKeysIn;
  return _baseKeysIn$1;
}
var keysIn_1$1;
var hasRequiredKeysIn$1;
function requireKeysIn$1() {
  if (hasRequiredKeysIn$1)
    return keysIn_1$1;
  hasRequiredKeysIn$1 = 1;
  var arrayLikeKeys = require_arrayLikeKeys$1(), baseKeysIn = require_baseKeysIn$1(), isArrayLike = requireIsArrayLike$1();
  function keysIn(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
  }
  keysIn_1$1 = keysIn;
  return keysIn_1$1;
}
var _baseAssignIn;
var hasRequired_baseAssignIn;
function require_baseAssignIn() {
  if (hasRequired_baseAssignIn)
    return _baseAssignIn;
  hasRequired_baseAssignIn = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn$1();
  function baseAssignIn(object2, source) {
    return object2 && copyObject(source, keysIn(source), object2);
  }
  _baseAssignIn = baseAssignIn;
  return _baseAssignIn;
}
var _cloneBuffer = { exports: {} };
var hasRequired_cloneBuffer;
function require_cloneBuffer() {
  if (hasRequired_cloneBuffer)
    return _cloneBuffer.exports;
  hasRequired_cloneBuffer = 1;
  (function(module2, exports2) {
    var root2 = require_root$1();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer = moduleExports ? root2.Buffer : void 0, allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
    function cloneBuffer(buffer2, isDeep) {
      if (isDeep) {
        return buffer2.slice();
      }
      var length2 = buffer2.length, result = allocUnsafe ? allocUnsafe(length2) : new buffer2.constructor(length2);
      buffer2.copy(result);
      return result;
    }
    module2.exports = cloneBuffer;
  })(_cloneBuffer, _cloneBuffer.exports);
  return _cloneBuffer.exports;
}
var _copyArray;
var hasRequired_copyArray;
function require_copyArray() {
  if (hasRequired_copyArray)
    return _copyArray;
  hasRequired_copyArray = 1;
  function copyArray(source, array2) {
    var index2 = -1, length2 = source.length;
    array2 || (array2 = Array(length2));
    while (++index2 < length2) {
      array2[index2] = source[index2];
    }
    return array2;
  }
  _copyArray = copyArray;
  return _copyArray;
}
var _arrayFilter;
var hasRequired_arrayFilter;
function require_arrayFilter() {
  if (hasRequired_arrayFilter)
    return _arrayFilter;
  hasRequired_arrayFilter = 1;
  function arrayFilter(array2, predicate) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while (++index2 < length2) {
      var value = array2[index2];
      if (predicate(value, index2, array2)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  _arrayFilter = arrayFilter;
  return _arrayFilter;
}
var stubArray_1;
var hasRequiredStubArray;
function requireStubArray() {
  if (hasRequiredStubArray)
    return stubArray_1;
  hasRequiredStubArray = 1;
  function stubArray() {
    return [];
  }
  stubArray_1 = stubArray;
  return stubArray_1;
}
var _getSymbols;
var hasRequired_getSymbols;
function require_getSymbols() {
  if (hasRequired_getSymbols)
    return _getSymbols;
  hasRequired_getSymbols = 1;
  var arrayFilter = require_arrayFilter(), stubArray = requireStubArray();
  var objectProto2 = Object.prototype;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbols = !nativeGetSymbols ? stubArray : function(object2) {
    if (object2 == null) {
      return [];
    }
    object2 = Object(object2);
    return arrayFilter(nativeGetSymbols(object2), function(symbol2) {
      return propertyIsEnumerable.call(object2, symbol2);
    });
  };
  _getSymbols = getSymbols;
  return _getSymbols;
}
var _copySymbols;
var hasRequired_copySymbols;
function require_copySymbols() {
  if (hasRequired_copySymbols)
    return _copySymbols;
  hasRequired_copySymbols = 1;
  var copyObject = require_copyObject(), getSymbols = require_getSymbols();
  function copySymbols(source, object2) {
    return copyObject(source, getSymbols(source), object2);
  }
  _copySymbols = copySymbols;
  return _copySymbols;
}
var _arrayPush$1;
var hasRequired_arrayPush$1;
function require_arrayPush$1() {
  if (hasRequired_arrayPush$1)
    return _arrayPush$1;
  hasRequired_arrayPush$1 = 1;
  function arrayPush2(array2, values2) {
    var index2 = -1, length2 = values2.length, offset = array2.length;
    while (++index2 < length2) {
      array2[offset + index2] = values2[index2];
    }
    return array2;
  }
  _arrayPush$1 = arrayPush2;
  return _arrayPush$1;
}
var _getPrototype$1;
var hasRequired_getPrototype$1;
function require_getPrototype$1() {
  if (hasRequired_getPrototype$1)
    return _getPrototype$1;
  hasRequired_getPrototype$1 = 1;
  var overArg = require_overArg$1();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype$1 = getPrototype;
  return _getPrototype$1;
}
var _getSymbolsIn;
var hasRequired_getSymbolsIn;
function require_getSymbolsIn() {
  if (hasRequired_getSymbolsIn)
    return _getSymbolsIn;
  hasRequired_getSymbolsIn = 1;
  var arrayPush2 = require_arrayPush$1(), getPrototype = require_getPrototype$1(), getSymbols = require_getSymbols(), stubArray = requireStubArray();
  var nativeGetSymbols = Object.getOwnPropertySymbols;
  var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object2) {
    var result = [];
    while (object2) {
      arrayPush2(result, getSymbols(object2));
      object2 = getPrototype(object2);
    }
    return result;
  };
  _getSymbolsIn = getSymbolsIn;
  return _getSymbolsIn;
}
var _copySymbolsIn;
var hasRequired_copySymbolsIn;
function require_copySymbolsIn() {
  if (hasRequired_copySymbolsIn)
    return _copySymbolsIn;
  hasRequired_copySymbolsIn = 1;
  var copyObject = require_copyObject(), getSymbolsIn = require_getSymbolsIn();
  function copySymbolsIn(source, object2) {
    return copyObject(source, getSymbolsIn(source), object2);
  }
  _copySymbolsIn = copySymbolsIn;
  return _copySymbolsIn;
}
var _baseGetAllKeys;
var hasRequired_baseGetAllKeys;
function require_baseGetAllKeys() {
  if (hasRequired_baseGetAllKeys)
    return _baseGetAllKeys;
  hasRequired_baseGetAllKeys = 1;
  var arrayPush2 = require_arrayPush$1(), isArray = requireIsArray$1();
  function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray(object2) ? result : arrayPush2(result, symbolsFunc(object2));
  }
  _baseGetAllKeys = baseGetAllKeys;
  return _baseGetAllKeys;
}
var _getAllKeys;
var hasRequired_getAllKeys;
function require_getAllKeys() {
  if (hasRequired_getAllKeys)
    return _getAllKeys;
  hasRequired_getAllKeys = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbols = require_getSymbols(), keys2 = requireKeys$1();
  function getAllKeys(object2) {
    return baseGetAllKeys(object2, keys2, getSymbols);
  }
  _getAllKeys = getAllKeys;
  return _getAllKeys;
}
var _getAllKeysIn;
var hasRequired_getAllKeysIn;
function require_getAllKeysIn() {
  if (hasRequired_getAllKeysIn)
    return _getAllKeysIn;
  hasRequired_getAllKeysIn = 1;
  var baseGetAllKeys = require_baseGetAllKeys(), getSymbolsIn = require_getSymbolsIn(), keysIn = requireKeysIn$1();
  function getAllKeysIn(object2) {
    return baseGetAllKeys(object2, keysIn, getSymbolsIn);
  }
  _getAllKeysIn = getAllKeysIn;
  return _getAllKeysIn;
}
var _DataView;
var hasRequired_DataView;
function require_DataView() {
  if (hasRequired_DataView)
    return _DataView;
  hasRequired_DataView = 1;
  var getNative2 = require_getNative$1(), root2 = require_root$1();
  var DataView2 = getNative2(root2, "DataView");
  _DataView = DataView2;
  return _DataView;
}
var _Promise;
var hasRequired_Promise;
function require_Promise() {
  if (hasRequired_Promise)
    return _Promise;
  hasRequired_Promise = 1;
  var getNative2 = require_getNative$1(), root2 = require_root$1();
  var Promise2 = getNative2(root2, "Promise");
  _Promise = Promise2;
  return _Promise;
}
var _Set;
var hasRequired_Set;
function require_Set() {
  if (hasRequired_Set)
    return _Set;
  hasRequired_Set = 1;
  var getNative2 = require_getNative$1(), root2 = require_root$1();
  var Set4 = getNative2(root2, "Set");
  _Set = Set4;
  return _Set;
}
var _WeakMap;
var hasRequired_WeakMap;
function require_WeakMap() {
  if (hasRequired_WeakMap)
    return _WeakMap;
  hasRequired_WeakMap = 1;
  var getNative2 = require_getNative$1(), root2 = require_root$1();
  var WeakMap = getNative2(root2, "WeakMap");
  _WeakMap = WeakMap;
  return _WeakMap;
}
var _getTag;
var hasRequired_getTag;
function require_getTag() {
  if (hasRequired_getTag)
    return _getTag;
  hasRequired_getTag = 1;
  var DataView2 = require_DataView(), Map2 = require_Map(), Promise2 = require_Promise(), Set4 = require_Set(), WeakMap = require_WeakMap(), baseGetTag = require_baseGetTag$1(), toSource = require_toSource$1();
  var mapTag = "[object Map]", objectTag = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
  var dataViewTag = "[object DataView]";
  var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set4), weakMapCtorString = toSource(WeakMap);
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set4 && getTag(new Set4()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
    getTag = function(value) {
      var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  _getTag = getTag;
  return _getTag;
}
var _initCloneArray;
var hasRequired_initCloneArray;
function require_initCloneArray() {
  if (hasRequired_initCloneArray)
    return _initCloneArray;
  hasRequired_initCloneArray = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function initCloneArray(array2) {
    var length2 = array2.length, result = new array2.constructor(length2);
    if (length2 && typeof array2[0] == "string" && hasOwnProperty2.call(array2, "index")) {
      result.index = array2.index;
      result.input = array2.input;
    }
    return result;
  }
  _initCloneArray = initCloneArray;
  return _initCloneArray;
}
var _Uint8Array;
var hasRequired_Uint8Array;
function require_Uint8Array() {
  if (hasRequired_Uint8Array)
    return _Uint8Array;
  hasRequired_Uint8Array = 1;
  var root2 = require_root$1();
  var Uint8Array2 = root2.Uint8Array;
  _Uint8Array = Uint8Array2;
  return _Uint8Array;
}
var _cloneArrayBuffer;
var hasRequired_cloneArrayBuffer;
function require_cloneArrayBuffer() {
  if (hasRequired_cloneArrayBuffer)
    return _cloneArrayBuffer;
  hasRequired_cloneArrayBuffer = 1;
  var Uint8Array2 = require_Uint8Array();
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  _cloneArrayBuffer = cloneArrayBuffer;
  return _cloneArrayBuffer;
}
var _cloneDataView;
var hasRequired_cloneDataView;
function require_cloneDataView() {
  if (hasRequired_cloneDataView)
    return _cloneDataView;
  hasRequired_cloneDataView = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneDataView(dataView, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
  }
  _cloneDataView = cloneDataView;
  return _cloneDataView;
}
var _cloneRegExp;
var hasRequired_cloneRegExp;
function require_cloneRegExp() {
  if (hasRequired_cloneRegExp)
    return _cloneRegExp;
  hasRequired_cloneRegExp = 1;
  var reFlags = /\w*$/;
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }
  _cloneRegExp = cloneRegExp;
  return _cloneRegExp;
}
var _cloneSymbol;
var hasRequired_cloneSymbol;
function require_cloneSymbol() {
  if (hasRequired_cloneSymbol)
    return _cloneSymbol;
  hasRequired_cloneSymbol = 1;
  var Symbol2 = require_Symbol$1();
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function cloneSymbol(symbol2) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol2)) : {};
  }
  _cloneSymbol = cloneSymbol;
  return _cloneSymbol;
}
var _cloneTypedArray;
var hasRequired_cloneTypedArray;
function require_cloneTypedArray() {
  if (hasRequired_cloneTypedArray)
    return _cloneTypedArray;
  hasRequired_cloneTypedArray = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer();
  function cloneTypedArray(typedArray, isDeep) {
    var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
  }
  _cloneTypedArray = cloneTypedArray;
  return _cloneTypedArray;
}
var _initCloneByTag;
var hasRequired_initCloneByTag;
function require_initCloneByTag() {
  if (hasRequired_initCloneByTag)
    return _initCloneByTag;
  hasRequired_initCloneByTag = 1;
  var cloneArrayBuffer = require_cloneArrayBuffer(), cloneDataView = require_cloneDataView(), cloneRegExp = require_cloneRegExp(), cloneSymbol = require_cloneSymbol(), cloneTypedArray = require_cloneTypedArray();
  var boolTag = "[object Boolean]", dateTag = "[object Date]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  function initCloneByTag(object2, tag, isDeep) {
    var Ctor = object2.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object2);
      case boolTag:
      case dateTag:
        return new Ctor(+object2);
      case dataViewTag:
        return cloneDataView(object2, isDeep);
      case float32Tag:
      case float64Tag:
      case int8Tag:
      case int16Tag:
      case int32Tag:
      case uint8Tag:
      case uint8ClampedTag:
      case uint16Tag:
      case uint32Tag:
        return cloneTypedArray(object2, isDeep);
      case mapTag:
        return new Ctor();
      case numberTag:
      case stringTag:
        return new Ctor(object2);
      case regexpTag:
        return cloneRegExp(object2);
      case setTag:
        return new Ctor();
      case symbolTag:
        return cloneSymbol(object2);
    }
  }
  _initCloneByTag = initCloneByTag;
  return _initCloneByTag;
}
var _baseCreate;
var hasRequired_baseCreate;
function require_baseCreate() {
  if (hasRequired_baseCreate)
    return _baseCreate;
  hasRequired_baseCreate = 1;
  var isObject = requireIsObject$1();
  var objectCreate = Object.create;
  var baseCreate = function() {
    function object2() {
    }
    return function(proto2) {
      if (!isObject(proto2)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto2);
      }
      object2.prototype = proto2;
      var result = new object2();
      object2.prototype = void 0;
      return result;
    };
  }();
  _baseCreate = baseCreate;
  return _baseCreate;
}
var _initCloneObject;
var hasRequired_initCloneObject;
function require_initCloneObject() {
  if (hasRequired_initCloneObject)
    return _initCloneObject;
  hasRequired_initCloneObject = 1;
  var baseCreate = require_baseCreate(), getPrototype = require_getPrototype$1(), isPrototype = require_isPrototype$1();
  function initCloneObject(object2) {
    return typeof object2.constructor == "function" && !isPrototype(object2) ? baseCreate(getPrototype(object2)) : {};
  }
  _initCloneObject = initCloneObject;
  return _initCloneObject;
}
var _baseIsMap;
var hasRequired_baseIsMap;
function require_baseIsMap() {
  if (hasRequired_baseIsMap)
    return _baseIsMap;
  hasRequired_baseIsMap = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike$1();
  var mapTag = "[object Map]";
  function baseIsMap(value) {
    return isObjectLike(value) && getTag(value) == mapTag;
  }
  _baseIsMap = baseIsMap;
  return _baseIsMap;
}
var isMap_1;
var hasRequiredIsMap;
function requireIsMap() {
  if (hasRequiredIsMap)
    return isMap_1;
  hasRequiredIsMap = 1;
  var baseIsMap = require_baseIsMap(), baseUnary = require_baseUnary$1(), nodeUtil = require_nodeUtil$1();
  var nodeIsMap = nodeUtil && nodeUtil.isMap;
  var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
  isMap_1 = isMap;
  return isMap_1;
}
var _baseIsSet;
var hasRequired_baseIsSet;
function require_baseIsSet() {
  if (hasRequired_baseIsSet)
    return _baseIsSet;
  hasRequired_baseIsSet = 1;
  var getTag = require_getTag(), isObjectLike = requireIsObjectLike$1();
  var setTag = "[object Set]";
  function baseIsSet(value) {
    return isObjectLike(value) && getTag(value) == setTag;
  }
  _baseIsSet = baseIsSet;
  return _baseIsSet;
}
var isSet_1;
var hasRequiredIsSet;
function requireIsSet() {
  if (hasRequiredIsSet)
    return isSet_1;
  hasRequiredIsSet = 1;
  var baseIsSet = require_baseIsSet(), baseUnary = require_baseUnary$1(), nodeUtil = require_nodeUtil$1();
  var nodeIsSet = nodeUtil && nodeUtil.isSet;
  var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
  isSet_1 = isSet;
  return isSet_1;
}
var _baseClone;
var hasRequired_baseClone;
function require_baseClone() {
  if (hasRequired_baseClone)
    return _baseClone;
  hasRequired_baseClone = 1;
  var Stack = require_Stack(), arrayEach = require_arrayEach$1(), assignValue = require_assignValue$1(), baseAssign = require_baseAssign(), baseAssignIn = require_baseAssignIn(), cloneBuffer = require_cloneBuffer(), copyArray = require_copyArray(), copySymbols = require_copySymbols(), copySymbolsIn = require_copySymbolsIn(), getAllKeys = require_getAllKeys(), getAllKeysIn = require_getAllKeysIn(), getTag = require_getTag(), initCloneArray = require_initCloneArray(), initCloneByTag = require_initCloneByTag(), initCloneObject = require_initCloneObject(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isMap = requireIsMap(), isObject = requireIsObject$1(), isSet = requireIsSet(), keys2 = requireKeys$1(), keysIn = requireKeysIn$1();
  var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
  function baseClone(value, bitmask, customizer, key, object2, stack2) {
    var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
    if (customizer) {
      result = object2 ? customizer(value, key, object2, stack2) : customizer(value);
    }
    if (result !== void 0) {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
      if (isBuffer2(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || isFunc && !object2) {
        result = isFlat || isFunc ? {} : initCloneObject(value);
        if (!isDeep) {
          return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object2 ? value : {};
        }
        result = initCloneByTag(value, tag, isDeep);
      }
    }
    stack2 || (stack2 = new Stack());
    var stacked = stack2.get(value);
    if (stacked) {
      return stacked;
    }
    stack2.set(value, result);
    if (isSet(value)) {
      value.forEach(function(subValue) {
        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
      });
    } else if (isMap(value)) {
      value.forEach(function(subValue, key2) {
        result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
      });
    }
    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
    var props = isArr ? void 0 : keysFunc(value);
    arrayEach(props || value, function(subValue, key2) {
      if (props) {
        key2 = subValue;
        subValue = value[key2];
      }
      assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
    });
    return result;
  }
  _baseClone = baseClone;
  return _baseClone;
}
var clone_1;
var hasRequiredClone;
function requireClone() {
  if (hasRequiredClone)
    return clone_1;
  hasRequiredClone = 1;
  var baseClone = require_baseClone();
  var CLONE_SYMBOLS_FLAG = 4;
  function clone2(value) {
    return baseClone(value, CLONE_SYMBOLS_FLAG);
  }
  clone_1 = clone2;
  return clone_1;
}
var constant_1$1;
var hasRequiredConstant$1;
function requireConstant$1() {
  if (hasRequiredConstant$1)
    return constant_1$1;
  hasRequiredConstant$1 = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1$1 = constant2;
  return constant_1$1;
}
var each$1 = { exports: {} };
var _createBaseFor$1;
var hasRequired_createBaseFor$1;
function require_createBaseFor$1() {
  if (hasRequired_createBaseFor$1)
    return _createBaseFor$1;
  hasRequired_createBaseFor$1 = 1;
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  _createBaseFor$1 = createBaseFor;
  return _createBaseFor$1;
}
var _baseFor$1;
var hasRequired_baseFor$1;
function require_baseFor$1() {
  if (hasRequired_baseFor$1)
    return _baseFor$1;
  hasRequired_baseFor$1 = 1;
  var createBaseFor = require_createBaseFor$1();
  var baseFor = createBaseFor();
  _baseFor$1 = baseFor;
  return _baseFor$1;
}
var _baseForOwn$1;
var hasRequired_baseForOwn$1;
function require_baseForOwn$1() {
  if (hasRequired_baseForOwn$1)
    return _baseForOwn$1;
  hasRequired_baseForOwn$1 = 1;
  var baseFor = require_baseFor$1(), keys2 = requireKeys$1();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor(object2, iteratee, keys2);
  }
  _baseForOwn$1 = baseForOwn;
  return _baseForOwn$1;
}
var _createBaseEach$1;
var hasRequired_createBaseEach$1;
function require_createBaseEach$1() {
  if (hasRequired_createBaseEach$1)
    return _createBaseEach$1;
  hasRequired_createBaseEach$1 = 1;
  var isArrayLike = requireIsArrayLike$1();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach$1 = createBaseEach;
  return _createBaseEach$1;
}
var _baseEach$1;
var hasRequired_baseEach$1;
function require_baseEach$1() {
  if (hasRequired_baseEach$1)
    return _baseEach$1;
  hasRequired_baseEach$1 = 1;
  var baseForOwn = require_baseForOwn$1(), createBaseEach = require_createBaseEach$1();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach$1 = baseEach;
  return _baseEach$1;
}
var identity_1$1;
var hasRequiredIdentity$1;
function requireIdentity$1() {
  if (hasRequiredIdentity$1)
    return identity_1$1;
  hasRequiredIdentity$1 = 1;
  function identity2(value) {
    return value;
  }
  identity_1$1 = identity2;
  return identity_1$1;
}
var _castFunction$1;
var hasRequired_castFunction$1;
function require_castFunction$1() {
  if (hasRequired_castFunction$1)
    return _castFunction$1;
  hasRequired_castFunction$1 = 1;
  var identity2 = requireIdentity$1();
  function castFunction(value) {
    return typeof value == "function" ? value : identity2;
  }
  _castFunction$1 = castFunction;
  return _castFunction$1;
}
var forEach_1$1;
var hasRequiredForEach$1;
function requireForEach$1() {
  if (hasRequiredForEach$1)
    return forEach_1$1;
  hasRequiredForEach$1 = 1;
  var arrayEach = require_arrayEach$1(), baseEach = require_baseEach$1(), castFunction = require_castFunction$1(), isArray = requireIsArray$1();
  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1$1 = forEach;
  return forEach_1$1;
}
var hasRequiredEach$1;
function requireEach$1() {
  if (hasRequiredEach$1)
    return each$1.exports;
  hasRequiredEach$1 = 1;
  (function(module2) {
    module2.exports = requireForEach$1();
  })(each$1);
  return each$1.exports;
}
var _baseFilter;
var hasRequired_baseFilter;
function require_baseFilter() {
  if (hasRequired_baseFilter)
    return _baseFilter;
  hasRequired_baseFilter = 1;
  var baseEach = require_baseEach$1();
  function baseFilter(collection, predicate) {
    var result = [];
    baseEach(collection, function(value, index2, collection2) {
      if (predicate(value, index2, collection2)) {
        result.push(value);
      }
    });
    return result;
  }
  _baseFilter = baseFilter;
  return _baseFilter;
}
var _setCacheAdd;
var hasRequired_setCacheAdd;
function require_setCacheAdd() {
  if (hasRequired_setCacheAdd)
    return _setCacheAdd;
  hasRequired_setCacheAdd = 1;
  var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED2);
    return this;
  }
  _setCacheAdd = setCacheAdd;
  return _setCacheAdd;
}
var _setCacheHas;
var hasRequired_setCacheHas;
function require_setCacheHas() {
  if (hasRequired_setCacheHas)
    return _setCacheHas;
  hasRequired_setCacheHas = 1;
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  _setCacheHas = setCacheHas;
  return _setCacheHas;
}
var _SetCache;
var hasRequired_SetCache;
function require_SetCache() {
  if (hasRequired_SetCache)
    return _SetCache;
  hasRequired_SetCache = 1;
  var MapCache2 = require_MapCache(), setCacheAdd = require_setCacheAdd(), setCacheHas = require_setCacheHas();
  function SetCache(values2) {
    var index2 = -1, length2 = values2 == null ? 0 : values2.length;
    this.__data__ = new MapCache2();
    while (++index2 < length2) {
      this.add(values2[index2]);
    }
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  _SetCache = SetCache;
  return _SetCache;
}
var _arraySome;
var hasRequired_arraySome;
function require_arraySome() {
  if (hasRequired_arraySome)
    return _arraySome;
  hasRequired_arraySome = 1;
  function arraySome(array2, predicate) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (predicate(array2[index2], index2, array2)) {
        return true;
      }
    }
    return false;
  }
  _arraySome = arraySome;
  return _arraySome;
}
var _cacheHas;
var hasRequired_cacheHas;
function require_cacheHas() {
  if (hasRequired_cacheHas)
    return _cacheHas;
  hasRequired_cacheHas = 1;
  function cacheHas(cache, key) {
    return cache.has(key);
  }
  _cacheHas = cacheHas;
  return _cacheHas;
}
var _equalArrays;
var hasRequired_equalArrays;
function require_equalArrays() {
  if (hasRequired_equalArrays)
    return _equalArrays;
  hasRequired_equalArrays = 1;
  var SetCache = require_SetCache(), arraySome = require_arraySome(), cacheHas = require_cacheHas();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function equalArrays(array2, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var arrStacked = stack2.get(array2);
    var othStacked = stack2.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array2;
    }
    var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : void 0;
    stack2.set(array2, other);
    stack2.set(other, array2);
    while (++index2 < arrLength) {
      var arrValue = array2[index2], othValue = other[index2];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack2) : customizer(arrValue, othValue, index2, array2, other, stack2);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
        result = false;
        break;
      }
    }
    stack2["delete"](array2);
    stack2["delete"](other);
    return result;
  }
  _equalArrays = equalArrays;
  return _equalArrays;
}
var _mapToArray;
var hasRequired_mapToArray;
function require_mapToArray() {
  if (hasRequired_mapToArray)
    return _mapToArray;
  hasRequired_mapToArray = 1;
  function mapToArray(map2) {
    var index2 = -1, result = Array(map2.size);
    map2.forEach(function(value, key) {
      result[++index2] = [key, value];
    });
    return result;
  }
  _mapToArray = mapToArray;
  return _mapToArray;
}
var _setToArray;
var hasRequired_setToArray;
function require_setToArray() {
  if (hasRequired_setToArray)
    return _setToArray;
  hasRequired_setToArray = 1;
  function setToArray(set2) {
    var index2 = -1, result = Array(set2.size);
    set2.forEach(function(value) {
      result[++index2] = value;
    });
    return result;
  }
  _setToArray = setToArray;
  return _setToArray;
}
var _equalByTag;
var hasRequired_equalByTag;
function require_equalByTag() {
  if (hasRequired_equalByTag)
    return _equalByTag;
  hasRequired_equalByTag = 1;
  var Symbol2 = require_Symbol$1(), Uint8Array2 = require_Uint8Array(), eq2 = requireEq$1(), equalArrays = require_equalArrays(), mapToArray = require_mapToArray(), setToArray = require_setToArray();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack2) {
    switch (tag) {
      case dataViewTag:
        if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
          return false;
        }
        object2 = object2.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object2), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq2(+object2, +other);
      case errorTag:
        return object2.name == other.name && object2.message == other.message;
      case regexpTag:
      case stringTag:
        return object2 == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
        convert || (convert = setToArray);
        if (object2.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack2.get(object2);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG;
        stack2.set(object2, other);
        var result = equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack2);
        stack2["delete"](object2);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object2) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  _equalByTag = equalByTag;
  return _equalByTag;
}
var _equalObjects;
var hasRequired_equalObjects;
function require_equalObjects() {
  if (hasRequired_equalObjects)
    return _equalObjects;
  hasRequired_equalObjects = 1;
  var getAllKeys = require_getAllKeys();
  var COMPARE_PARTIAL_FLAG = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function equalObjects(object2, other, bitmask, customizer, equalFunc, stack2) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index2 = objLength;
    while (index2--) {
      var key = objProps[index2];
      if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
        return false;
      }
    }
    var objStacked = stack2.get(object2);
    var othStacked = stack2.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object2;
    }
    var result = true;
    stack2.set(object2, other);
    stack2.set(other, object2);
    var skipCtor = isPartial;
    while (++index2 < objLength) {
      key = objProps[index2];
      var objValue = object2[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack2) : customizer(objValue, othValue, key, object2, other, stack2);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object2.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack2["delete"](object2);
    stack2["delete"](other);
    return result;
  }
  _equalObjects = equalObjects;
  return _equalObjects;
}
var _baseIsEqualDeep;
var hasRequired_baseIsEqualDeep;
function require_baseIsEqualDeep() {
  if (hasRequired_baseIsEqualDeep)
    return _baseIsEqualDeep;
  hasRequired_baseIsEqualDeep = 1;
  var Stack = require_Stack(), equalArrays = require_equalArrays(), equalByTag = require_equalByTag(), equalObjects = require_equalObjects(), getTag = require_getTag(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isTypedArray = requireIsTypedArray$1();
  var COMPARE_PARTIAL_FLAG = 1;
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack2) {
    var objIsArr = isArray(object2), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer2(object2)) {
      if (!isBuffer2(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack2 || (stack2 = new Stack());
      return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack2);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
        stack2 || (stack2 = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack2 || (stack2 = new Stack());
    return equalObjects(object2, other, bitmask, customizer, equalFunc, stack2);
  }
  _baseIsEqualDeep = baseIsEqualDeep;
  return _baseIsEqualDeep;
}
var _baseIsEqual;
var hasRequired_baseIsEqual;
function require_baseIsEqual() {
  if (hasRequired_baseIsEqual)
    return _baseIsEqual;
  hasRequired_baseIsEqual = 1;
  var baseIsEqualDeep = require_baseIsEqualDeep(), isObjectLike = requireIsObjectLike$1();
  function baseIsEqual(value, other, bitmask, customizer, stack2) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
  }
  _baseIsEqual = baseIsEqual;
  return _baseIsEqual;
}
var _baseIsMatch;
var hasRequired_baseIsMatch;
function require_baseIsMatch() {
  if (hasRequired_baseIsMatch)
    return _baseIsMatch;
  hasRequired_baseIsMatch = 1;
  var Stack = require_Stack(), baseIsEqual = require_baseIsEqual();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseIsMatch(object2, source, matchData, customizer) {
    var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
    if (object2 == null) {
      return !length2;
    }
    object2 = Object(object2);
    while (index2--) {
      var data = matchData[index2];
      if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
        return false;
      }
    }
    while (++index2 < length2) {
      data = matchData[index2];
      var key = data[0], objValue = object2[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object2)) {
          return false;
        }
      } else {
        var stack2 = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object2, source, stack2);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack2) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  _baseIsMatch = baseIsMatch;
  return _baseIsMatch;
}
var _isStrictComparable;
var hasRequired_isStrictComparable;
function require_isStrictComparable() {
  if (hasRequired_isStrictComparable)
    return _isStrictComparable;
  hasRequired_isStrictComparable = 1;
  var isObject = requireIsObject$1();
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  _isStrictComparable = isStrictComparable;
  return _isStrictComparable;
}
var _getMatchData;
var hasRequired_getMatchData;
function require_getMatchData() {
  if (hasRequired_getMatchData)
    return _getMatchData;
  hasRequired_getMatchData = 1;
  var isStrictComparable = require_isStrictComparable(), keys2 = requireKeys$1();
  function getMatchData(object2) {
    var result = keys2(object2), length2 = result.length;
    while (length2--) {
      var key = result[length2], value = object2[key];
      result[length2] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  _getMatchData = getMatchData;
  return _getMatchData;
}
var _matchesStrictComparable;
var hasRequired_matchesStrictComparable;
function require_matchesStrictComparable() {
  if (hasRequired_matchesStrictComparable)
    return _matchesStrictComparable;
  hasRequired_matchesStrictComparable = 1;
  function matchesStrictComparable(key, srcValue) {
    return function(object2) {
      if (object2 == null) {
        return false;
      }
      return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
    };
  }
  _matchesStrictComparable = matchesStrictComparable;
  return _matchesStrictComparable;
}
var _baseMatches;
var hasRequired_baseMatches;
function require_baseMatches() {
  if (hasRequired_baseMatches)
    return _baseMatches;
  hasRequired_baseMatches = 1;
  var baseIsMatch = require_baseIsMatch(), getMatchData = require_getMatchData(), matchesStrictComparable = require_matchesStrictComparable();
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object2) {
      return object2 === source || baseIsMatch(object2, source, matchData);
    };
  }
  _baseMatches = baseMatches;
  return _baseMatches;
}
var isSymbol_1$1;
var hasRequiredIsSymbol$1;
function requireIsSymbol$1() {
  if (hasRequiredIsSymbol$1)
    return isSymbol_1$1;
  hasRequiredIsSymbol$1 = 1;
  var baseGetTag = require_baseGetTag$1(), isObjectLike = requireIsObjectLike$1();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1$1 = isSymbol;
  return isSymbol_1$1;
}
var _isKey$1;
var hasRequired_isKey$1;
function require_isKey$1() {
  if (hasRequired_isKey$1)
    return _isKey$1;
  hasRequired_isKey$1 = 1;
  var isArray = requireIsArray$1(), isSymbol = requireIsSymbol$1();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object2) {
    if (isArray(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  _isKey$1 = isKey;
  return _isKey$1;
}
var memoize_1$1;
var hasRequiredMemoize;
function requireMemoize() {
  if (hasRequiredMemoize)
    return memoize_1$1;
  hasRequiredMemoize = 1;
  var MapCache2 = require_MapCache();
  var FUNC_ERROR_TEXT2 = "Expected a function";
  function memoize2(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT2);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize2.Cache || MapCache2)();
    return memoized;
  }
  memoize2.Cache = MapCache2;
  memoize_1$1 = memoize2;
  return memoize_1$1;
}
var _memoizeCapped$1;
var hasRequired_memoizeCapped$1;
function require_memoizeCapped$1() {
  if (hasRequired_memoizeCapped$1)
    return _memoizeCapped$1;
  hasRequired_memoizeCapped$1 = 1;
  var memoize2 = requireMemoize();
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize2(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped$1 = memoizeCapped;
  return _memoizeCapped$1;
}
var _stringToPath$1;
var hasRequired_stringToPath$1;
function require_stringToPath$1() {
  if (hasRequired_stringToPath$1)
    return _stringToPath$1;
  hasRequired_stringToPath$1 = 1;
  var memoizeCapped = require_memoizeCapped$1();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number3, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
    });
    return result;
  });
  _stringToPath$1 = stringToPath;
  return _stringToPath$1;
}
var _arrayMap$1;
var hasRequired_arrayMap$1;
function require_arrayMap$1() {
  if (hasRequired_arrayMap$1)
    return _arrayMap$1;
  hasRequired_arrayMap$1 = 1;
  function arrayMap(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array2[index2], index2, array2);
    }
    return result;
  }
  _arrayMap$1 = arrayMap;
  return _arrayMap$1;
}
var _baseToString$1;
var hasRequired_baseToString$1;
function require_baseToString$1() {
  if (hasRequired_baseToString$1)
    return _baseToString$1;
  hasRequired_baseToString$1 = 1;
  var Symbol2 = require_Symbol$1(), arrayMap = require_arrayMap$1(), isArray = requireIsArray$1(), isSymbol = requireIsSymbol$1();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString$1 = baseToString;
  return _baseToString$1;
}
var toString_1$1;
var hasRequiredToString$1;
function requireToString$1() {
  if (hasRequiredToString$1)
    return toString_1$1;
  hasRequiredToString$1 = 1;
  var baseToString = require_baseToString$1();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1$1 = toString;
  return toString_1$1;
}
var _castPath$1;
var hasRequired_castPath$1;
function require_castPath$1() {
  if (hasRequired_castPath$1)
    return _castPath$1;
  hasRequired_castPath$1 = 1;
  var isArray = requireIsArray$1(), isKey = require_isKey$1(), stringToPath = require_stringToPath$1(), toString = requireToString$1();
  function castPath(value, object2) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object2) ? [value] : stringToPath(toString(value));
  }
  _castPath$1 = castPath;
  return _castPath$1;
}
var _toKey$1;
var hasRequired_toKey$1;
function require_toKey$1() {
  if (hasRequired_toKey$1)
    return _toKey$1;
  hasRequired_toKey$1 = 1;
  var isSymbol = requireIsSymbol$1();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _toKey$1 = toKey;
  return _toKey$1;
}
var _baseGet$1;
var hasRequired_baseGet$1;
function require_baseGet$1() {
  if (hasRequired_baseGet$1)
    return _baseGet$1;
  hasRequired_baseGet$1 = 1;
  var castPath = require_castPath$1(), toKey = require_toKey$1();
  function baseGet(object2, path2) {
    path2 = castPath(path2, object2);
    var index2 = 0, length2 = path2.length;
    while (object2 != null && index2 < length2) {
      object2 = object2[toKey(path2[index2++])];
    }
    return index2 && index2 == length2 ? object2 : void 0;
  }
  _baseGet$1 = baseGet;
  return _baseGet$1;
}
var get_1;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet)
    return get_1;
  hasRequiredGet = 1;
  var baseGet = require_baseGet$1();
  function get2(object2, path2, defaultValue) {
    var result = object2 == null ? void 0 : baseGet(object2, path2);
    return result === void 0 ? defaultValue : result;
  }
  get_1 = get2;
  return get_1;
}
var _baseHasIn$1;
var hasRequired_baseHasIn$1;
function require_baseHasIn$1() {
  if (hasRequired_baseHasIn$1)
    return _baseHasIn$1;
  hasRequired_baseHasIn$1 = 1;
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  _baseHasIn$1 = baseHasIn;
  return _baseHasIn$1;
}
var _hasPath$1;
var hasRequired_hasPath$1;
function require_hasPath$1() {
  if (hasRequired_hasPath$1)
    return _hasPath$1;
  hasRequired_hasPath$1 = 1;
  var castPath = require_castPath$1(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isIndex = require_isIndex$1(), isLength = requireIsLength$1(), toKey = require_toKey$1();
  function hasPath(object2, path2, hasFunc) {
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, result = false;
    while (++index2 < length2) {
      var key = toKey(path2[index2]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object2 == null ? 0 : object2.length;
    return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
  }
  _hasPath$1 = hasPath;
  return _hasPath$1;
}
var hasIn_1$1;
var hasRequiredHasIn$1;
function requireHasIn$1() {
  if (hasRequiredHasIn$1)
    return hasIn_1$1;
  hasRequiredHasIn$1 = 1;
  var baseHasIn = require_baseHasIn$1(), hasPath = require_hasPath$1();
  function hasIn(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHasIn);
  }
  hasIn_1$1 = hasIn;
  return hasIn_1$1;
}
var _baseMatchesProperty;
var hasRequired_baseMatchesProperty;
function require_baseMatchesProperty() {
  if (hasRequired_baseMatchesProperty)
    return _baseMatchesProperty;
  hasRequired_baseMatchesProperty = 1;
  var baseIsEqual = require_baseIsEqual(), get2 = requireGet(), hasIn = requireHasIn$1(), isKey = require_isKey$1(), isStrictComparable = require_isStrictComparable(), matchesStrictComparable = require_matchesStrictComparable(), toKey = require_toKey$1();
  var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
  function baseMatchesProperty(path2, srcValue) {
    if (isKey(path2) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path2), srcValue);
    }
    return function(object2) {
      var objValue = get2(object2, path2);
      return objValue === void 0 && objValue === srcValue ? hasIn(object2, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  _baseMatchesProperty = baseMatchesProperty;
  return _baseMatchesProperty;
}
var _baseProperty;
var hasRequired_baseProperty;
function require_baseProperty() {
  if (hasRequired_baseProperty)
    return _baseProperty;
  hasRequired_baseProperty = 1;
  function baseProperty(key) {
    return function(object2) {
      return object2 == null ? void 0 : object2[key];
    };
  }
  _baseProperty = baseProperty;
  return _baseProperty;
}
var _basePropertyDeep;
var hasRequired_basePropertyDeep;
function require_basePropertyDeep() {
  if (hasRequired_basePropertyDeep)
    return _basePropertyDeep;
  hasRequired_basePropertyDeep = 1;
  var baseGet = require_baseGet$1();
  function basePropertyDeep(path2) {
    return function(object2) {
      return baseGet(object2, path2);
    };
  }
  _basePropertyDeep = basePropertyDeep;
  return _basePropertyDeep;
}
var property_1;
var hasRequiredProperty;
function requireProperty() {
  if (hasRequiredProperty)
    return property_1;
  hasRequiredProperty = 1;
  var baseProperty = require_baseProperty(), basePropertyDeep = require_basePropertyDeep(), isKey = require_isKey$1(), toKey = require_toKey$1();
  function property(path2) {
    return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
  }
  property_1 = property;
  return property_1;
}
var _baseIteratee;
var hasRequired_baseIteratee;
function require_baseIteratee() {
  if (hasRequired_baseIteratee)
    return _baseIteratee;
  hasRequired_baseIteratee = 1;
  var baseMatches = require_baseMatches(), baseMatchesProperty = require_baseMatchesProperty(), identity2 = requireIdentity$1(), isArray = requireIsArray$1(), property = requireProperty();
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity2;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  _baseIteratee = baseIteratee;
  return _baseIteratee;
}
var filter_1;
var hasRequiredFilter;
function requireFilter() {
  if (hasRequiredFilter)
    return filter_1;
  hasRequiredFilter = 1;
  var arrayFilter = require_arrayFilter(), baseFilter = require_baseFilter(), baseIteratee = require_baseIteratee(), isArray = requireIsArray$1();
  function filter(collection, predicate) {
    var func = isArray(collection) ? arrayFilter : baseFilter;
    return func(collection, baseIteratee(predicate, 3));
  }
  filter_1 = filter;
  return filter_1;
}
var _baseHas$1;
var hasRequired_baseHas$1;
function require_baseHas$1() {
  if (hasRequired_baseHas$1)
    return _baseHas$1;
  hasRequired_baseHas$1 = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseHas(object2, key) {
    return object2 != null && hasOwnProperty2.call(object2, key);
  }
  _baseHas$1 = baseHas;
  return _baseHas$1;
}
var has_1$1;
var hasRequiredHas$1;
function requireHas$1() {
  if (hasRequiredHas$1)
    return has_1$1;
  hasRequiredHas$1 = 1;
  var baseHas = require_baseHas$1(), hasPath = require_hasPath$1();
  function has(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHas);
  }
  has_1$1 = has;
  return has_1$1;
}
var isEmpty_1;
var hasRequiredIsEmpty;
function requireIsEmpty() {
  if (hasRequiredIsEmpty)
    return isEmpty_1;
  hasRequiredIsEmpty = 1;
  var baseKeys = require_baseKeys$1(), getTag = require_getTag(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isArrayLike = requireIsArrayLike$1(), isBuffer2 = requireIsBuffer$1(), isPrototype = require_isPrototype$1(), isTypedArray = requireIsTypedArray$1();
  var mapTag = "[object Map]", setTag = "[object Set]";
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function isEmpty(value) {
    if (value == null) {
      return true;
    }
    if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray(value) || isArguments(value))) {
      return !value.length;
    }
    var tag = getTag(value);
    if (tag == mapTag || tag == setTag) {
      return !value.size;
    }
    if (isPrototype(value)) {
      return !baseKeys(value).length;
    }
    for (var key in value) {
      if (hasOwnProperty2.call(value, key)) {
        return false;
      }
    }
    return true;
  }
  isEmpty_1 = isEmpty;
  return isEmpty_1;
}
var isUndefined_1;
var hasRequiredIsUndefined;
function requireIsUndefined() {
  if (hasRequiredIsUndefined)
    return isUndefined_1;
  hasRequiredIsUndefined = 1;
  function isUndefined(value) {
    return value === void 0;
  }
  isUndefined_1 = isUndefined;
  return isUndefined_1;
}
var _baseMap;
var hasRequired_baseMap;
function require_baseMap() {
  if (hasRequired_baseMap)
    return _baseMap;
  hasRequired_baseMap = 1;
  var baseEach = require_baseEach$1(), isArrayLike = requireIsArrayLike$1();
  function baseMap(collection, iteratee) {
    var index2 = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
    baseEach(collection, function(value, key, collection2) {
      result[++index2] = iteratee(value, key, collection2);
    });
    return result;
  }
  _baseMap = baseMap;
  return _baseMap;
}
var map_1;
var hasRequiredMap;
function requireMap() {
  if (hasRequiredMap)
    return map_1;
  hasRequiredMap = 1;
  var arrayMap = require_arrayMap$1(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), isArray = requireIsArray$1();
  function map2(collection, iteratee) {
    var func = isArray(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee, 3));
  }
  map_1 = map2;
  return map_1;
}
var _arrayReduce;
var hasRequired_arrayReduce;
function require_arrayReduce() {
  if (hasRequired_arrayReduce)
    return _arrayReduce;
  hasRequired_arrayReduce = 1;
  function arrayReduce(array2, iteratee, accumulator, initAccum) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    if (initAccum && length2) {
      accumulator = array2[++index2];
    }
    while (++index2 < length2) {
      accumulator = iteratee(accumulator, array2[index2], index2, array2);
    }
    return accumulator;
  }
  _arrayReduce = arrayReduce;
  return _arrayReduce;
}
var _baseReduce;
var hasRequired_baseReduce;
function require_baseReduce() {
  if (hasRequired_baseReduce)
    return _baseReduce;
  hasRequired_baseReduce = 1;
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index2, collection2) {
      accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
    });
    return accumulator;
  }
  _baseReduce = baseReduce;
  return _baseReduce;
}
var reduce_1;
var hasRequiredReduce;
function requireReduce() {
  if (hasRequiredReduce)
    return reduce_1;
  hasRequiredReduce = 1;
  var arrayReduce = require_arrayReduce(), baseEach = require_baseEach$1(), baseIteratee = require_baseIteratee(), baseReduce = require_baseReduce(), isArray = requireIsArray$1();
  function reduce(collection, iteratee, accumulator) {
    var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
    return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  }
  reduce_1 = reduce;
  return reduce_1;
}
var isString_1;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString)
    return isString_1;
  hasRequiredIsString = 1;
  var baseGetTag = require_baseGetTag$1(), isArray = requireIsArray$1(), isObjectLike = requireIsObjectLike$1();
  var stringTag = "[object String]";
  function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
  }
  isString_1 = isString;
  return isString_1;
}
var _asciiSize;
var hasRequired_asciiSize;
function require_asciiSize() {
  if (hasRequired_asciiSize)
    return _asciiSize;
  hasRequired_asciiSize = 1;
  var baseProperty = require_baseProperty();
  var asciiSize = baseProperty("length");
  _asciiSize = asciiSize;
  return _asciiSize;
}
var _hasUnicode;
var hasRequired_hasUnicode;
function require_hasUnicode() {
  if (hasRequired_hasUnicode)
    return _hasUnicode;
  hasRequired_hasUnicode = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsZWJ = "\\u200d";
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  _hasUnicode = hasUnicode;
  return _hasUnicode;
}
var _unicodeSize;
var hasRequired_unicodeSize;
function require_unicodeSize() {
  if (hasRequired_unicodeSize)
    return _unicodeSize;
  hasRequired_unicodeSize = 1;
  var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }
  _unicodeSize = unicodeSize;
  return _unicodeSize;
}
var _stringSize;
var hasRequired_stringSize;
function require_stringSize() {
  if (hasRequired_stringSize)
    return _stringSize;
  hasRequired_stringSize = 1;
  var asciiSize = require_asciiSize(), hasUnicode = require_hasUnicode(), unicodeSize = require_unicodeSize();
  function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }
  _stringSize = stringSize;
  return _stringSize;
}
var size_1;
var hasRequiredSize;
function requireSize() {
  if (hasRequiredSize)
    return size_1;
  hasRequiredSize = 1;
  var baseKeys = require_baseKeys$1(), getTag = require_getTag(), isArrayLike = requireIsArrayLike$1(), isString = requireIsString(), stringSize = require_stringSize();
  var mapTag = "[object Map]", setTag = "[object Set]";
  function size(collection) {
    if (collection == null) {
      return 0;
    }
    if (isArrayLike(collection)) {
      return isString(collection) ? stringSize(collection) : collection.length;
    }
    var tag = getTag(collection);
    if (tag == mapTag || tag == setTag) {
      return collection.size;
    }
    return baseKeys(collection).length;
  }
  size_1 = size;
  return size_1;
}
var transform_1;
var hasRequiredTransform;
function requireTransform() {
  if (hasRequiredTransform)
    return transform_1;
  hasRequiredTransform = 1;
  var arrayEach = require_arrayEach$1(), baseCreate = require_baseCreate(), baseForOwn = require_baseForOwn$1(), baseIteratee = require_baseIteratee(), getPrototype = require_getPrototype$1(), isArray = requireIsArray$1(), isBuffer2 = requireIsBuffer$1(), isFunction = requireIsFunction$1(), isObject = requireIsObject$1(), isTypedArray = requireIsTypedArray$1();
  function transform2(object2, iteratee, accumulator) {
    var isArr = isArray(object2), isArrLike = isArr || isBuffer2(object2) || isTypedArray(object2);
    iteratee = baseIteratee(iteratee, 4);
    if (accumulator == null) {
      var Ctor = object2 && object2.constructor;
      if (isArrLike) {
        accumulator = isArr ? new Ctor() : [];
      } else if (isObject(object2)) {
        accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object2)) : {};
      } else {
        accumulator = {};
      }
    }
    (isArrLike ? arrayEach : baseForOwn)(object2, function(value, index2, object3) {
      return iteratee(accumulator, value, index2, object3);
    });
    return accumulator;
  }
  transform_1 = transform2;
  return transform_1;
}
var _isFlattenable$1;
var hasRequired_isFlattenable$1;
function require_isFlattenable$1() {
  if (hasRequired_isFlattenable$1)
    return _isFlattenable$1;
  hasRequired_isFlattenable$1 = 1;
  var Symbol2 = require_Symbol$1(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable$1 = isFlattenable;
  return _isFlattenable$1;
}
var _baseFlatten$1;
var hasRequired_baseFlatten$1;
function require_baseFlatten$1() {
  if (hasRequired_baseFlatten$1)
    return _baseFlatten$1;
  hasRequired_baseFlatten$1 = 1;
  var arrayPush2 = require_arrayPush$1(), isFlattenable = require_isFlattenable$1();
  function baseFlatten(array2, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array2.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array2[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush2(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten$1 = baseFlatten;
  return _baseFlatten$1;
}
var _apply$1;
var hasRequired_apply$1;
function require_apply$1() {
  if (hasRequired_apply$1)
    return _apply$1;
  hasRequired_apply$1 = 1;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply$1 = apply2;
  return _apply$1;
}
var _overRest$1;
var hasRequired_overRest$1;
function require_overRest$1() {
  if (hasRequired_overRest$1)
    return _overRest$1;
  hasRequired_overRest$1 = 1;
  var apply2 = require_apply$1();
  var nativeMax = Math.max;
  function overRest(func, start2, transform2) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
      while (++index2 < length2) {
        array2[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array2);
      return apply2(func, this, otherArgs);
    };
  }
  _overRest$1 = overRest;
  return _overRest$1;
}
var _baseSetToString$1;
var hasRequired_baseSetToString$1;
function require_baseSetToString$1() {
  if (hasRequired_baseSetToString$1)
    return _baseSetToString$1;
  hasRequired_baseSetToString$1 = 1;
  var constant2 = requireConstant$1(), defineProperty = require_defineProperty$1(), identity2 = requireIdentity$1();
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  _baseSetToString$1 = baseSetToString;
  return _baseSetToString$1;
}
var _shortOut$1;
var hasRequired_shortOut$1;
function require_shortOut$1() {
  if (hasRequired_shortOut$1)
    return _shortOut$1;
  hasRequired_shortOut$1 = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut$1 = shortOut;
  return _shortOut$1;
}
var _setToString$1;
var hasRequired_setToString$1;
function require_setToString$1() {
  if (hasRequired_setToString$1)
    return _setToString$1;
  hasRequired_setToString$1 = 1;
  var baseSetToString = require_baseSetToString$1(), shortOut = require_shortOut$1();
  var setToString = shortOut(baseSetToString);
  _setToString$1 = setToString;
  return _setToString$1;
}
var _baseRest$1;
var hasRequired_baseRest$1;
function require_baseRest$1() {
  if (hasRequired_baseRest$1)
    return _baseRest$1;
  hasRequired_baseRest$1 = 1;
  var identity2 = requireIdentity$1(), overRest = require_overRest$1(), setToString = require_setToString$1();
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity2), func + "");
  }
  _baseRest$1 = baseRest;
  return _baseRest$1;
}
var _baseFindIndex;
var hasRequired_baseFindIndex;
function require_baseFindIndex() {
  if (hasRequired_baseFindIndex)
    return _baseFindIndex;
  hasRequired_baseFindIndex = 1;
  function baseFindIndex(array2, predicate, fromIndex, fromRight) {
    var length2 = array2.length, index2 = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index2-- : ++index2 < length2) {
      if (predicate(array2[index2], index2, array2)) {
        return index2;
      }
    }
    return -1;
  }
  _baseFindIndex = baseFindIndex;
  return _baseFindIndex;
}
var _baseIsNaN;
var hasRequired_baseIsNaN;
function require_baseIsNaN() {
  if (hasRequired_baseIsNaN)
    return _baseIsNaN;
  hasRequired_baseIsNaN = 1;
  function baseIsNaN(value) {
    return value !== value;
  }
  _baseIsNaN = baseIsNaN;
  return _baseIsNaN;
}
var _strictIndexOf;
var hasRequired_strictIndexOf;
function require_strictIndexOf() {
  if (hasRequired_strictIndexOf)
    return _strictIndexOf;
  hasRequired_strictIndexOf = 1;
  function strictIndexOf(array2, value, fromIndex) {
    var index2 = fromIndex - 1, length2 = array2.length;
    while (++index2 < length2) {
      if (array2[index2] === value) {
        return index2;
      }
    }
    return -1;
  }
  _strictIndexOf = strictIndexOf;
  return _strictIndexOf;
}
var _baseIndexOf;
var hasRequired_baseIndexOf;
function require_baseIndexOf() {
  if (hasRequired_baseIndexOf)
    return _baseIndexOf;
  hasRequired_baseIndexOf = 1;
  var baseFindIndex = require_baseFindIndex(), baseIsNaN = require_baseIsNaN(), strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array2, value, fromIndex) {
    return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex(array2, baseIsNaN, fromIndex);
  }
  _baseIndexOf = baseIndexOf;
  return _baseIndexOf;
}
var _arrayIncludes;
var hasRequired_arrayIncludes;
function require_arrayIncludes() {
  if (hasRequired_arrayIncludes)
    return _arrayIncludes;
  hasRequired_arrayIncludes = 1;
  var baseIndexOf = require_baseIndexOf();
  function arrayIncludes(array2, value) {
    var length2 = array2 == null ? 0 : array2.length;
    return !!length2 && baseIndexOf(array2, value, 0) > -1;
  }
  _arrayIncludes = arrayIncludes;
  return _arrayIncludes;
}
var _arrayIncludesWith;
var hasRequired_arrayIncludesWith;
function require_arrayIncludesWith() {
  if (hasRequired_arrayIncludesWith)
    return _arrayIncludesWith;
  hasRequired_arrayIncludesWith = 1;
  function arrayIncludesWith(array2, value, comparator) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (comparator(value, array2[index2])) {
        return true;
      }
    }
    return false;
  }
  _arrayIncludesWith = arrayIncludesWith;
  return _arrayIncludesWith;
}
var noop_1;
var hasRequiredNoop;
function requireNoop() {
  if (hasRequiredNoop)
    return noop_1;
  hasRequiredNoop = 1;
  function noop2() {
  }
  noop_1 = noop2;
  return noop_1;
}
var _createSet;
var hasRequired_createSet;
function require_createSet() {
  if (hasRequired_createSet)
    return _createSet;
  hasRequired_createSet = 1;
  var Set4 = require_Set(), noop2 = requireNoop(), setToArray = require_setToArray();
  var INFINITY = 1 / 0;
  var createSet = !(Set4 && 1 / setToArray(new Set4([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
    return new Set4(values2);
  };
  _createSet = createSet;
  return _createSet;
}
var _baseUniq;
var hasRequired_baseUniq;
function require_baseUniq() {
  if (hasRequired_baseUniq)
    return _baseUniq;
  hasRequired_baseUniq = 1;
  var SetCache = require_SetCache(), arrayIncludes = require_arrayIncludes(), arrayIncludesWith = require_arrayIncludesWith(), cacheHas = require_cacheHas(), createSet = require_createSet(), setToArray = require_setToArray();
  var LARGE_ARRAY_SIZE = 200;
  function baseUniq(array2, iteratee, comparator) {
    var index2 = -1, includes2 = arrayIncludes, length2 = array2.length, isCommon = true, result = [], seen = result;
    if (comparator) {
      isCommon = false;
      includes2 = arrayIncludesWith;
    } else if (length2 >= LARGE_ARRAY_SIZE) {
      var set2 = iteratee ? null : createSet(array2);
      if (set2) {
        return setToArray(set2);
      }
      isCommon = false;
      includes2 = cacheHas;
      seen = new SetCache();
    } else {
      seen = iteratee ? [] : result;
    }
    outer:
      while (++index2 < length2) {
        var value = array2[index2], computed = iteratee ? iteratee(value) : value;
        value = comparator || value !== 0 ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        } else if (!includes2(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
    return result;
  }
  _baseUniq = baseUniq;
  return _baseUniq;
}
var isArrayLikeObject_1;
var hasRequiredIsArrayLikeObject;
function requireIsArrayLikeObject() {
  if (hasRequiredIsArrayLikeObject)
    return isArrayLikeObject_1;
  hasRequiredIsArrayLikeObject = 1;
  var isArrayLike = requireIsArrayLike$1(), isObjectLike = requireIsObjectLike$1();
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  isArrayLikeObject_1 = isArrayLikeObject;
  return isArrayLikeObject_1;
}
var union_1;
var hasRequiredUnion;
function requireUnion() {
  if (hasRequiredUnion)
    return union_1;
  hasRequiredUnion = 1;
  var baseFlatten = require_baseFlatten$1(), baseRest = require_baseRest$1(), baseUniq = require_baseUniq(), isArrayLikeObject = requireIsArrayLikeObject();
  var union = baseRest(function(arrays) {
    return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  });
  union_1 = union;
  return union_1;
}
var _baseValues;
var hasRequired_baseValues;
function require_baseValues() {
  if (hasRequired_baseValues)
    return _baseValues;
  hasRequired_baseValues = 1;
  var arrayMap = require_arrayMap$1();
  function baseValues(object2, props) {
    return arrayMap(props, function(key) {
      return object2[key];
    });
  }
  _baseValues = baseValues;
  return _baseValues;
}
var values_1;
var hasRequiredValues;
function requireValues() {
  if (hasRequiredValues)
    return values_1;
  hasRequiredValues = 1;
  var baseValues = require_baseValues(), keys2 = requireKeys$1();
  function values2(object2) {
    return object2 == null ? [] : baseValues(object2, keys2(object2));
  }
  values_1 = values2;
  return values_1;
}
var lodash$3;
if (typeof commonjsRequire$1 === "function") {
  try {
    lodash$3 = {
      clone: requireClone(),
      constant: requireConstant$1(),
      each: requireEach$1(),
      filter: requireFilter(),
      has: requireHas$1(),
      isArray: requireIsArray$1(),
      isEmpty: requireIsEmpty(),
      isFunction: requireIsFunction$1(),
      isUndefined: requireIsUndefined(),
      keys: requireKeys$1(),
      map: requireMap(),
      reduce: requireReduce(),
      size: requireSize(),
      transform: requireTransform(),
      union: requireUnion(),
      values: requireValues()
    };
  } catch (e) {
  }
}
if (!lodash$3) {
  lodash$3 = window._;
}
var lodash_1$3 = lodash$3;
var _$C = lodash_1$3;
var graph = Graph$a;
var DEFAULT_EDGE_NAME = "\0";
var GRAPH_NODE = "\0";
var EDGE_KEY_DELIM = "";
function Graph$a(opts) {
  this._isDirected = _$C.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _$C.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _$C.has(opts, "compound") ? opts.compound : false;
  this._label = void 0;
  this._defaultNodeLabelFn = _$C.constant(void 0);
  this._defaultEdgeLabelFn = _$C.constant(void 0);
  this._nodes = {};
  if (this._isCompound) {
    this._parent = {};
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }
  this._in = {};
  this._preds = {};
  this._out = {};
  this._sucs = {};
  this._edgeObjs = {};
  this._edgeLabels = {};
}
Graph$a.prototype._nodeCount = 0;
Graph$a.prototype._edgeCount = 0;
Graph$a.prototype.isDirected = function() {
  return this._isDirected;
};
Graph$a.prototype.isMultigraph = function() {
  return this._isMultigraph;
};
Graph$a.prototype.isCompound = function() {
  return this._isCompound;
};
Graph$a.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};
Graph$a.prototype.graph = function() {
  return this._label;
};
Graph$a.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_$C.isFunction(newDefault)) {
    newDefault = _$C.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};
Graph$a.prototype.nodeCount = function() {
  return this._nodeCount;
};
Graph$a.prototype.nodes = function() {
  return _$C.keys(this._nodes);
};
Graph$a.prototype.sources = function() {
  var self2 = this;
  return _$C.filter(this.nodes(), function(v) {
    return _$C.isEmpty(self2._in[v]);
  });
};
Graph$a.prototype.sinks = function() {
  var self2 = this;
  return _$C.filter(this.nodes(), function(v) {
    return _$C.isEmpty(self2._out[v]);
  });
};
Graph$a.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self2 = this;
  _$C.each(vs, function(v) {
    if (args.length > 1) {
      self2.setNode(v, value);
    } else {
      self2.setNode(v);
    }
  });
  return this;
};
Graph$a.prototype.setNode = function(v, value) {
  if (_$C.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }
  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};
Graph$a.prototype.node = function(v) {
  return this._nodes[v];
};
Graph$a.prototype.hasNode = function(v) {
  return _$C.has(this._nodes, v);
};
Graph$a.prototype.removeNode = function(v) {
  var self2 = this;
  if (_$C.has(this._nodes, v)) {
    var removeEdge = function(e) {
      self2.removeEdge(self2._edgeObjs[e]);
    };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _$C.each(this.children(v), function(child) {
        self2.setParent(child);
      });
      delete this._children[v];
    }
    _$C.each(_$C.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _$C.each(_$C.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};
Graph$a.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }
  if (_$C.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    parent += "";
    for (var ancestor = parent; !_$C.isUndefined(ancestor); ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent + " as parent of " + v + " would create a cycle");
      }
    }
    this.setNode(parent);
  }
  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};
Graph$a.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};
Graph$a.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};
Graph$a.prototype.children = function(v) {
  if (_$C.isUndefined(v)) {
    v = GRAPH_NODE;
  }
  if (this._isCompound) {
    var children = this._children[v];
    if (children) {
      return _$C.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};
Graph$a.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return _$C.keys(predsV);
  }
};
Graph$a.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return _$C.keys(sucsV);
  }
};
Graph$a.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return _$C.union(preds, this.successors(v));
  }
};
Graph$a.prototype.isLeaf = function(v) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};
Graph$a.prototype.filterNodes = function(filter) {
  var copy2 = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });
  copy2.setGraph(this.graph());
  var self2 = this;
  _$C.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy2.setNode(v, value);
    }
  });
  _$C.each(this._edgeObjs, function(e) {
    if (copy2.hasNode(e.v) && copy2.hasNode(e.w)) {
      copy2.setEdge(e, self2.edge(e));
    }
  });
  var parents2 = {};
  function findParent(v) {
    var parent = self2.parent(v);
    if (parent === void 0 || copy2.hasNode(parent)) {
      parents2[v] = parent;
      return parent;
    } else if (parent in parents2) {
      return parents2[parent];
    } else {
      return findParent(parent);
    }
  }
  if (this._isCompound) {
    _$C.each(copy2.nodes(), function(v) {
      copy2.setParent(v, findParent(v));
    });
  }
  return copy2;
};
Graph$a.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_$C.isFunction(newDefault)) {
    newDefault = _$C.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};
Graph$a.prototype.edgeCount = function() {
  return this._edgeCount;
};
Graph$a.prototype.edges = function() {
  return _$C.values(this._edgeObjs);
};
Graph$a.prototype.setPath = function(vs, value) {
  var self2 = this;
  var args = arguments;
  _$C.reduce(vs, function(v, w2) {
    if (args.length > 1) {
      self2.setEdge(v, w2, value);
    } else {
      self2.setEdge(v, w2);
    }
    return w2;
  });
  return this;
};
Graph$a.prototype.setEdge = function() {
  var v, w2, name2, value;
  var valueSpecified = false;
  var arg0 = arguments[0];
  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w2 = arg0.w;
    name2 = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w2 = arguments[1];
    name2 = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }
  v = "" + v;
  w2 = "" + w2;
  if (!_$C.isUndefined(name2)) {
    name2 = "" + name2;
  }
  var e = edgeArgsToId(this._isDirected, v, w2, name2);
  if (_$C.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }
  if (!_$C.isUndefined(name2) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }
  this.setNode(v);
  this.setNode(w2);
  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w2, name2);
  var edgeObj = edgeArgsToObj(this._isDirected, v, w2, name2);
  v = edgeObj.v;
  w2 = edgeObj.w;
  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w2], v);
  incrementOrInitEntry(this._sucs[v], w2);
  this._in[w2][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};
Graph$a.prototype.edge = function(v, w2, name2) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
  return this._edgeLabels[e];
};
Graph$a.prototype.hasEdge = function(v, w2, name2) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
  return _$C.has(this._edgeLabels, e);
};
Graph$a.prototype.removeEdge = function(v, w2, name2) {
  var e = arguments.length === 1 ? edgeObjToId(this._isDirected, arguments[0]) : edgeArgsToId(this._isDirected, v, w2, name2);
  var edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w2 = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w2], v);
    decrementOrRemoveEntry(this._sucs[v], w2);
    delete this._in[w2][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};
Graph$a.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges2 = _$C.values(inV);
    if (!u) {
      return edges2;
    }
    return _$C.filter(edges2, function(edge) {
      return edge.v === u;
    });
  }
};
Graph$a.prototype.outEdges = function(v, w2) {
  var outV = this._out[v];
  if (outV) {
    var edges2 = _$C.values(outV);
    if (!w2) {
      return edges2;
    }
    return _$C.filter(edges2, function(edge) {
      return edge.w === w2;
    });
  }
};
Graph$a.prototype.nodeEdges = function(v, w2) {
  var inEdges = this.inEdges(v, w2);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w2));
  }
};
function incrementOrInitEntry(map2, k2) {
  if (map2[k2]) {
    map2[k2]++;
  } else {
    map2[k2] = 1;
  }
}
function decrementOrRemoveEntry(map2, k2) {
  if (!--map2[k2]) {
    delete map2[k2];
  }
}
function edgeArgsToId(isDirected, v_, w_, name2) {
  var v = "" + v_;
  var w2 = "" + w_;
  if (!isDirected && v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  return v + EDGE_KEY_DELIM + w2 + EDGE_KEY_DELIM + (_$C.isUndefined(name2) ? DEFAULT_EDGE_NAME : name2);
}
function edgeArgsToObj(isDirected, v_, w_, name2) {
  var v = "" + v_;
  var w2 = "" + w_;
  if (!isDirected && v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  var edgeObj = { v, w: w2 };
  if (name2) {
    edgeObj.name = name2;
  }
  return edgeObj;
}
function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}
var version$5 = "2.1.8";
var lib$1 = {
  Graph: graph,
  version: version$5
};
var _$B = lodash_1$3;
var Graph$9 = graph;
var json$1 = {
  write,
  read
};
function write(g) {
  var json2 = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (!_$B.isUndefined(g.graph())) {
    json2.value = _$B.clone(g.graph());
  }
  return json2;
}
function writeNodes(g) {
  return _$B.map(g.nodes(), function(v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node2 = { v };
    if (!_$B.isUndefined(nodeValue)) {
      node2.value = nodeValue;
    }
    if (!_$B.isUndefined(parent)) {
      node2.parent = parent;
    }
    return node2;
  });
}
function writeEdges(g) {
  return _$B.map(g.edges(), function(e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!_$B.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!_$B.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}
function read(json2) {
  var g = new Graph$9(json2.options).setGraph(json2.value);
  _$B.each(json2.nodes, function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  _$B.each(json2.edges, function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}
var _$A = lodash_1$3;
var components_1 = components;
function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;
  function dfs2(v) {
    if (_$A.has(visited, v))
      return;
    visited[v] = true;
    cmpt.push(v);
    _$A.each(g.successors(v), dfs2);
    _$A.each(g.predecessors(v), dfs2);
  }
  _$A.each(g.nodes(), function(v) {
    cmpt = [];
    dfs2(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });
  return cmpts;
}
var _$z = lodash_1$3;
var priorityQueue = PriorityQueue$2;
function PriorityQueue$2() {
  this._arr = [];
  this._keyIndices = {};
}
PriorityQueue$2.prototype.size = function() {
  return this._arr.length;
};
PriorityQueue$2.prototype.keys = function() {
  return this._arr.map(function(x2) {
    return x2.key;
  });
};
PriorityQueue$2.prototype.has = function(key) {
  return _$z.has(this._keyIndices, key);
};
PriorityQueue$2.prototype.priority = function(key) {
  var index2 = this._keyIndices[key];
  if (index2 !== void 0) {
    return this._arr[index2].priority;
  }
};
PriorityQueue$2.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};
PriorityQueue$2.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!_$z.has(keyIndices, key)) {
    var arr = this._arr;
    var index2 = arr.length;
    keyIndices[key] = index2;
    arr.push({ key, priority });
    this._decrease(index2);
    return true;
  }
  return false;
};
PriorityQueue$2.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min2 = this._arr.pop();
  delete this._keyIndices[min2.key];
  this._heapify(0);
  return min2.key;
};
PriorityQueue$2.prototype.decrease = function(key, priority) {
  var index2 = this._keyIndices[key];
  if (priority > this._arr[index2].priority) {
    throw new Error("New priority is greater than current priority. Key: " + key + " Old: " + this._arr[index2].priority + " New: " + priority);
  }
  this._arr[index2].priority = priority;
  this._decrease(index2);
};
PriorityQueue$2.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};
PriorityQueue$2.prototype._decrease = function(index2) {
  var arr = this._arr;
  var priority = arr[index2].priority;
  var parent;
  while (index2 !== 0) {
    parent = index2 >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index2, parent);
    index2 = parent;
  }
};
PriorityQueue$2.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};
var _$y = lodash_1$3;
var PriorityQueue$1 = priorityQueue;
var dijkstra_1 = dijkstra$1;
var DEFAULT_WEIGHT_FUNC$1 = _$y.constant(1);
function dijkstra$1(g, source, weightFn, edgeFn) {
  return runDijkstra(
    g,
    String(source),
    weightFn || DEFAULT_WEIGHT_FUNC$1,
    edgeFn || function(v) {
      return g.outEdges(v);
    }
  );
}
function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue$1();
  var v, vEntry;
  var updateNeighbors = function(edge) {
    var w2 = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w2];
    var weight = weightFn(edge);
    var distance2 = vEntry.distance + weight;
    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. Bad edge: " + edge + " Weight: " + weight);
    }
    if (distance2 < wEntry.distance) {
      wEntry.distance = distance2;
      wEntry.predecessor = v;
      pq.decrease(w2, distance2);
    }
  };
  g.nodes().forEach(function(v2) {
    var distance2 = v2 === source ? 0 : Number.POSITIVE_INFINITY;
    results[v2] = { distance: distance2 };
    pq.add(v2, distance2);
  });
  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }
    edgeFn(v).forEach(updateNeighbors);
  }
  return results;
}
var dijkstra = dijkstra_1;
var _$x = lodash_1$3;
var dijkstraAll_1 = dijkstraAll;
function dijkstraAll(g, weightFunc, edgeFunc) {
  return _$x.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}
var _$w = lodash_1$3;
var tarjan_1 = tarjan$1;
function tarjan$1(g) {
  var index2 = 0;
  var stack2 = [];
  var visited = {};
  var results = [];
  function dfs2(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index2,
      index: index2++
    };
    stack2.push(v);
    g.successors(v).forEach(function(w3) {
      if (!_$w.has(visited, w3)) {
        dfs2(w3);
        entry.lowlink = Math.min(entry.lowlink, visited[w3].lowlink);
      } else if (visited[w3].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w3].index);
      }
    });
    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w2;
      do {
        w2 = stack2.pop();
        visited[w2].onStack = false;
        cmpt.push(w2);
      } while (v !== w2);
      results.push(cmpt);
    }
  }
  g.nodes().forEach(function(v) {
    if (!_$w.has(visited, v)) {
      dfs2(v);
    }
  });
  return results;
}
var _$v = lodash_1$3;
var tarjan = tarjan_1;
var findCycles_1 = findCycles;
function findCycles(g) {
  return _$v.filter(tarjan(g), function(cmpt) {
    return cmpt.length > 1 || cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]);
  });
}
var _$u = lodash_1$3;
var floydWarshall_1 = floydWarshall;
var DEFAULT_WEIGHT_FUNC = _$u.constant(1);
function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(
    g,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) {
      return g.outEdges(v);
    }
  );
}
function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();
  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w2) {
      if (v !== w2) {
        results[v][w2] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w2 = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w2] = { distance: d, predecessor: v };
    });
  });
  nodes.forEach(function(k2) {
    var rowK = results[k2];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k2];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });
  return results;
}
var _$t = lodash_1$3;
var topsort_1 = topsort$1;
topsort$1.CycleException = CycleException;
function topsort$1(g) {
  var visited = {};
  var stack2 = {};
  var results = [];
  function visit(node2) {
    if (_$t.has(stack2, node2)) {
      throw new CycleException();
    }
    if (!_$t.has(visited, node2)) {
      stack2[node2] = true;
      visited[node2] = true;
      _$t.each(g.predecessors(node2), visit);
      delete stack2[node2];
      results.push(node2);
    }
  }
  _$t.each(g.sinks(), visit);
  if (_$t.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }
  return results;
}
function CycleException() {
}
CycleException.prototype = new Error();
var topsort = topsort_1;
var isAcyclic_1 = isAcyclic;
function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}
var _$s = lodash_1$3;
var dfs_1 = dfs$3;
function dfs$3(g, vs, order2) {
  if (!_$s.isArray(vs)) {
    vs = [vs];
  }
  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);
  var acc = [];
  var visited = {};
  _$s.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }
    doDfs(g, v, order2 === "post", visited, navigation, acc);
  });
  return acc;
}
function doDfs(g, v, postorder2, visited, navigation, acc) {
  if (!_$s.has(visited, v)) {
    visited[v] = true;
    if (!postorder2) {
      acc.push(v);
    }
    _$s.each(navigation(v), function(w2) {
      doDfs(g, w2, postorder2, visited, navigation, acc);
    });
    if (postorder2) {
      acc.push(v);
    }
  }
}
var dfs$2 = dfs_1;
var postorder_1 = postorder$2;
function postorder$2(g, vs) {
  return dfs$2(g, vs, "post");
}
var dfs$1 = dfs_1;
var preorder_1 = preorder$1;
function preorder$1(g, vs) {
  return dfs$1(g, vs, "pre");
}
var _$r = lodash_1$3;
var Graph$8 = graph;
var PriorityQueue = priorityQueue;
var prim_1 = prim;
function prim(g, weightFunc) {
  var result = new Graph$8();
  var parents2 = {};
  var pq = new PriorityQueue();
  var v;
  function updateNeighbors(edge) {
    var w2 = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w2);
    if (pri !== void 0) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents2[w2] = v;
        pq.decrease(w2, edgeWeight);
      }
    }
  }
  if (g.nodeCount() === 0) {
    return result;
  }
  _$r.each(g.nodes(), function(v2) {
    pq.add(v2, Number.POSITIVE_INFINITY);
    result.setNode(v2);
  });
  pq.decrease(g.nodes()[0], 0);
  var init2 = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_$r.has(parents2, v)) {
      result.setEdge(v, parents2[v]);
    } else if (init2) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init2 = true;
    }
    g.nodeEdges(v).forEach(updateNeighbors);
  }
  return result;
}
var alg = {
  components: components_1,
  dijkstra: dijkstra_1,
  dijkstraAll: dijkstraAll_1,
  findCycles: findCycles_1,
  floydWarshall: floydWarshall_1,
  isAcyclic: isAcyclic_1,
  postorder: postorder_1,
  preorder: preorder_1,
  prim: prim_1,
  tarjan: tarjan_1,
  topsort: topsort_1
};
var lib = lib$1;
var graphlib$2 = {
  Graph: lib.Graph,
  json: json$1,
  alg,
  version: lib.version
};
var graphlib$1;
if (typeof commonjsRequire$1 === "function") {
  try {
    graphlib$1 = graphlib$2;
  } catch (e) {
  }
}
if (!graphlib$1) {
  graphlib$1 = window.graphlib;
}
var graphlib_1$1 = graphlib$1;
var cloneDeep_1;
var hasRequiredCloneDeep;
function requireCloneDeep() {
  if (hasRequiredCloneDeep)
    return cloneDeep_1;
  hasRequiredCloneDeep = 1;
  var baseClone = require_baseClone();
  var CLONE_DEEP_FLAG = 1, CLONE_SYMBOLS_FLAG = 4;
  function cloneDeep(value) {
    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  }
  cloneDeep_1 = cloneDeep;
  return cloneDeep_1;
}
var _isIterateeCall$1;
var hasRequired_isIterateeCall$1;
function require_isIterateeCall$1() {
  if (hasRequired_isIterateeCall$1)
    return _isIterateeCall$1;
  hasRequired_isIterateeCall$1 = 1;
  var eq2 = requireEq$1(), isArrayLike = requireIsArrayLike$1(), isIndex = require_isIndex$1(), isObject = requireIsObject$1();
  function isIterateeCall(value, index2, object2) {
    if (!isObject(object2)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
      return eq2(object2[index2], value);
    }
    return false;
  }
  _isIterateeCall$1 = isIterateeCall;
  return _isIterateeCall$1;
}
var defaults_1$1;
var hasRequiredDefaults$1;
function requireDefaults$1() {
  if (hasRequiredDefaults$1)
    return defaults_1$1;
  hasRequiredDefaults$1 = 1;
  var baseRest = require_baseRest$1(), eq2 = requireEq$1(), isIterateeCall = require_isIterateeCall$1(), keysIn = requireKeysIn$1();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var defaults = baseRest(function(object2, sources) {
    object2 = Object(object2);
    var index2 = -1;
    var length2 = sources.length;
    var guard = length2 > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length2 = 1;
    }
    while (++index2 < length2) {
      var source = sources[index2];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object2[key];
        if (value === void 0 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
          object2[key] = source[key];
        }
      }
    }
    return object2;
  });
  defaults_1$1 = defaults;
  return defaults_1$1;
}
var _createFind;
var hasRequired_createFind;
function require_createFind() {
  if (hasRequired_createFind)
    return _createFind;
  hasRequired_createFind = 1;
  var baseIteratee = require_baseIteratee(), isArrayLike = requireIsArrayLike$1(), keys2 = requireKeys$1();
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys2(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index2 = findIndexFunc(collection, predicate, fromIndex);
      return index2 > -1 ? iterable[iteratee ? collection[index2] : index2] : void 0;
    };
  }
  _createFind = createFind;
  return _createFind;
}
var _trimmedEndIndex$1;
var hasRequired_trimmedEndIndex$1;
function require_trimmedEndIndex$1() {
  if (hasRequired_trimmedEndIndex$1)
    return _trimmedEndIndex$1;
  hasRequired_trimmedEndIndex$1 = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex$1 = trimmedEndIndex;
  return _trimmedEndIndex$1;
}
var _baseTrim$1;
var hasRequired_baseTrim$1;
function require_baseTrim$1() {
  if (hasRequired_baseTrim$1)
    return _baseTrim$1;
  hasRequired_baseTrim$1 = 1;
  var trimmedEndIndex = require_trimmedEndIndex$1();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  _baseTrim$1 = baseTrim;
  return _baseTrim$1;
}
var toNumber_1$1;
var hasRequiredToNumber$1;
function requireToNumber$1() {
  if (hasRequiredToNumber$1)
    return toNumber_1$1;
  hasRequiredToNumber$1 = 1;
  var baseTrim = require_baseTrim$1(), isObject = requireIsObject$1(), isSymbol = requireIsSymbol$1();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1$1 = toNumber;
  return toNumber_1$1;
}
var toFinite_1$1;
var hasRequiredToFinite$1;
function requireToFinite$1() {
  if (hasRequiredToFinite$1)
    return toFinite_1$1;
  hasRequiredToFinite$1 = 1;
  var toNumber = requireToNumber$1();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1$1 = toFinite;
  return toFinite_1$1;
}
var toInteger_1;
var hasRequiredToInteger;
function requireToInteger() {
  if (hasRequiredToInteger)
    return toInteger_1;
  hasRequiredToInteger = 1;
  var toFinite = requireToFinite$1();
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  toInteger_1 = toInteger;
  return toInteger_1;
}
var findIndex_1;
var hasRequiredFindIndex;
function requireFindIndex() {
  if (hasRequiredFindIndex)
    return findIndex_1;
  hasRequiredFindIndex = 1;
  var baseFindIndex = require_baseFindIndex(), baseIteratee = require_baseIteratee(), toInteger = requireToInteger();
  var nativeMax = Math.max;
  function findIndex(array2, predicate, fromIndex) {
    var length2 = array2 == null ? 0 : array2.length;
    if (!length2) {
      return -1;
    }
    var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index2 < 0) {
      index2 = nativeMax(length2 + index2, 0);
    }
    return baseFindIndex(array2, baseIteratee(predicate, 3), index2);
  }
  findIndex_1 = findIndex;
  return findIndex_1;
}
var find_1;
var hasRequiredFind;
function requireFind() {
  if (hasRequiredFind)
    return find_1;
  hasRequiredFind = 1;
  var createFind = require_createFind(), findIndex = requireFindIndex();
  var find2 = createFind(findIndex);
  find_1 = find2;
  return find_1;
}
var flatten_1$1;
var hasRequiredFlatten$1;
function requireFlatten$1() {
  if (hasRequiredFlatten$1)
    return flatten_1$1;
  hasRequiredFlatten$1 = 1;
  var baseFlatten = require_baseFlatten$1();
  function flatten(array2) {
    var length2 = array2 == null ? 0 : array2.length;
    return length2 ? baseFlatten(array2, 1) : [];
  }
  flatten_1$1 = flatten;
  return flatten_1$1;
}
var forIn_1;
var hasRequiredForIn;
function requireForIn() {
  if (hasRequiredForIn)
    return forIn_1;
  hasRequiredForIn = 1;
  var baseFor = require_baseFor$1(), castFunction = require_castFunction$1(), keysIn = requireKeysIn$1();
  function forIn(object2, iteratee) {
    return object2 == null ? object2 : baseFor(object2, castFunction(iteratee), keysIn);
  }
  forIn_1 = forIn;
  return forIn_1;
}
var last_1;
var hasRequiredLast;
function requireLast() {
  if (hasRequiredLast)
    return last_1;
  hasRequiredLast = 1;
  function last(array2) {
    var length2 = array2 == null ? 0 : array2.length;
    return length2 ? array2[length2 - 1] : void 0;
  }
  last_1 = last;
  return last_1;
}
var mapValues_1;
var hasRequiredMapValues;
function requireMapValues() {
  if (hasRequiredMapValues)
    return mapValues_1;
  hasRequiredMapValues = 1;
  var baseAssignValue = require_baseAssignValue$1(), baseForOwn = require_baseForOwn$1(), baseIteratee = require_baseIteratee();
  function mapValues(object2, iteratee) {
    var result = {};
    iteratee = baseIteratee(iteratee, 3);
    baseForOwn(object2, function(value, key, object3) {
      baseAssignValue(result, key, iteratee(value, key, object3));
    });
    return result;
  }
  mapValues_1 = mapValues;
  return mapValues_1;
}
var _baseExtremum;
var hasRequired_baseExtremum;
function require_baseExtremum() {
  if (hasRequired_baseExtremum)
    return _baseExtremum;
  hasRequired_baseExtremum = 1;
  var isSymbol = requireIsSymbol$1();
  function baseExtremum(array2, iteratee, comparator) {
    var index2 = -1, length2 = array2.length;
    while (++index2 < length2) {
      var value = array2[index2], current = iteratee(value);
      if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
        var computed = current, result = value;
      }
    }
    return result;
  }
  _baseExtremum = baseExtremum;
  return _baseExtremum;
}
var _baseGt;
var hasRequired_baseGt;
function require_baseGt() {
  if (hasRequired_baseGt)
    return _baseGt;
  hasRequired_baseGt = 1;
  function baseGt(value, other) {
    return value > other;
  }
  _baseGt = baseGt;
  return _baseGt;
}
var max_1;
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax)
    return max_1;
  hasRequiredMax = 1;
  var baseExtremum = require_baseExtremum(), baseGt = require_baseGt(), identity2 = requireIdentity$1();
  function max2(array2) {
    return array2 && array2.length ? baseExtremum(array2, identity2, baseGt) : void 0;
  }
  max_1 = max2;
  return max_1;
}
var _assignMergeValue;
var hasRequired_assignMergeValue;
function require_assignMergeValue() {
  if (hasRequired_assignMergeValue)
    return _assignMergeValue;
  hasRequired_assignMergeValue = 1;
  var baseAssignValue = require_baseAssignValue$1(), eq2 = requireEq$1();
  function assignMergeValue(object2, key, value) {
    if (value !== void 0 && !eq2(object2[key], value) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignMergeValue = assignMergeValue;
  return _assignMergeValue;
}
var isPlainObject_1$1;
var hasRequiredIsPlainObject$1;
function requireIsPlainObject$1() {
  if (hasRequiredIsPlainObject$1)
    return isPlainObject_1$1;
  hasRequiredIsPlainObject$1 = 1;
  var baseGetTag = require_baseGetTag$1(), getPrototype = require_getPrototype$1(), isObjectLike = requireIsObjectLike$1();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto2 = getPrototype(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1$1 = isPlainObject;
  return isPlainObject_1$1;
}
var _safeGet;
var hasRequired_safeGet;
function require_safeGet() {
  if (hasRequired_safeGet)
    return _safeGet;
  hasRequired_safeGet = 1;
  function safeGet(object2, key) {
    if (key === "constructor" && typeof object2[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object2[key];
  }
  _safeGet = safeGet;
  return _safeGet;
}
var toPlainObject_1;
var hasRequiredToPlainObject;
function requireToPlainObject() {
  if (hasRequiredToPlainObject)
    return toPlainObject_1;
  hasRequiredToPlainObject = 1;
  var copyObject = require_copyObject(), keysIn = requireKeysIn$1();
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  toPlainObject_1 = toPlainObject;
  return toPlainObject_1;
}
var _baseMergeDeep;
var hasRequired_baseMergeDeep;
function require_baseMergeDeep() {
  if (hasRequired_baseMergeDeep)
    return _baseMergeDeep;
  hasRequired_baseMergeDeep = 1;
  var assignMergeValue = require_assignMergeValue(), cloneBuffer = require_cloneBuffer(), cloneTypedArray = require_cloneTypedArray(), copyArray = require_copyArray(), initCloneObject = require_initCloneObject(), isArguments = requireIsArguments$1(), isArray = requireIsArray$1(), isArrayLikeObject = requireIsArrayLikeObject(), isBuffer2 = requireIsBuffer$1(), isFunction = requireIsFunction$1(), isObject = requireIsObject$1(), isPlainObject = requireIsPlainObject$1(), isTypedArray = requireIsTypedArray$1(), safeGet = require_safeGet(), toPlainObject = requireToPlainObject();
  function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack2) {
    var objValue = safeGet(object2, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
    if (stacked) {
      assignMergeValue(object2, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack2) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack2.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
      stack2["delete"](srcValue);
    }
    assignMergeValue(object2, key, newValue);
  }
  _baseMergeDeep = baseMergeDeep;
  return _baseMergeDeep;
}
var _baseMerge;
var hasRequired_baseMerge;
function require_baseMerge() {
  if (hasRequired_baseMerge)
    return _baseMerge;
  hasRequired_baseMerge = 1;
  var Stack = require_Stack(), assignMergeValue = require_assignMergeValue(), baseFor = require_baseFor$1(), baseMergeDeep = require_baseMergeDeep(), isObject = requireIsObject$1(), keysIn = requireKeysIn$1(), safeGet = require_safeGet();
  function baseMerge(object2, source, srcIndex, customizer, stack2) {
    if (object2 === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack2 || (stack2 = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack2);
      } else {
        var newValue = customizer ? customizer(safeGet(object2, key), srcValue, key + "", object2, source, stack2) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object2, key, newValue);
      }
    }, keysIn);
  }
  _baseMerge = baseMerge;
  return _baseMerge;
}
var _createAssigner;
var hasRequired_createAssigner;
function require_createAssigner() {
  if (hasRequired_createAssigner)
    return _createAssigner;
  hasRequired_createAssigner = 1;
  var baseRest = require_baseRest$1(), isIterateeCall = require_isIterateeCall$1();
  function createAssigner(assigner) {
    return baseRest(function(object2, sources) {
      var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : void 0, guard = length2 > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length2 < 3 ? void 0 : customizer;
        length2 = 1;
      }
      object2 = Object(object2);
      while (++index2 < length2) {
        var source = sources[index2];
        if (source) {
          assigner(object2, source, index2, customizer);
        }
      }
      return object2;
    });
  }
  _createAssigner = createAssigner;
  return _createAssigner;
}
var merge_1;
var hasRequiredMerge;
function requireMerge() {
  if (hasRequiredMerge)
    return merge_1;
  hasRequiredMerge = 1;
  var baseMerge = require_baseMerge(), createAssigner = require_createAssigner();
  var merge2 = createAssigner(function(object2, source, srcIndex) {
    baseMerge(object2, source, srcIndex);
  });
  merge_1 = merge2;
  return merge_1;
}
var _baseLt;
var hasRequired_baseLt;
function require_baseLt() {
  if (hasRequired_baseLt)
    return _baseLt;
  hasRequired_baseLt = 1;
  function baseLt(value, other) {
    return value < other;
  }
  _baseLt = baseLt;
  return _baseLt;
}
var min_1;
var hasRequiredMin;
function requireMin() {
  if (hasRequiredMin)
    return min_1;
  hasRequiredMin = 1;
  var baseExtremum = require_baseExtremum(), baseLt = require_baseLt(), identity2 = requireIdentity$1();
  function min2(array2) {
    return array2 && array2.length ? baseExtremum(array2, identity2, baseLt) : void 0;
  }
  min_1 = min2;
  return min_1;
}
var minBy_1;
var hasRequiredMinBy;
function requireMinBy() {
  if (hasRequiredMinBy)
    return minBy_1;
  hasRequiredMinBy = 1;
  var baseExtremum = require_baseExtremum(), baseIteratee = require_baseIteratee(), baseLt = require_baseLt();
  function minBy(array2, iteratee) {
    return array2 && array2.length ? baseExtremum(array2, baseIteratee(iteratee, 2), baseLt) : void 0;
  }
  minBy_1 = minBy;
  return minBy_1;
}
var now_1;
var hasRequiredNow;
function requireNow() {
  if (hasRequiredNow)
    return now_1;
  hasRequiredNow = 1;
  var root2 = require_root$1();
  var now2 = function() {
    return root2.Date.now();
  };
  now_1 = now2;
  return now_1;
}
var _baseSet$1;
var hasRequired_baseSet$1;
function require_baseSet$1() {
  if (hasRequired_baseSet$1)
    return _baseSet$1;
  hasRequired_baseSet$1 = 1;
  var assignValue = require_assignValue$1(), castPath = require_castPath$1(), isIndex = require_isIndex$1(), isObject = requireIsObject$1(), toKey = require_toKey$1();
  function baseSet(object2, path2, value, customizer) {
    if (!isObject(object2)) {
      return object2;
    }
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
    while (nested != null && ++index2 < length2) {
      var key = toKey(path2[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object2;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object2;
  }
  _baseSet$1 = baseSet;
  return _baseSet$1;
}
var _basePickBy$1;
var hasRequired_basePickBy$1;
function require_basePickBy$1() {
  if (hasRequired_basePickBy$1)
    return _basePickBy$1;
  hasRequired_basePickBy$1 = 1;
  var baseGet = require_baseGet$1(), baseSet = require_baseSet$1(), castPath = require_castPath$1();
  function basePickBy(object2, paths, predicate) {
    var index2 = -1, length2 = paths.length, result = {};
    while (++index2 < length2) {
      var path2 = paths[index2], value = baseGet(object2, path2);
      if (predicate(value, path2)) {
        baseSet(result, castPath(path2, object2), value);
      }
    }
    return result;
  }
  _basePickBy$1 = basePickBy;
  return _basePickBy$1;
}
var _basePick$1;
var hasRequired_basePick$1;
function require_basePick$1() {
  if (hasRequired_basePick$1)
    return _basePick$1;
  hasRequired_basePick$1 = 1;
  var basePickBy = require_basePickBy$1(), hasIn = requireHasIn$1();
  function basePick(object2, paths) {
    return basePickBy(object2, paths, function(value, path2) {
      return hasIn(object2, path2);
    });
  }
  _basePick$1 = basePick;
  return _basePick$1;
}
var _flatRest$1;
var hasRequired_flatRest$1;
function require_flatRest$1() {
  if (hasRequired_flatRest$1)
    return _flatRest$1;
  hasRequired_flatRest$1 = 1;
  var flatten = requireFlatten$1(), overRest = require_overRest$1(), setToString = require_setToString$1();
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten), func + "");
  }
  _flatRest$1 = flatRest;
  return _flatRest$1;
}
var pick_1$1;
var hasRequiredPick$1;
function requirePick$1() {
  if (hasRequiredPick$1)
    return pick_1$1;
  hasRequiredPick$1 = 1;
  var basePick = require_basePick$1(), flatRest = require_flatRest$1();
  var pick = flatRest(function(object2, paths) {
    return object2 == null ? {} : basePick(object2, paths);
  });
  pick_1$1 = pick;
  return pick_1$1;
}
var _baseRange$1;
var hasRequired_baseRange$1;
function require_baseRange$1() {
  if (hasRequired_baseRange$1)
    return _baseRange$1;
  hasRequired_baseRange$1 = 1;
  var nativeCeil = Math.ceil, nativeMax = Math.max;
  function baseRange(start2, end2, step2, fromRight) {
    var index2 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step2 || 1)), 0), result = Array(length2);
    while (length2--) {
      result[fromRight ? length2 : ++index2] = start2;
      start2 += step2;
    }
    return result;
  }
  _baseRange$1 = baseRange;
  return _baseRange$1;
}
var _createRange$1;
var hasRequired_createRange$1;
function require_createRange$1() {
  if (hasRequired_createRange$1)
    return _createRange$1;
  hasRequired_createRange$1 = 1;
  var baseRange = require_baseRange$1(), isIterateeCall = require_isIterateeCall$1(), toFinite = requireToFinite$1();
  function createRange(fromRight) {
    return function(start2, end2, step2) {
      if (step2 && typeof step2 != "number" && isIterateeCall(start2, end2, step2)) {
        end2 = step2 = void 0;
      }
      start2 = toFinite(start2);
      if (end2 === void 0) {
        end2 = start2;
        start2 = 0;
      } else {
        end2 = toFinite(end2);
      }
      step2 = step2 === void 0 ? start2 < end2 ? 1 : -1 : toFinite(step2);
      return baseRange(start2, end2, step2, fromRight);
    };
  }
  _createRange$1 = createRange;
  return _createRange$1;
}
var range_1$1;
var hasRequiredRange$1;
function requireRange$1() {
  if (hasRequiredRange$1)
    return range_1$1;
  hasRequiredRange$1 = 1;
  var createRange = require_createRange$1();
  var range2 = createRange();
  range_1$1 = range2;
  return range_1$1;
}
var _baseSortBy;
var hasRequired_baseSortBy;
function require_baseSortBy() {
  if (hasRequired_baseSortBy)
    return _baseSortBy;
  hasRequired_baseSortBy = 1;
  function baseSortBy(array2, comparer) {
    var length2 = array2.length;
    array2.sort(comparer);
    while (length2--) {
      array2[length2] = array2[length2].value;
    }
    return array2;
  }
  _baseSortBy = baseSortBy;
  return _baseSortBy;
}
var _compareAscending;
var hasRequired_compareAscending;
function require_compareAscending() {
  if (hasRequired_compareAscending)
    return _compareAscending;
  hasRequired_compareAscending = 1;
  var isSymbol = requireIsSymbol$1();
  function compareAscending(value, other) {
    if (value !== other) {
      var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
      var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
      if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
        return 1;
      }
      if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
        return -1;
      }
    }
    return 0;
  }
  _compareAscending = compareAscending;
  return _compareAscending;
}
var _compareMultiple;
var hasRequired_compareMultiple;
function require_compareMultiple() {
  if (hasRequired_compareMultiple)
    return _compareMultiple;
  hasRequired_compareMultiple = 1;
  var compareAscending = require_compareAscending();
  function compareMultiple(object2, other, orders) {
    var index2 = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
    while (++index2 < length2) {
      var result = compareAscending(objCriteria[index2], othCriteria[index2]);
      if (result) {
        if (index2 >= ordersLength) {
          return result;
        }
        var order2 = orders[index2];
        return result * (order2 == "desc" ? -1 : 1);
      }
    }
    return object2.index - other.index;
  }
  _compareMultiple = compareMultiple;
  return _compareMultiple;
}
var _baseOrderBy;
var hasRequired_baseOrderBy;
function require_baseOrderBy() {
  if (hasRequired_baseOrderBy)
    return _baseOrderBy;
  hasRequired_baseOrderBy = 1;
  var arrayMap = require_arrayMap$1(), baseGet = require_baseGet$1(), baseIteratee = require_baseIteratee(), baseMap = require_baseMap(), baseSortBy = require_baseSortBy(), baseUnary = require_baseUnary$1(), compareMultiple = require_compareMultiple(), identity2 = requireIdentity$1(), isArray = requireIsArray$1();
  function baseOrderBy(collection, iteratees, orders) {
    if (iteratees.length) {
      iteratees = arrayMap(iteratees, function(iteratee) {
        if (isArray(iteratee)) {
          return function(value) {
            return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
          };
        }
        return iteratee;
      });
    } else {
      iteratees = [identity2];
    }
    var index2 = -1;
    iteratees = arrayMap(iteratees, baseUnary(baseIteratee));
    var result = baseMap(collection, function(value, key, collection2) {
      var criteria = arrayMap(iteratees, function(iteratee) {
        return iteratee(value);
      });
      return { "criteria": criteria, "index": ++index2, "value": value };
    });
    return baseSortBy(result, function(object2, other) {
      return compareMultiple(object2, other, orders);
    });
  }
  _baseOrderBy = baseOrderBy;
  return _baseOrderBy;
}
var sortBy_1;
var hasRequiredSortBy;
function requireSortBy() {
  if (hasRequiredSortBy)
    return sortBy_1;
  hasRequiredSortBy = 1;
  var baseFlatten = require_baseFlatten$1(), baseOrderBy = require_baseOrderBy(), baseRest = require_baseRest$1(), isIterateeCall = require_isIterateeCall$1();
  var sortBy = baseRest(function(collection, iteratees) {
    if (collection == null) {
      return [];
    }
    var length2 = iteratees.length;
    if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
      iteratees = [];
    } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
      iteratees = [iteratees[0]];
    }
    return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  });
  sortBy_1 = sortBy;
  return sortBy_1;
}
var uniqueId_1$1;
var hasRequiredUniqueId$1;
function requireUniqueId$1() {
  if (hasRequiredUniqueId$1)
    return uniqueId_1$1;
  hasRequiredUniqueId$1 = 1;
  var toString = requireToString$1();
  var idCounter = 0;
  function uniqueId(prefix2) {
    var id2 = ++idCounter;
    return toString(prefix2) + id2;
  }
  uniqueId_1$1 = uniqueId;
  return uniqueId_1$1;
}
var _baseZipObject;
var hasRequired_baseZipObject;
function require_baseZipObject() {
  if (hasRequired_baseZipObject)
    return _baseZipObject;
  hasRequired_baseZipObject = 1;
  function baseZipObject(props, values2, assignFunc) {
    var index2 = -1, length2 = props.length, valsLength = values2.length, result = {};
    while (++index2 < length2) {
      var value = index2 < valsLength ? values2[index2] : void 0;
      assignFunc(result, props[index2], value);
    }
    return result;
  }
  _baseZipObject = baseZipObject;
  return _baseZipObject;
}
var zipObject_1;
var hasRequiredZipObject;
function requireZipObject() {
  if (hasRequiredZipObject)
    return zipObject_1;
  hasRequiredZipObject = 1;
  var assignValue = require_assignValue$1(), baseZipObject = require_baseZipObject();
  function zipObject(props, values2) {
    return baseZipObject(props || [], values2 || [], assignValue);
  }
  zipObject_1 = zipObject;
  return zipObject_1;
}
var lodash$2;
if (typeof commonjsRequire$1 === "function") {
  try {
    lodash$2 = {
      cloneDeep: requireCloneDeep(),
      constant: requireConstant$1(),
      defaults: requireDefaults$1(),
      each: requireEach$1(),
      filter: requireFilter(),
      find: requireFind(),
      flatten: requireFlatten$1(),
      forEach: requireForEach$1(),
      forIn: requireForIn(),
      has: requireHas$1(),
      isUndefined: requireIsUndefined(),
      last: requireLast(),
      map: requireMap(),
      mapValues: requireMapValues(),
      max: requireMax(),
      merge: requireMerge(),
      min: requireMin(),
      minBy: requireMinBy(),
      now: requireNow(),
      pick: requirePick$1(),
      range: requireRange$1(),
      reduce: requireReduce(),
      sortBy: requireSortBy(),
      uniqueId: requireUniqueId$1(),
      values: requireValues(),
      zipObject: requireZipObject()
    };
  } catch (e) {
  }
}
if (!lodash$2) {
  lodash$2 = window._;
}
var lodash_1$2 = lodash$2;
var list = List$1;
function List$1() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}
List$1.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};
List$1.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};
List$1.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};
function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}
function filterOutLinks(k2, v) {
  if (k2 !== "_next" && k2 !== "_prev") {
    return v;
  }
}
var _$q = lodash_1$2;
var Graph$7 = graphlib_1$1.Graph;
var List = list;
var greedyFas = greedyFAS$1;
var DEFAULT_WEIGHT_FN = _$q.constant(1);
function greedyFAS$1(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
  return _$q.flatten(_$q.map(results, function(e) {
    return g.outEdges(e.v, e.w);
  }), true);
}
function doGreedyFAS(g, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];
  var entry;
  while (g.nodeCount()) {
    while (entry = sinks.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    while (entry = sources.dequeue()) {
      removeNode(g, buckets, zeroIdx, entry);
    }
    if (g.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }
  return results;
}
function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : void 0;
  _$q.forEach(g.inEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var uEntry = g.node(edge.v);
    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }
    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });
  _$q.forEach(g.outEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var w2 = edge.w;
    var wEntry = g.node(w2);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });
  g.removeNode(entry.v);
  return results;
}
function buildState(g, weightFn) {
  var fasGraph = new Graph$7();
  var maxIn = 0;
  var maxOut = 0;
  _$q.forEach(g.nodes(), function(v) {
    fasGraph.setNode(v, { v, "in": 0, out: 0 });
  });
  _$q.forEach(g.edges(), function(e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn = Math.max(maxIn, fasGraph.node(e.w)["in"] += weight);
  });
  var buckets = _$q.range(maxOut + maxIn + 3).map(function() {
    return new List();
  });
  var zeroIdx = maxIn + 1;
  _$q.forEach(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });
  return { graph: fasGraph, buckets, zeroIdx };
}
function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}
var _$p = lodash_1$2;
var greedyFAS = greedyFas;
var acyclic$1 = {
  run: run$2,
  undo: undo$2
};
function run$2(g) {
  var fas = g.graph().acyclicer === "greedy" ? greedyFAS(g, weightFn(g)) : dfsFAS(g);
  _$p.forEach(fas, function(e) {
    var label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, _$p.uniqueId("rev"));
  });
  function weightFn(g2) {
    return function(e) {
      return g2.edge(e).weight;
    };
  }
}
function dfsFAS(g) {
  var fas = [];
  var stack2 = {};
  var visited = {};
  function dfs2(v) {
    if (_$p.has(visited, v)) {
      return;
    }
    visited[v] = true;
    stack2[v] = true;
    _$p.forEach(g.outEdges(v), function(e) {
      if (_$p.has(stack2, e.w)) {
        fas.push(e);
      } else {
        dfs2(e.w);
      }
    });
    delete stack2[v];
  }
  _$p.forEach(g.nodes(), dfs2);
  return fas;
}
function undo$2(g) {
  _$p.forEach(g.edges(), function(e) {
    var label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);
      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}
var _$o = lodash_1$2;
var Graph$6 = graphlib_1$1.Graph;
var util$d = {
  addDummyNode,
  simplify: simplify$1,
  asNonCompoundGraph,
  successorWeights,
  predecessorWeights,
  intersectRect: intersectRect$2,
  buildLayerMatrix,
  normalizeRanks: normalizeRanks$1,
  removeEmptyRanks: removeEmptyRanks$1,
  addBorderNode: addBorderNode$1,
  maxRank,
  partition: partition$1,
  time: time$1,
  notime
};
function addDummyNode(g, type2, attrs, name2) {
  var v;
  do {
    v = _$o.uniqueId(name2);
  } while (g.hasNode(v));
  attrs.dummy = type2;
  g.setNode(v, attrs);
  return v;
}
function simplify$1(g) {
  var simplified = new Graph$6().setGraph(g.graph());
  _$o.forEach(g.nodes(), function(v) {
    simplified.setNode(v, g.node(v));
  });
  _$o.forEach(g.edges(), function(e) {
    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    var label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}
function asNonCompoundGraph(g) {
  var simplified = new Graph$6({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  _$o.forEach(g.nodes(), function(v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  _$o.forEach(g.edges(), function(e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}
function successorWeights(g) {
  var weightMap = _$o.map(g.nodes(), function(v) {
    var sucs = {};
    _$o.forEach(g.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return _$o.zipObject(g.nodes(), weightMap);
}
function predecessorWeights(g) {
  var weightMap = _$o.map(g.nodes(), function(v) {
    var preds = {};
    _$o.forEach(g.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return _$o.zipObject(g.nodes(), weightMap);
}
function intersectRect$2(rect2, point2) {
  var x2 = rect2.x;
  var y2 = rect2.y;
  var dx = point2.x - x2;
  var dy = point2.y - y2;
  var w2 = rect2.width / 2;
  var h = rect2.height / 2;
  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }
  var sx, sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h) {
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
}
function buildLayerMatrix(g) {
  var layering = _$o.map(_$o.range(maxRank(g) + 1), function() {
    return [];
  });
  _$o.forEach(g.nodes(), function(v) {
    var node2 = g.node(v);
    var rank2 = node2.rank;
    if (!_$o.isUndefined(rank2)) {
      layering[rank2][node2.order] = v;
    }
  });
  return layering;
}
function normalizeRanks$1(g) {
  var min2 = _$o.min(_$o.map(g.nodes(), function(v) {
    return g.node(v).rank;
  }));
  _$o.forEach(g.nodes(), function(v) {
    var node2 = g.node(v);
    if (_$o.has(node2, "rank")) {
      node2.rank -= min2;
    }
  });
}
function removeEmptyRanks$1(g) {
  var offset = _$o.min(_$o.map(g.nodes(), function(v) {
    return g.node(v).rank;
  }));
  var layers = [];
  _$o.forEach(g.nodes(), function(v) {
    var rank2 = g.node(v).rank - offset;
    if (!layers[rank2]) {
      layers[rank2] = [];
    }
    layers[rank2].push(v);
  });
  var delta = 0;
  var nodeRankFactor = g.graph().nodeRankFactor;
  _$o.forEach(layers, function(vs, i) {
    if (_$o.isUndefined(vs) && i % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      _$o.forEach(vs, function(v) {
        g.node(v).rank += delta;
      });
    }
  });
}
function addBorderNode$1(g, prefix2, rank2, order2) {
  var node2 = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node2.rank = rank2;
    node2.order = order2;
  }
  return addDummyNode(g, "border", node2, prefix2);
}
function maxRank(g) {
  return _$o.max(_$o.map(g.nodes(), function(v) {
    var rank2 = g.node(v).rank;
    if (!_$o.isUndefined(rank2)) {
      return rank2;
    }
  }));
}
function partition$1(collection, fn) {
  var result = { lhs: [], rhs: [] };
  _$o.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}
function time$1(name2, fn) {
  var start2 = _$o.now();
  try {
    return fn();
  } finally {
    console.log(name2 + " time: " + (_$o.now() - start2) + "ms");
  }
}
function notime(name2, fn) {
  return fn();
}
var _$n = lodash_1$2;
var util$c = util$d;
var normalize$2 = {
  run: run$1,
  undo: undo$1
};
function run$1(g) {
  g.graph().dummyChains = [];
  _$n.forEach(g.edges(), function(edge) {
    normalizeEdge(g, edge);
  });
}
function normalizeEdge(g, e) {
  var v = e.v;
  var vRank = g.node(v).rank;
  var w2 = e.w;
  var wRank = g.node(w2).rank;
  var name2 = e.name;
  var edgeLabel = g.edge(e);
  var labelRank = edgeLabel.labelRank;
  if (wRank === vRank + 1)
    return;
  g.removeEdge(e);
  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0,
      height: 0,
      edgeLabel,
      edgeObj: e,
      rank: vRank
    };
    dummy = util$c.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name2);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }
  g.setEdge(v, w2, { weight: edgeLabel.weight }, name2);
}
function undo$1(g) {
  _$n.forEach(g.graph().dummyChains, function(v) {
    var node2 = g.node(v);
    var origLabel = node2.edgeLabel;
    var w2;
    g.setEdge(node2.edgeObj, origLabel);
    while (node2.dummy) {
      w2 = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node2.x, y: node2.y });
      if (node2.dummy === "edge-label") {
        origLabel.x = node2.x;
        origLabel.y = node2.y;
        origLabel.width = node2.width;
        origLabel.height = node2.height;
      }
      v = w2;
      node2 = g.node(v);
    }
  });
}
var _$m = lodash_1$2;
var util$b = {
  longestPath: longestPath$1,
  slack: slack$2
};
function longestPath$1(g) {
  var visited = {};
  function dfs2(v) {
    var label = g.node(v);
    if (_$m.has(visited, v)) {
      return label.rank;
    }
    visited[v] = true;
    var rank2 = _$m.min(_$m.map(g.outEdges(v), function(e) {
      return dfs2(e.w) - g.edge(e).minlen;
    }));
    if (rank2 === Number.POSITIVE_INFINITY || rank2 === void 0 || rank2 === null) {
      rank2 = 0;
    }
    return label.rank = rank2;
  }
  _$m.forEach(g.sources(), dfs2);
}
function slack$2(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}
var _$l = lodash_1$2;
var Graph$5 = graphlib_1$1.Graph;
var slack$1 = util$b.slack;
var feasibleTree_1 = feasibleTree$2;
function feasibleTree$2(g) {
  var t = new Graph$5({ directed: false });
  var start2 = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start2, {});
  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack$1(g, edge) : -slack$1(g, edge);
    shiftRanks(t, g, delta);
  }
  return t;
}
function tightTree(t, g) {
  function dfs2(v) {
    _$l.forEach(g.nodeEdges(v), function(e) {
      var edgeV = e.v, w2 = v === edgeV ? e.w : edgeV;
      if (!t.hasNode(w2) && !slack$1(g, e)) {
        t.setNode(w2, {});
        t.setEdge(v, w2, {});
        dfs2(w2);
      }
    });
  }
  _$l.forEach(t.nodes(), dfs2);
  return t.nodeCount();
}
function findMinSlackEdge(t, g) {
  return _$l.minBy(g.edges(), function(e) {
    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
      return slack$1(g, e);
    }
  });
}
function shiftRanks(t, g, delta) {
  _$l.forEach(t.nodes(), function(v) {
    g.node(v).rank += delta;
  });
}
var _$k = lodash_1$2;
var feasibleTree$1 = feasibleTree_1;
var slack = util$b.slack;
var initRank = util$b.longestPath;
var preorder = graphlib_1$1.alg.preorder;
var postorder$1 = graphlib_1$1.alg.postorder;
var simplify = util$d.simplify;
var networkSimplex_1 = networkSimplex$1;
networkSimplex$1.initLowLimValues = initLowLimValues;
networkSimplex$1.initCutValues = initCutValues;
networkSimplex$1.calcCutValue = calcCutValue;
networkSimplex$1.leaveEdge = leaveEdge;
networkSimplex$1.enterEdge = enterEdge;
networkSimplex$1.exchangeEdges = exchangeEdges;
function networkSimplex$1(g) {
  g = simplify(g);
  initRank(g);
  var t = feasibleTree$1(g);
  initLowLimValues(t);
  initCutValues(t, g);
  var e, f;
  while (e = leaveEdge(t)) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}
function initCutValues(t, g) {
  var vs = postorder$1(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  _$k.forEach(vs, function(v) {
    assignCutValue(t, g, v);
  });
}
function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  var childIsTail = true;
  var graphEdge = g.edge(child, parent);
  var cutValue = 0;
  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }
  cutValue = graphEdge.weight;
  _$k.forEach(g.nodeEdges(child), function(e) {
    var isOutEdge = e.v === child, other = isOutEdge ? e.w : e.v;
    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail, otherWeight = g.edge(e).weight;
      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });
  return cutValue;
}
function initLowLimValues(tree2, root2) {
  if (arguments.length < 2) {
    root2 = tree2.nodes()[0];
  }
  dfsAssignLowLim(tree2, {}, 1, root2);
}
function dfsAssignLowLim(tree2, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree2.node(v);
  visited[v] = true;
  _$k.forEach(tree2.neighbors(v), function(w2) {
    if (!_$k.has(visited, w2)) {
      nextLim = dfsAssignLowLim(tree2, visited, nextLim, w2, v);
    }
  });
  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    delete label.parent;
  }
  return nextLim;
}
function leaveEdge(tree2) {
  return _$k.find(tree2.edges(), function(e) {
    return tree2.edge(e).cutvalue < 0;
  });
}
function enterEdge(t, g, edge) {
  var v = edge.v;
  var w2 = edge.w;
  if (!g.hasEdge(v, w2)) {
    v = edge.w;
    w2 = edge.v;
  }
  var vLabel = t.node(v);
  var wLabel = t.node(w2);
  var tailLabel = vLabel;
  var flip = false;
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }
  var candidates = _$k.filter(g.edges(), function(edge2) {
    return flip === isDescendant(t, t.node(edge2.v), tailLabel) && flip !== isDescendant(t, t.node(edge2.w), tailLabel);
  });
  return _$k.minBy(candidates, function(edge2) {
    return slack(g, edge2);
  });
}
function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w2 = e.w;
  t.removeEdge(v, w2);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}
function updateRanks(t, g) {
  var root2 = _$k.find(t.nodes(), function(v) {
    return !g.node(v).parent;
  });
  var vs = preorder(t, root2);
  vs = vs.slice(1);
  _$k.forEach(vs, function(v) {
    var parent = t.node(v).parent, edge = g.edge(v, parent), flipped = false;
    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }
    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}
function isTreeEdge(tree2, u, v) {
  return tree2.hasEdge(u, v);
}
function isDescendant(tree2, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}
var rankUtil = util$b;
var longestPath = rankUtil.longestPath;
var feasibleTree = feasibleTree_1;
var networkSimplex = networkSimplex_1;
var rank_1 = rank$1;
function rank$1(g) {
  switch (g.graph().ranker) {
    case "network-simplex":
      networkSimplexRanker(g);
      break;
    case "tight-tree":
      tightTreeRanker(g);
      break;
    case "longest-path":
      longestPathRanker(g);
      break;
    default:
      networkSimplexRanker(g);
  }
}
var longestPathRanker = longestPath;
function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}
function networkSimplexRanker(g) {
  networkSimplex(g);
}
var _$j = lodash_1$2;
var parentDummyChains_1 = parentDummyChains$1;
function parentDummyChains$1(g) {
  var postorderNums = postorder(g);
  _$j.forEach(g.graph().dummyChains, function(v) {
    var node2 = g.node(v);
    var edgeObj = node2.edgeObj;
    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    var path2 = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path2[pathIdx];
    var ascending2 = true;
    while (v !== edgeObj.w) {
      node2 = g.node(v);
      if (ascending2) {
        while ((pathV = path2[pathIdx]) !== lca && g.node(pathV).maxRank < node2.rank) {
          pathIdx++;
        }
        if (pathV === lca) {
          ascending2 = false;
        }
      }
      if (!ascending2) {
        while (pathIdx < path2.length - 1 && g.node(pathV = path2[pathIdx + 1]).minRank <= node2.rank) {
          pathIdx++;
        }
        pathV = path2[pathIdx];
      }
      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}
function findPath(g, postorderNums, v, w2) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w2].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w2].lim);
  var parent;
  var lca;
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent && (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;
  parent = w2;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }
  return { path: vPath.concat(wPath.reverse()), lca };
}
function postorder(g) {
  var result = {};
  var lim = 0;
  function dfs2(v) {
    var low = lim;
    _$j.forEach(g.children(v), dfs2);
    result[v] = { low, lim: lim++ };
  }
  _$j.forEach(g.children(), dfs2);
  return result;
}
var _$i = lodash_1$2;
var util$a = util$d;
var nestingGraph$1 = {
  run,
  cleanup
};
function run(g) {
  var root2 = util$a.addDummyNode(g, "root", {}, "_root");
  var depths = treeDepths(g);
  var height2 = _$i.max(_$i.values(depths)) - 1;
  var nodeSep = 2 * height2 + 1;
  g.graph().nestingRoot = root2;
  _$i.forEach(g.edges(), function(e) {
    g.edge(e).minlen *= nodeSep;
  });
  var weight = sumWeights(g) + 1;
  _$i.forEach(g.children(), function(child) {
    dfs(g, root2, nodeSep, weight, height2, depths, child);
  });
  g.graph().nodeRankFactor = nodeSep;
}
function dfs(g, root2, nodeSep, weight, height2, depths, v) {
  var children = g.children(v);
  if (!children.length) {
    if (v !== root2) {
      g.setEdge(root2, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }
  var top2 = util$a.addBorderNode(g, "_bt");
  var bottom2 = util$a.addBorderNode(g, "_bb");
  var label = g.node(v);
  g.setParent(top2, v);
  label.borderTop = top2;
  g.setParent(bottom2, v);
  label.borderBottom = bottom2;
  _$i.forEach(children, function(child) {
    dfs(g, root2, nodeSep, weight, height2, depths, child);
    var childNode = g.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height2 - depths[v] + 1;
    g.setEdge(top2, childTop, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
    g.setEdge(childBottom, bottom2, {
      weight: thisWeight,
      minlen,
      nestingEdge: true
    });
  });
  if (!g.parent(v)) {
    g.setEdge(root2, top2, { weight: 0, minlen: height2 + depths[v] });
  }
}
function treeDepths(g) {
  var depths = {};
  function dfs2(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      _$i.forEach(children, function(child) {
        dfs2(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  _$i.forEach(g.children(), function(v) {
    dfs2(v, 1);
  });
  return depths;
}
function sumWeights(g) {
  return _$i.reduce(g.edges(), function(acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}
function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  _$i.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}
var _$h = lodash_1$2;
var util$9 = util$d;
var addBorderSegments_1 = addBorderSegments$1;
function addBorderSegments$1(g) {
  function dfs2(v) {
    var children = g.children(v);
    var node2 = g.node(v);
    if (children.length) {
      _$h.forEach(children, dfs2);
    }
    if (_$h.has(node2, "minRank")) {
      node2.borderLeft = [];
      node2.borderRight = [];
      for (var rank2 = node2.minRank, maxRank2 = node2.maxRank + 1; rank2 < maxRank2; ++rank2) {
        addBorderNode(g, "borderLeft", "_bl", v, node2, rank2);
        addBorderNode(g, "borderRight", "_br", v, node2, rank2);
      }
    }
  }
  _$h.forEach(g.children(), dfs2);
}
function addBorderNode(g, prop, prefix2, sg, sgNode, rank2) {
  var label = { width: 0, height: 0, rank: rank2, borderType: prop };
  var prev2 = sgNode[prop][rank2 - 1];
  var curr = util$9.addDummyNode(g, "border", label, prefix2);
  sgNode[prop][rank2] = curr;
  g.setParent(curr, sg);
  if (prev2) {
    g.setEdge(prev2, curr, { weight: 1 });
  }
}
var _$g = lodash_1$2;
var coordinateSystem$1 = {
  adjust,
  undo
};
function adjust(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}
function undo(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }
  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}
function swapWidthHeight(g) {
  _$g.forEach(g.nodes(), function(v) {
    swapWidthHeightOne(g.node(v));
  });
  _$g.forEach(g.edges(), function(e) {
    swapWidthHeightOne(g.edge(e));
  });
}
function swapWidthHeightOne(attrs) {
  var w2 = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w2;
}
function reverseY(g) {
  _$g.forEach(g.nodes(), function(v) {
    reverseYOne(g.node(v));
  });
  _$g.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _$g.forEach(edge.points, reverseYOne);
    if (_$g.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}
function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}
function swapXY(g) {
  _$g.forEach(g.nodes(), function(v) {
    swapXYOne(g.node(v));
  });
  _$g.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _$g.forEach(edge.points, swapXYOne);
    if (_$g.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}
function swapXYOne(attrs) {
  var x2 = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x2;
}
var _$f = lodash_1$2;
var initOrder_1 = initOrder$1;
function initOrder$1(g) {
  var visited = {};
  var simpleNodes = _$f.filter(g.nodes(), function(v) {
    return !g.children(v).length;
  });
  var maxRank2 = _$f.max(_$f.map(simpleNodes, function(v) {
    return g.node(v).rank;
  }));
  var layers = _$f.map(_$f.range(maxRank2 + 1), function() {
    return [];
  });
  function dfs2(v) {
    if (_$f.has(visited, v))
      return;
    visited[v] = true;
    var node2 = g.node(v);
    layers[node2.rank].push(v);
    _$f.forEach(g.successors(v), dfs2);
  }
  var orderedVs = _$f.sortBy(simpleNodes, function(v) {
    return g.node(v).rank;
  });
  _$f.forEach(orderedVs, dfs2);
  return layers;
}
var _$e = lodash_1$2;
var crossCount_1 = crossCount$1;
function crossCount$1(g, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
  }
  return cc;
}
function twoLayerCrossCount(g, northLayer, southLayer) {
  var southPos = _$e.zipObject(
    southLayer,
    _$e.map(southLayer, function(v, i) {
      return i;
    })
  );
  var southEntries = _$e.flatten(_$e.map(northLayer, function(v) {
    return _$e.sortBy(_$e.map(g.outEdges(v), function(e) {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }), "pos");
  }), true);
  var firstIndex = 1;
  while (firstIndex < southLayer.length)
    firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree2 = _$e.map(new Array(treeSize), function() {
    return 0;
  });
  var cc = 0;
  _$e.forEach(southEntries.forEach(function(entry) {
    var index2 = entry.pos + firstIndex;
    tree2[index2] += entry.weight;
    var weightSum = 0;
    while (index2 > 0) {
      if (index2 % 2) {
        weightSum += tree2[index2 + 1];
      }
      index2 = index2 - 1 >> 1;
      tree2[index2] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));
  return cc;
}
var _$d = lodash_1$2;
var barycenter_1 = barycenter$1;
function barycenter$1(g, movable) {
  return _$d.map(movable, function(v) {
    var inV = g.inEdges(v);
    if (!inV.length) {
      return { v };
    } else {
      var result = _$d.reduce(inV, function(acc, e) {
        var edge = g.edge(e), nodeU = g.node(e.v);
        return {
          sum: acc.sum + edge.weight * nodeU.order,
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });
      return {
        v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}
var _$c = lodash_1$2;
var resolveConflicts_1 = resolveConflicts$1;
function resolveConflicts$1(entries2, cg) {
  var mappedEntries = {};
  _$c.forEach(entries2, function(entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i
    };
    if (!_$c.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });
  _$c.forEach(cg.edges(), function(e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (!_$c.isUndefined(entryV) && !_$c.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });
  var sourceSet = _$c.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });
  return doResolveConflicts(sourceSet);
}
function doResolveConflicts(sourceSet) {
  var entries2 = [];
  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (_$c.isUndefined(uEntry.barycenter) || _$c.isUndefined(vEntry.barycenter) || uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }
  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }
  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries2.push(entry);
    _$c.forEach(entry["in"].reverse(), handleIn(entry));
    _$c.forEach(entry.out, handleOut(entry));
  }
  return _$c.map(
    _$c.filter(entries2, function(entry2) {
      return !entry2.merged;
    }),
    function(entry2) {
      return _$c.pick(entry2, ["vs", "i", "barycenter", "weight"]);
    }
  );
}
function mergeEntries(target, source) {
  var sum2 = 0;
  var weight = 0;
  if (target.weight) {
    sum2 += target.barycenter * target.weight;
    weight += target.weight;
  }
  if (source.weight) {
    sum2 += source.barycenter * source.weight;
    weight += source.weight;
  }
  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum2 / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}
var _$b = lodash_1$2;
var util$8 = util$d;
var sort_1 = sort$1;
function sort$1(entries2, biasRight) {
  var parts = util$8.partition(entries2, function(entry) {
    return _$b.has(entry, "barycenter");
  });
  var sortable = parts.lhs, unsortable = _$b.sortBy(parts.rhs, function(entry) {
    return -entry.i;
  }), vs = [], sum2 = 0, weight = 0, vsIndex = 0;
  sortable.sort(compareWithBias(!!biasRight));
  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  _$b.forEach(sortable, function(entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum2 += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });
  var result = { vs: _$b.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum2 / weight;
    result.weight = weight;
  }
  return result;
}
function consumeUnsortable(vs, unsortable, index2) {
  var last;
  while (unsortable.length && (last = _$b.last(unsortable)).i <= index2) {
    unsortable.pop();
    vs.push(last.vs);
    index2++;
  }
  return index2;
}
function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }
    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}
var _$a = lodash_1$2;
var barycenter = barycenter_1;
var resolveConflicts = resolveConflicts_1;
var sort = sort_1;
var sortSubgraph_1 = sortSubgraph$1;
function sortSubgraph$1(g, v, cg, biasRight) {
  var movable = g.children(v);
  var node2 = g.node(v);
  var bl = node2 ? node2.borderLeft : void 0;
  var br = node2 ? node2.borderRight : void 0;
  var subgraphs = {};
  if (bl) {
    movable = _$a.filter(movable, function(w2) {
      return w2 !== bl && w2 !== br;
    });
  }
  var barycenters = barycenter(g, movable);
  _$a.forEach(barycenters, function(entry) {
    if (g.children(entry.v).length) {
      var subgraphResult = sortSubgraph$1(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (_$a.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });
  var entries2 = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries2, subgraphs);
  var result = sort(entries2, biasRight);
  if (bl) {
    result.vs = _$a.flatten([bl, result.vs, br], true);
    if (g.predecessors(bl).length) {
      var blPred = g.node(g.predecessors(bl)[0]), brPred = g.node(g.predecessors(br)[0]);
      if (!_$a.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight + blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }
  return result;
}
function expandSubgraphs(entries2, subgraphs) {
  _$a.forEach(entries2, function(entry) {
    entry.vs = _$a.flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }), true);
  });
}
function mergeBarycenters(target, other) {
  if (!_$a.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight + other.barycenter * other.weight) / (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}
var _$9 = lodash_1$2;
var Graph$4 = graphlib_1$1.Graph;
var buildLayerGraph_1 = buildLayerGraph$1;
function buildLayerGraph$1(g, rank2, relationship) {
  var root2 = createRootNode(g), result = new Graph$4({ compound: true }).setGraph({ root: root2 }).setDefaultNodeLabel(function(v) {
    return g.node(v);
  });
  _$9.forEach(g.nodes(), function(v) {
    var node2 = g.node(v), parent = g.parent(v);
    if (node2.rank === rank2 || node2.minRank <= rank2 && rank2 <= node2.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root2);
      _$9.forEach(g[relationship](v), function(e) {
        var u = e.v === v ? e.w : e.v, edge = result.edge(u, v), weight = !_$9.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });
      if (_$9.has(node2, "minRank")) {
        result.setNode(v, {
          borderLeft: node2.borderLeft[rank2],
          borderRight: node2.borderRight[rank2]
        });
      }
    }
  });
  return result;
}
function createRootNode(g) {
  var v;
  while (g.hasNode(v = _$9.uniqueId("_root")))
    ;
  return v;
}
var _$8 = lodash_1$2;
var addSubgraphConstraints_1 = addSubgraphConstraints$1;
function addSubgraphConstraints$1(g, cg, vs) {
  var prev2 = {}, rootPrev;
  _$8.forEach(vs, function(v) {
    var child = g.parent(v), parent, prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev2[parent];
        prev2[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });
}
var _$7 = lodash_1$2;
var initOrder = initOrder_1;
var crossCount = crossCount_1;
var sortSubgraph = sortSubgraph_1;
var buildLayerGraph = buildLayerGraph_1;
var addSubgraphConstraints = addSubgraphConstraints_1;
var Graph$3 = graphlib_1$1.Graph;
var util$7 = util$d;
var order_1 = order$1;
function order$1(g) {
  var maxRank2 = util$7.maxRank(g), downLayerGraphs = buildLayerGraphs(g, _$7.range(1, maxRank2 + 1), "inEdges"), upLayerGraphs = buildLayerGraphs(g, _$7.range(maxRank2 - 1, -1, -1), "outEdges");
  var layering = initOrder(g);
  assignOrder(g, layering);
  var bestCC = Number.POSITIVE_INFINITY, best;
  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);
    layering = util$7.buildLayerMatrix(g);
    var cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = _$7.cloneDeep(layering);
      bestCC = cc;
    }
  }
  assignOrder(g, best);
}
function buildLayerGraphs(g, ranks, relationship) {
  return _$7.map(ranks, function(rank2) {
    return buildLayerGraph(g, rank2, relationship);
  });
}
function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph$3();
  _$7.forEach(layerGraphs, function(lg) {
    var root2 = lg.graph().root;
    var sorted = sortSubgraph(lg, root2, cg, biasRight);
    _$7.forEach(sorted.vs, function(v, i) {
      lg.node(v).order = i;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}
function assignOrder(g, layering) {
  _$7.forEach(layering, function(layer) {
    _$7.forEach(layer, function(v, i) {
      g.node(v).order = i;
    });
  });
}
var _$6 = lodash_1$2;
var Graph$2 = graphlib_1$1.Graph;
var util$6 = util$d;
var bk = {
  positionX: positionX$1,
  findType1Conflicts,
  findType2Conflicts,
  addConflict,
  hasConflict,
  verticalAlignment,
  horizontalCompaction,
  alignCoordinates,
  findSmallestWidthAlignment,
  balance
};
function findType1Conflicts(g, layering) {
  var conflicts = {};
  function visitLayer(prevLayer, layer) {
    var k0 = 0, scanPos = 0, prevLayerLength = prevLayer.length, lastNode = _$6.last(layer);
    _$6.forEach(layer, function(v, i) {
      var w2 = findOtherInnerSegmentNode(g, v), k1 = w2 ? g.node(w2).order : prevLayerLength;
      if (w2 || v === lastNode) {
        _$6.forEach(layer.slice(scanPos, i + 1), function(scanNode) {
          _$6.forEach(g.predecessors(scanNode), function(u) {
            var uLabel = g.node(u), uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) && !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });
    return layer;
  }
  _$6.reduce(layering, visitLayer);
  return conflicts;
}
function findType2Conflicts(g, layering) {
  var conflicts = {};
  function scan2(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    _$6.forEach(_$6.range(southPos, southEnd), function(i) {
      v = south[i];
      if (g.node(v).dummy) {
        _$6.forEach(g.predecessors(v), function(u) {
          var uNode = g.node(u);
          if (uNode.dummy && (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }
  function visitLayer(north, south) {
    var prevNorthPos = -1, nextNorthPos, southPos = 0;
    _$6.forEach(south, function(v, southLookahead) {
      if (g.node(v).dummy === "border") {
        var predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan2(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan2(south, southPos, south.length, nextNorthPos, north.length);
    });
    return south;
  }
  _$6.reduce(layering, visitLayer);
  return conflicts;
}
function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return _$6.find(g.predecessors(v), function(u) {
      return g.node(u).dummy;
    });
  }
}
function addConflict(conflicts, v, w2) {
  if (v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w2] = true;
}
function hasConflict(conflicts, v, w2) {
  if (v > w2) {
    var tmp = v;
    v = w2;
    w2 = tmp;
  }
  return _$6.has(conflicts[v], w2);
}
function verticalAlignment(g, layering, conflicts, neighborFn) {
  var root2 = {}, align = {}, pos = {};
  _$6.forEach(layering, function(layer) {
    _$6.forEach(layer, function(v, order2) {
      root2[v] = v;
      align[v] = v;
      pos[v] = order2;
    });
  });
  _$6.forEach(layering, function(layer) {
    var prevIdx = -1;
    _$6.forEach(layer, function(v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = _$6.sortBy(ws, function(w3) {
          return pos[w3];
        });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w2 = ws[i];
          if (align[v] === v && prevIdx < pos[w2] && !hasConflict(conflicts, v, w2)) {
            align[w2] = v;
            align[v] = root2[v] = root2[w2];
            prevIdx = pos[w2];
          }
        }
      }
    });
  });
  return { root: root2, align };
}
function horizontalCompaction(g, layering, root2, align, reverseSep) {
  var xs = {}, blockG = buildBlockGraph(g, layering, root2, reverseSep), borderType = reverseSep ? "borderLeft" : "borderRight";
  function iterate(setXsFunc, nextNodesFunc) {
    var stack2 = blockG.nodes();
    var elem = stack2.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack2.push(elem);
        stack2 = stack2.concat(nextNodesFunc(elem));
      }
      elem = stack2.pop();
    }
  }
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }
  function pass2(elem) {
    var min2 = blockG.outEdges(elem).reduce(function(acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);
    var node2 = g.node(elem);
    if (min2 !== Number.POSITIVE_INFINITY && node2.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min2);
    }
  }
  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));
  _$6.forEach(align, function(v) {
    xs[v] = xs[root2[v]];
  });
  return xs;
}
function buildBlockGraph(g, layering, root2, reverseSep) {
  var blockGraph = new Graph$2(), graphLabel = g.graph(), sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);
  _$6.forEach(layering, function(layer) {
    var u;
    _$6.forEach(layer, function(v) {
      var vRoot = root2[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root2[u], prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });
  return blockGraph;
}
function findSmallestWidthAlignment(g, xss) {
  return _$6.minBy(_$6.values(xss), function(xs) {
    var max2 = Number.NEGATIVE_INFINITY;
    var min2 = Number.POSITIVE_INFINITY;
    _$6.forIn(xs, function(x2, v) {
      var halfWidth = width$1(g, v) / 2;
      max2 = Math.max(x2 + halfWidth, max2);
      min2 = Math.min(x2 - halfWidth, min2);
    });
    return max2 - min2;
  });
}
function alignCoordinates(xss, alignTo) {
  var alignToVals = _$6.values(alignTo), alignToMin = _$6.min(alignToVals), alignToMax = _$6.max(alignToVals);
  _$6.forEach(["u", "d"], function(vert) {
    _$6.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz, xs = xss[alignment], delta;
      if (xs === alignTo)
        return;
      var xsVals = _$6.values(xs);
      delta = horiz === "l" ? alignToMin - _$6.min(xsVals) : alignToMax - _$6.max(xsVals);
      if (delta) {
        xss[alignment] = _$6.mapValues(xs, function(x2) {
          return x2 + delta;
        });
      }
    });
  });
}
function balance(xss, align) {
  return _$6.mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = _$6.sortBy(_$6.map(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}
function positionX$1(g) {
  var layering = util$6.buildLayerMatrix(g);
  var conflicts = _$6.merge(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering)
  );
  var xss = {};
  var adjustedLayering;
  _$6.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : _$6.values(layering).reverse();
    _$6.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = _$6.map(adjustedLayering, function(inner) {
          return _$6.values(inner).reverse();
        });
      }
      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(
        g,
        adjustedLayering,
        align.root,
        align.align,
        horiz === "r"
      );
      if (horiz === "r") {
        xs = _$6.mapValues(xs, function(x2) {
          return -x2;
        });
      }
      xss[vert + horiz] = xs;
    });
  });
  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}
function sep(nodeSep, edgeSep, reverseSep) {
  return function(g, v, w2) {
    var vLabel = g.node(v);
    var wLabel = g.node(w2);
    var sum2 = 0;
    var delta;
    sum2 += vLabel.width / 2;
    if (_$6.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
        case "l":
          delta = -vLabel.width / 2;
          break;
        case "r":
          delta = vLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum2 += reverseSep ? delta : -delta;
    }
    delta = 0;
    sum2 += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum2 += (wLabel.dummy ? edgeSep : nodeSep) / 2;
    sum2 += wLabel.width / 2;
    if (_$6.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
        case "l":
          delta = wLabel.width / 2;
          break;
        case "r":
          delta = -wLabel.width / 2;
          break;
      }
    }
    if (delta) {
      sum2 += reverseSep ? delta : -delta;
    }
    delta = 0;
    return sum2;
  };
}
function width$1(g, v) {
  return g.node(v).width;
}
var _$5 = lodash_1$2;
var util$5 = util$d;
var positionX = bk.positionX;
var position_1 = position$1;
function position$1(g) {
  g = util$5.asNonCompoundGraph(g);
  positionY(g);
  _$5.forEach(positionX(g), function(x2, v) {
    g.node(v).x = x2;
  });
}
function positionY(g) {
  var layering = util$5.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;
  _$5.forEach(layering, function(layer) {
    var maxHeight = _$5.max(_$5.map(layer, function(v) {
      return g.node(v).height;
    }));
    _$5.forEach(layer, function(v) {
      g.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}
var _$4 = lodash_1$2;
var acyclic = acyclic$1;
var normalize$1 = normalize$2;
var rank = rank_1;
var normalizeRanks = util$d.normalizeRanks;
var parentDummyChains = parentDummyChains_1;
var removeEmptyRanks = util$d.removeEmptyRanks;
var nestingGraph = nestingGraph$1;
var addBorderSegments = addBorderSegments_1;
var coordinateSystem = coordinateSystem$1;
var order = order_1;
var position = position_1;
var util$4 = util$d;
var Graph$1 = graphlib_1$1.Graph;
var layout_1 = layout$1;
function layout$1(g, opts) {
  var time2 = opts && opts.debugTiming ? util$4.time : util$4.notime;
  time2("layout", function() {
    var layoutGraph = time2("  buildLayoutGraph", function() {
      return buildLayoutGraph(g);
    });
    time2("  runLayout", function() {
      runLayout(layoutGraph, time2);
    });
    time2("  updateInputGraph", function() {
      updateInputGraph(g, layoutGraph);
    });
  });
}
function runLayout(g, time2) {
  time2("    makeSpaceForEdgeLabels", function() {
    makeSpaceForEdgeLabels(g);
  });
  time2("    removeSelfEdges", function() {
    removeSelfEdges(g);
  });
  time2("    acyclic", function() {
    acyclic.run(g);
  });
  time2("    nestingGraph.run", function() {
    nestingGraph.run(g);
  });
  time2("    rank", function() {
    rank(util$4.asNonCompoundGraph(g));
  });
  time2("    injectEdgeLabelProxies", function() {
    injectEdgeLabelProxies(g);
  });
  time2("    removeEmptyRanks", function() {
    removeEmptyRanks(g);
  });
  time2("    nestingGraph.cleanup", function() {
    nestingGraph.cleanup(g);
  });
  time2("    normalizeRanks", function() {
    normalizeRanks(g);
  });
  time2("    assignRankMinMax", function() {
    assignRankMinMax(g);
  });
  time2("    removeEdgeLabelProxies", function() {
    removeEdgeLabelProxies(g);
  });
  time2("    normalize.run", function() {
    normalize$1.run(g);
  });
  time2("    parentDummyChains", function() {
    parentDummyChains(g);
  });
  time2("    addBorderSegments", function() {
    addBorderSegments(g);
  });
  time2("    order", function() {
    order(g);
  });
  time2("    insertSelfEdges", function() {
    insertSelfEdges(g);
  });
  time2("    adjustCoordinateSystem", function() {
    coordinateSystem.adjust(g);
  });
  time2("    position", function() {
    position(g);
  });
  time2("    positionSelfEdges", function() {
    positionSelfEdges(g);
  });
  time2("    removeBorderNodes", function() {
    removeBorderNodes(g);
  });
  time2("    normalize.undo", function() {
    normalize$1.undo(g);
  });
  time2("    fixupEdgeLabelCoords", function() {
    fixupEdgeLabelCoords(g);
  });
  time2("    undoCoordinateSystem", function() {
    coordinateSystem.undo(g);
  });
  time2("    translateGraph", function() {
    translateGraph(g);
  });
  time2("    assignNodeIntersects", function() {
    assignNodeIntersects(g);
  });
  time2("    reversePoints", function() {
    reversePointsForReversedEdges(g);
  });
  time2("    acyclic.undo", function() {
    acyclic.undo(g);
  });
}
function updateInputGraph(inputGraph, layoutGraph) {
  _$4.forEach(inputGraph.nodes(), function(v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);
    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });
  _$4.forEach(inputGraph.edges(), function(e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);
    inputLabel.points = layoutLabel.points;
    if (_$4.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });
  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}
var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1,
  weight: 1,
  width: 0,
  height: 0,
  labeloffset: 10,
  labelpos: "r"
};
var edgeAttrs = ["labelpos"];
function buildLayoutGraph(inputGraph) {
  var g = new Graph$1({ multigraph: true, compound: true });
  var graph2 = canonicalize(inputGraph.graph());
  g.setGraph(_$4.merge(
    {},
    graphDefaults,
    selectNumberAttrs(graph2, graphNumAttrs),
    _$4.pick(graph2, graphAttrs)
  ));
  _$4.forEach(inputGraph.nodes(), function(v) {
    var node2 = canonicalize(inputGraph.node(v));
    g.setNode(v, _$4.defaults(selectNumberAttrs(node2, nodeNumAttrs), nodeDefaults));
    g.setParent(v, inputGraph.parent(v));
  });
  _$4.forEach(inputGraph.edges(), function(e) {
    var edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, _$4.merge(
      {},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      _$4.pick(edge, edgeAttrs)
    ));
  });
  return g;
}
function makeSpaceForEdgeLabels(g) {
  var graph2 = g.graph();
  graph2.ranksep /= 2;
  _$4.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph2.rankdir === "TB" || graph2.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}
function injectEdgeLabelProxies(g) {
  _$4.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.width && edge.height) {
      var v = g.node(e.v);
      var w2 = g.node(e.w);
      var label = { rank: (w2.rank - v.rank) / 2 + v.rank, e };
      util$4.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}
function assignRankMinMax(g) {
  var maxRank2 = 0;
  _$4.forEach(g.nodes(), function(v) {
    var node2 = g.node(v);
    if (node2.borderTop) {
      node2.minRank = g.node(node2.borderTop).rank;
      node2.maxRank = g.node(node2.borderBottom).rank;
      maxRank2 = _$4.max(maxRank2, node2.maxRank);
    }
  });
  g.graph().maxRank = maxRank2;
}
function removeEdgeLabelProxies(g) {
  _$4.forEach(g.nodes(), function(v) {
    var node2 = g.node(v);
    if (node2.dummy === "edge-proxy") {
      g.edge(node2.e).labelRank = node2.rank;
      g.removeNode(v);
    }
  });
}
function translateGraph(g) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY2 = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;
  function getExtremes(attrs) {
    var x2 = attrs.x;
    var y2 = attrs.y;
    var w2 = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x2 - w2 / 2);
    maxX = Math.max(maxX, x2 + w2 / 2);
    minY = Math.min(minY, y2 - h / 2);
    maxY2 = Math.max(maxY2, y2 + h / 2);
  }
  _$4.forEach(g.nodes(), function(v) {
    getExtremes(g.node(v));
  });
  _$4.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_$4.has(edge, "x")) {
      getExtremes(edge);
    }
  });
  minX -= marginX;
  minY -= marginY;
  _$4.forEach(g.nodes(), function(v) {
    var node2 = g.node(v);
    node2.x -= minX;
    node2.y -= minY;
  });
  _$4.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _$4.forEach(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (_$4.has(edge, "x")) {
      edge.x -= minX;
    }
    if (_$4.has(edge, "y")) {
      edge.y -= minY;
    }
  });
  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY2 - minY + marginY;
}
function assignNodeIntersects(g) {
  _$4.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    var nodeV = g.node(e.v);
    var nodeW = g.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util$4.intersectRect(nodeV, p1));
    edge.points.push(util$4.intersectRect(nodeW, p2));
  });
}
function fixupEdgeLabelCoords(g) {
  _$4.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_$4.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
        case "l":
          edge.x -= edge.width / 2 + edge.labeloffset;
          break;
        case "r":
          edge.x += edge.width / 2 + edge.labeloffset;
          break;
      }
    }
  });
}
function reversePointsForReversedEdges(g) {
  _$4.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}
function removeBorderNodes(g) {
  _$4.forEach(g.nodes(), function(v) {
    if (g.children(v).length) {
      var node2 = g.node(v);
      var t = g.node(node2.borderTop);
      var b = g.node(node2.borderBottom);
      var l = g.node(_$4.last(node2.borderLeft));
      var r = g.node(_$4.last(node2.borderRight));
      node2.width = Math.abs(r.x - l.x);
      node2.height = Math.abs(b.y - t.y);
      node2.x = l.x + node2.width / 2;
      node2.y = t.y + node2.height / 2;
    }
  });
  _$4.forEach(g.nodes(), function(v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}
function removeSelfEdges(g) {
  _$4.forEach(g.edges(), function(e) {
    if (e.v === e.w) {
      var node2 = g.node(e.v);
      if (!node2.selfEdges) {
        node2.selfEdges = [];
      }
      node2.selfEdges.push({ e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}
function insertSelfEdges(g) {
  var layers = util$4.buildLayerMatrix(g);
  _$4.forEach(layers, function(layer) {
    var orderShift = 0;
    _$4.forEach(layer, function(v, i) {
      var node2 = g.node(v);
      node2.order = i + orderShift;
      _$4.forEach(node2.selfEdges, function(selfEdge) {
        util$4.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node2.rank,
          order: i + ++orderShift,
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node2.selfEdges;
    });
  });
}
function positionSelfEdges(g) {
  _$4.forEach(g.nodes(), function(v) {
    var node2 = g.node(v);
    if (node2.dummy === "selfedge") {
      var selfNode = g.node(node2.e.v);
      var x2 = selfNode.x + selfNode.width / 2;
      var y2 = selfNode.y;
      var dx = node2.x - x2;
      var dy = selfNode.height / 2;
      g.setEdge(node2.e, node2.label);
      g.removeNode(v);
      node2.label.points = [
        { x: x2 + 2 * dx / 3, y: y2 - dy },
        { x: x2 + 5 * dx / 6, y: y2 - dy },
        { x: x2 + dx, y: y2 },
        { x: x2 + 5 * dx / 6, y: y2 + dy },
        { x: x2 + 2 * dx / 3, y: y2 + dy }
      ];
      node2.label.x = node2.x;
      node2.label.y = node2.y;
    }
  });
}
function selectNumberAttrs(obj, attrs) {
  return _$4.mapValues(_$4.pick(obj, attrs), Number);
}
function canonicalize(attrs) {
  var newAttrs = {};
  _$4.forEach(attrs, function(v, k2) {
    newAttrs[k2.toLowerCase()] = v;
  });
  return newAttrs;
}
var _$3 = lodash_1$2;
var util$3 = util$d;
var Graph = graphlib_1$1.Graph;
var debug = {
  debugOrdering
};
function debugOrdering(g) {
  var layerMatrix = util$3.buildLayerMatrix(g);
  var h = new Graph({ compound: true, multigraph: true }).setGraph({});
  _$3.forEach(g.nodes(), function(v) {
    h.setNode(v, { label: v });
    h.setParent(v, "layer" + g.node(v).rank);
  });
  _$3.forEach(g.edges(), function(e) {
    h.setEdge(e.v, e.w, {}, e.name);
  });
  _$3.forEach(layerMatrix, function(layer, i) {
    var layerV = "layer" + i;
    h.setNode(layerV, { rank: "same" });
    _$3.reduce(layer, function(u, v) {
      h.setEdge(u, v, { style: "invis" });
      return v;
    });
  });
  return h;
}
var version$4 = "0.8.5";
var dagre$1 = {
  graphlib: graphlib_1$1,
  layout: layout_1,
  debug,
  util: {
    time: util$d.time,
    notime: util$d.notime
  },
  version: version$4
};
let getRandomValues;
const rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}
const byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
const randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
const native = {
  randomUUID
};
function v4(options2, buf, offset) {
  if (native.randomUUID && !buf && !options2) {
    return native.randomUUID();
  }
  options2 = options2 || {};
  const rnds = options2.random || (options2.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var graphlib;
if (typeof commonjsRequire$1 === "function") {
  try {
    graphlib = graphlib$2;
  } catch (e) {
  }
}
if (!graphlib) {
  graphlib = window.graphlib;
}
var graphlib_1 = graphlib;
var dagre;
if (typeof commonjsRequire$1 === "function") {
  try {
    dagre = dagre$1;
  } catch (e) {
  }
}
if (!dagre) {
  dagre = window.dagre;
}
var dagre_1 = dagre;
var intersectNode_1 = intersectNode$1;
function intersectNode$1(node2, point2) {
  return node2.intersect(point2);
}
var intersectEllipse_1 = intersectEllipse$2;
function intersectEllipse$2(node2, rx, ry, point2) {
  var cx = node2.x;
  var cy = node2.y;
  var px = cx - point2.x;
  var py = cy - point2.y;
  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
  var dx = Math.abs(rx * ry * px / det);
  if (point2.x < cx) {
    dx = -dx;
  }
  var dy = Math.abs(rx * ry * py / det);
  if (point2.y < cy) {
    dy = -dy;
  }
  return { x: cx + dx, y: cy + dy };
}
var intersectEllipse$1 = intersectEllipse_1;
var intersectCircle_1 = intersectCircle$1;
function intersectCircle$1(node2, rx, point2) {
  return intersectEllipse$1(node2, rx, rx, point2);
}
var intersectLine_1 = intersectLine$2;
function intersectLine$2(p1, p2, q1, q2) {
  var a1, a2, b12, b22, c1, c2;
  var r1, r2, r3, r4;
  var denom, offset, num;
  var x2, y2;
  a1 = p2.y - p1.y;
  b12 = p1.x - p2.x;
  c1 = p2.x * p1.y - p1.x * p2.y;
  r3 = a1 * q1.x + b12 * q1.y + c1;
  r4 = a1 * q2.x + b12 * q2.y + c1;
  if (r3 !== 0 && r4 !== 0 && sameSign$1(r3, r4)) {
    return;
  }
  a2 = q2.y - q1.y;
  b22 = q1.x - q2.x;
  c2 = q2.x * q1.y - q1.x * q2.y;
  r1 = a2 * p1.x + b22 * p1.y + c2;
  r2 = a2 * p2.x + b22 * p2.y + c2;
  if (r1 !== 0 && r2 !== 0 && sameSign$1(r1, r2)) {
    return;
  }
  denom = a1 * b22 - a2 * b12;
  if (denom === 0) {
    return;
  }
  offset = Math.abs(denom / 2);
  num = b12 * c2 - b22 * c1;
  x2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  num = a2 * c1 - a1 * c2;
  y2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  return { x: x2, y: y2 };
}
function sameSign$1(r1, r2) {
  return r1 * r2 > 0;
}
var intersectLine$1 = intersectLine_1;
var intersectPolygon_1 = intersectPolygon$1;
function intersectPolygon$1(node2, polyPoints, point2) {
  var x12 = node2.x;
  var y12 = node2.y;
  var intersections = [];
  var minX = Number.POSITIVE_INFINITY;
  var minY = Number.POSITIVE_INFINITY;
  polyPoints.forEach(function(entry) {
    minX = Math.min(minX, entry.x);
    minY = Math.min(minY, entry.y);
  });
  var left2 = x12 - node2.width / 2 - minX;
  var top2 = y12 - node2.height / 2 - minY;
  for (var i = 0; i < polyPoints.length; i++) {
    var p1 = polyPoints[i];
    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
    var intersect2 = intersectLine$1(
      node2,
      point2,
      { x: left2 + p1.x, y: top2 + p1.y },
      { x: left2 + p2.x, y: top2 + p2.y }
    );
    if (intersect2) {
      intersections.push(intersect2);
    }
  }
  if (!intersections.length) {
    console.log("NO INTERSECTION FOUND, RETURN NODE CENTER", node2);
    return node2;
  }
  if (intersections.length > 1) {
    intersections.sort(function(p, q) {
      var pdx = p.x - point2.x;
      var pdy = p.y - point2.y;
      var distp = Math.sqrt(pdx * pdx + pdy * pdy);
      var qdx = q.x - point2.x;
      var qdy = q.y - point2.y;
      var distq = Math.sqrt(qdx * qdx + qdy * qdy);
      return distp < distq ? -1 : distp === distq ? 0 : 1;
    });
  }
  return intersections[0];
}
var intersectRect_1 = intersectRect$1;
function intersectRect$1(node2, point2) {
  var x2 = node2.x;
  var y2 = node2.y;
  var dx = point2.x - x2;
  var dy = point2.y - y2;
  var w2 = node2.width / 2;
  var h = node2.height / 2;
  var sx, sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h) {
    if (dy < 0) {
      h = -h;
    }
    sx = dy === 0 ? 0 : h * dx / dy;
    sy = h;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = dx === 0 ? 0 : w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
}
var intersect$2 = {
  node: intersectNode_1,
  circle: intersectCircle_1,
  ellipse: intersectEllipse_1,
  polygon: intersectPolygon_1,
  rect: intersectRect_1
};
var lodash$1;
if (typeof commonjsRequire$1 === "function") {
  try {
    lodash$1 = {
      defaults: requireDefaults$1(),
      each: requireEach$1(),
      isFunction: requireIsFunction$1(),
      isPlainObject: requireIsPlainObject$1(),
      pick: requirePick$1(),
      has: requireHas$1(),
      range: requireRange$1(),
      uniqueId: requireUniqueId$1()
    };
  } catch (e) {
  }
}
if (!lodash$1) {
  lodash$1 = window._;
}
var lodash_1$1 = lodash$1;
var version$3 = "5.16.0";
function ascending$3(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function bisector(compare) {
  if (compare.length === 1)
    compare = ascendingComparator(compare);
  return {
    left: function(a2, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a2.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      }
      return lo;
    },
    right: function(a2, x2, lo, hi) {
      if (lo == null)
        lo = 0;
      if (hi == null)
        hi = a2.length;
      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a2[mid], x2) > 0)
          hi = mid;
        else
          lo = mid + 1;
      }
      return lo;
    }
  };
}
function ascendingComparator(f) {
  return function(d, x2) {
    return ascending$3(f(d), x2);
  };
}
var ascendingBisect = bisector(ascending$3);
var bisectRight = ascendingBisect.right;
var bisectLeft = ascendingBisect.left;
function pairs(array2, f) {
  if (f == null)
    f = pair;
  var i = 0, n = array2.length - 1, p = array2[0], pairs2 = new Array(n < 0 ? 0 : n);
  while (i < n)
    pairs2[i] = f(p, p = array2[++i]);
  return pairs2;
}
function pair(a2, b) {
  return [a2, b];
}
function cross$3(values0, values1, reduce) {
  var n0 = values0.length, n1 = values1.length, values2 = new Array(n0 * n1), i0, i1, i, value0;
  if (reduce == null)
    reduce = pair;
  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values2[i] = reduce(value0, values1[i1]);
    }
  }
  return values2;
}
function descending$2(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function number$3(x2) {
  return x2 === null ? NaN : +x2;
}
function variance(values2, valueof) {
  var n = values2.length, m = 0, i = -1, mean2 = 0, value, delta, sum2 = 0;
  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values2[i]))) {
        delta = value - mean2;
        mean2 += delta / ++m;
        sum2 += delta * (value - mean2);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values2[i], i, values2)))) {
        delta = value - mean2;
        mean2 += delta / ++m;
        sum2 += delta * (value - mean2);
      }
    }
  }
  if (m > 1)
    return sum2 / (m - 1);
}
function deviation(array2, f) {
  var v = variance(array2, f);
  return v ? Math.sqrt(v) : v;
}
function extent$1(values2, valueof) {
  var n = values2.length, i = -1, value, min2, max2;
  if (valueof == null) {
    while (++i < n) {
      if ((value = values2[i]) != null && value >= value) {
        min2 = max2 = value;
        while (++i < n) {
          if ((value = values2[i]) != null) {
            if (min2 > value)
              min2 = value;
            if (max2 < value)
              max2 = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      if ((value = valueof(values2[i], i, values2)) != null && value >= value) {
        min2 = max2 = value;
        while (++i < n) {
          if ((value = valueof(values2[i], i, values2)) != null) {
            if (min2 > value)
              min2 = value;
            if (max2 < value)
              max2 = value;
          }
        }
      }
    }
  }
  return [min2, max2];
}
var array$3 = Array.prototype;
var slice$6 = array$3.slice;
var map$3 = array$3.map;
function constant$d(x2) {
  return function() {
    return x2;
  };
}
function identity$9(x2) {
  return x2;
}
function sequence(start2, stop, step2) {
  start2 = +start2, stop = +stop, step2 = (n = arguments.length) < 2 ? (stop = start2, start2 = 0, 1) : n < 3 ? 1 : +step2;
  var i = -1, n = Math.max(0, Math.ceil((stop - start2) / step2)) | 0, range2 = new Array(n);
  while (++i < n) {
    range2[i] = start2 + i * step2;
  }
  return range2;
}
var e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function ticks(start2, stop, count2) {
  var reverse2, i = -1, n, ticks2, step2;
  stop = +stop, start2 = +start2, count2 = +count2;
  if (start2 === stop && count2 > 0)
    return [start2];
  if (reverse2 = stop < start2)
    n = start2, start2 = stop, stop = n;
  if ((step2 = tickIncrement(start2, stop, count2)) === 0 || !isFinite(step2))
    return [];
  if (step2 > 0) {
    start2 = Math.ceil(start2 / step2);
    stop = Math.floor(stop / step2);
    ticks2 = new Array(n = Math.ceil(stop - start2 + 1));
    while (++i < n)
      ticks2[i] = (start2 + i) * step2;
  } else {
    start2 = Math.floor(start2 * step2);
    stop = Math.ceil(stop * step2);
    ticks2 = new Array(n = Math.ceil(start2 - stop + 1));
    while (++i < n)
      ticks2[i] = (start2 - i) / step2;
  }
  if (reverse2)
    ticks2.reverse();
  return ticks2;
}
function tickIncrement(start2, stop, count2) {
  var step2 = (stop - start2) / Math.max(0, count2), power = Math.floor(Math.log(step2) / Math.LN10), error = step2 / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function tickStep(start2, stop, count2) {
  var step0 = Math.abs(stop - start2) / Math.max(0, count2), step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)), error = step0 / step1;
  if (error >= e10)
    step1 *= 10;
  else if (error >= e5)
    step1 *= 5;
  else if (error >= e2)
    step1 *= 2;
  return stop < start2 ? -step1 : step1;
}
function thresholdSturges(values2) {
  return Math.ceil(Math.log(values2.length) / Math.LN2) + 1;
}
function histogram() {
  var value = identity$9, domain = extent$1, threshold2 = thresholdSturges;
  function histogram2(data) {
    var i, n = data.length, x2, values2 = new Array(n);
    for (i = 0; i < n; ++i) {
      values2[i] = value(data[i], i, data);
    }
    var xz = domain(values2), x02 = xz[0], x12 = xz[1], tz = threshold2(values2, x02, x12);
    if (!Array.isArray(tz)) {
      tz = tickStep(x02, x12, tz);
      tz = sequence(Math.ceil(x02 / tz) * tz, x12, tz);
    }
    var m = tz.length;
    while (tz[0] <= x02)
      tz.shift(), --m;
    while (tz[m - 1] > x12)
      tz.pop(), --m;
    var bins = new Array(m + 1), bin;
    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x02;
      bin.x1 = i < m ? tz[i] : x12;
    }
    for (i = 0; i < n; ++i) {
      x2 = values2[i];
      if (x02 <= x2 && x2 <= x12) {
        bins[bisectRight(tz, x2, 0, m)].push(data[i]);
      }
    }
    return bins;
  }
  histogram2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$d(_2), histogram2) : value;
  };
  histogram2.domain = function(_2) {
    return arguments.length ? (domain = typeof _2 === "function" ? _2 : constant$d([_2[0], _2[1]]), histogram2) : domain;
  };
  histogram2.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$d(slice$6.call(_2)) : constant$d(_2), histogram2) : threshold2;
  };
  return histogram2;
}
function threshold$1(values2, p, valueof) {
  if (valueof == null)
    valueof = number$3;
  if (!(n = values2.length))
    return;
  if ((p = +p) <= 0 || n < 2)
    return +valueof(values2[0], 0, values2);
  if (p >= 1)
    return +valueof(values2[n - 1], n - 1, values2);
  var n, i = (n - 1) * p, i0 = Math.floor(i), value0 = +valueof(values2[i0], i0, values2), value1 = +valueof(values2[i0 + 1], i0 + 1, values2);
  return value0 + (value1 - value0) * (i - i0);
}
function freedmanDiaconis(values2, min2, max2) {
  values2 = map$3.call(values2, number$3).sort(ascending$3);
  return Math.ceil((max2 - min2) / (2 * (threshold$1(values2, 0.75) - threshold$1(values2, 0.25)) * Math.pow(values2.length, -1 / 3)));
}
function scott(values2, min2, max2) {
  return Math.ceil((max2 - min2) / (3.5 * deviation(values2) * Math.pow(values2.length, -1 / 3)));
}
function max$2(values2, valueof) {
  var n = values2.length, i = -1, value, max2;
  if (valueof == null) {
    while (++i < n) {
      if ((value = values2[i]) != null && value >= value) {
        max2 = value;
        while (++i < n) {
          if ((value = values2[i]) != null && value > max2) {
            max2 = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      if ((value = valueof(values2[i], i, values2)) != null && value >= value) {
        max2 = value;
        while (++i < n) {
          if ((value = valueof(values2[i], i, values2)) != null && value > max2) {
            max2 = value;
          }
        }
      }
    }
  }
  return max2;
}
function mean(values2, valueof) {
  var n = values2.length, m = n, i = -1, value, sum2 = 0;
  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values2[i])))
        sum2 += value;
      else
        --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values2[i], i, values2))))
        sum2 += value;
      else
        --m;
    }
  }
  if (m)
    return sum2 / m;
}
function median(values2, valueof) {
  var n = values2.length, i = -1, value, numbers = [];
  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = number$3(values2[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = number$3(valueof(values2[i], i, values2)))) {
        numbers.push(value);
      }
    }
  }
  return threshold$1(numbers.sort(ascending$3), 0.5);
}
function merge$1(arrays) {
  var n = arrays.length, m, i = -1, j = 0, merged, array2;
  while (++i < n)
    j += arrays[i].length;
  merged = new Array(j);
  while (--n >= 0) {
    array2 = arrays[n];
    m = array2.length;
    while (--m >= 0) {
      merged[--j] = array2[m];
    }
  }
  return merged;
}
function min$1(values2, valueof) {
  var n = values2.length, i = -1, value, min2;
  if (valueof == null) {
    while (++i < n) {
      if ((value = values2[i]) != null && value >= value) {
        min2 = value;
        while (++i < n) {
          if ((value = values2[i]) != null && min2 > value) {
            min2 = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      if ((value = valueof(values2[i], i, values2)) != null && value >= value) {
        min2 = value;
        while (++i < n) {
          if ((value = valueof(values2[i], i, values2)) != null && min2 > value) {
            min2 = value;
          }
        }
      }
    }
  }
  return min2;
}
function permute(array2, indexes) {
  var i = indexes.length, permutes = new Array(i);
  while (i--)
    permutes[i] = array2[indexes[i]];
  return permutes;
}
function scan(values2, compare) {
  if (!(n = values2.length))
    return;
  var n, i = 0, j = 0, xi, xj = values2[j];
  if (compare == null)
    compare = ascending$3;
  while (++i < n) {
    if (compare(xi = values2[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }
  if (compare(xj, xj) === 0)
    return j;
}
function shuffle$1(array2, i0, i1) {
  var m = (i1 == null ? array2.length : i1) - (i0 = i0 == null ? 0 : +i0), t, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array2[m + i0];
    array2[m + i0] = array2[i + i0];
    array2[i + i0] = t;
  }
  return array2;
}
function sum$2(values2, valueof) {
  var n = values2.length, i = -1, value, sum2 = 0;
  if (valueof == null) {
    while (++i < n) {
      if (value = +values2[i])
        sum2 += value;
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values2[i], i, values2))
        sum2 += value;
    }
  }
  return sum2;
}
function transpose(matrix) {
  if (!(n = matrix.length))
    return [];
  for (var i = -1, m = min$1(matrix, length$2), transpose2 = new Array(m); ++i < m; ) {
    for (var j = -1, n, row = transpose2[i] = new Array(n); ++j < n; ) {
      row[j] = matrix[j][i];
    }
  }
  return transpose2;
}
function length$2(d) {
  return d.length;
}
function zip() {
  return transpose(arguments);
}
var slice$5 = Array.prototype.slice;
function identity$8(x2) {
  return x2;
}
var top = 1, right = 2, bottom = 3, left = 4, epsilon$4 = 1e-6;
function translateX(x2) {
  return "translate(" + (x2 + 0.5) + ",0)";
}
function translateY(y2) {
  return "translate(0," + (y2 + 0.5) + ")";
}
function number$2(scale) {
  return function(d) {
    return +scale(d);
  };
}
function center$1(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2;
  if (scale.round())
    offset = Math.round(offset);
  return function(d) {
    return +scale(d) + offset;
  };
}
function entering() {
  return !this.__axis;
}
function axis(orient, scale) {
  var tickArguments = [], tickValues = null, tickFormat2 = null, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, k2 = orient === top || orient === left ? -1 : 1, x2 = orient === left || orient === right ? "x" : "y", transform2 = orient === top || orient === bottom ? translateX : translateY;
  function axis2(context) {
    var values2 = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues, format2 = tickFormat2 == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : identity$8 : tickFormat2, spacing = Math.max(tickSizeInner, 0) + tickPadding, range2 = scale.range(), range0 = +range2[0] + 0.5, range1 = +range2[range2.length - 1] + 0.5, position2 = (scale.bandwidth ? center$1 : number$2)(scale.copy()), selection2 = context.selection ? context.selection() : context, path2 = selection2.selectAll(".domain").data([null]), tick = selection2.selectAll(".tick").data(values2, scale).order(), tickExit = tick.exit(), tickEnter = tick.enter().append("g").attr("class", "tick"), line2 = tick.select("line"), text2 = tick.select("text");
    path2 = path2.merge(path2.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "currentColor"));
    tick = tick.merge(tickEnter);
    line2 = line2.merge(tickEnter.append("line").attr("stroke", "currentColor").attr(x2 + "2", k2 * tickSizeInner));
    text2 = text2.merge(tickEnter.append("text").attr("fill", "currentColor").attr(x2, k2 * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));
    if (context !== selection2) {
      path2 = path2.transition(context);
      tick = tick.transition(context);
      line2 = line2.transition(context);
      text2 = text2.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon$4).attr("transform", function(d) {
        return isFinite(d = position2(d)) ? transform2(d) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon$4).attr("transform", function(d) {
        var p = this.parentNode.__axis;
        return transform2(p && isFinite(p = p(d)) ? p : position2(d));
      });
    }
    tickExit.remove();
    path2.attr("d", orient === left || orient == right ? tickSizeOuter ? "M" + k2 * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k2 * tickSizeOuter : "M0.5," + range0 + "V" + range1 : tickSizeOuter ? "M" + range0 + "," + k2 * tickSizeOuter + "V0.5H" + range1 + "V" + k2 * tickSizeOuter : "M" + range0 + ",0.5H" + range1);
    tick.attr("opacity", 1).attr("transform", function(d) {
      return transform2(position2(d));
    });
    line2.attr(x2 + "2", k2 * tickSizeInner);
    text2.attr(x2, k2 * spacing).text(format2);
    selection2.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection2.each(function() {
      this.__axis = position2;
    });
  }
  axis2.scale = function(_2) {
    return arguments.length ? (scale = _2, axis2) : scale;
  };
  axis2.ticks = function() {
    return tickArguments = slice$5.call(arguments), axis2;
  };
  axis2.tickArguments = function(_2) {
    return arguments.length ? (tickArguments = _2 == null ? [] : slice$5.call(_2), axis2) : tickArguments.slice();
  };
  axis2.tickValues = function(_2) {
    return arguments.length ? (tickValues = _2 == null ? null : slice$5.call(_2), axis2) : tickValues && tickValues.slice();
  };
  axis2.tickFormat = function(_2) {
    return arguments.length ? (tickFormat2 = _2, axis2) : tickFormat2;
  };
  axis2.tickSize = function(_2) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeInner = function(_2) {
    return arguments.length ? (tickSizeInner = +_2, axis2) : tickSizeInner;
  };
  axis2.tickSizeOuter = function(_2) {
    return arguments.length ? (tickSizeOuter = +_2, axis2) : tickSizeOuter;
  };
  axis2.tickPadding = function(_2) {
    return arguments.length ? (tickPadding = +_2, axis2) : tickPadding;
  };
  return axis2;
}
function axisTop(scale) {
  return axis(top, scale);
}
function axisRight(scale) {
  return axis(right, scale);
}
function axisBottom(scale) {
  return axis(bottom, scale);
}
function axisLeft(scale) {
  return axis(left, scale);
}
var noop$3 = { value: function() {
} };
function dispatch() {
  for (var i = 0, n = arguments.length, _2 = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _2 || /[\s.]/.test(t))
      throw new Error("illegal type: " + t);
    _2[t] = [];
  }
  return new Dispatch(_2);
}
function Dispatch(_2) {
  this._ = _2;
}
function parseTypenames$1(typenames, types2) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types2.hasOwnProperty(t))
      throw new Error("unknown type: " + t);
    return { type: t, name: name2 };
  });
}
Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _2 = this._, T = parseTypenames$1(typename + "", _2), t, i = -1, n = T.length;
    if (arguments.length < 2) {
      while (++i < n)
        if ((t = (typename = T[i]).type) && (t = get$1(_2[t], typename.name)))
          return t;
      return;
    }
    if (callback != null && typeof callback !== "function")
      throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type)
        _2[t] = set$2(_2[t], typename.name, callback);
      else if (callback == null)
        for (t in _2)
          _2[t] = set$2(_2[t], typename.name, null);
    }
    return this;
  },
  copy: function() {
    var copy2 = {}, _2 = this._;
    for (var t in _2)
      copy2[t] = _2[t].slice();
    return new Dispatch(copy2);
  },
  call: function(type2, that) {
    if ((n = arguments.length - 2) > 0)
      for (var args = new Array(n), i = 0, n, t; i < n; ++i)
        args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  },
  apply: function(type2, that, args) {
    if (!this._.hasOwnProperty(type2))
      throw new Error("unknown type: " + type2);
    for (var t = this._[type2], i = 0, n = t.length; i < n; ++i)
      t[i].value.apply(that, args);
  }
};
function get$1(type2, name2) {
  for (var i = 0, n = type2.length, c2; i < n; ++i) {
    if ((c2 = type2[i]).name === name2) {
      return c2.value;
    }
  }
}
function set$2(type2, name2, callback) {
  for (var i = 0, n = type2.length; i < n; ++i) {
    if (type2[i].name === name2) {
      type2[i] = noop$3, type2 = type2.slice(0, i).concat(type2.slice(i + 1));
      break;
    }
  }
  if (callback != null)
    type2.push({ name: name2, value: callback });
  return type2;
}
var xhtml = "http://www.w3.org/1999/xhtml";
const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
function namespace(name2) {
  var prefix2 = name2 += "", i = prefix2.indexOf(":");
  if (i >= 0 && (prefix2 = name2.slice(0, i)) !== "xmlns")
    name2 = name2.slice(i + 1);
  return namespaces.hasOwnProperty(prefix2) ? { space: namespaces[prefix2], local: name2 } : name2;
}
function creatorInherit(name2) {
  return function() {
    var document2 = this.ownerDocument, uri = this.namespaceURI;
    return uri === xhtml && document2.documentElement.namespaceURI === xhtml ? document2.createElement(name2) : document2.createElementNS(uri, name2);
  };
}
function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}
function creator(name2) {
  var fullname = namespace(name2);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
function none$2() {
}
function selector(selector2) {
  return selector2 == null ? none$2 : function() {
    return this.querySelector(selector2);
  };
}
function selection_select(select2) {
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function empty$1() {
  return [];
}
function selectorAll(selector2) {
  return selector2 == null ? empty$1 : function() {
    return this.querySelectorAll(selector2);
  };
}
function selection_selectAll(select2) {
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        subgroups.push(select2.call(node2, node2.__data__, i, group));
        parents2.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, parents2);
}
function matcher(selector2) {
  return function() {
    return this.matches(selector2);
  };
}
function selection_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Selection$1(subgroups, this._parents);
}
function sparse(update) {
  return new Array(update.length);
}
function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}
function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}
EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function(child, next2) {
    return this._parent.insertBefore(child, next2);
  },
  querySelector: function(selector2) {
    return this._parent.querySelector(selector2);
  },
  querySelectorAll: function(selector2) {
    return this._parent.querySelectorAll(selector2);
  }
};
function constant$c(x2) {
  return function() {
    return x2;
  };
}
var keyPrefix$1 = "$";
function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0, node2, groupLength = group.length, dataLength = data.length;
  for (; i < dataLength; ++i) {
    if (node2 = group[i]) {
      node2.__data__ = data[i];
      update[i] = node2;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (; i < groupLength; ++i) {
    if (node2 = group[i]) {
      exit[i] = node2;
    }
  }
}
function bindKey(parent, group, enter, update, exit, data, key) {
  var i, node2, nodeByKeyValue = {}, groupLength = group.length, dataLength = data.length, keyValues = new Array(groupLength), keyValue;
  for (i = 0; i < groupLength; ++i) {
    if (node2 = group[i]) {
      keyValues[i] = keyValue = keyPrefix$1 + key.call(node2, node2.__data__, i, group);
      if (keyValue in nodeByKeyValue) {
        exit[i] = node2;
      } else {
        nodeByKeyValue[keyValue] = node2;
      }
    }
  }
  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix$1 + key.call(parent, data[i], i, data);
    if (node2 = nodeByKeyValue[keyValue]) {
      update[i] = node2;
      node2.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }
  for (i = 0; i < groupLength; ++i) {
    if ((node2 = group[i]) && nodeByKeyValue[keyValues[i]] === node2) {
      exit[i] = node2;
    }
  }
}
function selection_data(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function(d) {
      data[++j] = d;
    });
    return data;
  }
  var bind = key ? bindKey : bindIndex, parents2 = this._parents, groups = this._groups;
  if (typeof value !== "function")
    value = constant$c(value);
  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents2[j], group = groups[j], groupLength = group.length, data = value.call(parent, parent && parent.__data__, j, parents2), dataLength = data.length, enterGroup = enter[j] = new Array(dataLength), updateGroup = update[j] = new Array(dataLength), exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);
    for (var i0 = 0, i1 = 0, previous, next2; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1)
          i1 = i0 + 1;
        while (!(next2 = updateGroup[i1]) && ++i1 < dataLength)
          ;
        previous._next = next2 || null;
      }
    }
  }
  update = new Selection$1(update, parents2);
  update._enter = enter;
  update._exit = exit;
  return update;
}
function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}
function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  enter = typeof onenter === "function" ? onenter(enter) : enter.append(onenter + "");
  if (onupdate != null)
    update = onupdate(update);
  if (onexit == null)
    exit.remove();
  else
    onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}
function selection_merge(selection2) {
  for (var groups0 = this._groups, groups1 = selection2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Selection$1(merges, this._parents);
}
function selection_order() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m; ) {
    for (var group = groups[j], i = group.length - 1, next2 = group[i], node2; --i >= 0; ) {
      if (node2 = group[i]) {
        if (next2 && node2.compareDocumentPosition(next2) ^ 4)
          next2.parentNode.insertBefore(node2, next2);
        next2 = node2;
      }
    }
  }
  return this;
}
function selection_sort(compare) {
  if (!compare)
    compare = ascending$2;
  function compareNode(a2, b) {
    return a2 && b ? compare(a2.__data__, b.__data__) : !a2 - !b;
  }
  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        sortgroup[i] = node2;
      }
    }
    sortgroup.sort(compareNode);
  }
  return new Selection$1(sortgroups, this._parents).order();
}
function ascending$2(a2, b) {
  return a2 < b ? -1 : a2 > b ? 1 : a2 >= b ? 0 : NaN;
}
function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
function selection_nodes() {
  var nodes = new Array(this.size()), i = -1;
  this.each(function() {
    nodes[++i] = this;
  });
  return nodes;
}
function selection_node() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node2 = group[i];
      if (node2)
        return node2;
    }
  }
  return null;
}
function selection_size() {
  var size = 0;
  this.each(function() {
    ++size;
  });
  return size;
}
function selection_empty() {
  return !this.node();
}
function selection_each(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node2; i < n; ++i) {
      if (node2 = group[i])
        callback.call(node2, node2.__data__, i, group);
    }
  }
  return this;
}
function attrRemove$1(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant$1(name2, value) {
  return function() {
    this.setAttribute(name2, value);
  };
}
function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}
function attrFunction$1(name2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttribute(name2);
    else
      this.setAttribute(name2, v);
  };
}
function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.removeAttributeNS(fullname.space, fullname.local);
    else
      this.setAttributeNS(fullname.space, fullname.local, v);
  };
}
function selection_attr(name2, value) {
  var fullname = namespace(name2);
  if (arguments.length < 2) {
    var node2 = this.node();
    return fullname.local ? node2.getAttributeNS(fullname.space, fullname.local) : node2.getAttribute(fullname);
  }
  return this.each((value == null ? fullname.local ? attrRemoveNS$1 : attrRemove$1 : typeof value === "function" ? fullname.local ? attrFunctionNS$1 : attrFunction$1 : fullname.local ? attrConstantNS$1 : attrConstant$1)(fullname, value));
}
function defaultView(node2) {
  return node2.ownerDocument && node2.ownerDocument.defaultView || node2.document && node2 || node2.defaultView;
}
function styleRemove$1(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant$1(name2, value, priority) {
  return function() {
    this.style.setProperty(name2, value, priority);
  };
}
function styleFunction$1(name2, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      this.style.removeProperty(name2);
    else
      this.style.setProperty(name2, v, priority);
  };
}
function selection_style(name2, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove$1 : typeof value === "function" ? styleFunction$1 : styleConstant$1)(name2, value, priority == null ? "" : priority)) : styleValue(this.node(), name2);
}
function styleValue(node2, name2) {
  return node2.style.getPropertyValue(name2) || defaultView(node2).getComputedStyle(node2, null).getPropertyValue(name2);
}
function propertyRemove(name2) {
  return function() {
    delete this[name2];
  };
}
function propertyConstant(name2, value) {
  return function() {
    this[name2] = value;
  };
}
function propertyFunction(name2, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null)
      delete this[name2];
    else
      this[name2] = v;
  };
}
function selection_property(name2, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name2, value)) : this.node()[name2];
}
function classArray(string) {
  return string.trim().split(/^|\s+/);
}
function classList(node2) {
  return node2.classList || new ClassList(node2);
}
function ClassList(node2) {
  this._node = node2;
  this._names = classArray(node2.getAttribute("class") || "");
}
ClassList.prototype = {
  add: function(name2) {
    var i = this._names.indexOf(name2);
    if (i < 0) {
      this._names.push(name2);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name2) {
    var i = this._names.indexOf(name2);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name2) {
    return this._names.indexOf(name2) >= 0;
  }
};
function classedAdd(node2, names) {
  var list2 = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list2.add(names[i]);
}
function classedRemove(node2, names) {
  var list2 = classList(node2), i = -1, n = names.length;
  while (++i < n)
    list2.remove(names[i]);
}
function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}
function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}
function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}
function selection_classed(name2, value) {
  var names = classArray(name2 + "");
  if (arguments.length < 2) {
    var list2 = classList(this.node()), i = -1, n = names.length;
    while (++i < n)
      if (!list2.contains(names[i]))
        return false;
    return true;
  }
  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
function textRemove() {
  this.textContent = "";
}
function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}
function selection_text(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction$1 : textConstant$1)(value)) : this.node().textContent;
}
function htmlRemove() {
  this.innerHTML = "";
}
function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}
function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}
function selection_html(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
function raise() {
  if (this.nextSibling)
    this.parentNode.appendChild(this);
}
function selection_raise() {
  return this.each(raise);
}
function lower() {
  if (this.previousSibling)
    this.parentNode.insertBefore(this, this.parentNode.firstChild);
}
function selection_lower() {
  return this.each(lower);
}
function selection_append(name2) {
  var create2 = typeof name2 === "function" ? name2 : creator(name2);
  return this.select(function() {
    return this.appendChild(create2.apply(this, arguments));
  });
}
function constantNull() {
  return null;
}
function selection_insert(name2, before) {
  var create2 = typeof name2 === "function" ? name2 : creator(name2), select2 = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create2.apply(this, arguments), select2.apply(this, arguments) || null);
  });
}
function remove() {
  var parent = this.parentNode;
  if (parent)
    parent.removeChild(this);
}
function selection_remove() {
  return this.each(remove);
}
function selection_cloneShallow() {
  var clone2 = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_cloneDeep() {
  var clone2 = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone2, this.nextSibling) : clone2;
}
function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
function selection_datum(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
var filterEvents = {};
var event = null;
if (typeof document !== "undefined") {
  var element = document.documentElement;
  if (!("onmouseenter" in element)) {
    filterEvents = { mouseenter: "mouseover", mouseleave: "mouseout" };
  }
}
function filterContextListener(listener, index2, group) {
  listener = contextListener(listener, index2, group);
  return function(event2) {
    var related = event2.relatedTarget;
    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event2);
    }
  };
}
function contextListener(listener, index2, group) {
  return function(event1) {
    var event0 = event;
    event = event1;
    try {
      listener.call(this, this.__data__, index2, group);
    } finally {
      event = event0;
    }
  };
}
function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name2 = "", i = t.indexOf(".");
    if (i >= 0)
      name2 = t.slice(i + 1), t = t.slice(0, i);
    return { type: t, name: name2 };
  });
}
function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on)
      return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }
    if (++i)
      on.length = i;
    else
      delete this.__on;
  };
}
function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function(d, i, group) {
    var on = this.__on, o, listener = wrap(value, i, group);
    if (on)
      for (var j = 0, m = on.length; j < m; ++j) {
        if ((o = on[j]).type === typename.type && o.name === typename.name) {
          this.removeEventListener(o.type, o.listener, o.capture);
          this.addEventListener(o.type, o.listener = listener, o.capture = capture);
          o.value = value;
          return;
        }
      }
    this.addEventListener(typename.type, listener, capture);
    o = { type: typename.type, name: typename.name, value, listener, capture };
    if (!on)
      this.__on = [o];
    else
      on.push(o);
  };
}
function selection_on(typename, value, capture) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;
  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on)
      for (var j = 0, m = on.length, o; j < m; ++j) {
        for (i = 0, o = on[j]; i < n; ++i) {
          if ((t = typenames[i]).type === o.type && t.name === o.name) {
            return o.value;
          }
        }
      }
    return;
  }
  on = value ? onAdd : onRemove;
  if (capture == null)
    capture = false;
  for (i = 0; i < n; ++i)
    this.each(on(typenames[i], value, capture));
  return this;
}
function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  event = event1;
  try {
    return listener.apply(that, args);
  } finally {
    event = event0;
  }
}
function dispatchEvent(node2, type2, params) {
  var window2 = defaultView(node2), event2 = window2.CustomEvent;
  if (typeof event2 === "function") {
    event2 = new event2(type2, params);
  } else {
    event2 = window2.document.createEvent("Event");
    if (params)
      event2.initEvent(type2, params.bubbles, params.cancelable), event2.detail = params.detail;
    else
      event2.initEvent(type2, false, false);
  }
  node2.dispatchEvent(event2);
}
function dispatchConstant(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params);
  };
}
function dispatchFunction(type2, params) {
  return function() {
    return dispatchEvent(this, type2, params.apply(this, arguments));
  };
}
function selection_dispatch(type2, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type2, params));
}
var root$2 = [null];
function Selection$1(groups, parents2) {
  this._groups = groups;
  this._parents = parents2;
}
function selection() {
  return new Selection$1([[document.documentElement]], root$2);
}
Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch
};
function select(selector2) {
  return typeof selector2 === "string" ? new Selection$1([[document.querySelector(selector2)]], [document.documentElement]) : new Selection$1([[selector2]], root$2);
}
function create$1(name2) {
  return select(creator(name2).call(document.documentElement));
}
var nextId = 0;
function local$1() {
  return new Local();
}
function Local() {
  this._ = "@" + (++nextId).toString(36);
}
Local.prototype = local$1.prototype = {
  constructor: Local,
  get: function(node2) {
    var id2 = this._;
    while (!(id2 in node2))
      if (!(node2 = node2.parentNode))
        return;
    return node2[id2];
  },
  set: function(node2, value) {
    return node2[this._] = value;
  },
  remove: function(node2) {
    return this._ in node2 && delete node2[this._];
  },
  toString: function() {
    return this._;
  }
};
function sourceEvent() {
  var current = event, source;
  while (source = current.sourceEvent)
    current = source;
  return current;
}
function point$6(node2, event2) {
  var svg2 = node2.ownerSVGElement || node2;
  if (svg2.createSVGPoint) {
    var point2 = svg2.createSVGPoint();
    point2.x = event2.clientX, point2.y = event2.clientY;
    point2 = point2.matrixTransform(node2.getScreenCTM().inverse());
    return [point2.x, point2.y];
  }
  var rect2 = node2.getBoundingClientRect();
  return [event2.clientX - rect2.left - node2.clientLeft, event2.clientY - rect2.top - node2.clientTop];
}
function mouse(node2) {
  var event2 = sourceEvent();
  if (event2.changedTouches)
    event2 = event2.changedTouches[0];
  return point$6(node2, event2);
}
function selectAll(selector2) {
  return typeof selector2 === "string" ? new Selection$1([document.querySelectorAll(selector2)], [document.documentElement]) : new Selection$1([selector2 == null ? [] : selector2], root$2);
}
function touch(node2, touches2, identifier2) {
  if (arguments.length < 3)
    identifier2 = touches2, touches2 = sourceEvent().changedTouches;
  for (var i = 0, n = touches2 ? touches2.length : 0, touch2; i < n; ++i) {
    if ((touch2 = touches2[i]).identifier === identifier2) {
      return point$6(node2, touch2);
    }
  }
  return null;
}
function touches(node2, touches2) {
  if (touches2 == null)
    touches2 = sourceEvent().touches;
  for (var i = 0, n = touches2 ? touches2.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = point$6(node2, touches2[i]);
  }
  return points;
}
function nopropagation$2() {
  event.stopImmediatePropagation();
}
function noevent$2() {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function dragDisable(view) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", noevent$2, true);
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", noevent$2, true);
  } else {
    root2.__noselect = root2.style.MozUserSelect;
    root2.style.MozUserSelect = "none";
  }
}
function yesdrag(view, noclick) {
  var root2 = view.document.documentElement, selection2 = select(view).on("dragstart.drag", null);
  if (noclick) {
    selection2.on("click.drag", noevent$2, true);
    setTimeout(function() {
      selection2.on("click.drag", null);
    }, 0);
  }
  if ("onselectstart" in root2) {
    selection2.on("selectstart.drag", null);
  } else {
    root2.style.MozUserSelect = root2.__noselect;
    delete root2.__noselect;
  }
}
function constant$b(x2) {
  return function() {
    return x2;
  };
}
function DragEvent(target, type2, subject, id2, active2, x2, y2, dx, dy, dispatch2) {
  this.target = target;
  this.type = type2;
  this.subject = subject;
  this.identifier = id2;
  this.active = active2;
  this.x = x2;
  this.y = y2;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch2;
}
DragEvent.prototype.on = function() {
  var value = this._.on.apply(this._, arguments);
  return value === this._ ? this : value;
};
function defaultFilter$2() {
  return !event.ctrlKey && !event.button;
}
function defaultContainer() {
  return this.parentNode;
}
function defaultSubject(d) {
  return d == null ? { x: event.x, y: event.y } : d;
}
function defaultTouchable$2() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function drag() {
  var filter = defaultFilter$2, container = defaultContainer, subject = defaultSubject, touchable = defaultTouchable$2, gestures = {}, listeners = dispatch("start", "drag", "end"), active2 = 0, mousedownx, mousedowny, mousemoving, touchending, clickDistance2 = 0;
  function drag2(selection2) {
    selection2.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  function mousedowned() {
    if (touchending || !filter.apply(this, arguments))
      return;
    var gesture = beforestart("mouse", container.apply(this, arguments), mouse, this, arguments);
    if (!gesture)
      return;
    select(event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    dragDisable(event.view);
    nopropagation$2();
    mousemoving = false;
    mousedownx = event.clientX;
    mousedowny = event.clientY;
    gesture("start");
  }
  function mousemoved() {
    noevent$2();
    if (!mousemoving) {
      var dx = event.clientX - mousedownx, dy = event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }
    gestures.mouse("drag");
  }
  function mouseupped() {
    select(event.view).on("mousemove.drag mouseup.drag", null);
    yesdrag(event.view, mousemoving);
    noevent$2();
    gestures.mouse("end");
  }
  function touchstarted() {
    if (!filter.apply(this, arguments))
      return;
    var touches2 = event.changedTouches, c2 = container.apply(this, arguments), n = touches2.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches2[i].identifier, c2, touch, this, arguments)) {
        nopropagation$2();
        gesture("start");
      }
    }
  }
  function touchmoved() {
    var touches2 = event.changedTouches, n = touches2.length, i, gesture;
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches2[i].identifier]) {
        noevent$2();
        gesture("drag");
      }
    }
  }
  function touchended() {
    var touches2 = event.changedTouches, n = touches2.length, i, gesture;
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, 500);
    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches2[i].identifier]) {
        nopropagation$2();
        gesture("end");
      }
    }
  }
  function beforestart(id2, container2, point2, that, args) {
    var p = point2(container2, id2), s2, dx, dy, sublisteners = listeners.copy();
    if (!customEvent(new DragEvent(drag2, "beforestart", s2, id2, active2, p[0], p[1], 0, 0, sublisteners), function() {
      if ((event.subject = s2 = subject.apply(that, args)) == null)
        return false;
      dx = s2.x - p[0] || 0;
      dy = s2.y - p[1] || 0;
      return true;
    }))
      return;
    return function gesture(type2) {
      var p02 = p, n;
      switch (type2) {
        case "start":
          gestures[id2] = gesture, n = active2++;
          break;
        case "end":
          delete gestures[id2], --active2;
        case "drag":
          p = point2(container2, id2), n = active2;
          break;
      }
      customEvent(new DragEvent(drag2, type2, s2, id2, n, p[0] + dx, p[1] + dy, p[0] - p02[0], p[1] - p02[1], sublisteners), sublisteners.apply, sublisteners, [type2, that, args]);
    };
  }
  drag2.filter = function(_2) {
    return arguments.length ? (filter = typeof _2 === "function" ? _2 : constant$b(!!_2), drag2) : filter;
  };
  drag2.container = function(_2) {
    return arguments.length ? (container = typeof _2 === "function" ? _2 : constant$b(_2), drag2) : container;
  };
  drag2.subject = function(_2) {
    return arguments.length ? (subject = typeof _2 === "function" ? _2 : constant$b(_2), drag2) : subject;
  };
  drag2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$b(!!_2), drag2) : touchable;
  };
  drag2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag2 : value;
  };
  drag2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, drag2) : Math.sqrt(clickDistance2);
  };
  return drag2;
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a2) {
  if (a2 <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a2 = this.opacity;
  a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
  return (a2 === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a2 === 1 ? ")" : ", " + a2 + ")");
}
function hex(value) {
  value = Math.max(0, Math.min(255, Math.round(value) || 0));
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h, s2, l, a2) {
  if (a2 <= 0)
    h = s2 = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s2 = NaN;
  else if (s2 <= 0)
    h = NaN;
  return new Hsl(h, s2, l, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s2 = max2 - min2, l = (max2 + min2) / 2;
  if (s2) {
    if (r === max2)
      h = (g - b) / s2 + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s2 + 2;
    else
      h = (r - g) / s2 + 4;
    s2 /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s2 = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s2, l, o.opacity);
}
function hsl$2(h, s2, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s2, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl$2, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s2, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a2 = this.opacity;
    a2 = isNaN(a2) ? 1 : Math.max(0, Math.min(1, a2));
    return (a2 === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a2 === 1 ? ")" : ", " + a2 + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
var deg2rad = Math.PI / 180;
var rad2deg = 180 / Math.PI;
var K = 18, Xn = 0.96422, Yn = 1, Zn = 0.82521, t0$1 = 4 / 29, t1$1 = 6 / 29, t2 = 3 * t1$1 * t1$1, t3 = t1$1 * t1$1 * t1$1;
function labConvert(o) {
  if (o instanceof Lab)
    return new Lab(o.l, o.a, o.b, o.opacity);
  if (o instanceof Hcl)
    return hcl2lab(o);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = rgb2lrgb(o.r), g = rgb2lrgb(o.g), b = rgb2lrgb(o.b), y2 = xyz2lab((0.2225045 * r + 0.7168786 * g + 0.0606169 * b) / Yn), x2, z;
  if (r === g && g === b)
    x2 = z = y2;
  else {
    x2 = xyz2lab((0.4360747 * r + 0.3850649 * g + 0.1430804 * b) / Xn);
    z = xyz2lab((0.0139322 * r + 0.0971045 * g + 0.7141733 * b) / Zn);
  }
  return new Lab(116 * y2 - 16, 500 * (x2 - y2), 200 * (y2 - z), o.opacity);
}
function gray(l, opacity) {
  return new Lab(l, 0, 0, opacity == null ? 1 : opacity);
}
function lab$1(l, a2, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a2, b, opacity == null ? 1 : opacity);
}
function Lab(l, a2, b, opacity) {
  this.l = +l;
  this.a = +a2;
  this.b = +b;
  this.opacity = +opacity;
}
define(Lab, lab$1, extend(Color, {
  brighter: function(k2) {
    return new Lab(this.l + K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  darker: function(k2) {
    return new Lab(this.l - K * (k2 == null ? 1 : k2), this.a, this.b, this.opacity);
  },
  rgb: function() {
    var y2 = (this.l + 16) / 116, x2 = isNaN(this.a) ? y2 : y2 + this.a / 500, z = isNaN(this.b) ? y2 : y2 - this.b / 200;
    x2 = Xn * lab2xyz(x2);
    y2 = Yn * lab2xyz(y2);
    z = Zn * lab2xyz(z);
    return new Rgb(
      lrgb2rgb(3.1338561 * x2 - 1.6168667 * y2 - 0.4906146 * z),
      lrgb2rgb(-0.9787684 * x2 + 1.9161415 * y2 + 0.033454 * z),
      lrgb2rgb(0.0719453 * x2 - 0.2289914 * y2 + 1.4052427 * z),
      this.opacity
    );
  }
}));
function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0$1;
}
function lab2xyz(t) {
  return t > t1$1 ? t * t * t : t2 * (t - t0$1);
}
function lrgb2rgb(x2) {
  return 255 * (x2 <= 31308e-7 ? 12.92 * x2 : 1.055 * Math.pow(x2, 1 / 2.4) - 0.055);
}
function rgb2lrgb(x2) {
  return (x2 /= 255) <= 0.04045 ? x2 / 12.92 : Math.pow((x2 + 0.055) / 1.055, 2.4);
}
function hclConvert(o) {
  if (o instanceof Hcl)
    return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab))
    o = labConvert(o);
  if (o.a === 0 && o.b === 0)
    return new Hcl(NaN, 0 < o.l && o.l < 100 ? 0 : NaN, o.l, o.opacity);
  var h = Math.atan2(o.b, o.a) * rad2deg;
  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}
function lch(l, c2, h, opacity) {
  return arguments.length === 1 ? hclConvert(l) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
}
function hcl$2(h, c2, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c2, l, opacity == null ? 1 : opacity);
}
function Hcl(h, c2, l, opacity) {
  this.h = +h;
  this.c = +c2;
  this.l = +l;
  this.opacity = +opacity;
}
function hcl2lab(o) {
  if (isNaN(o.h))
    return new Lab(o.l, 0, 0, o.opacity);
  var h = o.h * deg2rad;
  return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
}
define(Hcl, hcl$2, extend(Color, {
  brighter: function(k2) {
    return new Hcl(this.h, this.c, this.l + K * (k2 == null ? 1 : k2), this.opacity);
  },
  darker: function(k2) {
    return new Hcl(this.h, this.c, this.l - K * (k2 == null ? 1 : k2), this.opacity);
  },
  rgb: function() {
    return hcl2lab(this).rgb();
  }
}));
var A = -0.14861, B = 1.78277, C = -0.29227, D = -0.90649, E = 1.97294, ED = E * D, EB = E * B, BC_DA = B * C - D * A;
function cubehelixConvert(o) {
  if (o instanceof Cubehelix)
    return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Rgb))
    o = rgbConvert(o);
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB), bl = b - l, k2 = (E * (g - l) - C * bl) / D, s2 = Math.sqrt(k2 * k2 + bl * bl) / (E * l * (1 - l)), h = s2 ? Math.atan2(k2, bl) * rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s2, l, o.opacity);
}
function cubehelix$3(h, s2, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s2, l, opacity == null ? 1 : opacity);
}
function Cubehelix(h, s2, l, opacity) {
  this.h = +h;
  this.s = +s2;
  this.l = +l;
  this.opacity = +opacity;
}
define(Cubehelix, cubehelix$3, extend(Color, {
  brighter: function(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  darker: function(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Cubehelix(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb: function() {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * deg2rad, l = +this.l, a2 = isNaN(this.s) ? 0 : this.s * l * (1 - l), cosh2 = Math.cos(h), sinh2 = Math.sin(h);
    return new Rgb(
      255 * (l + a2 * (A * cosh2 + B * sinh2)),
      255 * (l + a2 * (C * cosh2 + D * sinh2)),
      255 * (l + a2 * (E * cosh2)),
      this.opacity
    );
  }
}));
function basis$1(t12, v0, v1, v2, v3) {
  var t22 = t12 * t12, t32 = t22 * t12;
  return ((1 - 3 * t12 + 3 * t22 - t32) * v0 + (4 - 6 * t22 + 3 * t32) * v1 + (1 + 3 * t12 + 3 * t22 - 3 * t32) * v2 + t32 * v3) / 6;
}
function basis$2(values2) {
  var n = values2.length - 1;
  return function(t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n), v1 = values2[i], v2 = values2[i + 1], v0 = i > 0 ? values2[i - 1] : 2 * v1 - v2, v3 = i < n - 1 ? values2[i + 2] : 2 * v2 - v1;
    return basis$1((t - i / n) * n, v0, v1, v2, v3);
  };
}
function basisClosed$1(values2) {
  var n = values2.length;
  return function(t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n), v0 = values2[(i + n - 1) % n], v1 = values2[i % n], v2 = values2[(i + 1) % n], v3 = values2[(i + 2) % n];
    return basis$1((t - i / n) * n, v0, v1, v2, v3);
  };
}
function constant$a(x2) {
  return function() {
    return x2;
  };
}
function linear$2(a2, d) {
  return function(t) {
    return a2 + t * d;
  };
}
function exponential$1(a2, b, y2) {
  return a2 = Math.pow(a2, y2), b = Math.pow(b, y2) - a2, y2 = 1 / y2, function(t) {
    return Math.pow(a2 + t * b, y2);
  };
}
function hue$1(a2, b) {
  var d = b - a2;
  return d ? linear$2(a2, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$a(isNaN(a2) ? b : a2);
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b) {
    return b - a2 ? exponential$1(a2, b, y2) : constant$a(isNaN(a2) ? b : a2);
  };
}
function nogamma(a2, b) {
  var d = b - a2;
  return d ? linear$2(a2, d) : constant$a(isNaN(a2) ? b : a2);
}
const interpolateRgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb$1(start2, end2) {
    var r = color2((start2 = rgb(start2)).r, (end2 = rgb(end2)).r), g = color2(start2.g, end2.g), b = color2(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.r = r(t);
      start2.g = g(t);
      start2.b = b(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  }
  rgb$1.gamma = rgbGamma;
  return rgb$1;
}(1);
function rgbSpline(spline) {
  return function(colors2) {
    var n = colors2.length, r = new Array(n), g = new Array(n), b = new Array(n), i, color2;
    for (i = 0; i < n; ++i) {
      color2 = rgb(colors2[i]);
      r[i] = color2.r || 0;
      g[i] = color2.g || 0;
      b[i] = color2.b || 0;
    }
    r = spline(r);
    g = spline(g);
    b = spline(b);
    color2.opacity = 1;
    return function(t) {
      color2.r = r(t);
      color2.g = g(t);
      color2.b = b(t);
      return color2 + "";
    };
  };
}
var rgbBasis = rgbSpline(basis$2);
var rgbBasisClosed = rgbSpline(basisClosed$1);
function numberArray(a2, b) {
  if (!b)
    b = [];
  var n = a2 ? Math.min(b.length, a2.length) : 0, c2 = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c2[i] = a2[i] * (1 - t) + b[i] * t;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function array$2(a2, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a2, b);
}
function genericArray(a2, b) {
  var nb = b ? b.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = interpolateValue(a2[i], b[i]);
  for (; i < nb; ++i)
    c2[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c2[i] = x2[i](t);
    return c2;
  };
}
function date$1(a2, b) {
  var d = new Date();
  return a2 = +a2, b = +b, function(t) {
    return d.setTime(a2 * (1 - t) + b * t), d;
  };
}
function interpolateNumber(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return a2 * (1 - t) + b * t;
  };
}
function object$1(a2, b) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k2 in b) {
    if (k2 in a2) {
      i[k2] = interpolateValue(a2[k2], b[k2]);
    } else {
      c2[k2] = b[k2];
    }
  }
  return function(t) {
    for (k2 in i)
      c2[k2] = i[k2](t);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function interpolateString(a2, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q = [];
  a2 = a2 + "", b = b + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q.push({ i, x: interpolateNumber(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s2[(o = q[i2]).i] = o.x(t);
    return s2.join("");
  });
}
function interpolateValue(a2, b) {
  var t = typeof b, c2;
  return b == null || t === "boolean" ? constant$a(b) : (t === "number" ? interpolateNumber : t === "string" ? (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString : b instanceof color ? interpolateRgb : b instanceof Date ? date$1 : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1 : interpolateNumber)(a2, b);
}
function discrete(range2) {
  var n = range2.length;
  return function(t) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
function hue(a2, b) {
  var i = hue$1(+a2, +b);
  return function(t) {
    var x2 = i(t);
    return x2 - 360 * Math.floor(x2 / 360);
  };
}
function interpolateRound(a2, b) {
  return a2 = +a2, b = +b, function(t) {
    return Math.round(a2 * (1 - t) + b * t);
  };
}
var degrees$1 = 180 / Math.PI;
var identity$7 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
function decompose(a2, b, c2, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a2 * a2 + b * b))
    a2 /= scaleX, b /= scaleX;
  if (skewX = a2 * c2 + b * d)
    c2 -= a2 * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c2 * c2 + d * d))
    c2 /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a2 * d < b * c2)
    a2 = -a2, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a2) * degrees$1,
    skewX: Math.atan(skewX) * degrees$1,
    scaleX,
    scaleY
  };
}
var cssNode, cssRoot, cssView, svgNode;
function parseCss(value) {
  if (value === "none")
    return identity$7;
  if (!cssNode)
    cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return decompose(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}
function parseSvg(value) {
  if (value == null)
    return identity$7;
  if (!svgNode)
    svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate()))
    return identity$7;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}
function interpolateTransform(parse2, pxComma, pxParen, degParen) {
  function pop(s2) {
    return s2.length ? s2.pop() + " " : "";
  }
  function translate(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push("translate(", null, pxComma, null, pxParen);
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb || yb) {
      s2.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }
  function rotate(a2, b, s2, q) {
    if (a2 !== b) {
      if (a2 - b > 180)
        b += 360;
      else if (b - a2 > 180)
        a2 += 360;
      q.push({ i: s2.push(pop(s2) + "rotate(", null, degParen) - 2, x: interpolateNumber(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "rotate(" + b + degParen);
    }
  }
  function skewX(a2, b, s2, q) {
    if (a2 !== b) {
      q.push({ i: s2.push(pop(s2) + "skewX(", null, degParen) - 2, x: interpolateNumber(a2, b) });
    } else if (b) {
      s2.push(pop(s2) + "skewX(" + b + degParen);
    }
  }
  function scale(xa, ya, xb, yb, s2, q) {
    if (xa !== xb || ya !== yb) {
      var i = s2.push(pop(s2) + "scale(", null, ",", null, ")");
      q.push({ i: i - 4, x: interpolateNumber(xa, xb) }, { i: i - 2, x: interpolateNumber(ya, yb) });
    } else if (xb !== 1 || yb !== 1) {
      s2.push(pop(s2) + "scale(" + xb + "," + yb + ")");
    }
  }
  return function(a2, b) {
    var s2 = [], q = [];
    a2 = parse2(a2), b = parse2(b);
    translate(a2.translateX, a2.translateY, b.translateX, b.translateY, s2, q);
    rotate(a2.rotate, b.rotate, s2, q);
    skewX(a2.skewX, b.skewX, s2, q);
    scale(a2.scaleX, a2.scaleY, b.scaleX, b.scaleY, s2, q);
    a2 = b = null;
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n)
        s2[(o = q[i]).i] = o.x(t);
      return s2.join("");
    };
  };
}
var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");
var rho = Math.SQRT2, rho2 = 2, rho4 = 4, epsilon2$2 = 1e-12;
function cosh(x2) {
  return ((x2 = Math.exp(x2)) + 1 / x2) / 2;
}
function sinh(x2) {
  return ((x2 = Math.exp(x2)) - 1 / x2) / 2;
}
function tanh(x2) {
  return ((x2 = Math.exp(2 * x2)) - 1) / (x2 + 1);
}
function interpolateZoom(p02, p1) {
  var ux0 = p02[0], uy0 = p02[1], w0 = p02[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;
  if (d2 < epsilon2$2) {
    S = Math.log(w1 / w0) / rho;
    i = function(t) {
      return [
        ux0 + t * dx,
        uy0 + t * dy,
        w0 * Math.exp(rho * t * S)
      ];
    };
  } else {
    var d1 = Math.sqrt(d2), b02 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1), b12 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1), r0 = Math.log(Math.sqrt(b02 * b02 + 1) - b02), r1 = Math.log(Math.sqrt(b12 * b12 + 1) - b12);
    S = (r1 - r0) / rho;
    i = function(t) {
      var s2 = t * S, coshr0 = cosh(r0), u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s2 + r0) - sinh(r0));
      return [
        ux0 + u * dx,
        uy0 + u * dy,
        w0 * coshr0 / cosh(rho * s2 + r0)
      ];
    };
  }
  i.duration = S * 1e3;
  return i;
}
function hsl(hue2) {
  return function(start2, end2) {
    var h = hue2((start2 = hsl$2(start2)).h, (end2 = hsl$2(end2)).h), s2 = nogamma(start2.s, end2.s), l = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.h = h(t);
      start2.s = s2(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
const hsl$1 = hsl(hue$1);
var hslLong = hsl(nogamma);
function lab(start2, end2) {
  var l = nogamma((start2 = lab$1(start2)).l, (end2 = lab$1(end2)).l), a2 = nogamma(start2.a, end2.a), b = nogamma(start2.b, end2.b), opacity = nogamma(start2.opacity, end2.opacity);
  return function(t) {
    start2.l = l(t);
    start2.a = a2(t);
    start2.b = b(t);
    start2.opacity = opacity(t);
    return start2 + "";
  };
}
function hcl(hue2) {
  return function(start2, end2) {
    var h = hue2((start2 = hcl$2(start2)).h, (end2 = hcl$2(end2)).h), c2 = nogamma(start2.c, end2.c), l = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
    return function(t) {
      start2.h = h(t);
      start2.c = c2(t);
      start2.l = l(t);
      start2.opacity = opacity(t);
      return start2 + "";
    };
  };
}
const hcl$1 = hcl(hue$1);
var hclLong = hcl(nogamma);
function cubehelix$1(hue2) {
  return function cubehelixGamma(y2) {
    y2 = +y2;
    function cubehelix2(start2, end2) {
      var h = hue2((start2 = cubehelix$3(start2)).h, (end2 = cubehelix$3(end2)).h), s2 = nogamma(start2.s, end2.s), l = nogamma(start2.l, end2.l), opacity = nogamma(start2.opacity, end2.opacity);
      return function(t) {
        start2.h = h(t);
        start2.s = s2(t);
        start2.l = l(Math.pow(t, y2));
        start2.opacity = opacity(t);
        return start2 + "";
      };
    }
    cubehelix2.gamma = cubehelixGamma;
    return cubehelix2;
  }(1);
}
const cubehelix$2 = cubehelix$1(hue$1);
var cubehelixLong = cubehelix$1(nogamma);
function piecewise(interpolate2, values2) {
  var i = 0, n = values2.length - 1, v = values2[0], I = new Array(n < 0 ? 0 : n);
  while (i < n)
    I[i] = interpolate2(v, v = values2[++i]);
  return function(t) {
    var i2 = Math.max(0, Math.min(n - 1, Math.floor(t *= n)));
    return I[i2](t - i2);
  };
}
function quantize$1(interpolator, n) {
  var samples = new Array(n);
  for (var i = 0; i < n; ++i)
    samples[i] = interpolator(i / (n - 1));
  return samples;
}
var frame = 0, timeout$1 = 0, interval$1 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time2) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time2 = (time2 == null ? now() : +time2) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time2;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time2) {
  var t = new Timer();
  t.restart(callback, delay, time2);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t02, t12 = taskHead, t22, time2 = Infinity;
  while (t12) {
    if (t12._call) {
      if (time2 > t12._time)
        time2 = t12._time;
      t02 = t12, t12 = t12._next;
    } else {
      t22 = t12._next, t12._next = null;
      t12 = t02 ? t02._next = t22 : taskHead = t22;
    }
  }
  taskTail = t02;
  sleep(time2);
}
function sleep(time2) {
  if (frame)
    return;
  if (timeout$1)
    timeout$1 = clearTimeout(timeout$1);
  var delay = time2 - clockNow;
  if (delay > 24) {
    if (time2 < Infinity)
      timeout$1 = setTimeout(wake, time2 - clock.now() - clockSkew);
    if (interval$1)
      interval$1 = clearInterval(interval$1);
  } else {
    if (!interval$1)
      clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function timeout(callback, delay, time2) {
  var t = new Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function(elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time2);
  return t;
}
function interval(callback, delay, time2) {
  var t = new Timer(), total = delay;
  if (delay == null)
    return t.restart(callback, delay, time2), t;
  delay = +delay, time2 = time2 == null ? now() : +time2;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time2);
    callback(elapsed);
  }, delay, time2);
  return t;
}
var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];
var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;
function schedule(node2, name2, id2, index2, group, timing) {
  var schedules = node2.__transition;
  if (!schedules)
    node2.__transition = {};
  else if (id2 in schedules)
    return;
  create(node2, id2, {
    name: name2,
    index: index2,
    group,
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}
function init$1(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > CREATED)
    throw new Error("too late; already scheduled");
  return schedule2;
}
function set$1(node2, id2) {
  var schedule2 = get(node2, id2);
  if (schedule2.state > STARTED)
    throw new Error("too late; already running");
  return schedule2;
}
function get(node2, id2) {
  var schedule2 = node2.__transition;
  if (!schedule2 || !(schedule2 = schedule2[id2]))
    throw new Error("transition not found");
  return schedule2;
}
function create(node2, id2, self2) {
  var schedules = node2.__transition, tween;
  schedules[id2] = self2;
  self2.timer = timer(schedule2, 0, self2.time);
  function schedule2(elapsed) {
    self2.state = SCHEDULED;
    self2.timer.restart(start2, self2.delay, self2.time);
    if (self2.delay <= elapsed)
      start2(elapsed - self2.delay);
  }
  function start2(elapsed) {
    var i, j, n, o;
    if (self2.state !== SCHEDULED)
      return stop();
    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self2.name)
        continue;
      if (o.state === STARTED)
        return timeout(start2);
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      } else if (+i < id2) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node2, node2.__data__, o.index, o.group);
        delete schedules[i];
      }
    }
    timeout(function() {
      if (self2.state === STARTED) {
        self2.state = RUNNING;
        self2.timer.restart(tick, self2.delay, self2.time);
        tick(elapsed);
      }
    });
    self2.state = STARTING;
    self2.on.call("start", node2, node2.__data__, self2.index, self2.group);
    if (self2.state !== STARTING)
      return;
    self2.state = STARTED;
    tween = new Array(n = self2.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self2.tween[i].value.call(node2, node2.__data__, self2.index, self2.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }
  function tick(elapsed) {
    var t = elapsed < self2.duration ? self2.ease.call(null, elapsed / self2.duration) : (self2.timer.restart(stop), self2.state = ENDING, 1), i = -1, n = tween.length;
    while (++i < n) {
      tween[i].call(node2, t);
    }
    if (self2.state === ENDING) {
      self2.on.call("end", node2, node2.__data__, self2.index, self2.group);
      stop();
    }
  }
  function stop() {
    self2.state = ENDED;
    self2.timer.stop();
    delete schedules[id2];
    for (var i in schedules)
      return;
    delete node2.__transition;
  }
}
function interrupt(node2, name2) {
  var schedules = node2.__transition, schedule2, active2, empty2 = true, i;
  if (!schedules)
    return;
  name2 = name2 == null ? null : name2 + "";
  for (i in schedules) {
    if ((schedule2 = schedules[i]).name !== name2) {
      empty2 = false;
      continue;
    }
    active2 = schedule2.state > STARTING && schedule2.state < ENDING;
    schedule2.state = ENDED;
    schedule2.timer.stop();
    schedule2.on.call(active2 ? "interrupt" : "cancel", node2, node2.__data__, schedule2.index, schedule2.group);
    delete schedules[i];
  }
  if (empty2)
    delete node2.__transition;
}
function selection_interrupt(name2) {
  return this.each(function() {
    interrupt(this, name2);
  });
}
function tweenRemove(id2, name2) {
  var tween0, tween1;
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }
    schedule2.tween = tween1;
  };
}
function tweenFunction(id2, name2, value) {
  var tween0, tween1;
  if (typeof value !== "function")
    throw new Error();
  return function() {
    var schedule2 = set$1(this, id2), tween = schedule2.tween;
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = { name: name2, value }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name2) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n)
        tween1.push(t);
    }
    schedule2.tween = tween1;
  };
}
function transition_tween(name2, value) {
  var id2 = this._id;
  name2 += "";
  if (arguments.length < 2) {
    var tween = get(this.node(), id2).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name2) {
        return t.value;
      }
    }
    return null;
  }
  return this.each((value == null ? tweenRemove : tweenFunction)(id2, name2, value));
}
function tweenValue(transition2, name2, value) {
  var id2 = transition2._id;
  transition2.each(function() {
    var schedule2 = set$1(this, id2);
    (schedule2.value || (schedule2.value = {}))[name2] = value.apply(this, arguments);
  });
  return function(node2) {
    return get(node2, id2).value[name2];
  };
}
function interpolate$1(a2, b) {
  var c2;
  return (typeof b === "number" ? interpolateNumber : b instanceof color ? interpolateRgb : (c2 = color(b)) ? (b = c2, interpolateRgb) : interpolateString)(a2, b);
}
function attrRemove(name2) {
  return function() {
    this.removeAttribute(name2);
  };
}
function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}
function attrConstant(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttribute(name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrConstantNS(fullname, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function attrFunction(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttribute(name2);
    string0 = this.getAttribute(name2);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function attrFunctionNS(fullname, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null)
      return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function transition_attr(name2, value) {
  var fullname = namespace(name2), i = fullname === "transform" ? interpolateTransformSvg : interpolate$1;
  return this.attrTween(name2, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name2, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}
function attrInterpolate(name2, i) {
  return function(t) {
    this.setAttribute(name2, i.call(this, t));
  };
}
function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}
function attrTweenNS(fullname, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function attrTween(name2, value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && attrInterpolate(name2, i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function transition_attrTween(name2, value) {
  var key = "attr." + name2;
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  var fullname = namespace(name2);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
function delayFunction(id2, value) {
  return function() {
    init$1(this, id2).delay = +value.apply(this, arguments);
  };
}
function delayConstant(id2, value) {
  return value = +value, function() {
    init$1(this, id2).delay = value;
  };
}
function transition_delay(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id2, value)) : get(this.node(), id2).delay;
}
function durationFunction(id2, value) {
  return function() {
    set$1(this, id2).duration = +value.apply(this, arguments);
  };
}
function durationConstant(id2, value) {
  return value = +value, function() {
    set$1(this, id2).duration = value;
  };
}
function transition_duration(value) {
  var id2 = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id2, value)) : get(this.node(), id2).duration;
}
function easeConstant(id2, value) {
  if (typeof value !== "function")
    throw new Error();
  return function() {
    set$1(this, id2).ease = value;
  };
}
function transition_ease(value) {
  var id2 = this._id;
  return arguments.length ? this.each(easeConstant(id2, value)) : get(this.node(), id2).ease;
}
function transition_filter(match) {
  if (typeof match !== "function")
    match = matcher(match);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node2, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && match.call(node2, node2.__data__, i, group)) {
        subgroup.push(node2);
      }
    }
  }
  return new Transition(subgroups, this._parents, this._name, this._id);
}
function transition_merge(transition2) {
  if (transition2._id !== this._id)
    throw new Error();
  for (var groups0 = this._groups, groups1 = transition2._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge2 = merges[j] = new Array(n), node2, i = 0; i < n; ++i) {
      if (node2 = group0[i] || group1[i]) {
        merge2[i] = node2;
      }
    }
  }
  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }
  return new Transition(merges, this._parents, this._name, this._id);
}
function start$1(name2) {
  return (name2 + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0)
      t = t.slice(0, i);
    return !t || t === "start";
  });
}
function onFunction(id2, name2, listener) {
  var on0, on1, sit = start$1(name2) ? init$1 : set$1;
  return function() {
    var schedule2 = sit(this, id2), on = schedule2.on;
    if (on !== on0)
      (on1 = (on0 = on).copy()).on(name2, listener);
    schedule2.on = on1;
  };
}
function transition_on(name2, listener) {
  var id2 = this._id;
  return arguments.length < 2 ? get(this.node(), id2).on.on(name2) : this.each(onFunction(id2, name2, listener));
}
function removeFunction(id2) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition)
      if (+i !== id2)
        return;
    if (parent)
      parent.removeChild(this);
  };
}
function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}
function transition_select(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selector(select2);
  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node2, subnode, i = 0; i < n; ++i) {
      if ((node2 = group[i]) && (subnode = select2.call(node2, node2.__data__, i, group))) {
        if ("__data__" in node2)
          subnode.__data__ = node2.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name2, id2, i, subgroup, get(node2, id2));
      }
    }
  }
  return new Transition(subgroups, this._parents, name2, id2);
}
function transition_selectAll(select2) {
  var name2 = this._name, id2 = this._id;
  if (typeof select2 !== "function")
    select2 = selectorAll(select2);
  for (var groups = this._groups, m = groups.length, subgroups = [], parents2 = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        for (var children = select2.call(node2, node2.__data__, i, group), child, inherit2 = get(node2, id2), k2 = 0, l = children.length; k2 < l; ++k2) {
          if (child = children[k2]) {
            schedule(child, name2, id2, k2, children, inherit2);
          }
        }
        subgroups.push(children);
        parents2.push(node2);
      }
    }
  }
  return new Transition(subgroups, parents2, name2, id2);
}
var Selection = selection.prototype.constructor;
function transition_selection() {
  return new Selection(this._groups, this._parents);
}
function styleNull(name2, interpolate2) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), string1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, string10 = string1);
  };
}
function styleRemove(name2) {
  return function() {
    this.style.removeProperty(name2);
  };
}
function styleConstant(name2, interpolate2, value1) {
  var string00, string1 = value1 + "", interpolate0;
  return function() {
    var string0 = styleValue(this, name2);
    return string0 === string1 ? null : string0 === string00 ? interpolate0 : interpolate0 = interpolate2(string00 = string0, value1);
  };
}
function styleFunction(name2, interpolate2, value) {
  var string00, string10, interpolate0;
  return function() {
    var string0 = styleValue(this, name2), value1 = value(this), string1 = value1 + "";
    if (value1 == null)
      string1 = value1 = (this.style.removeProperty(name2), styleValue(this, name2));
    return string0 === string1 ? null : string0 === string00 && string1 === string10 ? interpolate0 : (string10 = string1, interpolate0 = interpolate2(string00 = string0, value1));
  };
}
function styleMaybeRemove(id2, name2) {
  var on0, on1, listener0, key = "style." + name2, event2 = "end." + key, remove2;
  return function() {
    var schedule2 = set$1(this, id2), on = schedule2.on, listener = schedule2.value[key] == null ? remove2 || (remove2 = styleRemove(name2)) : void 0;
    if (on !== on0 || listener0 !== listener)
      (on1 = (on0 = on).copy()).on(event2, listener0 = listener);
    schedule2.on = on1;
  };
}
function transition_style(name2, value, priority) {
  var i = (name2 += "") === "transform" ? interpolateTransformCss : interpolate$1;
  return value == null ? this.styleTween(name2, styleNull(name2, i)).on("end.style." + name2, styleRemove(name2)) : typeof value === "function" ? this.styleTween(name2, styleFunction(name2, i, tweenValue(this, "style." + name2, value))).each(styleMaybeRemove(this._id, name2)) : this.styleTween(name2, styleConstant(name2, i, value), priority).on("end.style." + name2, null);
}
function styleInterpolate(name2, i, priority) {
  return function(t) {
    this.style.setProperty(name2, i.call(this, t), priority);
  };
}
function styleTween(name2, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t = (i0 = i) && styleInterpolate(name2, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}
function transition_styleTween(name2, value, priority) {
  var key = "style." + (name2 += "");
  if (arguments.length < 2)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, styleTween(name2, value, priority == null ? "" : priority));
}
function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}
function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}
function transition_text(value) {
  return this.tween("text", typeof value === "function" ? textFunction(tweenValue(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}
function textTween(value) {
  var t02, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0)
      t02 = (i0 = i) && textInterpolate(i);
    return t02;
  }
  tween._value = value;
  return tween;
}
function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1)
    return (key = this.tween(key)) && key._value;
  if (value == null)
    return this.tween(key, null);
  if (typeof value !== "function")
    throw new Error();
  return this.tween(key, textTween(value));
}
function transition_transition() {
  var name2 = this._name, id0 = this._id, id1 = newId();
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        var inherit2 = get(node2, id0);
        schedule(node2, name2, id1, i, group, {
          time: inherit2.time + inherit2.delay + inherit2.duration,
          delay: 0,
          duration: inherit2.duration,
          ease: inherit2.ease
        });
      }
    }
  }
  return new Transition(groups, this._parents, name2, id1);
}
function transition_end() {
  var on0, on1, that = this, id2 = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = { value: reject }, end2 = { value: function() {
      if (--size === 0)
        resolve();
    } };
    that.each(function() {
      var schedule2 = set$1(this, id2), on = schedule2.on;
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end2);
      }
      schedule2.on = on1;
    });
  });
}
var id = 0;
function Transition(groups, parents2, name2, id2) {
  this._groups = groups;
  this._parents = parents2;
  this._name = name2;
  this._id = id2;
}
function transition(name2) {
  return selection().transition(name2);
}
function newId() {
  return ++id;
}
var selection_prototype = selection.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  end: transition_end
};
function linear$1(t) {
  return +t;
}
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var exponent$1 = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent$1);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent$1);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent$1);
var pi$4 = Math.PI, halfPi$3 = pi$4 / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi$3);
}
function sinOut(t) {
  return Math.sin(t * halfPi$3);
}
function sinInOut(t) {
  return (1 - Math.cos(pi$4 * t)) / 2;
}
function tpmt(x2) {
  return (Math.pow(2, -10 * x2) - 9765625e-10) * 1.0009775171065494;
}
function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}
var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}
var overshoot = 1.70158;
var backIn = function custom4(s2) {
  s2 = +s2;
  function backIn2(t) {
    return (t = +t) * t * (s2 * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s2) {
  s2 = +s2;
  function backOut2(t) {
    return --t * t * ((t + 1) * s2 + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s2) {
  s2 = +s2;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s2 + 1) * t - s2) : (t -= 2) * t * ((s2 + 1) * t + s2) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);
var tau$4 = 2 * Math.PI, amplitude = 1, period = 0.3;
var elasticIn = function custom7(a2, p) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$4);
  function elasticIn2(t) {
    return a2 * tpmt(- --t) * Math.sin((s2 - t) / p);
  }
  elasticIn2.amplitude = function(a3) {
    return custom7(a3, p * tau$4);
  };
  elasticIn2.period = function(p2) {
    return custom7(a2, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a2, p) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$4);
  function elasticOut2(t) {
    return 1 - a2 * tpmt(t = +t) * Math.sin((t + s2) / p);
  }
  elasticOut2.amplitude = function(a3) {
    return custom8(a3, p * tau$4);
  };
  elasticOut2.period = function(p2) {
    return custom8(a2, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a2, p) {
  var s2 = Math.asin(1 / (a2 = Math.max(1, a2))) * (p /= tau$4);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a2 * tpmt(-t) * Math.sin((s2 - t) / p) : 2 - a2 * tpmt(t) * Math.sin((s2 + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a3) {
    return custom9(a3, p * tau$4);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a2, p2);
  };
  return elasticInOut2;
}(amplitude, period);
var defaultTiming = {
  time: null,
  delay: 0,
  duration: 250,
  ease: cubicInOut
};
function inherit(node2, id2) {
  var timing;
  while (!(timing = node2.__transition) || !(timing = timing[id2])) {
    if (!(node2 = node2.parentNode)) {
      return defaultTiming.time = now(), defaultTiming;
    }
  }
  return timing;
}
function selection_transition(name2) {
  var id2, timing;
  if (name2 instanceof Transition) {
    id2 = name2._id, name2 = name2._name;
  } else {
    id2 = newId(), (timing = defaultTiming).time = now(), name2 = name2 == null ? null : name2 + "";
  }
  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node2, i = 0; i < n; ++i) {
      if (node2 = group[i]) {
        schedule(node2, name2, id2, i, group, timing || inherit(node2, id2));
      }
    }
  }
  return new Transition(groups, this._parents, name2, id2);
}
selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;
var root$1 = [null];
function active(node2, name2) {
  var schedules = node2.__transition, schedule2, i;
  if (schedules) {
    name2 = name2 == null ? null : name2 + "";
    for (i in schedules) {
      if ((schedule2 = schedules[i]).state > SCHEDULED && schedule2.name === name2) {
        return new Transition([[node2]], root$1, name2, +i);
      }
    }
  }
  return null;
}
function constant$9(x2) {
  return function() {
    return x2;
  };
}
function BrushEvent(target, type2, selection2) {
  this.target = target;
  this.type = type2;
  this.selection = selection2;
}
function nopropagation$1() {
  event.stopImmediatePropagation();
}
function noevent$1() {
  event.preventDefault();
  event.stopImmediatePropagation();
}
var MODE_DRAG = { name: "drag" }, MODE_SPACE = { name: "space" }, MODE_HANDLE = { name: "handle" }, MODE_CENTER = { name: "center" };
function number1(e) {
  return [+e[0], +e[1]];
}
function number2(e) {
  return [number1(e[0]), number1(e[1])];
}
function toucher(identifier2) {
  return function(target) {
    return touch(target, event.touches, identifier2);
  };
}
var X = {
  name: "x",
  handles: ["w", "e"].map(type$1),
  input: function(x2, e) {
    return x2 == null ? null : [[+x2[0], e[0][1]], [+x2[1], e[1][1]]];
  },
  output: function(xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type$1),
  input: function(y2, e) {
    return y2 == null ? null : [[e[0][0], +y2[0]], [e[1][0], +y2[1]]];
  },
  output: function(xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(type$1),
  input: function(xy) {
    return xy == null ? null : number2(xy);
  },
  output: function(xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: 1,
  selection: 1,
  n: null,
  e: 1,
  s: null,
  w: -1,
  nw: -1,
  ne: 1,
  se: 1,
  sw: -1
};
var signsY = {
  overlay: 1,
  selection: 1,
  n: -1,
  e: null,
  s: 1,
  w: null,
  nw: -1,
  ne: -1,
  se: 1,
  sw: 1
};
function type$1(t) {
  return { type: t };
}
function defaultFilter$1() {
  return !event.ctrlKey && !event.button;
}
function defaultExtent$1() {
  var svg2 = this.ownerSVGElement || this;
  if (svg2.hasAttribute("viewBox")) {
    svg2 = svg2.viewBox.baseVal;
    return [[svg2.x, svg2.y], [svg2.x + svg2.width, svg2.y + svg2.height]];
  }
  return [[0, 0], [svg2.width.baseVal.value, svg2.height.baseVal.value]];
}
function defaultTouchable$1() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function local(node2) {
  while (!node2.__brush)
    if (!(node2 = node2.parentNode))
      return;
  return node2.__brush;
}
function empty(extent2) {
  return extent2[0][0] === extent2[1][0] || extent2[0][1] === extent2[1][1];
}
function brushSelection(node2) {
  var state = node2.__brush;
  return state ? state.dim.output(state.selection) : null;
}
function brushX() {
  return brush$1(X);
}
function brushY() {
  return brush$1(Y);
}
function brush() {
  return brush$1(XY);
}
function brush$1(dim) {
  var extent2 = defaultExtent$1, filter = defaultFilter$1, touchable = defaultTouchable$1, keys2 = true, listeners = dispatch("start", "brush", "end"), handleSize = 6, touchending;
  function brush2(group) {
    var overlay = group.property("__brush", initialize2).selectAll(".overlay").data([type$1("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function() {
      var extent3 = local(this).extent;
      select(this).attr("x", extent3[0][0]).attr("y", extent3[0][1]).attr("width", extent3[1][0] - extent3[0][0]).attr("height", extent3[1][1] - extent3[0][1]);
    });
    group.selectAll(".selection").data([type$1("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function(d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function(d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function(d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").on("mousedown.brush", started).filter(touchable).on("touchstart.brush", started).on("touchmove.brush", touchmoved).on("touchend.brush touchcancel.brush", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  brush2.move = function(group, selection2) {
    if (group.selection) {
      group.on("start.brush", function() {
        emitter(this, arguments).beforestart().start();
      }).on("interrupt.brush end.brush", function() {
        emitter(this, arguments).end();
      }).tween("brush", function() {
        var that = this, state = that.__brush, emit = emitter(that, arguments), selection0 = state.selection, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(this, arguments) : selection2, state.extent), i = interpolateValue(selection0, selection1);
        function tween(t) {
          state.selection = t === 1 && selection1 === null ? null : i(t);
          redraw.call(that);
          emit.brush();
        }
        return selection0 !== null && selection1 !== null ? tween : tween(1);
      });
    } else {
      group.each(function() {
        var that = this, args = arguments, state = that.__brush, selection1 = dim.input(typeof selection2 === "function" ? selection2.apply(that, args) : selection2, state.extent), emit = emitter(that, args).beforestart();
        interrupt(that);
        state.selection = selection1 === null ? null : selection1;
        redraw.call(that);
        emit.start().brush().end();
      });
    }
  };
  brush2.clear = function(group) {
    brush2.move(group, null);
  };
  function redraw() {
    var group = select(this), selection2 = local(this).selection;
    if (selection2) {
      group.selectAll(".selection").style("display", null).attr("x", selection2[0][0]).attr("y", selection2[0][1]).attr("width", selection2[1][0] - selection2[0][0]).attr("height", selection2[1][1] - selection2[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function(d) {
        return d.type[d.type.length - 1] === "e" ? selection2[1][0] - handleSize / 2 : selection2[0][0] - handleSize / 2;
      }).attr("y", function(d) {
        return d.type[0] === "s" ? selection2[1][1] - handleSize / 2 : selection2[0][1] - handleSize / 2;
      }).attr("width", function(d) {
        return d.type === "n" || d.type === "s" ? selection2[1][0] - selection2[0][0] + handleSize : handleSize;
      }).attr("height", function(d) {
        return d.type === "e" || d.type === "w" ? selection2[1][1] - selection2[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }
  function emitter(that, args, clean) {
    var emit = that.__brush.emitter;
    return emit && (!clean || !emit.clean) ? emit : new Emitter(that, args, clean);
  }
  function Emitter(that, args, clean) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
    this.clean = clean;
  }
  Emitter.prototype = {
    beforestart: function() {
      if (++this.active === 1)
        this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function() {
      if (this.starting)
        this.starting = false, this.emit("start");
      else
        this.emit("brush");
      return this;
    },
    brush: function() {
      this.emit("brush");
      return this;
    },
    end: function() {
      if (--this.active === 0)
        delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function(type2) {
      customEvent(new BrushEvent(brush2, type2, dim.output(this.state.selection)), listeners.apply, listeners, [type2, this.that, this.args]);
    }
  };
  function started() {
    if (touchending && !event.touches)
      return;
    if (!filter.apply(this, arguments))
      return;
    var that = this, type2 = event.target.__data__.type, mode = (keys2 && event.metaKey ? type2 = "overlay" : type2) === "selection" ? MODE_DRAG : keys2 && event.altKey ? MODE_CENTER : MODE_HANDLE, signX = dim === Y ? null : signsX[type2], signY = dim === X ? null : signsY[type2], state = local(that), extent3 = state.extent, selection2 = state.selection, W = extent3[0][0], w0, w1, N = extent3[0][1], n0, n1, E2 = extent3[1][0], e0, e1, S = extent3[1][1], s0, s1, dx = 0, dy = 0, moving, shifting = signX && signY && keys2 && event.shiftKey, lockX, lockY, pointer = event.touches ? toucher(event.changedTouches[0].identifier) : mouse, point0 = pointer(that), point2 = point0, emit = emitter(that, arguments, true).beforestart();
    if (type2 === "overlay") {
      if (selection2)
        moving = true;
      state.selection = selection2 = [
        [w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]],
        [e0 = dim === Y ? E2 : w0, s0 = dim === X ? S : n0]
      ];
    } else {
      w0 = selection2[0][0];
      n0 = selection2[0][1];
      e0 = selection2[1][0];
      s0 = selection2[1][1];
    }
    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = select(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type2]);
    if (event.touches) {
      emit.moved = moved;
      emit.ended = ended;
    } else {
      var view = select(event.view).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      if (keys2)
        view.on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true);
      dragDisable(event.view);
    }
    nopropagation$1();
    interrupt(that);
    redraw.call(that);
    emit.start();
    function moved() {
      var point1 = pointer(that);
      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point2[0]) > Math.abs(point1[1] - point2[1]))
          lockY = true;
        else
          lockX = true;
      }
      point2 = point1;
      moving = true;
      noevent$1();
      move();
    }
    function move() {
      var t;
      dx = point2[0] - point0[0];
      dy = point2[1] - point0[1];
      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG: {
          if (signX)
            dx = Math.max(W - w0, Math.min(E2 - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
          if (signY)
            dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
          break;
        }
        case MODE_HANDLE: {
          if (signX < 0)
            dx = Math.max(W - w0, Math.min(E2 - w0, dx)), w1 = w0 + dx, e1 = e0;
          else if (signX > 0)
            dx = Math.max(W - e0, Math.min(E2 - e0, dx)), w1 = w0, e1 = e0 + dx;
          if (signY < 0)
            dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;
          else if (signY > 0)
            dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
          break;
        }
        case MODE_CENTER: {
          if (signX)
            w1 = Math.max(W, Math.min(E2, w0 - dx * signX)), e1 = Math.max(W, Math.min(E2, e0 + dx * signX));
          if (signY)
            n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
          break;
        }
      }
      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type2 in flipX)
          overlay.attr("cursor", cursors[type2 = flipX[type2]]);
      }
      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type2 in flipY)
          overlay.attr("cursor", cursors[type2 = flipY[type2]]);
      }
      if (state.selection)
        selection2 = state.selection;
      if (lockX)
        w1 = selection2[0][0], e1 = selection2[1][0];
      if (lockY)
        n1 = selection2[0][1], s1 = selection2[1][1];
      if (selection2[0][0] !== w1 || selection2[0][1] !== n1 || selection2[1][0] !== e1 || selection2[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }
    function ended() {
      nopropagation$1();
      if (event.touches) {
        if (event.touches.length)
          return;
        if (touchending)
          clearTimeout(touchending);
        touchending = setTimeout(function() {
          touchending = null;
        }, 500);
      } else {
        yesdrag(event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }
      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection)
        selection2 = state.selection;
      if (empty(selection2))
        state.selection = null, redraw.call(that);
      emit.end();
    }
    function keydowned() {
      switch (event.keyCode) {
        case 16: {
          shifting = signX && signY;
          break;
        }
        case 18: {
          if (mode === MODE_HANDLE) {
            if (signX)
              e0 = e1 - dx * signX, w0 = w1 + dx * signX;
            if (signY)
              s0 = s1 - dy * signY, n0 = n1 + dy * signY;
            mode = MODE_CENTER;
            move();
          }
          break;
        }
        case 32: {
          if (mode === MODE_HANDLE || mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1 - dx;
            else if (signX > 0)
              w0 = w1 - dx;
            if (signY < 0)
              s0 = s1 - dy;
            else if (signY > 0)
              n0 = n1 - dy;
            mode = MODE_SPACE;
            overlay.attr("cursor", cursors.selection);
            move();
          }
          break;
        }
        default:
          return;
      }
      noevent$1();
    }
    function keyupped() {
      switch (event.keyCode) {
        case 16: {
          if (shifting) {
            lockX = lockY = shifting = false;
            move();
          }
          break;
        }
        case 18: {
          if (mode === MODE_CENTER) {
            if (signX < 0)
              e0 = e1;
            else if (signX > 0)
              w0 = w1;
            if (signY < 0)
              s0 = s1;
            else if (signY > 0)
              n0 = n1;
            mode = MODE_HANDLE;
            move();
          }
          break;
        }
        case 32: {
          if (mode === MODE_SPACE) {
            if (event.altKey) {
              if (signX)
                e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY)
                s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
            } else {
              if (signX < 0)
                e0 = e1;
              else if (signX > 0)
                w0 = w1;
              if (signY < 0)
                s0 = s1;
              else if (signY > 0)
                n0 = n1;
              mode = MODE_HANDLE;
            }
            overlay.attr("cursor", cursors[type2]);
            move();
          }
          break;
        }
        default:
          return;
      }
      noevent$1();
    }
  }
  function touchmoved() {
    emitter(this, arguments).moved();
  }
  function touchended() {
    emitter(this, arguments).ended();
  }
  function initialize2() {
    var state = this.__brush || { selection: null };
    state.extent = number2(extent2.apply(this, arguments));
    state.dim = dim;
    return state;
  }
  brush2.extent = function(_2) {
    return arguments.length ? (extent2 = typeof _2 === "function" ? _2 : constant$9(number2(_2)), brush2) : extent2;
  };
  brush2.filter = function(_2) {
    return arguments.length ? (filter = typeof _2 === "function" ? _2 : constant$9(!!_2), brush2) : filter;
  };
  brush2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant$9(!!_2), brush2) : touchable;
  };
  brush2.handleSize = function(_2) {
    return arguments.length ? (handleSize = +_2, brush2) : handleSize;
  };
  brush2.keyModifiers = function(_2) {
    return arguments.length ? (keys2 = !!_2, brush2) : keys2;
  };
  brush2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush2 : value;
  };
  return brush2;
}
var cos$2 = Math.cos;
var sin$2 = Math.sin;
var pi$3 = Math.PI;
var halfPi$2 = pi$3 / 2;
var tau$3 = pi$3 * 2;
var max$1 = Math.max;
function compareValue(compare) {
  return function(a2, b) {
    return compare(
      a2.source.value + a2.target.value,
      b.source.value + b.target.value
    );
  };
}
function chord() {
  var padAngle = 0, sortGroups = null, sortSubgroups = null, sortChords = null;
  function chord2(matrix) {
    var n = matrix.length, groupSums = [], groupIndex = sequence(n), subgroupIndex = [], chords = [], groups = chords.groups = new Array(n), subgroups = new Array(n * n), k2, x2, x02, dx, i, j;
    k2 = 0, i = -1;
    while (++i < n) {
      x2 = 0, j = -1;
      while (++j < n) {
        x2 += matrix[i][j];
      }
      groupSums.push(x2);
      subgroupIndex.push(sequence(n));
      k2 += x2;
    }
    if (sortGroups)
      groupIndex.sort(function(a2, b) {
        return sortGroups(groupSums[a2], groupSums[b]);
      });
    if (sortSubgroups)
      subgroupIndex.forEach(function(d, i2) {
        d.sort(function(a2, b) {
          return sortSubgroups(matrix[i2][a2], matrix[i2][b]);
        });
      });
    k2 = max$1(0, tau$3 - padAngle * n) / k2;
    dx = k2 ? padAngle : tau$3 / n;
    x2 = 0, i = -1;
    while (++i < n) {
      x02 = x2, j = -1;
      while (++j < n) {
        var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x2, a1 = x2 += v * k2;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }
      groups[di] = {
        index: di,
        startAngle: x02,
        endAngle: x2,
        value: groupSums[di]
      };
      x2 += dx;
    }
    i = -1;
    while (++i < n) {
      j = i - 1;
      while (++j < n) {
        var source = subgroups[j * n + i], target = subgroups[i * n + j];
        if (source.value || target.value) {
          chords.push(source.value < target.value ? { source: target, target: source } : { source, target });
        }
      }
    }
    return sortChords ? chords.sort(sortChords) : chords;
  }
  chord2.padAngle = function(_2) {
    return arguments.length ? (padAngle = max$1(0, _2), chord2) : padAngle;
  };
  chord2.sortGroups = function(_2) {
    return arguments.length ? (sortGroups = _2, chord2) : sortGroups;
  };
  chord2.sortSubgroups = function(_2) {
    return arguments.length ? (sortSubgroups = _2, chord2) : sortSubgroups;
  };
  chord2.sortChords = function(_2) {
    return arguments.length ? (_2 == null ? sortChords = null : (sortChords = compareValue(_2))._ = _2, chord2) : sortChords && sortChords._;
  };
  return chord2;
}
var slice$4 = Array.prototype.slice;
function constant$8(x2) {
  return function() {
    return x2;
  };
}
var pi$2 = Math.PI, tau$2 = 2 * pi$2, epsilon$3 = 1e-6, tauEpsilon = tau$2 - epsilon$3;
function Path() {
  this._x0 = this._y0 = this._x1 = this._y1 = null;
  this._ = "";
}
function path() {
  return new Path();
}
Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function(x2, y2) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2);
  },
  closePath: function() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function(x2, y2) {
    this._ += "L" + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  quadraticCurveTo: function(x12, y12, x2, y2) {
    this._ += "Q" + +x12 + "," + +y12 + "," + (this._x1 = +x2) + "," + (this._y1 = +y2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._ += "C" + +x12 + "," + +y12 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x3) + "," + (this._y1 = +y3);
  },
  arcTo: function(x12, y12, x2, y2, r) {
    x12 = +x12, y12 = +y12, x2 = +x2, y2 = +y2, r = +r;
    var x02 = this._x1, y02 = this._y1, x21 = x2 - x12, y21 = y2 - y12, x01 = x02 - x12, y01 = y02 - y12, l01_2 = x01 * x01 + y01 * y01;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else if (!(l01_2 > epsilon$3))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$3) || !r) {
      this._ += "L" + (this._x1 = x12) + "," + (this._y1 = y12);
    } else {
      var x20 = x2 - x02, y20 = y2 - y02, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l = r * Math.tan((pi$2 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l / l01, t21 = l / l21;
      if (Math.abs(t01 - 1) > epsilon$3) {
        this._ += "L" + (x12 + t01 * x01) + "," + (y12 + t01 * y01);
      }
      this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x12 + t21 * x21) + "," + (this._y1 = y12 + t21 * y21);
    }
  },
  arc: function(x2, y2, r, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r = +r, ccw = !!ccw;
    var dx = r * Math.cos(a0), dy = r * Math.sin(a0), x02 = x2 + dx, y02 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (r < 0)
      throw new Error("negative radius: " + r);
    if (this._x1 === null) {
      this._ += "M" + x02 + "," + y02;
    } else if (Math.abs(this._x1 - x02) > epsilon$3 || Math.abs(this._y1 - y02) > epsilon$3) {
      this._ += "L" + x02 + "," + y02;
    }
    if (!r)
      return;
    if (da < 0)
      da = da % tau$2 + tau$2;
    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x2 - dx) + "," + (y2 - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x02) + "," + (this._y1 = y02);
    } else if (da > epsilon$3) {
      this._ += "A" + r + "," + r + ",0," + +(da >= pi$2) + "," + cw + "," + (this._x1 = x2 + r * Math.cos(a1)) + "," + (this._y1 = y2 + r * Math.sin(a1));
    }
  },
  rect: function(x2, y2, w2, h) {
    this._ += "M" + (this._x0 = this._x1 = +x2) + "," + (this._y0 = this._y1 = +y2) + "h" + +w2 + "v" + +h + "h" + -w2 + "Z";
  },
  toString: function() {
    return this._;
  }
};
function defaultSource$1(d) {
  return d.source;
}
function defaultTarget(d) {
  return d.target;
}
function defaultRadius$1(d) {
  return d.radius;
}
function defaultStartAngle(d) {
  return d.startAngle;
}
function defaultEndAngle(d) {
  return d.endAngle;
}
function ribbon() {
  var source = defaultSource$1, target = defaultTarget, radius = defaultRadius$1, startAngle = defaultStartAngle, endAngle = defaultEndAngle, context = null;
  function ribbon2() {
    var buffer2, argv = slice$4.call(arguments), s2 = source.apply(this, argv), t = target.apply(this, argv), sr = +radius.apply(this, (argv[0] = s2, argv)), sa0 = startAngle.apply(this, argv) - halfPi$2, sa1 = endAngle.apply(this, argv) - halfPi$2, sx0 = sr * cos$2(sa0), sy0 = sr * sin$2(sa0), tr = +radius.apply(this, (argv[0] = t, argv)), ta0 = startAngle.apply(this, argv) - halfPi$2, ta1 = endAngle.apply(this, argv) - halfPi$2;
    if (!context)
      context = buffer2 = path();
    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);
    if (sa0 !== ta0 || sa1 !== ta1) {
      context.quadraticCurveTo(0, 0, tr * cos$2(ta0), tr * sin$2(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }
    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  ribbon2.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$8(+_2), ribbon2) : radius;
  };
  ribbon2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$8(+_2), ribbon2) : startAngle;
  };
  ribbon2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$8(+_2), ribbon2) : endAngle;
  };
  ribbon2.source = function(_2) {
    return arguments.length ? (source = _2, ribbon2) : source;
  };
  ribbon2.target = function(_2) {
    return arguments.length ? (target = _2, ribbon2) : target;
  };
  ribbon2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, ribbon2) : context;
  };
  return ribbon2;
}
var prefix = "$";
function Map$3() {
}
Map$3.prototype = map$2.prototype = {
  constructor: Map$3,
  has: function(key) {
    return prefix + key in this;
  },
  get: function(key) {
    return this[prefix + key];
  },
  set: function(key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function(key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function() {
    for (var property in this)
      if (property[0] === prefix)
        delete this[property];
  },
  keys: function() {
    var keys2 = [];
    for (var property in this)
      if (property[0] === prefix)
        keys2.push(property.slice(1));
    return keys2;
  },
  values: function() {
    var values2 = [];
    for (var property in this)
      if (property[0] === prefix)
        values2.push(this[property]);
    return values2;
  },
  entries: function() {
    var entries2 = [];
    for (var property in this)
      if (property[0] === prefix)
        entries2.push({ key: property.slice(1), value: this[property] });
    return entries2;
  },
  size: function() {
    var size = 0;
    for (var property in this)
      if (property[0] === prefix)
        ++size;
    return size;
  },
  empty: function() {
    for (var property in this)
      if (property[0] === prefix)
        return false;
    return true;
  },
  each: function(f) {
    for (var property in this)
      if (property[0] === prefix)
        f(this[property], property.slice(1), this);
  }
};
function map$2(object2, f) {
  var map2 = new Map$3();
  if (object2 instanceof Map$3)
    object2.each(function(value, key2) {
      map2.set(key2, value);
    });
  else if (Array.isArray(object2)) {
    var i = -1, n = object2.length, o;
    if (f == null)
      while (++i < n)
        map2.set(i, object2[i]);
    else
      while (++i < n)
        map2.set(f(o = object2[i], i, object2), o);
  } else if (object2)
    for (var key in object2)
      map2.set(key, object2[key]);
  return map2;
}
function nest() {
  var keys2 = [], sortKeys = [], sortValues, rollup, nest2;
  function apply2(array2, depth, createResult, setResult) {
    if (depth >= keys2.length) {
      if (sortValues != null)
        array2.sort(sortValues);
      return rollup != null ? rollup(array2) : array2;
    }
    var i = -1, n = array2.length, key = keys2[depth++], keyValue, value, valuesByKey = map$2(), values2, result = createResult();
    while (++i < n) {
      if (values2 = valuesByKey.get(keyValue = key(value = array2[i]) + "")) {
        values2.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }
    valuesByKey.each(function(values3, key2) {
      setResult(result, key2, apply2(values3, depth, createResult, setResult));
    });
    return result;
  }
  function entries2(map2, depth) {
    if (++depth > keys2.length)
      return map2;
    var array2, sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys2.length)
      array2 = map2.entries();
    else
      array2 = [], map2.each(function(v, k2) {
        array2.push({ key: k2, values: entries2(v, depth) });
      });
    return sortKey != null ? array2.sort(function(a2, b) {
      return sortKey(a2.key, b.key);
    }) : array2;
  }
  return nest2 = {
    object: function(array2) {
      return apply2(array2, 0, createObject, setObject);
    },
    map: function(array2) {
      return apply2(array2, 0, createMap, setMap);
    },
    entries: function(array2) {
      return entries2(apply2(array2, 0, createMap, setMap), 0);
    },
    key: function(d) {
      keys2.push(d);
      return nest2;
    },
    sortKeys: function(order2) {
      sortKeys[keys2.length - 1] = order2;
      return nest2;
    },
    sortValues: function(order2) {
      sortValues = order2;
      return nest2;
    },
    rollup: function(f) {
      rollup = f;
      return nest2;
    }
  };
}
function createObject() {
  return {};
}
function setObject(object2, key, value) {
  object2[key] = value;
}
function createMap() {
  return map$2();
}
function setMap(map2, key, value) {
  map2.set(key, value);
}
function Set$1() {
}
var proto = map$2.prototype;
Set$1.prototype = set.prototype = {
  constructor: Set$1,
  has: proto.has,
  add: function(value) {
    value += "";
    this[prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};
function set(object2, f) {
  var set2 = new Set$1();
  if (object2 instanceof Set$1)
    object2.each(function(value) {
      set2.add(value);
    });
  else if (object2) {
    var i = -1, n = object2.length;
    if (f == null)
      while (++i < n)
        set2.add(object2[i]);
    else
      while (++i < n)
        set2.add(f(object2[i], i, object2));
  }
  return set2;
}
function keys(map2) {
  var keys2 = [];
  for (var key in map2)
    keys2.push(key);
  return keys2;
}
function values(map2) {
  var values2 = [];
  for (var key in map2)
    values2.push(map2[key]);
  return values2;
}
function entries(map2) {
  var entries2 = [];
  for (var key in map2)
    entries2.push({ key, value: map2[key] });
  return entries2;
}
var array$1 = Array.prototype;
var slice$3 = array$1.slice;
function ascending$1(a2, b) {
  return a2 - b;
}
function area$3(ring) {
  var i = 0, n = ring.length, area2 = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n)
    area2 += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area2;
}
function constant$7(x2) {
  return function() {
    return x2;
  };
}
function contains$2(ring, hole) {
  var i = -1, n = hole.length, c2;
  while (++i < n)
    if (c2 = ringContains(ring, hole[i]))
      return c2;
  return 0;
}
function ringContains(ring, point2) {
  var x2 = point2[0], y2 = point2[1], contains2 = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi2 = ring[i], xi = pi2[0], yi = pi2[1], pj = ring[j], xj = pj[0], yj = pj[1];
    if (segmentContains(pi2, pj, point2))
      return 0;
    if (yi > y2 !== yj > y2 && x2 < (xj - xi) * (y2 - yi) / (yj - yi) + xi)
      contains2 = -contains2;
  }
  return contains2;
}
function segmentContains(a2, b, c2) {
  var i;
  return collinear(a2, b, c2) && within(a2[i = +(a2[0] === b[0])], c2[i], b[i]);
}
function collinear(a2, b, c2) {
  return (b[0] - a2[0]) * (c2[1] - a2[1]) === (c2[0] - a2[0]) * (b[1] - a2[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}
function noop$2() {
}
var cases = [
  [],
  [[[1, 1.5], [0.5, 1]]],
  [[[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [0.5, 1]]],
  [[[1, 0.5], [1.5, 1]]],
  [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]],
  [[[1, 0.5], [1, 1.5]]],
  [[[1, 0.5], [0.5, 1]]],
  [[[0.5, 1], [1, 0.5]]],
  [[[1, 1.5], [1, 0.5]]],
  [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]],
  [[[1.5, 1], [1, 0.5]]],
  [[[0.5, 1], [1.5, 1]]],
  [[[1, 1.5], [1.5, 1]]],
  [[[0.5, 1], [1, 1.5]]],
  []
];
function contours() {
  var dx = 1, dy = 1, threshold2 = thresholdSturges, smooth = smoothLinear;
  function contours2(values2) {
    var tz = threshold2(values2);
    if (!Array.isArray(tz)) {
      var domain = extent$1(values2), start2 = domain[0], stop = domain[1];
      tz = tickStep(start2, stop, tz);
      tz = sequence(Math.floor(start2 / tz) * tz, Math.floor(stop / tz) * tz, tz);
    } else {
      tz = tz.slice().sort(ascending$1);
    }
    return tz.map(function(value) {
      return contour(values2, value);
    });
  }
  function contour(values2, value) {
    var polygons = [], holes = [];
    isorings(values2, value, function(ring) {
      smooth(ring, values2, value);
      if (area$3(ring) > 0)
        polygons.push([ring]);
      else
        holes.push(ring);
    });
    holes.forEach(function(hole) {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains$2((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: "MultiPolygon",
      value,
      coordinates: polygons
    };
  }
  function isorings(values2, value, callback) {
    var fragmentByStart = new Array(), fragmentByEnd = new Array(), x2, y2, t02, t12, t22, t32;
    x2 = y2 = -1;
    t12 = values2[0] >= value;
    cases[t12 << 1].forEach(stitch);
    while (++x2 < dx - 1) {
      t02 = t12, t12 = values2[x2 + 1] >= value;
      cases[t02 | t12 << 1].forEach(stitch);
    }
    cases[t12 << 0].forEach(stitch);
    while (++y2 < dy - 1) {
      x2 = -1;
      t12 = values2[y2 * dx + dx] >= value;
      t22 = values2[y2 * dx] >= value;
      cases[t12 << 1 | t22 << 2].forEach(stitch);
      while (++x2 < dx - 1) {
        t02 = t12, t12 = values2[y2 * dx + dx + x2 + 1] >= value;
        t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value;
        cases[t02 | t12 << 1 | t22 << 2 | t32 << 3].forEach(stitch);
      }
      cases[t12 | t22 << 3].forEach(stitch);
    }
    x2 = -1;
    t22 = values2[y2 * dx] >= value;
    cases[t22 << 2].forEach(stitch);
    while (++x2 < dx - 1) {
      t32 = t22, t22 = values2[y2 * dx + x2 + 1] >= value;
      cases[t22 << 2 | t32 << 3].forEach(stitch);
    }
    cases[t22 << 3].forEach(stitch);
    function stitch(line2) {
      var start2 = [line2[0][0] + x2, line2[0][1] + y2], end2 = [line2[1][0] + x2, line2[1][1] + y2], startIndex = index2(start2), endIndex = index2(end2), f, g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end2);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = { start: f.start, end: g.end, ring: f.ring.concat(g.ring) };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end2);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end2);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = { start: g.start, end: f.end, ring: g.ring.concat(f.ring) };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start2);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = { start: startIndex, end: endIndex, ring: [start2, end2] };
      }
    }
  }
  function index2(point2) {
    return point2[0] * 2 + point2[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values2, value) {
    ring.forEach(function(point2) {
      var x2 = point2[0], y2 = point2[1], xt = x2 | 0, yt = y2 | 0, v0, v1 = values2[yt * dx + xt];
      if (x2 > 0 && x2 < dx && xt === x2) {
        v0 = values2[yt * dx + xt - 1];
        point2[0] = x2 + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y2 > 0 && y2 < dy && yt === y2) {
        v0 = values2[(yt - 1) * dx + xt];
        point2[1] = y2 + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours2.contour = contour;
  contours2.size = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.ceil(_2[0]), _1 = Math.ceil(_2[1]);
    if (!(_0 > 0) || !(_1 > 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, contours2;
  };
  contours2.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$7(slice$3.call(_2)) : constant$7(_2), contours2) : threshold2;
  };
  contours2.smooth = function(_2) {
    return arguments.length ? (smooth = _2 ? smoothLinear : noop$2, contours2) : smooth === smoothLinear;
  };
  return contours2;
}
function blurX(source, target, r) {
  var n = source.width, m = source.height, w2 = (r << 1) + 1;
  for (var j = 0; j < m; ++j) {
    for (var i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source.data[i + j * n];
      }
      if (i >= r) {
        if (i >= w2) {
          sr -= source.data[i - w2 + j * n];
        }
        target.data[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w2 - i, w2);
      }
    }
  }
}
function blurY(source, target, r) {
  var n = source.width, m = source.height, w2 = (r << 1) + 1;
  for (var i = 0; i < n; ++i) {
    for (var j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source.data[i + j * n];
      }
      if (j >= r) {
        if (j >= w2) {
          sr -= source.data[i + (j - w2) * n];
        }
        target.data[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w2 - j, w2);
      }
    }
  }
}
function defaultX$1(d) {
  return d[0];
}
function defaultY$1(d) {
  return d[1];
}
function defaultWeight() {
  return 1;
}
function density() {
  var x2 = defaultX$1, y2 = defaultY$1, weight = defaultWeight, dx = 960, dy = 500, r = 20, k2 = 2, o = r * 3, n = dx + o * 2 >> k2, m = dy + o * 2 >> k2, threshold2 = constant$7(20);
  function density2(data) {
    var values0 = new Float32Array(n * m), values1 = new Float32Array(n * m);
    data.forEach(function(d, i, data2) {
      var xi = +x2(d, i, data2) + o >> k2, yi = +y2(d, i, data2) + o >> k2, wi = +weight(d, i, data2);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += wi;
      }
    });
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k2);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k2);
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k2);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k2);
    blurX({ width: n, height: m, data: values0 }, { width: n, height: m, data: values1 }, r >> k2);
    blurY({ width: n, height: m, data: values1 }, { width: n, height: m, data: values0 }, r >> k2);
    var tz = threshold2(values0);
    if (!Array.isArray(tz)) {
      var stop = max$2(values0);
      tz = tickStep(0, stop, tz);
      tz = sequence(0, Math.floor(stop / tz) * tz, tz);
      tz.shift();
    }
    return contours().thresholds(tz).size([n, m])(values0).map(transform2);
  }
  function transform2(geometry) {
    geometry.value *= Math.pow(2, -2 * k2);
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  }
  function transformPolygon(coordinates2) {
    coordinates2.forEach(transformRing);
  }
  function transformRing(coordinates2) {
    coordinates2.forEach(transformPoint);
  }
  function transformPoint(coordinates2) {
    coordinates2[0] = coordinates2[0] * Math.pow(2, k2) - o;
    coordinates2[1] = coordinates2[1] * Math.pow(2, k2) - o;
  }
  function resize() {
    o = r * 3;
    n = dx + o * 2 >> k2;
    m = dy + o * 2 >> k2;
    return density2;
  }
  density2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$7(+_2), density2) : x2;
  };
  density2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$7(+_2), density2) : y2;
  };
  density2.weight = function(_2) {
    return arguments.length ? (weight = typeof _2 === "function" ? _2 : constant$7(+_2), density2) : weight;
  };
  density2.size = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    var _0 = Math.ceil(_2[0]), _1 = Math.ceil(_2[1]);
    if (!(_0 >= 0) && !(_0 >= 0))
      throw new Error("invalid size");
    return dx = _0, dy = _1, resize();
  };
  density2.cellSize = function(_2) {
    if (!arguments.length)
      return 1 << k2;
    if (!((_2 = +_2) >= 1))
      throw new Error("invalid cell size");
    return k2 = Math.floor(Math.log(_2) / Math.LN2), resize();
  };
  density2.thresholds = function(_2) {
    return arguments.length ? (threshold2 = typeof _2 === "function" ? _2 : Array.isArray(_2) ? constant$7(slice$3.call(_2)) : constant$7(_2), density2) : threshold2;
  };
  density2.bandwidth = function(_2) {
    if (!arguments.length)
      return Math.sqrt(r * (r + 1));
    if (!((_2 = +_2) >= 0))
      throw new Error("invalid bandwidth");
    return r = Math.round((Math.sqrt(4 * _2 * _2 + 1) - 1) / 2), resize();
  };
  return density2;
}
var EOL = {}, EOF = {}, QUOTE = 34, NEWLINE = 10, RETURN = 13;
function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function(name2, i) {
    return JSON.stringify(name2) + ": d[" + i + '] || ""';
  }).join(",") + "}");
}
function customConverter(columns, f) {
  var object2 = objectConverter(columns);
  return function(row, i) {
    return f(object2(row), i, columns);
  };
}
function inferColumns(rows) {
  var columnSet = /* @__PURE__ */ Object.create(null), columns = [];
  rows.forEach(function(row) {
    for (var column2 in row) {
      if (!(column2 in columnSet)) {
        columns.push(columnSet[column2] = column2);
      }
    }
  });
  return columns;
}
function pad$1(value, width2) {
  var s2 = value + "", length2 = s2.length;
  return length2 < width2 ? new Array(width2 - length2 + 1).join(0) + s2 : s2;
}
function formatYear$1(year2) {
  return year2 < 0 ? "-" + pad$1(-year2, 6) : year2 > 9999 ? "+" + pad$1(year2, 6) : pad$1(year2, 4);
}
function formatDate(date2) {
  var hours2 = date2.getUTCHours(), minutes2 = date2.getUTCMinutes(), seconds2 = date2.getUTCSeconds(), milliseconds2 = date2.getUTCMilliseconds();
  return isNaN(date2) ? "Invalid Date" : formatYear$1(date2.getUTCFullYear()) + "-" + pad$1(date2.getUTCMonth() + 1, 2) + "-" + pad$1(date2.getUTCDate(), 2) + (milliseconds2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + ":" + pad$1(seconds2, 2) + "." + pad$1(milliseconds2, 3) + "Z" : seconds2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + ":" + pad$1(seconds2, 2) + "Z" : minutes2 || hours2 ? "T" + pad$1(hours2, 2) + ":" + pad$1(minutes2, 2) + "Z" : "");
}
function dsvFormat(delimiter2) {
  var reFormat = new RegExp('["' + delimiter2 + "\n\r]"), DELIMITER = delimiter2.charCodeAt(0);
  function parse2(text2, f) {
    var convert, columns, rows = parseRows(text2, function(row, i) {
      if (convert)
        return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }
  function parseRows(text2, f) {
    var rows = [], N = text2.length, I = 0, n = 0, t, eof = N <= 0, eol = false;
    if (text2.charCodeAt(N - 1) === NEWLINE)
      --N;
    if (text2.charCodeAt(N - 1) === RETURN)
      --N;
    function token2() {
      if (eof)
        return EOF;
      if (eol)
        return eol = false, EOL;
      var i, j = I, c2;
      if (text2.charCodeAt(j) === QUOTE) {
        while (I++ < N && text2.charCodeAt(I) !== QUOTE || text2.charCodeAt(++I) === QUOTE)
          ;
        if ((i = I) >= N)
          eof = true;
        else if ((c2 = text2.charCodeAt(I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        }
        return text2.slice(j + 1, i - 1).replace(/""/g, '"');
      }
      while (I < N) {
        if ((c2 = text2.charCodeAt(i = I++)) === NEWLINE)
          eol = true;
        else if (c2 === RETURN) {
          eol = true;
          if (text2.charCodeAt(I) === NEWLINE)
            ++I;
        } else if (c2 !== DELIMITER)
          continue;
        return text2.slice(j, i);
      }
      return eof = true, text2.slice(j, N);
    }
    while ((t = token2()) !== EOF) {
      var row = [];
      while (t !== EOL && t !== EOF)
        row.push(t), t = token2();
      if (f && (row = f(row, n++)) == null)
        continue;
      rows.push(row);
    }
    return rows;
  }
  function preformatBody(rows, columns) {
    return rows.map(function(row) {
      return columns.map(function(column2) {
        return formatValue(row[column2]);
      }).join(delimiter2);
    });
  }
  function format2(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter2)].concat(preformatBody(rows, columns)).join("\n");
  }
  function formatBody(rows, columns) {
    if (columns == null)
      columns = inferColumns(rows);
    return preformatBody(rows, columns).join("\n");
  }
  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }
  function formatRow(row) {
    return row.map(formatValue).join(delimiter2);
  }
  function formatValue(value) {
    return value == null ? "" : value instanceof Date ? formatDate(value) : reFormat.test(value += "") ? '"' + value.replace(/"/g, '""') + '"' : value;
  }
  return {
    parse: parse2,
    parseRows,
    format: format2,
    formatBody,
    formatRows,
    formatRow,
    formatValue
  };
}
var csv$1 = dsvFormat(",");
var csvParse = csv$1.parse;
var csvParseRows = csv$1.parseRows;
var csvFormat = csv$1.format;
var csvFormatBody = csv$1.formatBody;
var csvFormatRows = csv$1.formatRows;
var csvFormatRow = csv$1.formatRow;
var csvFormatValue = csv$1.formatValue;
var tsv$1 = dsvFormat("	");
var tsvParse = tsv$1.parse;
var tsvParseRows = tsv$1.parseRows;
var tsvFormat = tsv$1.format;
var tsvFormatBody = tsv$1.formatBody;
var tsvFormatRows = tsv$1.formatRows;
var tsvFormatRow = tsv$1.formatRow;
var tsvFormatValue = tsv$1.formatValue;
function autoType(object2) {
  for (var key in object2) {
    var value = object2[key].trim(), number3, m;
    if (!value)
      value = null;
    else if (value === "true")
      value = true;
    else if (value === "false")
      value = false;
    else if (value === "NaN")
      value = NaN;
    else if (!isNaN(number3 = +value))
      value = number3;
    else if (m = value.match(/^([-+]\d{2})?\d{4}(-\d{2}(-\d{2})?)?(T\d{2}:\d{2}(:\d{2}(\.\d{3})?)?(Z|[-+]\d{2}:\d{2})?)?$/)) {
      if (fixtz && !!m[4] && !m[7])
        value = value.replace(/-/g, "/").replace(/T/, " ");
      value = new Date(value);
    } else
      continue;
    object2[key] = value;
  }
  return object2;
}
var fixtz = new Date("2019-01-01T00:00").getHours() || new Date("2019-07-01T00:00").getHours();
function responseBlob(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.blob();
}
function blob(input, init2) {
  return fetch(input, init2).then(responseBlob);
}
function responseArrayBuffer(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.arrayBuffer();
}
function buffer(input, init2) {
  return fetch(input, init2).then(responseArrayBuffer);
}
function responseText(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  return response.text();
}
function text(input, init2) {
  return fetch(input, init2).then(responseText);
}
function dsvParse(parse2) {
  return function(input, init2, row) {
    if (arguments.length === 2 && typeof init2 === "function")
      row = init2, init2 = void 0;
    return text(input, init2).then(function(response) {
      return parse2(response, row);
    });
  };
}
function dsv(delimiter2, input, init2, row) {
  if (arguments.length === 3 && typeof init2 === "function")
    row = init2, init2 = void 0;
  var format2 = dsvFormat(delimiter2);
  return text(input, init2).then(function(response) {
    return format2.parse(response, row);
  });
}
var csv = dsvParse(csvParse);
var tsv = dsvParse(tsvParse);
function image(input, init2) {
  return new Promise(function(resolve, reject) {
    var image2 = new Image();
    for (var key in init2)
      image2[key] = init2[key];
    image2.onerror = reject;
    image2.onload = function() {
      resolve(image2);
    };
    image2.src = input;
  });
}
function responseJson(response) {
  if (!response.ok)
    throw new Error(response.status + " " + response.statusText);
  if (response.status === 204 || response.status === 205)
    return;
  return response.json();
}
function json(input, init2) {
  return fetch(input, init2).then(responseJson);
}
function parser$c(type2) {
  return function(input, init2) {
    return text(input, init2).then(function(text2) {
      return new DOMParser().parseFromString(text2, type2);
    });
  };
}
const xml = parser$c("application/xml");
var html = parser$c("text/html");
var svg = parser$c("image/svg+xml");
function center(x2, y2) {
  var nodes;
  if (x2 == null)
    x2 = 0;
  if (y2 == null)
    y2 = 0;
  function force() {
    var i, n = nodes.length, node2, sx = 0, sy = 0;
    for (i = 0; i < n; ++i) {
      node2 = nodes[i], sx += node2.x, sy += node2.y;
    }
    for (sx = sx / n - x2, sy = sy / n - y2, i = 0; i < n; ++i) {
      node2 = nodes[i], node2.x -= sx, node2.y -= sy;
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  return force;
}
function constant$6(x2) {
  return function() {
    return x2;
  };
}
function jiggle() {
  return (Math.random() - 0.5) * 1e-6;
}
function tree_add(d) {
  var x2 = +this._x.call(null, d), y2 = +this._y.call(null, d);
  return add$1(this.cover(x2, y2), x2, y2, d);
}
function add$1(tree2, x2, y2, d) {
  if (isNaN(x2) || isNaN(y2))
    return tree2;
  var parent, node2 = tree2._root, leaf = { data: d }, x02 = tree2._x0, y02 = tree2._y0, x12 = tree2._x1, y12 = tree2._y1, xm, ym, xp, yp, right2, bottom2, i, j;
  if (!node2)
    return tree2._root = leaf, tree2;
  while (node2.length) {
    if (right2 = x2 >= (xm = (x02 + x12) / 2))
      x02 = xm;
    else
      x12 = xm;
    if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
      y02 = ym;
    else
      y12 = ym;
    if (parent = node2, !(node2 = node2[i = bottom2 << 1 | right2]))
      return parent[i] = leaf, tree2;
  }
  xp = +tree2._x.call(null, node2.data);
  yp = +tree2._y.call(null, node2.data);
  if (x2 === xp && y2 === yp)
    return leaf.next = node2, parent ? parent[i] = leaf : tree2._root = leaf, tree2;
  do {
    parent = parent ? parent[i] = new Array(4) : tree2._root = new Array(4);
    if (right2 = x2 >= (xm = (x02 + x12) / 2))
      x02 = xm;
    else
      x12 = xm;
    if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
      y02 = ym;
    else
      y12 = ym;
  } while ((i = bottom2 << 1 | right2) === (j = (yp >= ym) << 1 | xp >= xm));
  return parent[j] = node2, parent[i] = leaf, tree2;
}
function addAll(data) {
  var d, i, n = data.length, x2, y2, xz = new Array(n), yz = new Array(n), x02 = Infinity, y02 = Infinity, x12 = -Infinity, y12 = -Infinity;
  for (i = 0; i < n; ++i) {
    if (isNaN(x2 = +this._x.call(null, d = data[i])) || isNaN(y2 = +this._y.call(null, d)))
      continue;
    xz[i] = x2;
    yz[i] = y2;
    if (x2 < x02)
      x02 = x2;
    if (x2 > x12)
      x12 = x2;
    if (y2 < y02)
      y02 = y2;
    if (y2 > y12)
      y12 = y2;
  }
  if (x02 > x12 || y02 > y12)
    return this;
  this.cover(x02, y02).cover(x12, y12);
  for (i = 0; i < n; ++i) {
    add$1(this, xz[i], yz[i], data[i]);
  }
  return this;
}
function tree_cover(x2, y2) {
  if (isNaN(x2 = +x2) || isNaN(y2 = +y2))
    return this;
  var x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1;
  if (isNaN(x02)) {
    x12 = (x02 = Math.floor(x2)) + 1;
    y12 = (y02 = Math.floor(y2)) + 1;
  } else {
    var z = x12 - x02, node2 = this._root, parent, i;
    while (x02 > x2 || x2 >= x12 || y02 > y2 || y2 >= y12) {
      i = (y2 < y02) << 1 | x2 < x02;
      parent = new Array(4), parent[i] = node2, node2 = parent, z *= 2;
      switch (i) {
        case 0:
          x12 = x02 + z, y12 = y02 + z;
          break;
        case 1:
          x02 = x12 - z, y12 = y02 + z;
          break;
        case 2:
          x12 = x02 + z, y02 = y12 - z;
          break;
        case 3:
          x02 = x12 - z, y02 = y12 - z;
          break;
      }
    }
    if (this._root && this._root.length)
      this._root = node2;
  }
  this._x0 = x02;
  this._y0 = y02;
  this._x1 = x12;
  this._y1 = y12;
  return this;
}
function tree_data() {
  var data = [];
  this.visit(function(node2) {
    if (!node2.length)
      do
        data.push(node2.data);
      while (node2 = node2.next);
  });
  return data;
}
function tree_extent(_2) {
  return arguments.length ? this.cover(+_2[0][0], +_2[0][1]).cover(+_2[1][0], +_2[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Quad(node2, x02, y02, x12, y12) {
  this.node = node2;
  this.x0 = x02;
  this.y0 = y02;
  this.x1 = x12;
  this.y1 = y12;
}
function tree_find(x2, y2, radius) {
  var data, x02 = this._x0, y02 = this._y0, x12, y12, x22, y22, x3 = this._x1, y3 = this._y1, quads = [], node2 = this._root, q, i;
  if (node2)
    quads.push(new Quad(node2, x02, y02, x3, y3));
  if (radius == null)
    radius = Infinity;
  else {
    x02 = x2 - radius, y02 = y2 - radius;
    x3 = x2 + radius, y3 = y2 + radius;
    radius *= radius;
  }
  while (q = quads.pop()) {
    if (!(node2 = q.node) || (x12 = q.x0) > x3 || (y12 = q.y0) > y3 || (x22 = q.x1) < x02 || (y22 = q.y1) < y02)
      continue;
    if (node2.length) {
      var xm = (x12 + x22) / 2, ym = (y12 + y22) / 2;
      quads.push(
        new Quad(node2[3], xm, ym, x22, y22),
        new Quad(node2[2], x12, ym, xm, y22),
        new Quad(node2[1], xm, y12, x22, ym),
        new Quad(node2[0], x12, y12, xm, ym)
      );
      if (i = (y2 >= ym) << 1 | x2 >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } else {
      var dx = x2 - +this._x.call(null, node2.data), dy = y2 - +this._y.call(null, node2.data), d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x02 = x2 - d, y02 = y2 - d;
        x3 = x2 + d, y3 = y2 + d;
        data = node2.data;
      }
    }
  }
  return data;
}
function tree_remove(d) {
  if (isNaN(x2 = +this._x.call(null, d)) || isNaN(y2 = +this._y.call(null, d)))
    return this;
  var parent, node2 = this._root, retainer, previous, next2, x02 = this._x0, y02 = this._y0, x12 = this._x1, y12 = this._y1, x2, y2, xm, ym, right2, bottom2, i, j;
  if (!node2)
    return this;
  if (node2.length)
    while (true) {
      if (right2 = x2 >= (xm = (x02 + x12) / 2))
        x02 = xm;
      else
        x12 = xm;
      if (bottom2 = y2 >= (ym = (y02 + y12) / 2))
        y02 = ym;
      else
        y12 = ym;
      if (!(parent = node2, node2 = node2[i = bottom2 << 1 | right2]))
        return this;
      if (!node2.length)
        break;
      if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3])
        retainer = parent, j = i;
    }
  while (node2.data !== d)
    if (!(previous = node2, node2 = node2.next))
      return this;
  if (next2 = node2.next)
    delete node2.next;
  if (previous)
    return next2 ? previous.next = next2 : delete previous.next, this;
  if (!parent)
    return this._root = next2, this;
  next2 ? parent[i] = next2 : delete parent[i];
  if ((node2 = parent[0] || parent[1] || parent[2] || parent[3]) && node2 === (parent[3] || parent[2] || parent[1] || parent[0]) && !node2.length) {
    if (retainer)
      retainer[j] = node2;
    else
      this._root = node2;
  }
  return this;
}
function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i)
    this.remove(data[i]);
  return this;
}
function tree_root() {
  return this._root;
}
function tree_size() {
  var size = 0;
  this.visit(function(node2) {
    if (!node2.length)
      do
        ++size;
      while (node2 = node2.next);
  });
  return size;
}
function tree_visit(callback) {
  var quads = [], q, node2 = this._root, child, x02, y02, x12, y12;
  if (node2)
    quads.push(new Quad(node2, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node2 = q.node, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1) && node2.length) {
      var xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
      if (child = node2[3])
        quads.push(new Quad(child, xm, ym, x12, y12));
      if (child = node2[2])
        quads.push(new Quad(child, x02, ym, xm, y12));
      if (child = node2[1])
        quads.push(new Quad(child, xm, y02, x12, ym));
      if (child = node2[0])
        quads.push(new Quad(child, x02, y02, xm, ym));
    }
  }
  return this;
}
function tree_visitAfter(callback) {
  var quads = [], next2 = [], q;
  if (this._root)
    quads.push(new Quad(this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node2 = q.node;
    if (node2.length) {
      var child, x02 = q.x0, y02 = q.y0, x12 = q.x1, y12 = q.y1, xm = (x02 + x12) / 2, ym = (y02 + y12) / 2;
      if (child = node2[0])
        quads.push(new Quad(child, x02, y02, xm, ym));
      if (child = node2[1])
        quads.push(new Quad(child, xm, y02, x12, ym));
      if (child = node2[2])
        quads.push(new Quad(child, x02, ym, xm, y12));
      if (child = node2[3])
        quads.push(new Quad(child, xm, ym, x12, y12));
    }
    next2.push(q);
  }
  while (q = next2.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}
function defaultX(d) {
  return d[0];
}
function tree_x(_2) {
  return arguments.length ? (this._x = _2, this) : this._x;
}
function defaultY(d) {
  return d[1];
}
function tree_y(_2) {
  return arguments.length ? (this._y = _2, this) : this._y;
}
function quadtree(nodes, x2, y2) {
  var tree2 = new Quadtree(x2 == null ? defaultX : x2, y2 == null ? defaultY : y2, NaN, NaN, NaN, NaN);
  return nodes == null ? tree2 : tree2.addAll(nodes);
}
function Quadtree(x2, y2, x02, y02, x12, y12) {
  this._x = x2;
  this._y = y2;
  this._x0 = x02;
  this._y0 = y02;
  this._x1 = x12;
  this._y1 = y12;
  this._root = void 0;
}
function leaf_copy(leaf) {
  var copy2 = { data: leaf.data }, next2 = copy2;
  while (leaf = leaf.next)
    next2 = next2.next = { data: leaf.data };
  return copy2;
}
var treeProto = quadtree.prototype = Quadtree.prototype;
treeProto.copy = function() {
  var copy2 = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1), node2 = this._root, nodes, child;
  if (!node2)
    return copy2;
  if (!node2.length)
    return copy2._root = leaf_copy(node2), copy2;
  nodes = [{ source: node2, target: copy2._root = new Array(4) }];
  while (node2 = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node2.source[i]) {
        if (child.length)
          nodes.push({ source: child, target: node2.target[i] = new Array(4) });
        else
          node2.target[i] = leaf_copy(child);
      }
    }
  }
  return copy2;
};
treeProto.add = tree_add;
treeProto.addAll = addAll;
treeProto.cover = tree_cover;
treeProto.data = tree_data;
treeProto.extent = tree_extent;
treeProto.find = tree_find;
treeProto.remove = tree_remove;
treeProto.removeAll = removeAll;
treeProto.root = tree_root;
treeProto.size = tree_size;
treeProto.visit = tree_visit;
treeProto.visitAfter = tree_visitAfter;
treeProto.x = tree_x;
treeProto.y = tree_y;
function x$4(d) {
  return d.x + d.vx;
}
function y$4(d) {
  return d.y + d.vy;
}
function collide(radius) {
  var nodes, radii, strength = 1, iterations2 = 1;
  if (typeof radius !== "function")
    radius = constant$6(radius == null ? 1 : +radius);
  function force() {
    var i, n = nodes.length, tree2, node2, xi, yi, ri, ri2;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      tree2 = quadtree(nodes, x$4, y$4).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        ri = radii[node2.index], ri2 = ri * ri;
        xi = node2.x + node2.vx;
        yi = node2.y + node2.vy;
        tree2.visit(apply2);
      }
    }
    function apply2(quad, x02, y02, x12, y12) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node2.index) {
          var x2 = xi - data.x - data.vx, y2 = yi - data.y - data.vy, l = x2 * x2 + y2 * y2;
          if (l < r * r) {
            if (x2 === 0)
              x2 = jiggle(), l += x2 * x2;
            if (y2 === 0)
              y2 = jiggle(), l += y2 * y2;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node2.vx += (x2 *= l) * (r = (rj *= rj) / (ri2 + rj));
            node2.vy += (y2 *= l) * r;
            data.vx -= x2 * (r = 1 - r);
            data.vy -= y2 * r;
          }
        }
        return;
      }
      return x02 > xi + r || x12 < xi - r || y02 > yi + r || y12 < yi - r;
    }
  }
  function prepare(quad) {
    if (quad.data)
      return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length, node2;
    radii = new Array(n);
    for (i = 0; i < n; ++i)
      node2 = nodes[i], radii[node2.index] = +radius(node2, i, nodes);
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, force) : iterations2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = +_2, force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : radius;
  };
  return force;
}
function index$3(d) {
  return d.index;
}
function find(nodeById, nodeId) {
  var node2 = nodeById.get(nodeId);
  if (!node2)
    throw new Error("missing: " + nodeId);
  return node2;
}
function link$2(links2) {
  var id2 = index$3, strength = defaultStrength, strengths, distance2 = constant$6(30), distances, nodes, count2, bias, iterations2 = 1;
  if (links2 == null)
    links2 = [];
  function defaultStrength(link2) {
    return 1 / Math.min(count2[link2.source.index], count2[link2.target.index]);
  }
  function force(alpha) {
    for (var k2 = 0, n = links2.length; k2 < iterations2; ++k2) {
      for (var i = 0, link2, source, target, x2, y2, l, b; i < n; ++i) {
        link2 = links2[i], source = link2.source, target = link2.target;
        x2 = target.x + target.vx - source.x - source.vx || jiggle();
        y2 = target.y + target.vy - source.y - source.vy || jiggle();
        l = Math.sqrt(x2 * x2 + y2 * y2);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x2 *= l, y2 *= l;
        target.vx -= x2 * (b = bias[i]);
        target.vy -= y2 * b;
        source.vx += x2 * (b = 1 - b);
        source.vy += y2 * b;
      }
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length, m = links2.length, nodeById = map$2(nodes, id2), link2;
    for (i = 0, count2 = new Array(n); i < m; ++i) {
      link2 = links2[i], link2.index = i;
      if (typeof link2.source !== "object")
        link2.source = find(nodeById, link2.source);
      if (typeof link2.target !== "object")
        link2.target = find(nodeById, link2.target);
      count2[link2.source.index] = (count2[link2.source.index] || 0) + 1;
      count2[link2.target.index] = (count2[link2.target.index] || 0) + 1;
    }
    for (i = 0, bias = new Array(m); i < m; ++i) {
      link2 = links2[i], bias[i] = count2[link2.source.index] / (count2[link2.source.index] + count2[link2.target.index]);
    }
    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }
  function initializeStrength() {
    if (!nodes)
      return;
    for (var i = 0, n = links2.length; i < n; ++i) {
      strengths[i] = +strength(links2[i], i, links2);
    }
  }
  function initializeDistance() {
    if (!nodes)
      return;
    for (var i = 0, n = links2.length; i < n; ++i) {
      distances[i] = +distance2(links2[i], i, links2);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.links = function(_2) {
    return arguments.length ? (links2 = _2, initialize2(), force) : links2;
  };
  force.id = function(_2) {
    return arguments.length ? (id2 = _2, force) : id2;
  };
  force.iterations = function(_2) {
    return arguments.length ? (iterations2 = +_2, force) : iterations2;
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initializeStrength(), force) : strength;
  };
  force.distance = function(_2) {
    return arguments.length ? (distance2 = typeof _2 === "function" ? _2 : constant$6(+_2), initializeDistance(), force) : distance2;
  };
  return force;
}
function x$3(d) {
  return d.x;
}
function y$3(d) {
  return d.y;
}
var initialRadius = 10, initialAngle = Math.PI * (3 - Math.sqrt(5));
function simulation(nodes) {
  var simulation2, alpha = 1, alphaMin = 1e-3, alphaDecay = 1 - Math.pow(alphaMin, 1 / 300), alphaTarget = 0, velocityDecay = 0.6, forces = map$2(), stepper = timer(step2), event2 = dispatch("tick", "end");
  if (nodes == null)
    nodes = [];
  function step2() {
    tick();
    event2.call("tick", simulation2);
    if (alpha < alphaMin) {
      stepper.stop();
      event2.call("end", simulation2);
    }
  }
  function tick(iterations2) {
    var i, n = nodes.length, node2;
    if (iterations2 === void 0)
      iterations2 = 1;
    for (var k2 = 0; k2 < iterations2; ++k2) {
      alpha += (alphaTarget - alpha) * alphaDecay;
      forces.each(function(force) {
        force(alpha);
      });
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        if (node2.fx == null)
          node2.x += node2.vx *= velocityDecay;
        else
          node2.x = node2.fx, node2.vx = 0;
        if (node2.fy == null)
          node2.y += node2.vy *= velocityDecay;
        else
          node2.y = node2.fy, node2.vy = 0;
      }
    }
    return simulation2;
  }
  function initializeNodes() {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.index = i;
      if (node2.fx != null)
        node2.x = node2.fx;
      if (node2.fy != null)
        node2.y = node2.fy;
      if (isNaN(node2.x) || isNaN(node2.y)) {
        var radius = initialRadius * Math.sqrt(i), angle2 = i * initialAngle;
        node2.x = radius * Math.cos(angle2);
        node2.y = radius * Math.sin(angle2);
      }
      if (isNaN(node2.vx) || isNaN(node2.vy)) {
        node2.vx = node2.vy = 0;
      }
    }
  }
  function initializeForce(force) {
    if (force.initialize)
      force.initialize(nodes);
    return force;
  }
  initializeNodes();
  return simulation2 = {
    tick,
    restart: function() {
      return stepper.restart(step2), simulation2;
    },
    stop: function() {
      return stepper.stop(), simulation2;
    },
    nodes: function(_2) {
      return arguments.length ? (nodes = _2, initializeNodes(), forces.each(initializeForce), simulation2) : nodes;
    },
    alpha: function(_2) {
      return arguments.length ? (alpha = +_2, simulation2) : alpha;
    },
    alphaMin: function(_2) {
      return arguments.length ? (alphaMin = +_2, simulation2) : alphaMin;
    },
    alphaDecay: function(_2) {
      return arguments.length ? (alphaDecay = +_2, simulation2) : +alphaDecay;
    },
    alphaTarget: function(_2) {
      return arguments.length ? (alphaTarget = +_2, simulation2) : alphaTarget;
    },
    velocityDecay: function(_2) {
      return arguments.length ? (velocityDecay = 1 - _2, simulation2) : 1 - velocityDecay;
    },
    force: function(name2, _2) {
      return arguments.length > 1 ? (_2 == null ? forces.remove(name2) : forces.set(name2, initializeForce(_2)), simulation2) : forces.get(name2);
    },
    find: function(x2, y2, radius) {
      var i = 0, n = nodes.length, dx, dy, d2, node2, closest;
      if (radius == null)
        radius = Infinity;
      else
        radius *= radius;
      for (i = 0; i < n; ++i) {
        node2 = nodes[i];
        dx = x2 - node2.x;
        dy = y2 - node2.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius)
          closest = node2, radius = d2;
      }
      return closest;
    },
    on: function(name2, _2) {
      return arguments.length > 1 ? (event2.on(name2, _2), simulation2) : event2.on(name2);
    }
  };
}
function manyBody() {
  var nodes, node2, alpha, strength = constant$6(-30), strengths, distanceMin2 = 1, distanceMax2 = Infinity, theta2 = 0.81;
  function force(_2) {
    var i, n = nodes.length, tree2 = quadtree(nodes, x$3, y$3).visitAfter(accumulate);
    for (alpha = _2, i = 0; i < n; ++i)
      node2 = nodes[i], tree2.visit(apply2);
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length, node3;
    strengths = new Array(n);
    for (i = 0; i < n; ++i)
      node3 = nodes[i], strengths[node3.index] = +strength(node3, i, nodes);
  }
  function accumulate(quad) {
    var strength2 = 0, q, c2, weight = 0, x2, y2, i;
    if (quad.length) {
      for (x2 = y2 = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c2 = Math.abs(q.value))) {
          strength2 += q.value, weight += c2, x2 += c2 * q.x, y2 += c2 * q.y;
        }
      }
      quad.x = x2 / weight;
      quad.y = y2 / weight;
    } else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do
        strength2 += strengths[q.data.index];
      while (q = q.next);
    }
    quad.value = strength2;
  }
  function apply2(quad, x12, _2, x2) {
    if (!quad.value)
      return true;
    var x3 = quad.x - node2.x, y2 = quad.y - node2.y, w2 = x2 - x12, l = x3 * x3 + y2 * y2;
    if (w2 * w2 / theta2 < l) {
      if (l < distanceMax2) {
        if (x3 === 0)
          x3 = jiggle(), l += x3 * x3;
        if (y2 === 0)
          y2 = jiggle(), l += y2 * y2;
        if (l < distanceMin2)
          l = Math.sqrt(distanceMin2 * l);
        node2.vx += x3 * quad.value * alpha / l;
        node2.vy += y2 * quad.value * alpha / l;
      }
      return true;
    } else if (quad.length || l >= distanceMax2)
      return;
    if (quad.data !== node2 || quad.next) {
      if (x3 === 0)
        x3 = jiggle(), l += x3 * x3;
      if (y2 === 0)
        y2 = jiggle(), l += y2 * y2;
      if (l < distanceMin2)
        l = Math.sqrt(distanceMin2 * l);
    }
    do
      if (quad.data !== node2) {
        w2 = strengths[quad.data.index] * alpha / l;
        node2.vx += x3 * w2;
        node2.vy += y2 * w2;
      }
    while (quad = quad.next);
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.distanceMin = function(_2) {
    return arguments.length ? (distanceMin2 = _2 * _2, force) : Math.sqrt(distanceMin2);
  };
  force.distanceMax = function(_2) {
    return arguments.length ? (distanceMax2 = _2 * _2, force) : Math.sqrt(distanceMax2);
  };
  force.theta = function(_2) {
    return arguments.length ? (theta2 = _2 * _2, force) : Math.sqrt(theta2);
  };
  return force;
}
function radial(radius, x2, y2) {
  var nodes, strength = constant$6(0.1), strengths, radiuses;
  if (typeof radius !== "function")
    radius = constant$6(+radius);
  if (x2 == null)
    x2 = 0;
  if (y2 == null)
    y2 = 0;
  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node2 = nodes[i], dx = node2.x - x2 || 1e-6, dy = node2.y - y2 || 1e-6, r = Math.sqrt(dx * dx + dy * dy), k2 = (radiuses[i] - r) * strengths[i] * alpha / r;
      node2.vx += dx * k2;
      node2.vy += dy * k2;
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2, initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : radius;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = +_2, force) : x2;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = +_2, force) : y2;
  };
  return force;
}
function x$2(x2) {
  var strength = constant$6(0.1), nodes, strengths, xz;
  if (typeof x2 !== "function")
    x2 = constant$6(x2 == null ? 0 : +x2);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.vx += (xz[i] - node2.x) * strengths[i] * alpha;
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : x2;
  };
  return force;
}
function y$2(y2) {
  var strength = constant$6(0.1), nodes, strengths, yz;
  if (typeof y2 !== "function")
    y2 = constant$6(y2 == null ? 0 : +y2);
  function force(alpha) {
    for (var i = 0, n = nodes.length, node2; i < n; ++i) {
      node2 = nodes[i], node2.vy += (yz[i] - node2.y) * strengths[i] * alpha;
    }
  }
  function initialize2() {
    if (!nodes)
      return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y2(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }
  force.initialize = function(_2) {
    nodes = _2;
    initialize2();
  };
  force.strength = function(_2) {
    return arguments.length ? (strength = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : strength;
  };
  force.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$6(+_2), initialize2(), force) : y2;
  };
  return force;
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p) {
  if ((i = (x2 = p ? x2.toExponential(p - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width2) {
    var i = value.length, t = [], j = 0, g = grouping[0], length2 = 0;
    while (i > 0 && g > 0) {
      if (length2 + g + 1 > width2)
        g = Math.max(1, width2 - length2);
      t.push(value.substring(i -= g, i + g));
      if ((length2 += g + 1) > width2)
        break;
      g = grouping[j = (j + 1) % grouping.length];
    }
    return t.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out:
    for (var n = s2.length, i = 1, i0 = -1, i1; i < n; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p + i - 1))[0];
}
function formatRounded(x2, p) {
  var d = formatDecimalParts(x2, p);
  if (!d)
    return x2 + "";
  var coefficient = d[0], exponent2 = d[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": function(x2, p) {
    return (x2 * 100).toFixed(p);
  },
  "b": function(x2) {
    return Math.round(x2).toString(2);
  },
  "c": function(x2) {
    return x2 + "";
  },
  "d": formatDecimal,
  "e": function(x2, p) {
    return x2.toExponential(p);
  },
  "f": function(x2, p) {
    return x2.toFixed(p);
  },
  "g": function(x2, p) {
    return x2.toPrecision(p);
  },
  "o": function(x2) {
    return Math.round(x2).toString(8);
  },
  "p": function(x2, p) {
    return formatRounded(x2 * 100, p);
  },
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": function(x2) {
    return Math.round(x2).toString(16).toUpperCase();
  },
  "x": function(x2) {
    return Math.round(x2).toString(16);
  }
};
function identity$6(x2) {
  return x2;
}
var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "\xB5", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$6 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$6 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "-" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol2 = specifier.symbol, zero2 = specifier.zero, width2 = specifier.width, comma = specifier.comma, precision = specifier.precision, trim2 = specifier.trim, type2 = specifier.type;
    if (type2 === "n")
      comma = true, type2 = "g";
    else if (!formatTypes[type2])
      precision === void 0 && (precision = 12), trim2 = true, type2 = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix2 = symbol2 === "$" ? currencyPrefix : symbol2 === "#" && /[boxX]/.test(type2) ? "0" + type2.toLowerCase() : "", suffix = symbol2 === "$" ? currencySuffix : /[%p]/.test(type2) ? percent : "";
    var formatType = formatTypes[type2], maybeSuffix = /[defgprs%]/.test(type2);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type2) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix2, valueSuffix = suffix, i, n, c2;
      if (type2 === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim2)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type2 === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n = value.length;
          while (++i < n) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma && !zero2)
        value = group(value, Infinity);
      var length2 = valuePrefix.length + value.length + valueSuffix.length, padding2 = length2 < width2 ? new Array(width2 - length2 + 1).join(fill) : "";
      if (comma && zero2)
        value = group(padding2 + value, padding2.length ? width2 - valueSuffix.length : Infinity), padding2 = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding2;
          break;
        case "=":
          value = valuePrefix + padding2 + value + valueSuffix;
          break;
        case "^":
          value = padding2.slice(0, length2 = padding2.length >> 1) + valuePrefix + value + valueSuffix + padding2.slice(length2);
          break;
        default:
          value = padding2 + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e), prefix2 = prefixes[8 + e / 3];
    return function(value2) {
      return f(k2 * value2) + prefix2;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$1;
var format$1;
var formatPrefix;
defaultLocale$1({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""],
  minus: "-"
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format$1 = locale$1.format;
  formatPrefix = locale$1.formatPrefix;
  return locale$1;
}
function precisionFixed(step2) {
  return Math.max(0, -exponent(Math.abs(step2)));
}
function precisionPrefix(step2, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step2)));
}
function precisionRound(step2, max2) {
  step2 = Math.abs(step2), max2 = Math.abs(max2) - step2;
  return Math.max(0, exponent(max2) - exponent(step2)) + 1;
}
function adder() {
  return new Adder();
}
function Adder() {
  this.reset();
}
Adder.prototype = {
  constructor: Adder,
  reset: function() {
    this.s = this.t = 0;
  },
  add: function(y2) {
    add(temp, y2, this.t);
    add(this, temp.s, this.s);
    if (this.s)
      this.t += temp.t;
    else
      this.s = temp.t;
  },
  valueOf: function() {
    return this.s;
  }
};
var temp = new Adder();
function add(adder2, a2, b) {
  var x2 = adder2.s = a2 + b, bv = x2 - a2, av = x2 - bv;
  adder2.t = a2 - av + (b - bv);
}
var epsilon$2 = 1e-6;
var epsilon2$1 = 1e-12;
var pi$1 = Math.PI;
var halfPi$1 = pi$1 / 2;
var quarterPi = pi$1 / 4;
var tau$1 = pi$1 * 2;
var degrees = 180 / pi$1;
var radians = pi$1 / 180;
var abs$1 = Math.abs;
var atan = Math.atan;
var atan2$1 = Math.atan2;
var cos$1 = Math.cos;
var ceil = Math.ceil;
var exp = Math.exp;
var log$3 = Math.log;
var pow$1 = Math.pow;
var sin$1 = Math.sin;
var sign$1 = Math.sign || function(x2) {
  return x2 > 0 ? 1 : x2 < 0 ? -1 : 0;
};
var sqrt$2 = Math.sqrt;
var tan = Math.tan;
function acos$1(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi$1 : Math.acos(x2);
}
function asin$1(x2) {
  return x2 > 1 ? halfPi$1 : x2 < -1 ? -halfPi$1 : Math.asin(x2);
}
function haversin(x2) {
  return (x2 = sin$1(x2 / 2)) * x2;
}
function noop$1() {
}
function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}
var streamObjectType = {
  Feature: function(object2, stream) {
    streamGeometry(object2.geometry, stream);
  },
  FeatureCollection: function(object2, stream) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n)
      streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function(object2, stream) {
    stream.sphere();
  },
  Point: function(object2, stream) {
    object2 = object2.coordinates;
    stream.point(object2[0], object2[1], object2[2]);
  },
  MultiPoint: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      object2 = coordinates2[i], stream.point(object2[0], object2[1], object2[2]);
  },
  LineString: function(object2, stream) {
    streamLine(object2.coordinates, stream, 0);
  },
  MultiLineString: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      streamLine(coordinates2[i], stream, 0);
  },
  Polygon: function(object2, stream) {
    streamPolygon(object2.coordinates, stream);
  },
  MultiPolygon: function(object2, stream) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      streamPolygon(coordinates2[i], stream);
  },
  GeometryCollection: function(object2, stream) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      streamGeometry(geometries[i], stream);
  }
};
function streamLine(coordinates2, stream, closed) {
  var i = -1, n = coordinates2.length - closed, coordinate;
  stream.lineStart();
  while (++i < n)
    coordinate = coordinates2[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);
  stream.lineEnd();
}
function streamPolygon(coordinates2, stream) {
  var i = -1, n = coordinates2.length;
  stream.polygonStart();
  while (++i < n)
    streamLine(coordinates2[i], stream, 1);
  stream.polygonEnd();
}
function geoStream(object2, stream) {
  if (object2 && streamObjectType.hasOwnProperty(object2.type)) {
    streamObjectType[object2.type](object2, stream);
  } else {
    streamGeometry(object2, stream);
  }
}
var areaRingSum$1 = adder();
var areaSum$1 = adder(), lambda00$2, phi00$2, lambda0$2, cosPhi0$1, sinPhi0$1;
var areaStream$1 = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaRingSum$1.reset();
    areaStream$1.lineStart = areaRingStart$1;
    areaStream$1.lineEnd = areaRingEnd$1;
  },
  polygonEnd: function() {
    var areaRing = +areaRingSum$1;
    areaSum$1.add(areaRing < 0 ? tau$1 + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = noop$1;
  },
  sphere: function() {
    areaSum$1.add(tau$1);
  }
};
function areaRingStart$1() {
  areaStream$1.point = areaPointFirst$1;
}
function areaRingEnd$1() {
  areaPoint$1(lambda00$2, phi00$2);
}
function areaPointFirst$1(lambda, phi2) {
  areaStream$1.point = areaPoint$1;
  lambda00$2 = lambda, phi00$2 = phi2;
  lambda *= radians, phi2 *= radians;
  lambda0$2 = lambda, cosPhi0$1 = cos$1(phi2 = phi2 / 2 + quarterPi), sinPhi0$1 = sin$1(phi2);
}
function areaPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  phi2 = phi2 / 2 + quarterPi;
  var dLambda = lambda - lambda0$2, sdLambda = dLambda >= 0 ? 1 : -1, adLambda = sdLambda * dLambda, cosPhi = cos$1(phi2), sinPhi = sin$1(phi2), k2 = sinPhi0$1 * sinPhi, u = cosPhi0$1 * cosPhi + k2 * cos$1(adLambda), v = k2 * sdLambda * sin$1(adLambda);
  areaRingSum$1.add(atan2$1(v, u));
  lambda0$2 = lambda, cosPhi0$1 = cosPhi, sinPhi0$1 = sinPhi;
}
function area$2(object2) {
  areaSum$1.reset();
  geoStream(object2, areaStream$1);
  return areaSum$1 * 2;
}
function spherical(cartesian2) {
  return [atan2$1(cartesian2[1], cartesian2[0]), asin$1(cartesian2[2])];
}
function cartesian(spherical2) {
  var lambda = spherical2[0], phi2 = spherical2[1], cosPhi = cos$1(phi2);
  return [cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2)];
}
function cartesianDot(a2, b) {
  return a2[0] * b[0] + a2[1] * b[1] + a2[2] * b[2];
}
function cartesianCross(a2, b) {
  return [a2[1] * b[2] - a2[2] * b[1], a2[2] * b[0] - a2[0] * b[2], a2[0] * b[1] - a2[1] * b[0]];
}
function cartesianAddInPlace(a2, b) {
  a2[0] += b[0], a2[1] += b[1], a2[2] += b[2];
}
function cartesianScale(vector, k2) {
  return [vector[0] * k2, vector[1] * k2, vector[2] * k2];
}
function cartesianNormalizeInPlace(d) {
  var l = sqrt$2(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}
var lambda0$1, phi0, lambda1, phi1, lambda2, lambda00$1, phi00$1, p0, deltaSum = adder(), ranges, range;
var boundsStream$2 = {
  point: boundsPoint$1,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function() {
    boundsStream$2.point = boundsRingPoint;
    boundsStream$2.lineStart = boundsRingStart;
    boundsStream$2.lineEnd = boundsRingEnd;
    deltaSum.reset();
    areaStream$1.polygonStart();
  },
  polygonEnd: function() {
    areaStream$1.polygonEnd();
    boundsStream$2.point = boundsPoint$1;
    boundsStream$2.lineStart = boundsLineStart;
    boundsStream$2.lineEnd = boundsLineEnd;
    if (areaRingSum$1 < 0)
      lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
    else if (deltaSum > epsilon$2)
      phi1 = 90;
    else if (deltaSum < -epsilon$2)
      phi0 = -90;
    range[0] = lambda0$1, range[1] = lambda1;
  },
  sphere: function() {
    lambda0$1 = -(lambda1 = 180), phi0 = -(phi1 = 90);
  }
};
function boundsPoint$1(lambda, phi2) {
  ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
}
function linePoint(lambda, phi2) {
  var p = cartesian([lambda * radians, phi2 * radians]);
  if (p0) {
    var normal2 = cartesianCross(p0, p), equatorial = [normal2[1], -normal2[0], 0], inflection = cartesianCross(equatorial, normal2);
    cartesianNormalizeInPlace(inflection);
    inflection = spherical(inflection);
    var delta = lambda - lambda2, sign2 = delta > 0 ? 1 : -1, lambdai = inflection[0] * degrees * sign2, phii, antimeridian = abs$1(delta) > 180;
    if (antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
      phii = inflection[1] * degrees;
      if (phii > phi1)
        phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign2 * lambda2 < lambdai && lambdai < sign2 * lambda)) {
      phii = -inflection[1] * degrees;
      if (phii < phi0)
        phi0 = phii;
    } else {
      if (phi2 < phi0)
        phi0 = phi2;
      if (phi2 > phi1)
        phi1 = phi2;
    }
    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
          lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
          lambda0$1 = lambda;
      }
    } else {
      if (lambda1 >= lambda0$1) {
        if (lambda < lambda0$1)
          lambda0$1 = lambda;
        if (lambda > lambda1)
          lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0$1, lambda) > angle(lambda0$1, lambda1))
            lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0$1, lambda1))
            lambda0$1 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0$1 = lambda, lambda1 = lambda]);
  }
  if (phi2 < phi0)
    phi0 = phi2;
  if (phi2 > phi1)
    phi1 = phi2;
  p0 = p, lambda2 = lambda;
}
function boundsLineStart() {
  boundsStream$2.point = linePoint;
}
function boundsLineEnd() {
  range[0] = lambda0$1, range[1] = lambda1;
  boundsStream$2.point = boundsPoint$1;
  p0 = null;
}
function boundsRingPoint(lambda, phi2) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add(abs$1(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00$1 = lambda, phi00$1 = phi2;
  }
  areaStream$1.point(lambda, phi2);
  linePoint(lambda, phi2);
}
function boundsRingStart() {
  areaStream$1.lineStart();
}
function boundsRingEnd() {
  boundsRingPoint(lambda00$1, phi00$1);
  areaStream$1.lineEnd();
  if (abs$1(deltaSum) > epsilon$2)
    lambda0$1 = -(lambda1 = 180);
  range[0] = lambda0$1, range[1] = lambda1;
  p0 = null;
}
function angle(lambda02, lambda12) {
  return (lambda12 -= lambda02) < 0 ? lambda12 + 360 : lambda12;
}
function rangeCompare(a2, b) {
  return a2[0] - b[0];
}
function rangeContains(range2, x2) {
  return range2[0] <= range2[1] ? range2[0] <= x2 && x2 <= range2[1] : x2 < range2[0] || range2[1] < x2;
}
function bounds$2(feature) {
  var i, n, a2, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0$1 = phi0 = Infinity);
  ranges = [];
  geoStream(feature, boundsStream$2);
  if (n = ranges.length) {
    ranges.sort(rangeCompare);
    for (i = 1, a2 = ranges[0], merged = [a2]; i < n; ++i) {
      b = ranges[i];
      if (rangeContains(a2, b[0]) || rangeContains(a2, b[1])) {
        if (angle(a2[0], b[1]) > angle(a2[0], a2[1]))
          a2[1] = b[1];
        if (angle(b[0], a2[1]) > angle(a2[0], a2[1]))
          a2[0] = b[0];
      } else {
        merged.push(a2 = b);
      }
    }
    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a2 = merged[n]; i <= n; a2 = b, ++i) {
      b = merged[i];
      if ((delta = angle(a2[1], b[0])) > deltaMax)
        deltaMax = delta, lambda0$1 = b[0], lambda1 = a2[1];
    }
  }
  ranges = range = null;
  return lambda0$1 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0$1, phi0], [lambda1, phi1]];
}
var W0, W1, X0$1, Y0$1, Z0$1, X1$1, Y1$1, Z1$1, X2$1, Y2$1, Z2$1, lambda00, phi00, x0$4, y0$4, z0;
var centroidStream$1 = {
  sphere: noop$1,
  point: centroidPoint$1,
  lineStart: centroidLineStart$1,
  lineEnd: centroidLineEnd$1,
  polygonStart: function() {
    centroidStream$1.lineStart = centroidRingStart$1;
    centroidStream$1.lineEnd = centroidRingEnd$1;
  },
  polygonEnd: function() {
    centroidStream$1.lineStart = centroidLineStart$1;
    centroidStream$1.lineEnd = centroidLineEnd$1;
  }
};
function centroidPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2);
  centroidPointCartesian(cosPhi * cos$1(lambda), cosPhi * sin$1(lambda), sin$1(phi2));
}
function centroidPointCartesian(x2, y2, z) {
  ++W0;
  X0$1 += (x2 - X0$1) / W0;
  Y0$1 += (y2 - Y0$1) / W0;
  Z0$1 += (z - Z0$1) / W0;
}
function centroidLineStart$1() {
  centroidStream$1.point = centroidLinePointFirst;
}
function centroidLinePointFirst(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2);
  x0$4 = cosPhi * cos$1(lambda);
  y0$4 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi2);
  centroidStream$1.point = centroidLinePoint;
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLinePoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z = sin$1(phi2), w2 = atan2$1(sqrt$2((w2 = y0$4 * z - z0 * y2) * w2 + (w2 = z0 * x2 - x0$4 * z) * w2 + (w2 = x0$4 * y2 - y0$4 * x2) * w2), x0$4 * x2 + y0$4 * y2 + z0 * z);
  W1 += w2;
  X1$1 += w2 * (x0$4 + (x0$4 = x2));
  Y1$1 += w2 * (y0$4 + (y0$4 = y2));
  Z1$1 += w2 * (z0 + (z0 = z));
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidLineEnd$1() {
  centroidStream$1.point = centroidPoint$1;
}
function centroidRingStart$1() {
  centroidStream$1.point = centroidRingPointFirst;
}
function centroidRingEnd$1() {
  centroidRingPoint(lambda00, phi00);
  centroidStream$1.point = centroidPoint$1;
}
function centroidRingPointFirst(lambda, phi2) {
  lambda00 = lambda, phi00 = phi2;
  lambda *= radians, phi2 *= radians;
  centroidStream$1.point = centroidRingPoint;
  var cosPhi = cos$1(phi2);
  x0$4 = cosPhi * cos$1(lambda);
  y0$4 = cosPhi * sin$1(lambda);
  z0 = sin$1(phi2);
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroidRingPoint(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var cosPhi = cos$1(phi2), x2 = cosPhi * cos$1(lambda), y2 = cosPhi * sin$1(lambda), z = sin$1(phi2), cx = y0$4 * z - z0 * y2, cy = z0 * x2 - x0$4 * z, cz = x0$4 * y2 - y0$4 * x2, m = sqrt$2(cx * cx + cy * cy + cz * cz), w2 = asin$1(m), v = m && -w2 / m;
  X2$1 += v * cx;
  Y2$1 += v * cy;
  Z2$1 += v * cz;
  W1 += w2;
  X1$1 += w2 * (x0$4 + (x0$4 = x2));
  Y1$1 += w2 * (y0$4 + (y0$4 = y2));
  Z1$1 += w2 * (z0 + (z0 = z));
  centroidPointCartesian(x0$4, y0$4, z0);
}
function centroid$1(object2) {
  W0 = W1 = X0$1 = Y0$1 = Z0$1 = X1$1 = Y1$1 = Z1$1 = X2$1 = Y2$1 = Z2$1 = 0;
  geoStream(object2, centroidStream$1);
  var x2 = X2$1, y2 = Y2$1, z = Z2$1, m = x2 * x2 + y2 * y2 + z * z;
  if (m < epsilon2$1) {
    x2 = X1$1, y2 = Y1$1, z = Z1$1;
    if (W1 < epsilon$2)
      x2 = X0$1, y2 = Y0$1, z = Z0$1;
    m = x2 * x2 + y2 * y2 + z * z;
    if (m < epsilon2$1)
      return [NaN, NaN];
  }
  return [atan2$1(y2, x2) * degrees, asin$1(z / sqrt$2(m)) * degrees];
}
function constant$5(x2) {
  return function() {
    return x2;
  };
}
function compose(a2, b) {
  function compose2(x2, y2) {
    return x2 = a2(x2, y2), b(x2[0], x2[1]);
  }
  if (a2.invert && b.invert)
    compose2.invert = function(x2, y2) {
      return x2 = b.invert(x2, y2), x2 && a2.invert(x2[0], x2[1]);
    };
  return compose2;
}
function rotationIdentity(lambda, phi2) {
  return [abs$1(lambda) > pi$1 ? lambda + Math.round(-lambda / tau$1) * tau$1 : lambda, phi2];
}
rotationIdentity.invert = rotationIdentity;
function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= tau$1) ? deltaPhi || deltaGamma ? compose(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}
function forwardRotationLambda(deltaLambda) {
  return function(lambda, phi2) {
    return lambda += deltaLambda, [lambda > pi$1 ? lambda - tau$1 : lambda < -pi$1 ? lambda + tau$1 : lambda, phi2];
  };
}
function rotationLambda(deltaLambda) {
  var rotation2 = forwardRotationLambda(deltaLambda);
  rotation2.invert = forwardRotationLambda(-deltaLambda);
  return rotation2;
}
function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = cos$1(deltaPhi), sinDeltaPhi = sin$1(deltaPhi), cosDeltaGamma = cos$1(deltaGamma), sinDeltaGamma = sin$1(deltaGamma);
  function rotation2(lambda, phi2) {
    var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z = sin$1(phi2), k2 = z * cosDeltaPhi + x2 * sinDeltaPhi;
    return [
      atan2$1(y2 * cosDeltaGamma - k2 * sinDeltaGamma, x2 * cosDeltaPhi - z * sinDeltaPhi),
      asin$1(k2 * cosDeltaGamma + y2 * sinDeltaGamma)
    ];
  }
  rotation2.invert = function(lambda, phi2) {
    var cosPhi = cos$1(phi2), x2 = cos$1(lambda) * cosPhi, y2 = sin$1(lambda) * cosPhi, z = sin$1(phi2), k2 = z * cosDeltaGamma - y2 * sinDeltaGamma;
    return [
      atan2$1(y2 * cosDeltaGamma + z * sinDeltaGamma, x2 * cosDeltaPhi + k2 * sinDeltaPhi),
      asin$1(k2 * cosDeltaPhi - x2 * sinDeltaPhi)
    ];
  };
  return rotation2;
}
function rotation(rotate) {
  rotate = rotateRadians(rotate[0] * radians, rotate[1] * radians, rotate.length > 2 ? rotate[2] * radians : 0);
  function forward(coordinates2) {
    coordinates2 = rotate(coordinates2[0] * radians, coordinates2[1] * radians);
    return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
  }
  forward.invert = function(coordinates2) {
    coordinates2 = rotate.invert(coordinates2[0] * radians, coordinates2[1] * radians);
    return coordinates2[0] *= degrees, coordinates2[1] *= degrees, coordinates2;
  };
  return forward;
}
function circleStream(stream, radius, delta, direction2, t02, t12) {
  if (!delta)
    return;
  var cosRadius = cos$1(radius), sinRadius = sin$1(radius), step2 = direction2 * delta;
  if (t02 == null) {
    t02 = radius + direction2 * tau$1;
    t12 = radius - step2 / 2;
  } else {
    t02 = circleRadius(cosRadius, t02);
    t12 = circleRadius(cosRadius, t12);
    if (direction2 > 0 ? t02 < t12 : t02 > t12)
      t02 += direction2 * tau$1;
  }
  for (var point2, t = t02; direction2 > 0 ? t > t12 : t < t12; t -= step2) {
    point2 = spherical([cosRadius, -sinRadius * cos$1(t), -sinRadius * sin$1(t)]);
    stream.point(point2[0], point2[1]);
  }
}
function circleRadius(cosRadius, point2) {
  point2 = cartesian(point2), point2[0] -= cosRadius;
  cartesianNormalizeInPlace(point2);
  var radius = acos$1(-point2[1]);
  return ((-point2[2] < 0 ? -radius : radius) + tau$1 - epsilon$2) % tau$1;
}
function circle$4() {
  var center2 = constant$5([0, 0]), radius = constant$5(90), precision = constant$5(6), ring, rotate, stream = { point: point2 };
  function point2(x2, y2) {
    ring.push(x2 = rotate(x2, y2));
    x2[0] *= degrees, x2[1] *= degrees;
  }
  function circle2() {
    var c2 = center2.apply(this, arguments), r = radius.apply(this, arguments) * radians, p = precision.apply(this, arguments) * radians;
    ring = [];
    rotate = rotateRadians(-c2[0] * radians, -c2[1] * radians, 0).invert;
    circleStream(stream, r, p, 1);
    c2 = { type: "Polygon", coordinates: [ring] };
    ring = rotate = null;
    return c2;
  }
  circle2.center = function(_2) {
    return arguments.length ? (center2 = typeof _2 === "function" ? _2 : constant$5([+_2[0], +_2[1]]), circle2) : center2;
  };
  circle2.radius = function(_2) {
    return arguments.length ? (radius = typeof _2 === "function" ? _2 : constant$5(+_2), circle2) : radius;
  };
  circle2.precision = function(_2) {
    return arguments.length ? (precision = typeof _2 === "function" ? _2 : constant$5(+_2), circle2) : precision;
  };
  return circle2;
}
function clipBuffer() {
  var lines = [], line2;
  return {
    point: function(x2, y2, m) {
      line2.push([x2, y2, m]);
    },
    lineStart: function() {
      lines.push(line2 = []);
    },
    lineEnd: noop$1,
    rejoin: function() {
      if (lines.length > 1)
        lines.push(lines.pop().concat(lines.shift()));
    },
    result: function() {
      var result = lines;
      lines = [];
      line2 = null;
      return result;
    }
  };
}
function pointEqual(a2, b) {
  return abs$1(a2[0] - b[0]) < epsilon$2 && abs$1(a2[1] - b[1]) < epsilon$2;
}
function Intersection(point2, points, other, entry) {
  this.x = point2;
  this.z = points;
  this.o = other;
  this.e = entry;
  this.v = false;
  this.n = this.p = null;
}
function clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream) {
  var subject = [], clip2 = [], i, n;
  segments.forEach(function(segment) {
    if ((n2 = segment.length - 1) <= 0)
      return;
    var n2, p02 = segment[0], p1 = segment[n2], x2;
    if (pointEqual(p02, p1)) {
      if (!p02[2] && !p1[2]) {
        stream.lineStart();
        for (i = 0; i < n2; ++i)
          stream.point((p02 = segment[i])[0], p02[1]);
        stream.lineEnd();
        return;
      }
      p1[0] += 2 * epsilon$2;
    }
    subject.push(x2 = new Intersection(p02, segment, null, true));
    clip2.push(x2.o = new Intersection(p02, null, x2, false));
    subject.push(x2 = new Intersection(p1, segment, null, false));
    clip2.push(x2.o = new Intersection(p1, null, x2, true));
  });
  if (!subject.length)
    return;
  clip2.sort(compareIntersection2);
  link$1(subject);
  link$1(clip2);
  for (i = 0, n = clip2.length; i < n; ++i) {
    clip2[i].e = startInside = !startInside;
  }
  var start2 = subject[0], points, point2;
  while (1) {
    var current = start2, isSubject = true;
    while (current.v)
      if ((current = current.n) === start2)
        return;
    points = current.z;
    stream.lineStart();
    do {
      current.v = current.o.v = true;
      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i)
            stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate2(current.x, current.n.x, 1, stream);
        }
        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;
          for (i = points.length - 1; i >= 0; --i)
            stream.point((point2 = points[i])[0], point2[1]);
        } else {
          interpolate2(current.x, current.p.x, -1, stream);
        }
        current = current.p;
      }
      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);
    stream.lineEnd();
  }
}
function link$1(array2) {
  if (!(n = array2.length))
    return;
  var n, i = 0, a2 = array2[0], b;
  while (++i < n) {
    a2.n = b = array2[i];
    b.p = a2;
    a2 = b;
  }
  a2.n = b = array2[0];
  b.p = a2;
}
var sum$1 = adder();
function longitude(point2) {
  if (abs$1(point2[0]) <= pi$1)
    return point2[0];
  else
    return sign$1(point2[0]) * ((abs$1(point2[0]) + pi$1) % tau$1 - pi$1);
}
function polygonContains(polygon, point2) {
  var lambda = longitude(point2), phi2 = point2[1], sinPhi = sin$1(phi2), normal2 = [sin$1(lambda), -cos$1(lambda), 0], angle2 = 0, winding = 0;
  sum$1.reset();
  if (sinPhi === 1)
    phi2 = halfPi$1 + epsilon$2;
  else if (sinPhi === -1)
    phi2 = -halfPi$1 - epsilon$2;
  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length))
      continue;
    var ring, m, point0 = ring[m - 1], lambda02 = longitude(point0), phi02 = point0[1] / 2 + quarterPi, sinPhi02 = sin$1(phi02), cosPhi02 = cos$1(phi02);
    for (var j = 0; j < m; ++j, lambda02 = lambda12, sinPhi02 = sinPhi1, cosPhi02 = cosPhi1, point0 = point1) {
      var point1 = ring[j], lambda12 = longitude(point1), phi12 = point1[1] / 2 + quarterPi, sinPhi1 = sin$1(phi12), cosPhi1 = cos$1(phi12), delta = lambda12 - lambda02, sign2 = delta >= 0 ? 1 : -1, absDelta = sign2 * delta, antimeridian = absDelta > pi$1, k2 = sinPhi02 * sinPhi1;
      sum$1.add(atan2$1(k2 * sign2 * sin$1(absDelta), cosPhi02 * cosPhi1 + k2 * cos$1(absDelta)));
      angle2 += antimeridian ? delta + sign2 * tau$1 : delta;
      if (antimeridian ^ lambda02 >= lambda ^ lambda12 >= lambda) {
        var arc2 = cartesianCross(cartesian(point0), cartesian(point1));
        cartesianNormalizeInPlace(arc2);
        var intersection2 = cartesianCross(normal2, arc2);
        cartesianNormalizeInPlace(intersection2);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * asin$1(intersection2[2]);
        if (phi2 > phiArc || phi2 === phiArc && (arc2[0] || arc2[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  }
  return (angle2 < -epsilon$2 || angle2 < epsilon$2 && sum$1 < -epsilon$2) ^ winding & 1;
}
function clip(pointVisible, clipLine2, interpolate2, start2) {
  return function(sink) {
    var line2 = clipLine2(sink), ringBuffer = clipBuffer(), ringSink = clipLine2(ringBuffer), polygonStarted = false, polygon, segments, ring;
    var clip2 = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        clip2.point = pointRing;
        clip2.lineStart = ringStart;
        clip2.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function() {
        clip2.point = point2;
        clip2.lineStart = lineStart;
        clip2.lineEnd = lineEnd;
        segments = merge$1(segments);
        var startInside = polygonContains(polygon, start2);
        if (segments.length) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          clipRejoin(segments, compareIntersection, startInside, interpolate2, sink);
        } else if (startInside) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate2(null, null, 1, sink);
          sink.lineEnd();
        }
        if (polygonStarted)
          sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function() {
        sink.polygonStart();
        sink.lineStart();
        interpolate2(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };
    function point2(lambda, phi2) {
      if (pointVisible(lambda, phi2))
        sink.point(lambda, phi2);
    }
    function pointLine(lambda, phi2) {
      line2.point(lambda, phi2);
    }
    function lineStart() {
      clip2.point = pointLine;
      line2.lineStart();
    }
    function lineEnd() {
      clip2.point = point2;
      line2.lineEnd();
    }
    function pointRing(lambda, phi2) {
      ring.push([lambda, phi2]);
      ringSink.point(lambda, phi2);
    }
    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }
    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(), ringSegments = ringBuffer.result(), i, n = ringSegments.length, m, segment, point3;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n)
        return;
      if (clean & 1) {
        segment = ringSegments[0];
        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted)
            sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          for (i = 0; i < m; ++i)
            sink.point((point3 = segment[i])[0], point3[1]);
          sink.lineEnd();
        }
        return;
      }
      if (n > 1 && clean & 2)
        ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }
    return clip2;
  };
}
function validSegment(segment) {
  return segment.length > 1;
}
function compareIntersection(a2, b) {
  return ((a2 = a2.x)[0] < 0 ? a2[1] - halfPi$1 - epsilon$2 : halfPi$1 - a2[1]) - ((b = b.x)[0] < 0 ? b[1] - halfPi$1 - epsilon$2 : halfPi$1 - b[1]);
}
const clipAntimeridian = clip(
  function() {
    return true;
  },
  clipAntimeridianLine,
  clipAntimeridianInterpolate,
  [-pi$1, -halfPi$1]
);
function clipAntimeridianLine(stream) {
  var lambda02 = NaN, phi02 = NaN, sign0 = NaN, clean;
  return {
    lineStart: function() {
      stream.lineStart();
      clean = 1;
    },
    point: function(lambda12, phi12) {
      var sign1 = lambda12 > 0 ? pi$1 : -pi$1, delta = abs$1(lambda12 - lambda02);
      if (abs$1(delta - pi$1) < epsilon$2) {
        stream.point(lambda02, phi02 = (phi02 + phi12) / 2 > 0 ? halfPi$1 : -halfPi$1);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        stream.point(lambda12, phi02);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= pi$1) {
        if (abs$1(lambda02 - sign0) < epsilon$2)
          lambda02 -= sign0 * epsilon$2;
        if (abs$1(lambda12 - sign1) < epsilon$2)
          lambda12 -= sign1 * epsilon$2;
        phi02 = clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12);
        stream.point(sign0, phi02);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi02);
        clean = 0;
      }
      stream.point(lambda02 = lambda12, phi02 = phi12);
      sign0 = sign1;
    },
    lineEnd: function() {
      stream.lineEnd();
      lambda02 = phi02 = NaN;
    },
    clean: function() {
      return 2 - clean;
    }
  };
}
function clipAntimeridianIntersect(lambda02, phi02, lambda12, phi12) {
  var cosPhi02, cosPhi1, sinLambda0Lambda1 = sin$1(lambda02 - lambda12);
  return abs$1(sinLambda0Lambda1) > epsilon$2 ? atan((sin$1(phi02) * (cosPhi1 = cos$1(phi12)) * sin$1(lambda12) - sin$1(phi12) * (cosPhi02 = cos$1(phi02)) * sin$1(lambda02)) / (cosPhi02 * cosPhi1 * sinLambda0Lambda1)) : (phi02 + phi12) / 2;
}
function clipAntimeridianInterpolate(from2, to, direction2, stream) {
  var phi2;
  if (from2 == null) {
    phi2 = direction2 * halfPi$1;
    stream.point(-pi$1, phi2);
    stream.point(0, phi2);
    stream.point(pi$1, phi2);
    stream.point(pi$1, 0);
    stream.point(pi$1, -phi2);
    stream.point(0, -phi2);
    stream.point(-pi$1, -phi2);
    stream.point(-pi$1, 0);
    stream.point(-pi$1, phi2);
  } else if (abs$1(from2[0] - to[0]) > epsilon$2) {
    var lambda = from2[0] < to[0] ? pi$1 : -pi$1;
    phi2 = direction2 * lambda / 2;
    stream.point(-lambda, phi2);
    stream.point(0, phi2);
    stream.point(lambda, phi2);
  } else {
    stream.point(to[0], to[1]);
  }
}
function clipCircle(radius) {
  var cr = cos$1(radius), delta = 6 * radians, smallRadius = cr > 0, notHemisphere = abs$1(cr) > epsilon$2;
  function interpolate2(from2, to, direction2, stream) {
    circleStream(stream, radius, delta, direction2, from2, to);
  }
  function visible(lambda, phi2) {
    return cos$1(lambda) * cos$1(phi2) > cr;
  }
  function clipLine2(stream) {
    var point0, c0, v0, v00, clean;
    return {
      lineStart: function() {
        v00 = v0 = false;
        clean = 1;
      },
      point: function(lambda, phi2) {
        var point1 = [lambda, phi2], point2, v = visible(lambda, phi2), c2 = smallRadius ? v ? 0 : code(lambda, phi2) : v ? code(lambda + (lambda < 0 ? pi$1 : -pi$1), phi2) : 0;
        if (!point0 && (v00 = v0 = v))
          stream.lineStart();
        if (v !== v0) {
          point2 = intersect2(point0, point1);
          if (!point2 || pointEqual(point0, point2) || pointEqual(point1, point2))
            point1[2] = 1;
        }
        if (v !== v0) {
          clean = 0;
          if (v) {
            stream.lineStart();
            point2 = intersect2(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            point2 = intersect2(point0, point1);
            stream.point(point2[0], point2[1], 2);
            stream.lineEnd();
          }
          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t;
          if (!(c2 & c0) && (t = intersect2(point1, point0, true))) {
            clean = 0;
            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1], 3);
            }
          }
        }
        if (v && (!point0 || !pointEqual(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }
        point0 = point1, v0 = v, c0 = c2;
      },
      lineEnd: function() {
        if (v0)
          stream.lineEnd();
        point0 = null;
      },
      clean: function() {
        return clean | (v00 && v0) << 1;
      }
    };
  }
  function intersect2(a2, b, two) {
    var pa = cartesian(a2), pb = cartesian(b);
    var n1 = [1, 0, 0], n2 = cartesianCross(pa, pb), n2n2 = cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;
    if (!determinant)
      return !two && a2;
    var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = cartesianCross(n1, n2), A5 = cartesianScale(n1, c1), B2 = cartesianScale(n2, c2);
    cartesianAddInPlace(A5, B2);
    var u = n1xn2, w2 = cartesianDot(A5, u), uu = cartesianDot(u, u), t22 = w2 * w2 - uu * (cartesianDot(A5, A5) - 1);
    if (t22 < 0)
      return;
    var t = sqrt$2(t22), q = cartesianScale(u, (-w2 - t) / uu);
    cartesianAddInPlace(q, A5);
    q = spherical(q);
    if (!two)
      return q;
    var lambda02 = a2[0], lambda12 = b[0], phi02 = a2[1], phi12 = b[1], z;
    if (lambda12 < lambda02)
      z = lambda02, lambda02 = lambda12, lambda12 = z;
    var delta2 = lambda12 - lambda02, polar = abs$1(delta2 - pi$1) < epsilon$2, meridian = polar || delta2 < epsilon$2;
    if (!polar && phi12 < phi02)
      z = phi02, phi02 = phi12, phi12 = z;
    if (meridian ? polar ? phi02 + phi12 > 0 ^ q[1] < (abs$1(q[0] - lambda02) < epsilon$2 ? phi02 : phi12) : phi02 <= q[1] && q[1] <= phi12 : delta2 > pi$1 ^ (lambda02 <= q[0] && q[0] <= lambda12)) {
      var q1 = cartesianScale(u, (-w2 + t) / uu);
      cartesianAddInPlace(q1, A5);
      return [q, spherical(q1)];
    }
  }
  function code(lambda, phi2) {
    var r = smallRadius ? radius : pi$1 - radius, code2 = 0;
    if (lambda < -r)
      code2 |= 1;
    else if (lambda > r)
      code2 |= 2;
    if (phi2 < -r)
      code2 |= 4;
    else if (phi2 > r)
      code2 |= 8;
    return code2;
  }
  return clip(visible, clipLine2, interpolate2, smallRadius ? [0, -radius] : [-pi$1, radius - pi$1]);
}
function clipLine(a2, b, x02, y02, x12, y12) {
  var ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dx > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dx > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dy > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dy > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  if (t02 > 0)
    a2[0] = ax + t02 * dx, a2[1] = ay + t02 * dy;
  if (t12 < 1)
    b[0] = ax + t12 * dx, b[1] = ay + t12 * dy;
  return true;
}
var clipMax = 1e9, clipMin = -clipMax;
function clipRectangle(x02, y02, x12, y12) {
  function visible(x2, y2) {
    return x02 <= x2 && x2 <= x12 && y02 <= y2 && y2 <= y12;
  }
  function interpolate2(from2, to, direction2, stream) {
    var a2 = 0, a1 = 0;
    if (from2 == null || (a2 = corner(from2, direction2)) !== (a1 = corner(to, direction2)) || comparePoint(from2, to) < 0 ^ direction2 > 0) {
      do
        stream.point(a2 === 0 || a2 === 3 ? x02 : x12, a2 > 1 ? y12 : y02);
      while ((a2 = (a2 + direction2 + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }
  function corner(p, direction2) {
    return abs$1(p[0] - x02) < epsilon$2 ? direction2 > 0 ? 0 : 3 : abs$1(p[0] - x12) < epsilon$2 ? direction2 > 0 ? 2 : 1 : abs$1(p[1] - y02) < epsilon$2 ? direction2 > 0 ? 1 : 0 : direction2 > 0 ? 3 : 2;
  }
  function compareIntersection2(a2, b) {
    return comparePoint(a2.x, b.x);
  }
  function comparePoint(a2, b) {
    var ca = corner(a2, 1), cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a2[1] : ca === 1 ? a2[0] - b[0] : ca === 2 ? a2[1] - b[1] : b[0] - a2[0];
  }
  return function(stream) {
    var activeStream = stream, bufferStream = clipBuffer(), segments, polygon, ring, x__, y__, v__, x_, y_, v_, first, clean;
    var clipStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart,
      polygonEnd
    };
    function point2(x2, y2) {
      if (visible(x2, y2))
        activeStream.point(x2, y2);
    }
    function polygonInside() {
      var winding = 0;
      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring2 = polygon[i], j = 1, m = ring2.length, point3 = ring2[0], a0, a1, b02 = point3[0], b12 = point3[1]; j < m; ++j) {
          a0 = b02, a1 = b12, point3 = ring2[j], b02 = point3[0], b12 = point3[1];
          if (a1 <= y12) {
            if (b12 > y12 && (b02 - a0) * (y12 - a1) > (b12 - a1) * (x02 - a0))
              ++winding;
          } else {
            if (b12 <= y12 && (b02 - a0) * (y12 - a1) < (b12 - a1) * (x02 - a0))
              --winding;
          }
        }
      }
      return winding;
    }
    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }
    function polygonEnd() {
      var startInside = polygonInside(), cleanInside = clean && startInside, visible2 = (segments = merge$1(segments)).length;
      if (cleanInside || visible2) {
        stream.polygonStart();
        if (cleanInside) {
          stream.lineStart();
          interpolate2(null, null, 1, stream);
          stream.lineEnd();
        }
        if (visible2) {
          clipRejoin(segments, compareIntersection2, startInside, interpolate2, stream);
        }
        stream.polygonEnd();
      }
      activeStream = stream, segments = polygon = ring = null;
    }
    function lineStart() {
      clipStream.point = linePoint2;
      if (polygon)
        polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    }
    function lineEnd() {
      if (segments) {
        linePoint2(x__, y__);
        if (v__ && v_)
          bufferStream.rejoin();
        segments.push(bufferStream.result());
      }
      clipStream.point = point2;
      if (v_)
        activeStream.lineEnd();
    }
    function linePoint2(x2, y2) {
      var v = visible(x2, y2);
      if (polygon)
        ring.push([x2, y2]);
      if (first) {
        x__ = x2, y__ = y2, v__ = v;
        first = false;
        if (v) {
          activeStream.lineStart();
          activeStream.point(x2, y2);
        }
      } else {
        if (v && v_)
          activeStream.point(x2, y2);
        else {
          var a2 = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))], b = [x2 = Math.max(clipMin, Math.min(clipMax, x2)), y2 = Math.max(clipMin, Math.min(clipMax, y2))];
          if (clipLine(a2, b, x02, y02, x12, y12)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a2[0], a2[1]);
            }
            activeStream.point(b[0], b[1]);
            if (!v)
              activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x2, y2);
            clean = false;
          }
        }
      }
      x_ = x2, y_ = y2, v_ = v;
    }
    return clipStream;
  };
}
function extent() {
  var x02 = 0, y02 = 0, x12 = 960, y12 = 500, cache, cacheStream, clip2;
  return clip2 = {
    stream: function(stream) {
      return cache && cacheStream === stream ? cache : cache = clipRectangle(x02, y02, x12, y12)(cacheStream = stream);
    },
    extent: function(_2) {
      return arguments.length ? (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1], cache = cacheStream = null, clip2) : [[x02, y02], [x12, y12]];
    }
  };
}
var lengthSum$1 = adder(), lambda0, sinPhi0, cosPhi0;
var lengthStream$1 = {
  sphere: noop$1,
  point: noop$1,
  lineStart: lengthLineStart,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1
};
function lengthLineStart() {
  lengthStream$1.point = lengthPointFirst$1;
  lengthStream$1.lineEnd = lengthLineEnd;
}
function lengthLineEnd() {
  lengthStream$1.point = lengthStream$1.lineEnd = noop$1;
}
function lengthPointFirst$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  lambda0 = lambda, sinPhi0 = sin$1(phi2), cosPhi0 = cos$1(phi2);
  lengthStream$1.point = lengthPoint$1;
}
function lengthPoint$1(lambda, phi2) {
  lambda *= radians, phi2 *= radians;
  var sinPhi = sin$1(phi2), cosPhi = cos$1(phi2), delta = abs$1(lambda - lambda0), cosDelta = cos$1(delta), sinDelta = sin$1(delta), x2 = cosPhi * sinDelta, y2 = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta, z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum$1.add(atan2$1(sqrt$2(x2 * x2 + y2 * y2), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}
function length$1(object2) {
  lengthSum$1.reset();
  geoStream(object2, lengthStream$1);
  return +lengthSum$1;
}
var coordinates = [null, null], object = { type: "LineString", coordinates };
function distance$1(a2, b) {
  coordinates[0] = a2;
  coordinates[1] = b;
  return length$1(object);
}
var containsObjectType = {
  Feature: function(object2, point2) {
    return containsGeometry(object2.geometry, point2);
  },
  FeatureCollection: function(object2, point2) {
    var features = object2.features, i = -1, n = features.length;
    while (++i < n)
      if (containsGeometry(features[i].geometry, point2))
        return true;
    return false;
  }
};
var containsGeometryType = {
  Sphere: function() {
    return true;
  },
  Point: function(object2, point2) {
    return containsPoint(object2.coordinates, point2);
  },
  MultiPoint: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      if (containsPoint(coordinates2[i], point2))
        return true;
    return false;
  },
  LineString: function(object2, point2) {
    return containsLine(object2.coordinates, point2);
  },
  MultiLineString: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      if (containsLine(coordinates2[i], point2))
        return true;
    return false;
  },
  Polygon: function(object2, point2) {
    return containsPolygon(object2.coordinates, point2);
  },
  MultiPolygon: function(object2, point2) {
    var coordinates2 = object2.coordinates, i = -1, n = coordinates2.length;
    while (++i < n)
      if (containsPolygon(coordinates2[i], point2))
        return true;
    return false;
  },
  GeometryCollection: function(object2, point2) {
    var geometries = object2.geometries, i = -1, n = geometries.length;
    while (++i < n)
      if (containsGeometry(geometries[i], point2))
        return true;
    return false;
  }
};
function containsGeometry(geometry, point2) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point2) : false;
}
function containsPoint(coordinates2, point2) {
  return distance$1(coordinates2, point2) === 0;
}
function containsLine(coordinates2, point2) {
  var ao, bo, ab;
  for (var i = 0, n = coordinates2.length; i < n; i++) {
    bo = distance$1(coordinates2[i], point2);
    if (bo === 0)
      return true;
    if (i > 0) {
      ab = distance$1(coordinates2[i], coordinates2[i - 1]);
      if (ab > 0 && ao <= ab && bo <= ab && (ao + bo - ab) * (1 - Math.pow((ao - bo) / ab, 2)) < epsilon2$1 * ab)
        return true;
    }
    ao = bo;
  }
  return false;
}
function containsPolygon(coordinates2, point2) {
  return !!polygonContains(coordinates2.map(ringRadians), pointRadians(point2));
}
function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}
function pointRadians(point2) {
  return [point2[0] * radians, point2[1] * radians];
}
function contains$1(object2, point2) {
  return (object2 && containsObjectType.hasOwnProperty(object2.type) ? containsObjectType[object2.type] : containsGeometry)(object2, point2);
}
function graticuleX(y02, y12, dy) {
  var y2 = sequence(y02, y12 - epsilon$2, dy).concat(y12);
  return function(x2) {
    return y2.map(function(y3) {
      return [x2, y3];
    });
  };
}
function graticuleY(x02, x12, dx) {
  var x2 = sequence(x02, x12 - epsilon$2, dx).concat(x12);
  return function(y2) {
    return x2.map(function(x3) {
      return [x3, y2];
    });
  };
}
function graticule() {
  var x12, x02, X12, X02, y12, y02, Y12, Y02, dx = 10, dy = dx, DX = 90, DY = 360, x2, y2, X3, Y3, precision = 2.5;
  function graticule2() {
    return { type: "MultiLineString", coordinates: lines() };
  }
  function lines() {
    return sequence(ceil(X02 / DX) * DX, X12, DX).map(X3).concat(sequence(ceil(Y02 / DY) * DY, Y12, DY).map(Y3)).concat(sequence(ceil(x02 / dx) * dx, x12, dx).filter(function(x3) {
      return abs$1(x3 % DX) > epsilon$2;
    }).map(x2)).concat(sequence(ceil(y02 / dy) * dy, y12, dy).filter(function(y3) {
      return abs$1(y3 % DY) > epsilon$2;
    }).map(y2));
  }
  graticule2.lines = function() {
    return lines().map(function(coordinates2) {
      return { type: "LineString", coordinates: coordinates2 };
    });
  };
  graticule2.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        X3(X02).concat(
          Y3(Y12).slice(1),
          X3(X12).reverse().slice(1),
          Y3(Y02).reverse().slice(1)
        )
      ]
    };
  };
  graticule2.extent = function(_2) {
    if (!arguments.length)
      return graticule2.extentMinor();
    return graticule2.extentMajor(_2).extentMinor(_2);
  };
  graticule2.extentMajor = function(_2) {
    if (!arguments.length)
      return [[X02, Y02], [X12, Y12]];
    X02 = +_2[0][0], X12 = +_2[1][0];
    Y02 = +_2[0][1], Y12 = +_2[1][1];
    if (X02 > X12)
      _2 = X02, X02 = X12, X12 = _2;
    if (Y02 > Y12)
      _2 = Y02, Y02 = Y12, Y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.extentMinor = function(_2) {
    if (!arguments.length)
      return [[x02, y02], [x12, y12]];
    x02 = +_2[0][0], x12 = +_2[1][0];
    y02 = +_2[0][1], y12 = +_2[1][1];
    if (x02 > x12)
      _2 = x02, x02 = x12, x12 = _2;
    if (y02 > y12)
      _2 = y02, y02 = y12, y12 = _2;
    return graticule2.precision(precision);
  };
  graticule2.step = function(_2) {
    if (!arguments.length)
      return graticule2.stepMinor();
    return graticule2.stepMajor(_2).stepMinor(_2);
  };
  graticule2.stepMajor = function(_2) {
    if (!arguments.length)
      return [DX, DY];
    DX = +_2[0], DY = +_2[1];
    return graticule2;
  };
  graticule2.stepMinor = function(_2) {
    if (!arguments.length)
      return [dx, dy];
    dx = +_2[0], dy = +_2[1];
    return graticule2;
  };
  graticule2.precision = function(_2) {
    if (!arguments.length)
      return precision;
    precision = +_2;
    x2 = graticuleX(y02, y12, 90);
    y2 = graticuleY(x02, x12, precision);
    X3 = graticuleX(Y02, Y12, 90);
    Y3 = graticuleY(X02, X12, precision);
    return graticule2;
  };
  return graticule2.extentMajor([[-180, -90 + epsilon$2], [180, 90 - epsilon$2]]).extentMinor([[-180, -80 - epsilon$2], [180, 80 + epsilon$2]]);
}
function graticule10() {
  return graticule()();
}
function interpolate(a2, b) {
  var x02 = a2[0] * radians, y02 = a2[1] * radians, x12 = b[0] * radians, y12 = b[1] * radians, cy0 = cos$1(y02), sy0 = sin$1(y02), cy1 = cos$1(y12), sy1 = sin$1(y12), kx0 = cy0 * cos$1(x02), ky0 = cy0 * sin$1(x02), kx1 = cy1 * cos$1(x12), ky1 = cy1 * sin$1(x12), d = 2 * asin$1(sqrt$2(haversin(y12 - y02) + cy0 * cy1 * haversin(x12 - x02))), k2 = sin$1(d);
  var interpolate2 = d ? function(t) {
    var B2 = sin$1(t *= d) / k2, A5 = sin$1(d - t) / k2, x2 = A5 * kx0 + B2 * kx1, y2 = A5 * ky0 + B2 * ky1, z = A5 * sy0 + B2 * sy1;
    return [
      atan2$1(y2, x2) * degrees,
      atan2$1(z, sqrt$2(x2 * x2 + y2 * y2)) * degrees
    ];
  } : function() {
    return [x02 * degrees, y02 * degrees];
  };
  interpolate2.distance = d;
  return interpolate2;
}
function identity$5(x2) {
  return x2;
}
var areaSum = adder(), areaRingSum = adder(), x00$2, y00$2, x0$3, y0$3;
var areaStream = {
  point: noop$1,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: function() {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function() {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = noop$1;
    areaSum.add(abs$1(areaRingSum));
    areaRingSum.reset();
  },
  result: function() {
    var area2 = areaSum / 2;
    areaSum.reset();
    return area2;
  }
};
function areaRingStart() {
  areaStream.point = areaPointFirst;
}
function areaPointFirst(x2, y2) {
  areaStream.point = areaPoint;
  x00$2 = x0$3 = x2, y00$2 = y0$3 = y2;
}
function areaPoint(x2, y2) {
  areaRingSum.add(y0$3 * x2 - x0$3 * y2);
  x0$3 = x2, y0$3 = y2;
}
function areaRingEnd() {
  areaPoint(x00$2, y00$2);
}
const pathArea = areaStream;
var x0$2 = Infinity, y0$2 = x0$2, x1 = -x0$2, y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: noop$1,
  lineEnd: noop$1,
  polygonStart: noop$1,
  polygonEnd: noop$1,
  result: function() {
    var bounds2 = [[x0$2, y0$2], [x1, y1]];
    x1 = y1 = -(y0$2 = x0$2 = Infinity);
    return bounds2;
  }
};
function boundsPoint(x2, y2) {
  if (x2 < x0$2)
    x0$2 = x2;
  if (x2 > x1)
    x1 = x2;
  if (y2 < y0$2)
    y0$2 = y2;
  if (y2 > y1)
    y1 = y2;
}
const boundsStream$1 = boundsStream;
var X0 = 0, Y0 = 0, Z0 = 0, X1 = 0, Y1 = 0, Z1 = 0, X2 = 0, Y2 = 0, Z2 = 0, x00$1, y00$1, x0$1, y0$1;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function() {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function() {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function() {
    var centroid2 = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid2;
  }
};
function centroidPoint(x2, y2) {
  X0 += x2;
  Y0 += y2;
  ++Z0;
}
function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}
function centroidPointFirstLine(x2, y2) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
function centroidPointLine(x2, y2) {
  var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$2(dx * dx + dy * dy);
  X1 += z * (x0$1 + x2) / 2;
  Y1 += z * (y0$1 + y2) / 2;
  Z1 += z;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}
function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}
function centroidRingEnd() {
  centroidPointRing(x00$1, y00$1);
}
function centroidPointFirstRing(x2, y2) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00$1 = x0$1 = x2, y00$1 = y0$1 = y2);
}
function centroidPointRing(x2, y2) {
  var dx = x2 - x0$1, dy = y2 - y0$1, z = sqrt$2(dx * dx + dy * dy);
  X1 += z * (x0$1 + x2) / 2;
  Y1 += z * (y0$1 + y2) / 2;
  Z1 += z;
  z = y0$1 * x2 - x0$1 * y2;
  X2 += z * (x0$1 + x2);
  Y2 += z * (y0$1 + y2);
  Z2 += z * 3;
  centroidPoint(x0$1 = x2, y0$1 = y2);
}
const pathCentroid = centroidStream;
function PathContext(context) {
  this._context = context;
}
PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function(_2) {
    return this._radius = _2, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._context.closePath();
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(x2, y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(x2, y2);
        break;
      }
      default: {
        this._context.moveTo(x2 + this._radius, y2);
        this._context.arc(x2, y2, this._radius, 0, tau$1);
        break;
      }
    }
  },
  result: noop$1
};
var lengthSum = adder(), lengthRing, x00, y00, x0, y0;
var lengthStream = {
  point: noop$1,
  lineStart: function() {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function() {
    if (lengthRing)
      lengthPoint(x00, y00);
    lengthStream.point = noop$1;
  },
  polygonStart: function() {
    lengthRing = true;
  },
  polygonEnd: function() {
    lengthRing = null;
  },
  result: function() {
    var length2 = +lengthSum;
    lengthSum.reset();
    return length2;
  }
};
function lengthPointFirst(x2, y2) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x2, y00 = y0 = y2;
}
function lengthPoint(x2, y2) {
  x0 -= x2, y0 -= y2;
  lengthSum.add(sqrt$2(x0 * x0 + y0 * y0));
  x0 = x2, y0 = y2;
}
const pathMeasure = lengthStream;
function PathString() {
  this._string = [];
}
PathString.prototype = {
  _radius: 4.5,
  _circle: circle$3(4.5),
  pointRadius: function(_2) {
    if ((_2 = +_2) !== this._radius)
      this._radius = _2, this._circle = null;
    return this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line === 0)
      this._string.push("Z");
    this._point = NaN;
  },
  point: function(x2, y2) {
    switch (this._point) {
      case 0: {
        this._string.push("M", x2, ",", y2);
        this._point = 1;
        break;
      }
      case 1: {
        this._string.push("L", x2, ",", y2);
        break;
      }
      default: {
        if (this._circle == null)
          this._circle = circle$3(this._radius);
        this._string.push("M", x2, ",", y2, this._circle);
        break;
      }
    }
  },
  result: function() {
    if (this._string.length) {
      var result = this._string.join("");
      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};
function circle$3(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}
function index$2(projection2, context) {
  var pointRadius = 4.5, projectionStream, contextStream;
  function path2(object2) {
    if (object2) {
      if (typeof pointRadius === "function")
        contextStream.pointRadius(+pointRadius.apply(this, arguments));
      geoStream(object2, projectionStream(contextStream));
    }
    return contextStream.result();
  }
  path2.area = function(object2) {
    geoStream(object2, projectionStream(pathArea));
    return pathArea.result();
  };
  path2.measure = function(object2) {
    geoStream(object2, projectionStream(pathMeasure));
    return pathMeasure.result();
  };
  path2.bounds = function(object2) {
    geoStream(object2, projectionStream(boundsStream$1));
    return boundsStream$1.result();
  };
  path2.centroid = function(object2) {
    geoStream(object2, projectionStream(pathCentroid));
    return pathCentroid.result();
  };
  path2.projection = function(_2) {
    return arguments.length ? (projectionStream = _2 == null ? (projection2 = null, identity$5) : (projection2 = _2).stream, path2) : projection2;
  };
  path2.context = function(_2) {
    if (!arguments.length)
      return context;
    contextStream = _2 == null ? (context = null, new PathString()) : new PathContext(context = _2);
    if (typeof pointRadius !== "function")
      contextStream.pointRadius(pointRadius);
    return path2;
  };
  path2.pointRadius = function(_2) {
    if (!arguments.length)
      return pointRadius;
    pointRadius = typeof _2 === "function" ? _2 : (contextStream.pointRadius(+_2), +_2);
    return path2;
  };
  return path2.projection(projection2).context(context);
}
function transform$1(methods) {
  return {
    stream: transformer$3(methods)
  };
}
function transformer$3(methods) {
  return function(stream) {
    var s2 = new TransformStream();
    for (var key in methods)
      s2[key] = methods[key];
    s2.stream = stream;
    return s2;
  };
}
function TransformStream() {
}
TransformStream.prototype = {
  constructor: TransformStream,
  point: function(x2, y2) {
    this.stream.point(x2, y2);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function fit(projection2, fitBounds, object2) {
  var clip2 = projection2.clipExtent && projection2.clipExtent();
  projection2.scale(150).translate([0, 0]);
  if (clip2 != null)
    projection2.clipExtent(null);
  geoStream(object2, projection2.stream(boundsStream$1));
  fitBounds(boundsStream$1.result());
  if (clip2 != null)
    projection2.clipExtent(clip2);
  return projection2;
}
function fitExtent(projection2, extent2, object2) {
  return fit(projection2, function(b) {
    var w2 = extent2[1][0] - extent2[0][0], h = extent2[1][1] - extent2[0][1], k2 = Math.min(w2 / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])), x2 = +extent2[0][0] + (w2 - k2 * (b[1][0] + b[0][0])) / 2, y2 = +extent2[0][1] + (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object2);
}
function fitSize(projection2, size, object2) {
  return fitExtent(projection2, [[0, 0], size], object2);
}
function fitWidth(projection2, width2, object2) {
  return fit(projection2, function(b) {
    var w2 = +width2, k2 = w2 / (b[1][0] - b[0][0]), x2 = (w2 - k2 * (b[1][0] + b[0][0])) / 2, y2 = -k2 * b[0][1];
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object2);
}
function fitHeight(projection2, height2, object2) {
  return fit(projection2, function(b) {
    var h = +height2, k2 = h / (b[1][1] - b[0][1]), x2 = -k2 * b[0][0], y2 = (h - k2 * (b[1][1] + b[0][1])) / 2;
    projection2.scale(150 * k2).translate([x2, y2]);
  }, object2);
}
var maxDepth = 16, cosMinDistance = cos$1(30 * radians);
function resample(project, delta2) {
  return +delta2 ? resample$1(project, delta2) : resampleNone(project);
}
function resampleNone(project) {
  return transformer$3({
    point: function(x2, y2) {
      x2 = project(x2, y2);
      this.stream.point(x2[0], x2[1]);
    }
  });
}
function resample$1(project, delta2) {
  function resampleLineTo(x02, y02, lambda02, a0, b02, c0, x12, y12, lambda12, a1, b12, c1, depth, stream) {
    var dx = x12 - x02, dy = y12 - y02, d2 = dx * dx + dy * dy;
    if (d2 > 4 * delta2 && depth--) {
      var a2 = a0 + a1, b = b02 + b12, c2 = c0 + c1, m = sqrt$2(a2 * a2 + b * b + c2 * c2), phi2 = asin$1(c2 /= m), lambda22 = abs$1(abs$1(c2) - 1) < epsilon$2 || abs$1(lambda02 - lambda12) < epsilon$2 ? (lambda02 + lambda12) / 2 : atan2$1(b, a2), p = project(lambda22, phi2), x2 = p[0], y2 = p[1], dx2 = x2 - x02, dy2 = y2 - y02, dz = dy * dx2 - dx * dy2;
      if (dz * dz / d2 > delta2 || abs$1((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 || a0 * a1 + b02 * b12 + c0 * c1 < cosMinDistance) {
        resampleLineTo(x02, y02, lambda02, a0, b02, c0, x2, y2, lambda22, a2 /= m, b /= m, c2, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda22, a2, b, c2, x12, y12, lambda12, a1, b12, c1, depth, stream);
      }
    }
  }
  return function(stream) {
    var lambda002, x002, y002, a00, b00, c00, lambda02, x02, y02, a0, b02, c0;
    var resampleStream = {
      point: point2,
      lineStart,
      lineEnd,
      polygonStart: function() {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function() {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };
    function point2(x2, y2) {
      x2 = project(x2, y2);
      stream.point(x2[0], x2[1]);
    }
    function lineStart() {
      x02 = NaN;
      resampleStream.point = linePoint2;
      stream.lineStart();
    }
    function linePoint2(lambda, phi2) {
      var c2 = cartesian([lambda, phi2]), p = project(lambda, phi2);
      resampleLineTo(x02, y02, lambda02, a0, b02, c0, x02 = p[0], y02 = p[1], lambda02 = lambda, a0 = c2[0], b02 = c2[1], c0 = c2[2], maxDepth, stream);
      stream.point(x02, y02);
    }
    function lineEnd() {
      resampleStream.point = point2;
      stream.lineEnd();
    }
    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }
    function ringPoint(lambda, phi2) {
      linePoint2(lambda002 = lambda, phi2), x002 = x02, y002 = y02, a00 = a0, b00 = b02, c00 = c0;
      resampleStream.point = linePoint2;
    }
    function ringEnd() {
      resampleLineTo(x02, y02, lambda02, a0, b02, c0, x002, y002, lambda002, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }
    return resampleStream;
  };
}
var transformRadians = transformer$3({
  point: function(x2, y2) {
    this.stream.point(x2 * radians, y2 * radians);
  }
});
function transformRotate(rotate) {
  return transformer$3({
    point: function(x2, y2) {
      var r = rotate(x2, y2);
      return this.stream.point(r[0], r[1]);
    }
  });
}
function scaleTranslate(k2, dx, dy, sx, sy) {
  function transform2(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [dx + k2 * x2, dy - k2 * y2];
  }
  transform2.invert = function(x2, y2) {
    return [(x2 - dx) / k2 * sx, (dy - y2) / k2 * sy];
  };
  return transform2;
}
function scaleTranslateRotate(k2, dx, dy, sx, sy, alpha) {
  var cosAlpha = cos$1(alpha), sinAlpha = sin$1(alpha), a2 = cosAlpha * k2, b = sinAlpha * k2, ai = cosAlpha / k2, bi = sinAlpha / k2, ci = (sinAlpha * dy - cosAlpha * dx) / k2, fi = (sinAlpha * dx + cosAlpha * dy) / k2;
  function transform2(x2, y2) {
    x2 *= sx;
    y2 *= sy;
    return [a2 * x2 - b * y2 + dx, dy - b * x2 - a2 * y2];
  }
  transform2.invert = function(x2, y2) {
    return [sx * (ai * x2 - bi * y2 + ci), sy * (fi - bi * x2 - ai * y2)];
  };
  return transform2;
}
function projection(project) {
  return projectionMutator(function() {
    return project;
  })();
}
function projectionMutator(projectAt) {
  var project, k2 = 150, x2 = 480, y2 = 250, lambda = 0, phi2 = 0, deltaLambda = 0, deltaPhi = 0, deltaGamma = 0, rotate, alpha = 0, sx = 1, sy = 1, theta = null, preclip = clipAntimeridian, x02 = null, y02, x12, y12, postclip = identity$5, delta2 = 0.5, projectResample, projectTransform, projectRotateTransform, cache, cacheStream;
  function projection2(point2) {
    return projectRotateTransform(point2[0] * radians, point2[1] * radians);
  }
  function invert2(point2) {
    point2 = projectRotateTransform.invert(point2[0], point2[1]);
    return point2 && [point2[0] * degrees, point2[1] * degrees];
  }
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };
  projection2.preclip = function(_2) {
    return arguments.length ? (preclip = _2, theta = void 0, reset2()) : preclip;
  };
  projection2.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
  };
  projection2.clipAngle = function(_2) {
    return arguments.length ? (preclip = +_2 ? clipCircle(theta = _2 * radians) : (theta = null, clipAntimeridian), reset2()) : theta * degrees;
  };
  projection2.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity$5) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_2) {
    return arguments.length ? (k2 = +_2, recenter()) : k2;
  };
  projection2.translate = function(_2) {
    return arguments.length ? (x2 = +_2[0], y2 = +_2[1], recenter()) : [x2, y2];
  };
  projection2.center = function(_2) {
    return arguments.length ? (lambda = _2[0] % 360 * radians, phi2 = _2[1] % 360 * radians, recenter()) : [lambda * degrees, phi2 * degrees];
  };
  projection2.rotate = function(_2) {
    return arguments.length ? (deltaLambda = _2[0] % 360 * radians, deltaPhi = _2[1] % 360 * radians, deltaGamma = _2.length > 2 ? _2[2] % 360 * radians : 0, recenter()) : [deltaLambda * degrees, deltaPhi * degrees, deltaGamma * degrees];
  };
  projection2.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, recenter()) : alpha * degrees;
  };
  projection2.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, recenter()) : sx < 0;
  };
  projection2.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, recenter()) : sy < 0;
  };
  projection2.precision = function(_2) {
    return arguments.length ? (projectResample = resample(projectTransform, delta2 = _2 * _2), reset2()) : sqrt$2(delta2);
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  function recenter() {
    var center2 = scaleTranslateRotate(k2, 0, 0, sx, sy, alpha).apply(null, project(lambda, phi2)), transform2 = (alpha ? scaleTranslateRotate : scaleTranslate)(k2, x2 - center2[0], y2 - center2[1], sx, sy, alpha);
    rotate = rotateRadians(deltaLambda, deltaPhi, deltaGamma);
    projectTransform = compose(project, transform2);
    projectRotateTransform = compose(rotate, projectTransform);
    projectResample = resample(projectTransform, delta2);
    return reset2();
  }
  function reset2() {
    cache = cacheStream = null;
    return projection2;
  }
  return function() {
    project = projectAt.apply(this, arguments);
    projection2.invert = project.invert && invert2;
    return recenter();
  };
}
function conicProjection(projectAt) {
  var phi02 = 0, phi12 = pi$1 / 3, m = projectionMutator(projectAt), p = m(phi02, phi12);
  p.parallels = function(_2) {
    return arguments.length ? m(phi02 = _2[0] * radians, phi12 = _2[1] * radians) : [phi02 * degrees, phi12 * degrees];
  };
  return p;
}
function cylindricalEqualAreaRaw(phi02) {
  var cosPhi02 = cos$1(phi02);
  function forward(lambda, phi2) {
    return [lambda * cosPhi02, sin$1(phi2) / cosPhi02];
  }
  forward.invert = function(x2, y2) {
    return [x2 / cosPhi02, asin$1(y2 * cosPhi02)];
  };
  return forward;
}
function conicEqualAreaRaw(y02, y12) {
  var sy0 = sin$1(y02), n = (sy0 + sin$1(y12)) / 2;
  if (abs$1(n) < epsilon$2)
    return cylindricalEqualAreaRaw(y02);
  var c2 = 1 + sy0 * (2 * n - sy0), r0 = sqrt$2(c2) / n;
  function project(x2, y2) {
    var r = sqrt$2(c2 - 2 * n * sin$1(y2)) / n;
    return [r * sin$1(x2 *= n), r0 - r * cos$1(x2)];
  }
  project.invert = function(x2, y2) {
    var r0y = r0 - y2, l = atan2$1(x2, abs$1(r0y)) * sign$1(r0y);
    if (r0y * n < 0)
      l -= pi$1 * sign$1(x2) * sign$1(r0y);
    return [l / n, asin$1((c2 - (x2 * x2 + r0y * r0y) * n * n) / (2 * n))];
  };
  return project;
}
function conicEqualArea() {
  return conicProjection(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
function albers() {
  return conicEqualArea().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function(x2, y2) {
      var i = -1;
      while (++i < n)
        streams[i].point(x2, y2);
    },
    sphere: function() {
      var i = -1;
      while (++i < n)
        streams[i].sphere();
    },
    lineStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineStart();
    },
    lineEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].lineEnd();
    },
    polygonStart: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonStart();
    },
    polygonEnd: function() {
      var i = -1;
      while (++i < n)
        streams[i].polygonEnd();
    }
  };
}
function albersUsa() {
  var cache, cacheStream, lower48 = albers(), lower48Point, alaska = conicEqualArea().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), alaskaPoint, hawaii = conicEqualArea().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), hawaiiPoint, point2, pointStream = { point: function(x2, y2) {
    point2 = [x2, y2];
  } };
  function albersUsa2(coordinates2) {
    var x2 = coordinates2[0], y2 = coordinates2[1];
    return point2 = null, (lower48Point.point(x2, y2), point2) || (alaskaPoint.point(x2, y2), point2) || (hawaiiPoint.point(x2, y2), point2);
  }
  albersUsa2.invert = function(coordinates2) {
    var k2 = lower48.scale(), t = lower48.translate(), x2 = (coordinates2[0] - t[0]) / k2, y2 = (coordinates2[1] - t[1]) / k2;
    return (y2 >= 0.12 && y2 < 0.234 && x2 >= -0.425 && x2 < -0.214 ? alaska : y2 >= 0.166 && y2 < 0.234 && x2 >= -0.214 && x2 < -0.115 ? hawaii : lower48).invert(coordinates2);
  };
  albersUsa2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };
  albersUsa2.precision = function(_2) {
    if (!arguments.length)
      return lower48.precision();
    lower48.precision(_2), alaska.precision(_2), hawaii.precision(_2);
    return reset2();
  };
  albersUsa2.scale = function(_2) {
    if (!arguments.length)
      return lower48.scale();
    lower48.scale(_2), alaska.scale(_2 * 0.35), hawaii.scale(_2);
    return albersUsa2.translate(lower48.translate());
  };
  albersUsa2.translate = function(_2) {
    if (!arguments.length)
      return lower48.translate();
    var k2 = lower48.scale(), x2 = +_2[0], y2 = +_2[1];
    lower48Point = lower48.translate(_2).clipExtent([[x2 - 0.455 * k2, y2 - 0.238 * k2], [x2 + 0.455 * k2, y2 + 0.238 * k2]]).stream(pointStream);
    alaskaPoint = alaska.translate([x2 - 0.307 * k2, y2 + 0.201 * k2]).clipExtent([[x2 - 0.425 * k2 + epsilon$2, y2 + 0.12 * k2 + epsilon$2], [x2 - 0.214 * k2 - epsilon$2, y2 + 0.234 * k2 - epsilon$2]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x2 - 0.205 * k2, y2 + 0.212 * k2]).clipExtent([[x2 - 0.214 * k2 + epsilon$2, y2 + 0.166 * k2 + epsilon$2], [x2 - 0.115 * k2 - epsilon$2, y2 + 0.234 * k2 - epsilon$2]]).stream(pointStream);
    return reset2();
  };
  albersUsa2.fitExtent = function(extent2, object2) {
    return fitExtent(albersUsa2, extent2, object2);
  };
  albersUsa2.fitSize = function(size, object2) {
    return fitSize(albersUsa2, size, object2);
  };
  albersUsa2.fitWidth = function(width2, object2) {
    return fitWidth(albersUsa2, width2, object2);
  };
  albersUsa2.fitHeight = function(height2, object2) {
    return fitHeight(albersUsa2, height2, object2);
  };
  function reset2() {
    cache = cacheStream = null;
    return albersUsa2;
  }
  return albersUsa2.scale(1070);
}
function azimuthalRaw(scale) {
  return function(x2, y2) {
    var cx = cos$1(x2), cy = cos$1(y2), k2 = scale(cx * cy);
    return [
      k2 * cy * sin$1(x2),
      k2 * sin$1(y2)
    ];
  };
}
function azimuthalInvert(angle2) {
  return function(x2, y2) {
    var z = sqrt$2(x2 * x2 + y2 * y2), c2 = angle2(z), sc = sin$1(c2), cc = cos$1(c2);
    return [
      atan2$1(x2 * sc, z * cc),
      asin$1(z && y2 * sc / z)
    ];
  };
}
var azimuthalEqualAreaRaw = azimuthalRaw(function(cxcy) {
  return sqrt$2(2 / (1 + cxcy));
});
azimuthalEqualAreaRaw.invert = azimuthalInvert(function(z) {
  return 2 * asin$1(z / 2);
});
function azimuthalEqualArea() {
  return projection(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}
var azimuthalEquidistantRaw = azimuthalRaw(function(c2) {
  return (c2 = acos$1(c2)) && c2 / sin$1(c2);
});
azimuthalEquidistantRaw.invert = azimuthalInvert(function(z) {
  return z;
});
function azimuthalEquidistant() {
  return projection(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
function mercatorRaw(lambda, phi2) {
  return [lambda, log$3(tan((halfPi$1 + phi2) / 2))];
}
mercatorRaw.invert = function(x2, y2) {
  return [x2, 2 * atan(exp(y2)) - halfPi$1];
};
function mercator() {
  return mercatorProjection(mercatorRaw).scale(961 / tau$1);
}
function mercatorProjection(project) {
  var m = projection(project), center2 = m.center, scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, x02 = null, y02, x12, y12;
  m.scale = function(_2) {
    return arguments.length ? (scale(_2), reclip()) : scale();
  };
  m.translate = function(_2) {
    return arguments.length ? (translate(_2), reclip()) : translate();
  };
  m.center = function(_2) {
    return arguments.length ? (center2(_2), reclip()) : center2();
  };
  m.clipExtent = function(_2) {
    return arguments.length ? (_2 == null ? x02 = y02 = x12 = y12 = null : (x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reclip()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  function reclip() {
    var k2 = pi$1 * scale(), t = m(rotation(m.rotate()).invert([0, 0]));
    return clipExtent(x02 == null ? [[t[0] - k2, t[1] - k2], [t[0] + k2, t[1] + k2]] : project === mercatorRaw ? [[Math.max(t[0] - k2, x02), y02], [Math.min(t[0] + k2, x12), y12]] : [[x02, Math.max(t[1] - k2, y02)], [x12, Math.min(t[1] + k2, y12)]]);
  }
  return reclip();
}
function tany(y2) {
  return tan((halfPi$1 + y2) / 2);
}
function conicConformalRaw(y02, y12) {
  var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : log$3(cy0 / cos$1(y12)) / log$3(tany(y12) / tany(y02)), f = cy0 * pow$1(tany(y02), n) / n;
  if (!n)
    return mercatorRaw;
  function project(x2, y2) {
    if (f > 0) {
      if (y2 < -halfPi$1 + epsilon$2)
        y2 = -halfPi$1 + epsilon$2;
    } else {
      if (y2 > halfPi$1 - epsilon$2)
        y2 = halfPi$1 - epsilon$2;
    }
    var r = f / pow$1(tany(y2), n);
    return [r * sin$1(n * x2), f - r * cos$1(n * x2)];
  }
  project.invert = function(x2, y2) {
    var fy = f - y2, r = sign$1(n) * sqrt$2(x2 * x2 + fy * fy), l = atan2$1(x2, abs$1(fy)) * sign$1(fy);
    if (fy * n < 0)
      l -= pi$1 * sign$1(x2) * sign$1(fy);
    return [l / n, 2 * atan(pow$1(f / r, 1 / n)) - halfPi$1];
  };
  return project;
}
function conicConformal() {
  return conicProjection(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
function equirectangularRaw(lambda, phi2) {
  return [lambda, phi2];
}
equirectangularRaw.invert = equirectangularRaw;
function equirectangular() {
  return projection(equirectangularRaw).scale(152.63);
}
function conicEquidistantRaw(y02, y12) {
  var cy0 = cos$1(y02), n = y02 === y12 ? sin$1(y02) : (cy0 - cos$1(y12)) / (y12 - y02), g = cy0 / n + y02;
  if (abs$1(n) < epsilon$2)
    return equirectangularRaw;
  function project(x2, y2) {
    var gy = g - y2, nx = n * x2;
    return [gy * sin$1(nx), g - gy * cos$1(nx)];
  }
  project.invert = function(x2, y2) {
    var gy = g - y2, l = atan2$1(x2, abs$1(gy)) * sign$1(gy);
    if (gy * n < 0)
      l -= pi$1 * sign$1(x2) * sign$1(gy);
    return [l / n, g - sign$1(n) * sqrt$2(x2 * x2 + gy * gy)];
  };
  return project;
}
function conicEquidistant() {
  return conicProjection(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
var A1 = 1.340264, A2 = -0.081106, A3 = 893e-6, A4 = 3796e-6, M = sqrt$2(3) / 2, iterations = 12;
function equalEarthRaw(lambda, phi2) {
  var l = asin$1(M * sin$1(phi2)), l2 = l * l, l6 = l2 * l2 * l2;
  return [
    lambda * cos$1(l) / (M * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2))),
    l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2))
  ];
}
equalEarthRaw.invert = function(x2, y2) {
  var l = y2, l2 = l * l, l6 = l2 * l2 * l2;
  for (var i = 0, delta, fy, fpy; i < iterations; ++i) {
    fy = l * (A1 + A2 * l2 + l6 * (A3 + A4 * l2)) - y2;
    fpy = A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2);
    l -= delta = fy / fpy, l2 = l * l, l6 = l2 * l2 * l2;
    if (abs$1(delta) < epsilon2$1)
      break;
  }
  return [
    M * x2 * (A1 + 3 * A2 * l2 + l6 * (7 * A3 + 9 * A4 * l2)) / cos$1(l),
    asin$1(sin$1(l) / M)
  ];
};
function equalEarth() {
  return projection(equalEarthRaw).scale(177.158);
}
function gnomonicRaw(x2, y2) {
  var cy = cos$1(y2), k2 = cos$1(x2) * cy;
  return [cy * sin$1(x2) / k2, sin$1(y2) / k2];
}
gnomonicRaw.invert = azimuthalInvert(atan);
function gnomonic() {
  return projection(gnomonicRaw).scale(144.049).clipAngle(60);
}
function identity$4() {
  var k2 = 1, tx = 0, ty = 0, sx = 1, sy = 1, alpha = 0, ca, sa, x02 = null, y02, x12, y12, kx2 = 1, ky2 = 1, transform2 = transformer$3({
    point: function(x2, y2) {
      var p = projection2([x2, y2]);
      this.stream.point(p[0], p[1]);
    }
  }), postclip = identity$5, cache, cacheStream;
  function reset2() {
    kx2 = k2 * sx;
    ky2 = k2 * sy;
    cache = cacheStream = null;
    return projection2;
  }
  function projection2(p) {
    var x2 = p[0] * kx2, y2 = p[1] * ky2;
    if (alpha) {
      var t = y2 * ca - x2 * sa;
      x2 = x2 * ca + y2 * sa;
      y2 = t;
    }
    return [x2 + tx, y2 + ty];
  }
  projection2.invert = function(p) {
    var x2 = p[0] - tx, y2 = p[1] - ty;
    if (alpha) {
      var t = y2 * ca + x2 * sa;
      x2 = x2 * ca - y2 * sa;
      y2 = t;
    }
    return [x2 / kx2, y2 / ky2];
  };
  projection2.stream = function(stream) {
    return cache && cacheStream === stream ? cache : cache = transform2(postclip(cacheStream = stream));
  };
  projection2.postclip = function(_2) {
    return arguments.length ? (postclip = _2, x02 = y02 = x12 = y12 = null, reset2()) : postclip;
  };
  projection2.clipExtent = function(_2) {
    return arguments.length ? (postclip = _2 == null ? (x02 = y02 = x12 = y12 = null, identity$5) : clipRectangle(x02 = +_2[0][0], y02 = +_2[0][1], x12 = +_2[1][0], y12 = +_2[1][1]), reset2()) : x02 == null ? null : [[x02, y02], [x12, y12]];
  };
  projection2.scale = function(_2) {
    return arguments.length ? (k2 = +_2, reset2()) : k2;
  };
  projection2.translate = function(_2) {
    return arguments.length ? (tx = +_2[0], ty = +_2[1], reset2()) : [tx, ty];
  };
  projection2.angle = function(_2) {
    return arguments.length ? (alpha = _2 % 360 * radians, sa = sin$1(alpha), ca = cos$1(alpha), reset2()) : alpha * degrees;
  };
  projection2.reflectX = function(_2) {
    return arguments.length ? (sx = _2 ? -1 : 1, reset2()) : sx < 0;
  };
  projection2.reflectY = function(_2) {
    return arguments.length ? (sy = _2 ? -1 : 1, reset2()) : sy < 0;
  };
  projection2.fitExtent = function(extent2, object2) {
    return fitExtent(projection2, extent2, object2);
  };
  projection2.fitSize = function(size, object2) {
    return fitSize(projection2, size, object2);
  };
  projection2.fitWidth = function(width2, object2) {
    return fitWidth(projection2, width2, object2);
  };
  projection2.fitHeight = function(height2, object2) {
    return fitHeight(projection2, height2, object2);
  };
  return projection2;
}
function naturalEarth1Raw(lambda, phi2) {
  var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
  return [
    lambda * (0.8707 - 0.131979 * phi22 + phi4 * (-0.013791 + phi4 * (3971e-6 * phi22 - 1529e-6 * phi4))),
    phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4)))
  ];
}
naturalEarth1Raw.invert = function(x2, y2) {
  var phi2 = y2, i = 25, delta;
  do {
    var phi22 = phi2 * phi2, phi4 = phi22 * phi22;
    phi2 -= delta = (phi2 * (1.007226 + phi22 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi22 - 5916e-6 * phi4))) - y2) / (1.007226 + phi22 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi22 - 5916e-6 * 11 * phi4)));
  } while (abs$1(delta) > epsilon$2 && --i > 0);
  return [
    x2 / (0.8707 + (phi22 = phi2 * phi2) * (-0.131979 + phi22 * (-0.013791 + phi22 * phi22 * phi22 * (3971e-6 - 1529e-6 * phi22)))),
    phi2
  ];
};
function naturalEarth1() {
  return projection(naturalEarth1Raw).scale(175.295);
}
function orthographicRaw(x2, y2) {
  return [cos$1(y2) * sin$1(x2), sin$1(y2)];
}
orthographicRaw.invert = azimuthalInvert(asin$1);
function orthographic() {
  return projection(orthographicRaw).scale(249.5).clipAngle(90 + epsilon$2);
}
function stereographicRaw(x2, y2) {
  var cy = cos$1(y2), k2 = 1 + cos$1(x2) * cy;
  return [cy * sin$1(x2) / k2, sin$1(y2) / k2];
}
stereographicRaw.invert = azimuthalInvert(function(z) {
  return 2 * atan(z);
});
function stereographic() {
  return projection(stereographicRaw).scale(250).clipAngle(142);
}
function transverseMercatorRaw(lambda, phi2) {
  return [log$3(tan((halfPi$1 + phi2) / 2)), -lambda];
}
transverseMercatorRaw.invert = function(x2, y2) {
  return [-y2, 2 * atan(exp(x2)) - halfPi$1];
};
function transverseMercator() {
  var m = mercatorProjection(transverseMercatorRaw), center2 = m.center, rotate = m.rotate;
  m.center = function(_2) {
    return arguments.length ? center2([-_2[1], _2[0]]) : (_2 = center2(), [_2[1], -_2[0]]);
  };
  m.rotate = function(_2) {
    return arguments.length ? rotate([_2[0], _2[1], _2.length > 2 ? _2[2] + 90 : 90]) : (_2 = rotate(), [_2[0], _2[1], _2[2] - 90]);
  };
  return rotate([0, 0, 90]).scale(159.155);
}
function defaultSeparation$1(a2, b) {
  return a2.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x2, c2) {
  return x2 + c2.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y2, c2) {
  return Math.max(y2, c2.y);
}
function leafLeft(node2) {
  var children;
  while (children = node2.children)
    node2 = children[0];
  return node2;
}
function leafRight(node2) {
  var children;
  while (children = node2.children)
    node2 = children[children.length - 1];
  return node2;
}
function cluster() {
  var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = false;
  function cluster2(root2) {
    var previousNode, x2 = 0;
    root2.eachAfter(function(node2) {
      var children = node2.children;
      if (children) {
        node2.x = meanX(children);
        node2.y = maxY(children);
      } else {
        node2.x = previousNode ? x2 += separation(node2, previousNode) : 0;
        node2.y = 0;
        previousNode = node2;
      }
    });
    var left2 = leafLeft(root2), right2 = leafRight(root2), x02 = left2.x - separation(left2, right2) / 2, x12 = right2.x + separation(right2, left2) / 2;
    return root2.eachAfter(nodeSize ? function(node2) {
      node2.x = (node2.x - root2.x) * dx;
      node2.y = (root2.y - node2.y) * dy;
    } : function(node2) {
      node2.x = (node2.x - x02) / (x12 - x02) * dx;
      node2.y = (1 - (root2.y ? node2.y / root2.y : 1)) * dy;
    });
  }
  cluster2.separation = function(x2) {
    return arguments.length ? (separation = x2, cluster2) : separation;
  };
  cluster2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? null : [dx, dy];
  };
  cluster2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], cluster2) : nodeSize ? [dx, dy] : null;
  };
  return cluster2;
}
function count(node2) {
  var sum2 = 0, children = node2.children, i = children && children.length;
  if (!i)
    sum2 = 1;
  else
    while (--i >= 0)
      sum2 += children[i].value;
  node2.value = sum2;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback) {
  var node2 = this, current, next2 = [node2], children, i, n;
  do {
    current = next2.reverse(), next2 = [];
    while (node2 = current.pop()) {
      callback(node2), children = node2.children;
      if (children)
        for (i = 0, n = children.length; i < n; ++i) {
          next2.push(children[i]);
        }
    }
  } while (next2.length);
  return this;
}
function node_eachBefore(callback) {
  var node2 = this, nodes = [node2], children, i;
  while (node2 = nodes.pop()) {
    callback(node2), children = node2.children;
    if (children)
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
  }
  return this;
}
function node_eachAfter(callback) {
  var node2 = this, nodes = [node2], next2 = [], children, i, n;
  while (node2 = nodes.pop()) {
    next2.push(node2), children = node2.children;
    if (children)
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
  }
  while (node2 = next2.pop()) {
    callback(node2);
  }
  return this;
}
function node_sum(value) {
  return this.eachAfter(function(node2) {
    var sum2 = +value(node2.data) || 0, children = node2.children, i = children && children.length;
    while (--i >= 0)
      sum2 += children[i].value;
    node2.value = sum2;
  });
}
function node_sort(compare) {
  return this.eachBefore(function(node2) {
    if (node2.children) {
      node2.children.sort(compare);
    }
  });
}
function node_path(end2) {
  var start2 = this, ancestor = leastCommonAncestor(start2, end2), nodes = [start2];
  while (start2 !== ancestor) {
    start2 = start2.parent;
    nodes.push(start2);
  }
  var k2 = nodes.length;
  while (end2 !== ancestor) {
    nodes.splice(k2, 0, end2);
    end2 = end2.parent;
  }
  return nodes;
}
function leastCommonAncestor(a2, b) {
  if (a2 === b)
    return a2;
  var aNodes = a2.ancestors(), bNodes = b.ancestors(), c2 = null;
  a2 = aNodes.pop();
  b = bNodes.pop();
  while (a2 === b) {
    c2 = a2;
    a2 = aNodes.pop();
    b = bNodes.pop();
  }
  return c2;
}
function node_ancestors() {
  var node2 = this, nodes = [node2];
  while (node2 = node2.parent) {
    nodes.push(node2);
  }
  return nodes;
}
function node_descendants() {
  var nodes = [];
  this.each(function(node2) {
    nodes.push(node2);
  });
  return nodes;
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node2) {
    if (!node2.children) {
      leaves.push(node2);
    }
  });
  return leaves;
}
function node_links() {
  var root2 = this, links2 = [];
  root2.each(function(node2) {
    if (node2 !== root2) {
      links2.push({ source: node2.parent, target: node2 });
    }
  });
  return links2;
}
function hierarchy(data, children) {
  var root2 = new Node$1(data), valued = +data.value && (root2.value = data.value), node2, nodes = [root2], child, childs, i, n;
  if (children == null)
    children = defaultChildren;
  while (node2 = nodes.pop()) {
    if (valued)
      node2.value = +node2.data.value;
    if ((childs = children(node2.data)) && (n = childs.length)) {
      node2.children = new Array(n);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node2.children[i] = new Node$1(childs[i]));
        child.parent = node2;
        child.depth = node2.depth + 1;
      }
    }
  }
  return root2.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function defaultChildren(d) {
  return d.children;
}
function copyData(node2) {
  node2.data = node2.data.data;
}
function computeHeight(node2) {
  var height2 = 0;
  do
    node2.height = height2;
  while ((node2 = node2.parent) && node2.height < ++height2);
}
function Node$1(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}
Node$1.prototype = hierarchy.prototype = {
  constructor: Node$1,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy
};
var slice$2 = Array.prototype.slice;
function shuffle(array2) {
  var m = array2.length, t, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array2[m];
    array2[m] = array2[i];
    array2[i] = t;
  }
  return array2;
}
function enclose(circles2) {
  var i = 0, n = (circles2 = shuffle(slice$2.call(circles2))).length, B2 = [], p, e;
  while (i < n) {
    p = circles2[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B2 = extendBasis(B2, p)), i = 0;
  }
  return e;
}
function extendBasis(B2, p) {
  var i, j;
  if (enclosesWeakAll(p, B2))
    return [p];
  for (i = 0; i < B2.length; ++i) {
    if (enclosesNot(p, B2[i]) && enclosesWeakAll(encloseBasis2(B2[i], p), B2)) {
      return [B2[i], p];
    }
  }
  for (i = 0; i < B2.length - 1; ++i) {
    for (j = i + 1; j < B2.length; ++j) {
      if (enclosesNot(encloseBasis2(B2[i], B2[j]), p) && enclosesNot(encloseBasis2(B2[i], p), B2[j]) && enclosesNot(encloseBasis2(B2[j], p), B2[i]) && enclosesWeakAll(encloseBasis3(B2[i], B2[j], p), B2)) {
        return [B2[i], B2[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a2, b) {
  var dr = a2.r - b.r, dx = b.x - a2.x, dy = b.y - a2.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a2, b) {
  var dr = a2.r - b.r + 1e-6, dx = b.x - a2.x, dy = b.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a2, B2) {
  for (var i = 0; i < B2.length; ++i) {
    if (!enclosesWeak(a2, B2[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B2) {
  switch (B2.length) {
    case 1:
      return encloseBasis1(B2[0]);
    case 2:
      return encloseBasis2(B2[0], B2[1]);
    case 3:
      return encloseBasis3(B2[0], B2[1], B2[2]);
  }
}
function encloseBasis1(a2) {
  return {
    x: a2.x,
    y: a2.y,
    r: a2.r
  };
}
function encloseBasis2(a2, b) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x12, y21 = y2 - y12, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x12 + x2 + x21 / l * r21) / 2,
    y: (y12 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a2, b, c2) {
  var x12 = a2.x, y12 = a2.y, r1 = a2.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c2.x, y3 = c2.y, r3 = c2.r, a22 = x12 - x2, a3 = x12 - x3, b22 = y12 - y2, b32 = y12 - y3, c22 = r2 - r1, c3 = r3 - r1, d1 = x12 * x12 + y12 * y12 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d32 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b22 - a22 * b32, xa = (b22 * d32 - b32 * d2) / (ab * 2) - x12, xb = (b32 * c22 - b22 * c3) / ab, ya = (a3 * d2 - a22 * d32) / (ab * 2) - y12, yb = (a22 * c3 - a3 * c22) / ab, A5 = xb * xb + yb * yb - 1, B2 = 2 * (r1 + xa * xb + ya * yb), C2 = xa * xa + ya * ya - r1 * r1, r = -(A5 ? (B2 + Math.sqrt(B2 * B2 - 4 * A5 * C2)) / (2 * A5) : C2 / B2);
  return {
    x: x12 + xa + xb * r,
    y: y12 + ya + yb * r,
    r
  };
}
function place(b, a2, c2) {
  var dx = b.x - a2.x, x2, a22, dy = b.y - a2.y, y2, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a22 = a2.r + c2.r, a22 *= a22;
    b22 = b.r + c2.r, b22 *= b22;
    if (a22 > b22) {
      x2 = (d2 + b22 - a22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, b22 / d2 - x2 * x2));
      c2.x = b.x - x2 * dx - y2 * dy;
      c2.y = b.y - x2 * dy + y2 * dx;
    } else {
      x2 = (d2 + a22 - b22) / (2 * d2);
      y2 = Math.sqrt(Math.max(0, a22 / d2 - x2 * x2));
      c2.x = a2.x + x2 * dx - y2 * dy;
      c2.y = a2.y + x2 * dy + y2 * dx;
    }
  } else {
    c2.x = a2.x + c2.r;
    c2.y = a2.y;
  }
}
function intersects(a2, b) {
  var dr = a2.r + b.r - 1e-6, dx = b.x - a2.x, dy = b.y - a2.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node2) {
  var a2 = node2._, b = node2.next._, ab = a2.r + b.r, dx = (a2.x * b.r + b.x * a2.r) / ab, dy = (a2.y * b.r + b.y * a2.r) / ab;
  return dx * dx + dy * dy;
}
function Node(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles2) {
  if (!(n = circles2.length))
    return 0;
  var a2, b, c2, n, aa, ca, i, j, k2, sj, sk;
  a2 = circles2[0], a2.x = 0, a2.y = 0;
  if (!(n > 1))
    return a2.r;
  b = circles2[1], a2.x = -b.r, b.x = a2.r, b.y = 0;
  if (!(n > 2))
    return a2.r + b.r;
  place(b, a2, c2 = circles2[2]);
  a2 = new Node(a2), b = new Node(b), c2 = new Node(c2);
  a2.next = c2.previous = b;
  b.next = a2.previous = c2;
  c2.next = b.previous = a2;
  pack:
    for (i = 3; i < n; ++i) {
      place(a2._, b._, c2 = circles2[i]), c2 = new Node(c2);
      j = b.next, k2 = a2.previous, sj = b._.r, sk = a2._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c2._)) {
            b = j, a2.next = b, b.previous = a2, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k2._, c2._)) {
            a2 = k2, a2.next = b, b.previous = a2, --i;
            continue pack;
          }
          sk += k2._.r, k2 = k2.previous;
        }
      } while (j !== k2.next);
      c2.previous = a2, c2.next = b, a2.next = b.previous = b = c2;
      aa = score(a2);
      while ((c2 = c2.next) !== b) {
        if ((ca = score(c2)) < aa) {
          a2 = c2, aa = ca;
        }
      }
      b = a2.next;
    }
  a2 = [b._], c2 = b;
  while ((c2 = c2.next) !== b)
    a2.push(c2._);
  c2 = enclose(a2);
  for (i = 0; i < n; ++i)
    a2 = circles2[i], a2.x -= c2.x, a2.y -= c2.y;
  return c2.r;
}
function siblings(circles2) {
  packEnclose(circles2);
  return circles2;
}
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}
function constantZero() {
  return 0;
}
function constant$4(x2) {
  return function() {
    return x2;
  };
}
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function index$1() {
  var radius = null, dx = 1, dy = 1, padding2 = constantZero;
  function pack(root2) {
    root2.x = dx / 2, root2.y = dy / 2;
    if (radius) {
      root2.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding2, 0.5)).eachBefore(translateChild(1));
    } else {
      root2.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding2, root2.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root2.r)));
    }
    return root2;
  }
  pack.radius = function(x2) {
    return arguments.length ? (radius = optional(x2), pack) : radius;
  };
  pack.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], pack) : [dx, dy];
  };
  pack.padding = function(x2) {
    return arguments.length ? (padding2 = typeof x2 === "function" ? x2 : constant$4(+x2), pack) : padding2;
  };
  return pack;
}
function radiusLeaf(radius) {
  return function(node2) {
    if (!node2.children) {
      node2.r = Math.max(0, +radius(node2) || 0);
    }
  };
}
function packChildren(padding2, k2) {
  return function(node2) {
    if (children = node2.children) {
      var children, i, n = children.length, r = padding2(node2) * k2 || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r += r;
      e = packEnclose(children);
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r -= r;
      node2.r = e + r;
    }
  };
}
function translateChild(k2) {
  return function(node2) {
    var parent = node2.parent;
    node2.r *= k2;
    if (parent) {
      node2.x = parent.x + k2 * node2.x;
      node2.y = parent.y + k2 * node2.y;
    }
  };
}
function roundNode(node2) {
  node2.x0 = Math.round(node2.x0);
  node2.y0 = Math.round(node2.y0);
  node2.x1 = Math.round(node2.x1);
  node2.y1 = Math.round(node2.y1);
}
function treemapDice(parent, x02, y02, x12, y12) {
  var nodes = parent.children, node2, i = -1, n = nodes.length, k2 = parent.value && (x12 - x02) / parent.value;
  while (++i < n) {
    node2 = nodes[i], node2.y0 = y02, node2.y1 = y12;
    node2.x0 = x02, node2.x1 = x02 += node2.value * k2;
  }
}
function partition() {
  var dx = 1, dy = 1, padding2 = 0, round = false;
  function partition2(root2) {
    var n = root2.height + 1;
    root2.x0 = root2.y0 = padding2;
    root2.x1 = dx;
    root2.y1 = dy / n;
    root2.eachBefore(positionNode2(dy, n));
    if (round)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode2(dy2, n) {
    return function(node2) {
      if (node2.children) {
        treemapDice(node2, node2.x0, dy2 * (node2.depth + 1) / n, node2.x1, dy2 * (node2.depth + 2) / n);
      }
      var x02 = node2.x0, y02 = node2.y0, x12 = node2.x1 - padding2, y12 = node2.y1 - padding2;
      if (x12 < x02)
        x02 = x12 = (x02 + x12) / 2;
      if (y12 < y02)
        y02 = y12 = (y02 + y12) / 2;
      node2.x0 = x02;
      node2.y0 = y02;
      node2.x1 = x12;
      node2.y1 = y12;
    };
  }
  partition2.round = function(x2) {
    return arguments.length ? (round = !!x2, partition2) : round;
  };
  partition2.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x2) {
    return arguments.length ? (padding2 = +x2, partition2) : padding2;
  };
  return partition2;
}
var keyPrefix = "$", preroot = { depth: -1 }, ambiguous = {};
function defaultId(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify() {
  var id2 = defaultId, parentId = defaultParentId;
  function stratify2(data) {
    var d, i, n = data.length, root2, parent, node2, nodes = new Array(n), nodeId, nodeKey, nodeByKey = {};
    for (i = 0; i < n; ++i) {
      d = data[i], node2 = nodes[i] = new Node$1(d);
      if ((nodeId = id2(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node2.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node2;
      }
    }
    for (i = 0; i < n; ++i) {
      node2 = nodes[i], nodeId = parentId(data[i], i, data);
      if (nodeId == null || !(nodeId += "")) {
        if (root2)
          throw new Error("multiple roots");
        root2 = node2;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node2);
        else
          parent.children = [node2];
        node2.parent = parent;
      }
    }
    if (!root2)
      throw new Error("no root");
    root2.parent = preroot;
    root2.eachBefore(function(node3) {
      node3.depth = node3.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root2.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root2;
  }
  stratify2.id = function(x2) {
    return arguments.length ? (id2 = required(x2), stratify2) : id2;
  };
  stratify2.parentId = function(x2) {
    return arguments.length ? (parentId = required(x2), stratify2) : parentId;
  };
  return stratify2;
}
function defaultSeparation(a2, b) {
  return a2.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i = children.length, w2;
  while (--i >= 0) {
    w2 = children[i];
    w2.z += shift;
    w2.m += shift;
    shift += w2.s + (change += w2.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node2, i) {
  this._ = node2;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node$1.prototype);
function treeRoot(root2) {
  var tree2 = new TreeNode(root2, 0), node2, nodes = [tree2], child, children, i, n;
  while (node2 = nodes.pop()) {
    if (children = node2._.children) {
      node2.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node2.children[i] = new TreeNode(children[i], i));
        child.parent = node2;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree2(root2) {
    var t = treeRoot(root2);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root2.eachBefore(sizeNode);
    else {
      var left2 = root2, right2 = root2, bottom2 = root2;
      root2.eachBefore(function(node2) {
        if (node2.x < left2.x)
          left2 = node2;
        if (node2.x > right2.x)
          right2 = node2;
        if (node2.depth > bottom2.depth)
          bottom2 = node2;
      });
      var s2 = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s2 - left2.x, kx2 = dx / (right2.x + s2 + tx), ky2 = dy / (bottom2.depth || 1);
      root2.eachBefore(function(node2) {
        node2.x = (node2.x + tx) * kx2;
        node2.y = node2.depth * ky2;
      });
    }
    return root2;
  }
  function firstWalk(v) {
    var children = v.children, siblings2 = v.parent.children, w2 = v.i ? siblings2[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;
      if (w2) {
        v.z = w2.z + separation(v._, w2._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w2) {
      v.z = w2.z + separation(v._, w2._);
    }
    v.parent.A = apportion(v, w2, v.parent.A || siblings2[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w2, ancestor) {
    if (w2) {
      var vip = v, vop = v, vim = w2, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node2) {
    node2.x *= dx;
    node2.y = node2.depth * dy;
  }
  tree2.separation = function(x2) {
    return arguments.length ? (separation = x2, tree2) : separation;
  };
  tree2.size = function(x2) {
    return arguments.length ? (nodeSize = false, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? null : [dx, dy];
  };
  tree2.nodeSize = function(x2) {
    return arguments.length ? (nodeSize = true, dx = +x2[0], dy = +x2[1], tree2) : nodeSize ? [dx, dy] : null;
  };
  return tree2;
}
function treemapSlice(parent, x02, y02, x12, y12) {
  var nodes = parent.children, node2, i = -1, n = nodes.length, k2 = parent.value && (y12 - y02) / parent.value;
  while (++i < n) {
    node2 = nodes[i], node2.x0 = x02, node2.x1 = x12;
    node2.y0 = y02, node2.y1 = y02 += node2.value * k2;
  }
}
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x02, y02, x12, y12) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x12 - x02, dy = y12 - y02;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      treemapDice(row, x02, y02, x12, value ? y02 += dy * sumValue / value : y12);
    else
      treemapSlice(row, x02, y02, value ? x02 += dx * sumValue / value : x12, y12);
    value -= sumValue, i0 = i1;
  }
  return rows;
}
const squarify = function custom10(ratio) {
  function squarify2(parent, x02, y02, x12, y12) {
    squarifyRatio(ratio, parent, x02, y02, x12, y12);
  }
  squarify2.ratio = function(x2) {
    return custom10((x2 = +x2) > 1 ? x2 : 1);
  };
  return squarify2;
}(phi);
function index() {
  var tile = squarify, round = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap(root2) {
    root2.x0 = root2.y0 = 0;
    root2.x1 = dx;
    root2.y1 = dy;
    root2.eachBefore(positionNode2);
    paddingStack = [0];
    if (round)
      root2.eachBefore(roundNode);
    return root2;
  }
  function positionNode2(node2) {
    var p = paddingStack[node2.depth], x02 = node2.x0 + p, y02 = node2.y0 + p, x12 = node2.x1 - p, y12 = node2.y1 - p;
    if (x12 < x02)
      x02 = x12 = (x02 + x12) / 2;
    if (y12 < y02)
      y02 = y12 = (y02 + y12) / 2;
    node2.x0 = x02;
    node2.y0 = y02;
    node2.x1 = x12;
    node2.y1 = y12;
    if (node2.children) {
      p = paddingStack[node2.depth + 1] = paddingInner(node2) / 2;
      x02 += paddingLeft(node2) - p;
      y02 += paddingTop(node2) - p;
      x12 -= paddingRight(node2) - p;
      y12 -= paddingBottom(node2) - p;
      if (x12 < x02)
        x02 = x12 = (x02 + x12) / 2;
      if (y12 < y02)
        y02 = y12 = (y02 + y12) / 2;
      tile(node2, x02, y02, x12, y12);
    }
  }
  treemap.round = function(x2) {
    return arguments.length ? (round = !!x2, treemap) : round;
  };
  treemap.size = function(x2) {
    return arguments.length ? (dx = +x2[0], dy = +x2[1], treemap) : [dx, dy];
  };
  treemap.tile = function(x2) {
    return arguments.length ? (tile = required(x2), treemap) : tile;
  };
  treemap.padding = function(x2) {
    return arguments.length ? treemap.paddingInner(x2).paddingOuter(x2) : treemap.paddingInner();
  };
  treemap.paddingInner = function(x2) {
    return arguments.length ? (paddingInner = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingInner;
  };
  treemap.paddingOuter = function(x2) {
    return arguments.length ? treemap.paddingTop(x2).paddingRight(x2).paddingBottom(x2).paddingLeft(x2) : treemap.paddingTop();
  };
  treemap.paddingTop = function(x2) {
    return arguments.length ? (paddingTop = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingTop;
  };
  treemap.paddingRight = function(x2) {
    return arguments.length ? (paddingRight = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingRight;
  };
  treemap.paddingBottom = function(x2) {
    return arguments.length ? (paddingBottom = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingBottom;
  };
  treemap.paddingLeft = function(x2) {
    return arguments.length ? (paddingLeft = typeof x2 === "function" ? x2 : constant$4(+x2), treemap) : paddingLeft;
  };
  return treemap;
}
function binary(parent, x02, y02, x12, y12) {
  var nodes = parent.children, i, n = nodes.length, sum2, sums = new Array(n + 1);
  for (sums[0] = sum2 = i = 0; i < n; ++i) {
    sums[i + 1] = sum2 += nodes[i].value;
  }
  partition2(0, n, parent.value, x02, y02, x12, y12);
  function partition2(i2, j, value, x03, y03, x13, y13) {
    if (i2 >= j - 1) {
      var node2 = nodes[i2];
      node2.x0 = x03, node2.y0 = y03;
      node2.x1 = x13, node2.y1 = y13;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value / 2 + valueOffset, k2 = i2 + 1, hi = j - 1;
    while (k2 < hi) {
      var mid = k2 + hi >>> 1;
      if (sums[mid] < valueTarget)
        k2 = mid + 1;
      else
        hi = mid;
    }
    if (valueTarget - sums[k2 - 1] < sums[k2] - valueTarget && i2 + 1 < k2)
      --k2;
    var valueLeft = sums[k2] - valueOffset, valueRight = value - valueLeft;
    if (x13 - x03 > y13 - y03) {
      var xk = (x03 * valueRight + x13 * valueLeft) / value;
      partition2(i2, k2, valueLeft, x03, y03, xk, y13);
      partition2(k2, j, valueRight, xk, y03, x13, y13);
    } else {
      var yk = (y03 * valueRight + y13 * valueLeft) / value;
      partition2(i2, k2, valueLeft, x03, y03, x13, yk);
      partition2(k2, j, valueRight, x03, yk, x13, y13);
    }
  }
}
function sliceDice(parent, x02, y02, x12, y12) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x02, y02, x12, y12);
}
const resquarify = function custom11(ratio) {
  function resquarify2(parent, x02, y02, x12, y12) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m = rows.length, value = parent.value;
      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          treemapDice(row, x02, y02, x12, y02 += (y12 - y02) * row.value / value);
        else
          treemapSlice(row, x02, y02, x02 += (x12 - x02) * row.value / value, y12);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x02, y02, x12, y12);
      rows.ratio = ratio;
    }
  }
  resquarify2.ratio = function(x2) {
    return custom11((x2 = +x2) > 1 ? x2 : 1);
  };
  return resquarify2;
}(phi);
function area$1(polygon) {
  var i = -1, n = polygon.length, a2, b = polygon[n - 1], area2 = 0;
  while (++i < n) {
    a2 = b;
    b = polygon[i];
    area2 += a2[1] * b[0] - a2[0] * b[1];
  }
  return area2 / 2;
}
function centroid(polygon) {
  var i = -1, n = polygon.length, x2 = 0, y2 = 0, a2, b = polygon[n - 1], c2, k2 = 0;
  while (++i < n) {
    a2 = b;
    b = polygon[i];
    k2 += c2 = a2[0] * b[1] - b[0] * a2[1];
    x2 += (a2[0] + b[0]) * c2;
    y2 += (a2[1] + b[1]) * c2;
  }
  return k2 *= 3, [x2 / k2, y2 / k2];
}
function cross$2(a2, b, c2) {
  return (b[0] - a2[0]) * (c2[1] - a2[1]) - (b[1] - a2[1]) * (c2[0] - a2[0]);
}
function lexicographicOrder(a2, b) {
  return a2[0] - b[0] || a2[1] - b[1];
}
function computeUpperHullIndexes(points) {
  var n = points.length, indexes = [0, 1], size = 2;
  for (var i = 2; i < n; ++i) {
    while (size > 1 && cross$2(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0)
      --size;
    indexes[size++] = i;
  }
  return indexes.slice(0, size);
}
function hull(points) {
  if ((n = points.length) < 3)
    return null;
  var i, n, sortedPoints = new Array(n), flippedPoints = new Array(n);
  for (i = 0; i < n; ++i)
    sortedPoints[i] = [+points[i][0], +points[i][1], i];
  sortedPoints.sort(lexicographicOrder);
  for (i = 0; i < n; ++i)
    flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];
  var upperIndexes = computeUpperHullIndexes(sortedPoints), lowerIndexes = computeUpperHullIndexes(flippedPoints);
  var skipLeft = lowerIndexes[0] === upperIndexes[0], skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1], hull2 = [];
  for (i = upperIndexes.length - 1; i >= 0; --i)
    hull2.push(points[sortedPoints[upperIndexes[i]][2]]);
  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i)
    hull2.push(points[sortedPoints[lowerIndexes[i]][2]]);
  return hull2;
}
function contains(polygon, point2) {
  var n = polygon.length, p = polygon[n - 1], x2 = point2[0], y2 = point2[1], x02 = p[0], y02 = p[1], x12, y12, inside = false;
  for (var i = 0; i < n; ++i) {
    p = polygon[i], x12 = p[0], y12 = p[1];
    if (y12 > y2 !== y02 > y2 && x2 < (x02 - x12) * (y2 - y12) / (y02 - y12) + x12)
      inside = !inside;
    x02 = x12, y02 = y12;
  }
  return inside;
}
function length(polygon) {
  var i = -1, n = polygon.length, b = polygon[n - 1], xa, ya, xb = b[0], yb = b[1], perimeter = 0;
  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }
  return perimeter;
}
function defaultSource() {
  return Math.random();
}
const uniform = function sourceRandomUniform(source) {
  function randomUniform(min2, max2) {
    min2 = min2 == null ? 0 : +min2;
    max2 = max2 == null ? 1 : +max2;
    if (arguments.length === 1)
      max2 = min2, min2 = 0;
    else
      max2 -= min2;
    return function() {
      return source() * max2 + min2;
    };
  }
  randomUniform.source = sourceRandomUniform;
  return randomUniform;
}(defaultSource);
const normal = function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x2, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function() {
      var y2;
      if (x2 != null)
        y2 = x2, x2 = null;
      else
        do {
          x2 = source() * 2 - 1;
          y2 = source() * 2 - 1;
          r = x2 * x2 + y2 * y2;
        } while (!r || r > 1);
      return mu + sigma * y2 * Math.sqrt(-2 * Math.log(r) / r);
    };
  }
  randomNormal.source = sourceRandomNormal;
  return randomNormal;
}(defaultSource);
const logNormal = function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = normal.source(source).apply(this, arguments);
    return function() {
      return Math.exp(randomNormal());
    };
  }
  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
}(defaultSource);
const irwinHall = function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function() {
      for (var sum2 = 0, i = 0; i < n; ++i)
        sum2 += source();
      return sum2;
    };
  }
  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
}(defaultSource);
const bates = function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = irwinHall.source(source)(n);
    return function() {
      return randomIrwinHall() / n;
    };
  }
  randomBates.source = sourceRandomBates;
  return randomBates;
}(defaultSource);
const exponential = function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function() {
      return -Math.log(1 - source()) / lambda;
    };
  }
  randomExponential.source = sourceRandomExponential;
  return randomExponential;
}(defaultSource);
function initRange(domain, range2) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range2).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.interpolator(domain);
      break;
    default:
      this.interpolator(interpolator).domain(domain);
      break;
  }
  return this;
}
var array = Array.prototype;
var map = array.map;
var slice$1 = array.slice;
var implicit = { name: "implicit" };
function ordinal() {
  var index2 = map$2(), domain = [], range2 = [], unknown = implicit;
  function scale(d) {
    var key = d + "", i = index2.get(key);
    if (!i) {
      if (unknown !== implicit)
        return unknown;
      index2.set(key, i = domain.push(d));
    }
    return range2[(i - 1) % range2.length];
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index2 = map$2();
    var i = -1, n = _2.length, d, key;
    while (++i < n)
      if (!index2.has(key = (d = _2[i]) + ""))
        index2.set(key, domain.push(d));
    return scale;
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), scale) : range2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return ordinal(domain, range2).unknown(unknown);
  };
  initRange.apply(scale, arguments);
  return scale;
}
function band() {
  var scale = ordinal().unknown(void 0), domain = scale.domain, ordinalRange = scale.range, range2 = [0, 1], step2, bandwidth, round = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale.unknown;
  function rescale() {
    var n = domain().length, reverse2 = range2[1] < range2[0], start2 = range2[reverse2 - 0], stop = range2[1 - reverse2];
    step2 = (stop - start2) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round)
      step2 = Math.floor(step2);
    start2 += (stop - start2 - step2 * (n - paddingInner)) * align;
    bandwidth = step2 * (1 - paddingInner);
    if (round)
      start2 = Math.round(start2), bandwidth = Math.round(bandwidth);
    var values2 = sequence(n).map(function(i) {
      return start2 + step2 * i;
    });
    return ordinalRange(reverse2 ? values2.reverse() : values2);
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = [+_2[0], +_2[1]], rescale()) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return range2 = [+_2[0], +_2[1]], round = true, rescale();
  };
  scale.bandwidth = function() {
    return bandwidth;
  };
  scale.step = function() {
    return step2;
  };
  scale.round = function(_2) {
    return arguments.length ? (round = !!_2, rescale()) : round;
  };
  scale.padding = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_2), rescale()) : paddingInner;
  };
  scale.paddingInner = function(_2) {
    return arguments.length ? (paddingInner = Math.min(1, _2), rescale()) : paddingInner;
  };
  scale.paddingOuter = function(_2) {
    return arguments.length ? (paddingOuter = +_2, rescale()) : paddingOuter;
  };
  scale.align = function(_2) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _2)), rescale()) : align;
  };
  scale.copy = function() {
    return band(domain(), range2).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale) {
  var copy2 = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;
  scale.copy = function() {
    return pointish(copy2());
  };
  return scale;
}
function point$5() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
function constant$3(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$3(x2) {
  return x2;
}
function normalize(a2, b) {
  return (b -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b;
  } : constant$3(isNaN(b) ? NaN : 0.5);
}
function clamper(domain) {
  var a2 = domain[0], b = domain[domain.length - 1], t;
  if (a2 > b)
    t = a2, a2 = b, b = t;
  return function(x2) {
    return Math.max(a2, Math.min(b, x2));
  };
}
function bimap(domain, range2, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range2[0], r1 = range2[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range2, interpolate2) {
  var j = Math.min(domain.length, range2.length) - 1, d = new Array(j), r = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range2 = range2.slice().reverse();
  }
  while (++i < j) {
    d[i] = normalize(domain[i], domain[i + 1]);
    r[i] = interpolate2(range2[i], range2[i + 1]);
  }
  return function(x2) {
    var i2 = bisectRight(domain, x2, 1, j) - 1;
    return r[i2](d[i2](x2));
  };
}
function copy$2(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
  var domain = unit, range2 = unit, interpolate2 = interpolateValue, transform2, untransform, unknown, clamp = identity$3, piecewise2, output, input;
  function rescale() {
    piecewise2 = Math.min(domain.length, range2.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform2), range2, interpolate2)))(transform2(clamp(x2)));
  }
  scale.invert = function(y2) {
    return clamp(untransform((input || (input = piecewise2(range2, domain.map(transform2), interpolateNumber)))(y2)));
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain = map.call(_2, number$1), clamp === identity$3 || (clamp = clamper(domain)), rescale()) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), rescale()) : range2.slice();
  };
  scale.rangeRound = function(_2) {
    return range2 = slice$1.call(_2), interpolate2 = interpolateRound, rescale();
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = _2 ? clamper(domain) : identity$3, scale) : clamp !== identity$3;
  };
  scale.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, rescale()) : interpolate2;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t, u) {
    transform2 = t, untransform = u;
    return rescale();
  };
}
function continuous(transform2, untransform) {
  return transformer$2()(transform2, untransform);
}
function tickFormat(start2, stop, count2, specifier) {
  var step2 = tickStep(start2, stop, count2), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start2), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step2, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step2, Math.max(Math.abs(start2), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step2)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format$1(specifier);
}
function linearish(scale) {
  var domain = scale.domain;
  scale.ticks = function(count2) {
    var d = domain();
    return ticks(d[0], d[d.length - 1], count2 == null ? 10 : count2);
  };
  scale.tickFormat = function(count2, specifier) {
    var d = domain();
    return tickFormat(d[0], d[d.length - 1], count2 == null ? 10 : count2, specifier);
  };
  scale.nice = function(count2) {
    if (count2 == null)
      count2 = 10;
    var d = domain(), i0 = 0, i1 = d.length - 1, start2 = d[i0], stop = d[i1], step2;
    if (stop < start2) {
      step2 = start2, start2 = stop, stop = step2;
      step2 = i0, i0 = i1, i1 = step2;
    }
    step2 = tickIncrement(start2, stop, count2);
    if (step2 > 0) {
      start2 = Math.floor(start2 / step2) * step2;
      stop = Math.ceil(stop / step2) * step2;
      step2 = tickIncrement(start2, stop, count2);
    } else if (step2 < 0) {
      start2 = Math.ceil(start2 * step2) / step2;
      stop = Math.floor(stop * step2) / step2;
      step2 = tickIncrement(start2, stop, count2);
    }
    if (step2 > 0) {
      d[i0] = Math.floor(start2 / step2) * step2;
      d[i1] = Math.ceil(stop / step2) * step2;
      domain(d);
    } else if (step2 < 0) {
      d[i0] = Math.ceil(start2 * step2) / step2;
      d[i1] = Math.floor(stop * step2) / step2;
      domain(d);
    }
    return scale;
  };
  return scale;
}
function linear() {
  var scale = continuous(identity$3, identity$3);
  scale.copy = function() {
    return copy$2(scale, linear());
  };
  initRange.apply(scale, arguments);
  return linearish(scale);
}
function identity$2(domain) {
  var unknown;
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : x2;
  }
  scale.invert = scale;
  scale.domain = scale.range = function(_2) {
    return arguments.length ? (domain = map.call(_2, number$1), scale) : domain.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return identity$2(domain).unknown(unknown);
  };
  domain = arguments.length ? map.call(domain, number$1) : [0, 1];
  return linearish(scale);
}
function nice(domain, interval2) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x02 = domain[i0], x12 = domain[i1], t;
  if (x12 < x02) {
    t = i0, i0 = i1, i1 = t;
    t = x02, x02 = x12, x12 = t;
  }
  domain[i0] = interval2.floor(x02);
  domain[i1] = interval2.ceil(x12);
  return domain;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function(x2) {
    return Math.pow(base, x2);
  };
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function(x2) {
    return Math.log(x2) / base;
  });
}
function reflect(f) {
  return function(x2) {
    return -f(-x2);
  };
}
function loggish(transform2) {
  var scale = transform2(transformLog, transformExp), domain = scale.domain, base = 10, logs, pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform2(transformLogn, transformExpn);
    } else {
      transform2(transformLog, transformExp);
    }
    return scale;
  }
  scale.base = function(_2) {
    return arguments.length ? (base = +_2, rescale()) : base;
  };
  scale.domain = function(_2) {
    return arguments.length ? (domain(_2), rescale()) : domain();
  };
  scale.ticks = function(count2) {
    var d = domain(), u = d[0], v = d[d.length - 1], r;
    if (r = v < u)
      i = u, u = v, v = i;
    var i = logs(u), j = logs(v), p, k2, t, n = count2 == null ? 10 : +count2, z = [];
    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0)
        for (; i < j; ++i) {
          for (k2 = 1, p = pows(i); k2 < base; ++k2) {
            t = p * k2;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
      else
        for (; i < j; ++i) {
          for (k2 = base - 1, p = pows(i); k2 >= 1; --k2) {
            t = p * k2;
            if (t < u)
              continue;
            if (t > v)
              break;
            z.push(t);
          }
        }
    } else {
      z = ticks(i, j, Math.min(j - i, n)).map(pows);
    }
    return r ? z.reverse() : z;
  };
  scale.tickFormat = function(count2, specifier) {
    if (specifier == null)
      specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function")
      specifier = format$1(specifier);
    if (count2 === Infinity)
      return specifier;
    if (count2 == null)
      count2 = 10;
    var k2 = Math.max(1, base * count2 / scale.ticks().length);
    return function(d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k2 ? specifier(d) : "";
    };
  };
  scale.nice = function() {
    return domain(nice(domain(), {
      floor: function(x2) {
        return pows(Math.floor(logs(x2)));
      },
      ceil: function(x2) {
        return pows(Math.ceil(logs(x2)));
      }
    }));
  };
  return scale;
}
function log$2() {
  var scale = loggish(transformer$2()).domain([1, 10]);
  scale.copy = function() {
    return copy$2(scale, log$2()).base(scale.base());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform2) {
  var c2 = 1, scale = transform2(transformSymlog(c2), transformSymexp(c2));
  scale.constant = function(_2) {
    return arguments.length ? transform2(transformSymlog(c2 = +_2), transformSymexp(c2)) : c2;
  };
  return linearish(scale);
}
function symlog() {
  var scale = symlogish(transformer$2());
  scale.copy = function() {
    return copy$2(scale, symlog()).constant(scale.constant());
  };
  return initRange.apply(scale, arguments);
}
function transformPow(exponent2) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform2) {
  var scale = transform2(identity$3, identity$3), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform2(identity$3, identity$3) : exponent2 === 0.5 ? transform2(transformSqrt, transformSquare) : transform2(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale.exponent = function(_2) {
    return arguments.length ? (exponent2 = +_2, rescale()) : exponent2;
  };
  return linearish(scale);
}
function pow() {
  var scale = powish(transformer$2());
  scale.copy = function() {
    return copy$2(scale, pow()).exponent(scale.exponent());
  };
  initRange.apply(scale, arguments);
  return scale;
}
function sqrt$1() {
  return pow.apply(null, arguments).exponent(0.5);
}
function quantile() {
  var domain = [], range2 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n = Math.max(1, range2.length);
    thresholds = new Array(n - 1);
    while (++i < n)
      thresholds[i - 1] = threshold$1(domain, i / n);
    return scale;
  }
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : range2[bisectRight(thresholds, x2)];
  }
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (var i = 0, n = _2.length, d; i < n; ++i)
      if (d = _2[i], d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending$3);
    return rescale();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), rescale()) : range2.slice();
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.quantiles = function() {
    return thresholds.slice();
  };
  scale.copy = function() {
    return quantile().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
function quantize() {
  var x02 = 0, x12 = 1, n = 1, domain = [0.5], range2 = [0, 1], unknown;
  function scale(x2) {
    return x2 <= x2 ? range2[bisectRight(domain, x2, 0, n)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n);
    while (++i < n)
      domain[i] = ((i + 1) * x12 - (i - n) * x02) / (n + 1);
    return scale;
  }
  scale.domain = function(_2) {
    return arguments.length ? (x02 = +_2[0], x12 = +_2[1], rescale()) : [x02, x12];
  };
  scale.range = function(_2) {
    return arguments.length ? (n = (range2 = slice$1.call(_2)).length - 1, rescale()) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x02, domain[0]] : i >= n ? [domain[n - 1], x12] : [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : scale;
  };
  scale.thresholds = function() {
    return domain.slice();
  };
  scale.copy = function() {
    return quantize().domain([x02, x12]).range(range2).unknown(unknown);
  };
  return initRange.apply(linearish(scale), arguments);
}
function threshold() {
  var domain = [0.5], range2 = [0, 1], unknown, n = 1;
  function scale(x2) {
    return x2 <= x2 ? range2[bisectRight(domain, x2, 0, n)] : unknown;
  }
  scale.domain = function(_2) {
    return arguments.length ? (domain = slice$1.call(_2), n = Math.min(domain.length, range2.length - 1), scale) : domain.slice();
  };
  scale.range = function(_2) {
    return arguments.length ? (range2 = slice$1.call(_2), n = Math.min(domain.length, range2.length - 1), scale) : range2.slice();
  };
  scale.invertExtent = function(y2) {
    var i = range2.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  scale.copy = function() {
    return threshold().domain(domain).range(range2).unknown(unknown);
  };
  return initRange.apply(scale, arguments);
}
var t0 = new Date(), t1 = new Date();
function newInterval(floori, offseti, count2, field) {
  function interval2(date2) {
    return floori(date2 = arguments.length === 0 ? new Date() : new Date(+date2)), date2;
  }
  interval2.floor = function(date2) {
    return floori(date2 = new Date(+date2)), date2;
  };
  interval2.ceil = function(date2) {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval2.round = function(date2) {
    var d0 = interval2(date2), d1 = interval2.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval2.offset = function(date2, step2) {
    return offseti(date2 = new Date(+date2), step2 == null ? 1 : Math.floor(step2)), date2;
  };
  interval2.range = function(start2, stop, step2) {
    var range2 = [], previous;
    start2 = interval2.ceil(start2);
    step2 = step2 == null ? 1 : Math.floor(step2);
    if (!(start2 < stop) || !(step2 > 0))
      return range2;
    do
      range2.push(previous = new Date(+start2)), offseti(start2, step2), floori(start2);
    while (previous < start2 && start2 < stop);
    return range2;
  };
  interval2.filter = function(test) {
    return newInterval(function(date2) {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, function(date2, step2) {
      if (date2 >= date2) {
        if (step2 < 0)
          while (++step2 <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step2 >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count2) {
    interval2.count = function(start2, end2) {
      t0.setTime(+start2), t1.setTime(+end2);
      floori(t0), floori(t1);
      return Math.floor(count2(t0, t1));
    };
    interval2.every = function(step2) {
      step2 = Math.floor(step2);
      return !isFinite(step2) || !(step2 > 0) ? null : !(step2 > 1) ? interval2 : interval2.filter(field ? function(d) {
        return field(d) % step2 === 0;
      } : function(d) {
        return interval2.count(0, d) % step2 === 0;
      });
    };
  }
  return interval2;
}
var millisecond = newInterval(function() {
}, function(date2, step2) {
  date2.setTime(+date2 + step2);
}, function(start2, end2) {
  return end2 - start2;
});
millisecond.every = function(k2) {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond;
  return newInterval(function(date2) {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, function(date2, step2) {
    date2.setTime(+date2 + step2 * k2);
  }, function(start2, end2) {
    return (end2 - start2) / k2;
  });
};
const utcMillisecond = millisecond;
var milliseconds = millisecond.range;
var durationSecond$1 = 1e3;
var durationMinute$1 = 6e4;
var durationHour$1 = 36e5;
var durationDay$1 = 864e5;
var durationWeek$1 = 6048e5;
var second = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds());
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationSecond$1);
}, function(start2, end2) {
  return (end2 - start2) / durationSecond$1;
}, function(date2) {
  return date2.getUTCSeconds();
});
const utcSecond = second;
var seconds = second.range;
var minute = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$1);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$1;
}, function(date2) {
  return date2.getMinutes();
});
const timeMinute = minute;
var minutes = minute.range;
var hour = newInterval(function(date2) {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond$1 - date2.getMinutes() * durationMinute$1);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$1);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$1;
}, function(date2) {
  return date2.getHours();
});
const timeHour = hour;
var hours = hour.range;
var day = newInterval(function(date2) {
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setDate(date2.getDate() + step2);
}, function(start2, end2) {
  return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$1) / durationDay$1;
}, function(date2) {
  return date2.getDate() - 1;
});
const timeDay = day;
var days = day.range;
function weekday(i) {
  return newInterval(function(date2) {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setDate(date2.getDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2 - (end2.getTimezoneOffset() - start2.getTimezoneOffset()) * durationMinute$1) / durationWeek$1;
  });
}
var sunday = weekday(0);
var monday = weekday(1);
var tuesday = weekday(2);
var wednesday = weekday(3);
var thursday = weekday(4);
var friday = weekday(5);
var saturday = weekday(6);
var sundays = sunday.range;
var mondays = monday.range;
var tuesdays = tuesday.range;
var wednesdays = wednesday.range;
var thursdays = thursday.range;
var fridays = friday.range;
var saturdays = saturday.range;
var month = newInterval(function(date2) {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setMonth(date2.getMonth() + step2);
}, function(start2, end2) {
  return end2.getMonth() - start2.getMonth() + (end2.getFullYear() - start2.getFullYear()) * 12;
}, function(date2) {
  return date2.getMonth();
});
const timeMonth = month;
var months = month.range;
var year = newInterval(function(date2) {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setFullYear(date2.getFullYear() + step2);
}, function(start2, end2) {
  return end2.getFullYear() - start2.getFullYear();
}, function(date2) {
  return date2.getFullYear();
});
year.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setFullYear(date2.getFullYear() + step2 * k2);
  });
};
const timeYear = year;
var years = year.range;
var utcMinute = newInterval(function(date2) {
  date2.setUTCSeconds(0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationMinute$1);
}, function(start2, end2) {
  return (end2 - start2) / durationMinute$1;
}, function(date2) {
  return date2.getUTCMinutes();
});
const utcMinute$1 = utcMinute;
var utcMinutes = utcMinute.range;
var utcHour = newInterval(function(date2) {
  date2.setUTCMinutes(0, 0, 0);
}, function(date2, step2) {
  date2.setTime(+date2 + step2 * durationHour$1);
}, function(start2, end2) {
  return (end2 - start2) / durationHour$1;
}, function(date2) {
  return date2.getUTCHours();
});
const utcHour$1 = utcHour;
var utcHours = utcHour.range;
var utcDay = newInterval(function(date2) {
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCDate(date2.getUTCDate() + step2);
}, function(start2, end2) {
  return (end2 - start2) / durationDay$1;
}, function(date2) {
  return date2.getUTCDate() - 1;
});
const utcDay$1 = utcDay;
var utcDays = utcDay.range;
function utcWeekday(i) {
  return newInterval(function(date2) {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCDate(date2.getUTCDate() + step2 * 7);
  }, function(start2, end2) {
    return (end2 - start2) / durationWeek$1;
  });
}
var utcSunday = utcWeekday(0);
var utcMonday = utcWeekday(1);
var utcTuesday = utcWeekday(2);
var utcWednesday = utcWeekday(3);
var utcThursday = utcWeekday(4);
var utcFriday = utcWeekday(5);
var utcSaturday = utcWeekday(6);
var utcSundays = utcSunday.range;
var utcMondays = utcMonday.range;
var utcTuesdays = utcTuesday.range;
var utcWednesdays = utcWednesday.range;
var utcThursdays = utcThursday.range;
var utcFridays = utcFriday.range;
var utcSaturdays = utcSaturday.range;
var utcMonth = newInterval(function(date2) {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCMonth(date2.getUTCMonth() + step2);
}, function(start2, end2) {
  return end2.getUTCMonth() - start2.getUTCMonth() + (end2.getUTCFullYear() - start2.getUTCFullYear()) * 12;
}, function(date2) {
  return date2.getUTCMonth();
});
const utcMonth$1 = utcMonth;
var utcMonths = utcMonth.range;
var utcYear = newInterval(function(date2) {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, function(date2, step2) {
  date2.setUTCFullYear(date2.getUTCFullYear() + step2);
}, function(start2, end2) {
  return end2.getUTCFullYear() - start2.getUTCFullYear();
}, function(date2) {
  return date2.getUTCFullYear();
});
utcYear.every = function(k2) {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : newInterval(function(date2) {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, function(date2, step2) {
    date2.setUTCFullYear(date2.getUTCFullYear() + step2 * k2);
  });
};
const utcYear$1 = utcYear;
var utcYears = utcYear.range;
function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date2.setFullYear(d.y);
    return date2;
  }
  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}
function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date2 = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date2.setUTCFullYear(d.y);
    return date2;
  }
  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}
function newDate(y2, m, d) {
  return { y: y2, m, d, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string = [], i = -1, j = 0, n = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date))
        date2 = new Date(+date2);
      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2])
            c2 = format2(date2, pad2);
          string.push(c2);
          j = i + 1;
        }
      }
      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string) {
      var d = newDate(1900, void 0, 1), i = parseSpecifier(d, specifier, string += "", 0), week, day2;
      if (i != string.length)
        return null;
      if ("Q" in d)
        return new Date(d.Q);
      if ("s" in d)
        return new Date(d.s * 1e3 + ("L" in d ? d.L : 0));
      if (Z && !("Z" in d))
        d.Z = 0;
      if ("p" in d)
        d.H = d.H % 12 + d.p * 12;
      if (d.m === void 0)
        d.m = "q" in d ? d.q : 0;
      if ("V" in d) {
        if (d.V < 1 || d.V > 53)
          return null;
        if (!("w" in d))
          d.w = 1;
        if ("Z" in d) {
          week = utcDate(newDate(d.y, 0, 1)), day2 = week.getUTCDay();
          week = day2 > 4 || day2 === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay$1.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = localDate(newDate(d.y, 0, 1)), day2 = week.getDay();
          week = day2 > 4 || day2 === 0 ? monday.ceil(week) : monday(week);
          week = timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d))
          d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day2 = "Z" in d ? utcDate(newDate(d.y, 0, 1)).getUTCDay() : localDate(newDate(d.y, 0, 1)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day2 + 5) % 7 : d.w + d.U * 7 - (day2 + 6) % 7;
      }
      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      }
      return localDate(d);
    };
  }
  function parseSpecifier(d, specifier, string, j) {
    var i = 0, n = specifier.length, m = string.length, c2, parse2;
    while (i < n) {
      if (j >= m)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse2 || (j = parse2(d, string, j)) < 0)
          return -1;
      } else if (c2 != string.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }
  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }
  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }
  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }
  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }
  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }
  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }
  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }
  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }
  function formatQuarter(d) {
    return 1 + ~~(d.getMonth() / 3);
  }
  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }
  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }
  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }
  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }
  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d) {
    return 1 + ~~(d.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f = newFormat(specifier += "", formats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    parse: function(specifier) {
      var p = newParse(specifier += "", false);
      p.toString = function() {
        return specifier;
      };
      return p;
    },
    utcFormat: function(specifier) {
      var f = newFormat(specifier += "", utcFormats);
      f.toString = function() {
        return specifier;
      };
      return f;
    },
    utcParse: function(specifier) {
      var p = newParse(specifier += "", true);
      p.toString = function() {
        return specifier;
      };
      return p;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width2) {
  var sign2 = value < 0 ? "-" : "", string = (sign2 ? -value : value) + "", length2 = string.length;
  return sign2 + (length2 < width2 ? new Array(width2 - length2 + 1).join(fill) + string : string);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  var map2 = {}, i = -1, n = names.length;
  while (++i < n)
    map2[names[i].toLowerCase()] = i;
  return map2;
}
function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}
function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}
function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}
function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}
function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3), i + n[0].length) : -1;
}
function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}
function parseQuarter(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.q = n[0] * 3 - 3, i + n[0].length) : -1;
}
function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}
function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}
function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}
function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}
function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}
function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}
function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}
function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1e3), i + n[0].length) : -1;
}
function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}
function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}
function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.s = +n[0], i + n[0].length) : -1;
}
function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}
function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}
function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}
function formatDayOfYear(d, p) {
  return pad(1 + timeDay.count(timeYear(d), d), p, 3);
}
function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}
function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}
function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}
function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}
function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}
function formatWeekdayNumberMonday(d) {
  var day2 = d.getDay();
  return day2 === 0 ? 7 : day2;
}
function formatWeekNumberSunday(d, p) {
  return pad(sunday.count(timeYear(d) - 1, d), p, 2);
}
function dISO(d) {
  var day2 = d.getDay();
  return day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
}
function formatWeekNumberISO(d, p) {
  d = dISO(d);
  return pad(thursday.count(timeYear(d), d) + (timeYear(d).getDay() === 4), p, 2);
}
function formatWeekdayNumberSunday(d) {
  return d.getDay();
}
function formatWeekNumberMonday(d, p) {
  return pad(monday.count(timeYear(d) - 1, d), p, 2);
}
function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}
function formatYearISO(d, p) {
  d = dISO(d);
  return pad(d.getFullYear() % 100, p, 2);
}
function formatFullYear(d, p) {
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatFullYearISO(d, p) {
  var day2 = d.getDay();
  d = day2 >= 4 || day2 === 0 ? thursday(d) : thursday.ceil(d);
  return pad(d.getFullYear() % 1e4, p, 4);
}
function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}
function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}
function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}
function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}
function formatUTCDayOfYear(d, p) {
  return pad(1 + utcDay$1.count(utcYear$1(d), d), p, 3);
}
function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}
function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}
function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}
function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}
function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}
function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d, p) {
  return pad(utcSunday.count(utcYear$1(d) - 1, d), p, 2);
}
function UTCdISO(d) {
  var day2 = d.getUTCDay();
  return day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
}
function formatUTCWeekNumberISO(d, p) {
  d = UTCdISO(d);
  return pad(utcThursday.count(utcYear$1(d), d) + (utcYear$1(d).getUTCDay() === 4), p, 2);
}
function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}
function formatUTCWeekNumberMonday(d, p) {
  return pad(utcMonday.count(utcYear$1(d) - 1, d), p, 2);
}
function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCYearISO(d, p) {
  d = UTCdISO(d);
  return pad(d.getUTCFullYear() % 100, p, 2);
}
function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCFullYearISO(d, p) {
  var day2 = d.getUTCDay();
  d = day2 >= 4 || day2 === 0 ? utcThursday(d) : utcThursday.ceil(d);
  return pad(d.getUTCFullYear() % 1e4, p, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d) {
  return +d;
}
function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1e3);
}
var locale;
var timeFormat;
var timeParse;
var utcFormat;
var utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  timeParse = locale.parse;
  utcFormat = locale.utcFormat;
  utcParse = locale.utcParse;
  return locale;
}
var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
function formatIsoNative(date2) {
  return date2.toISOString();
}
var formatIso = Date.prototype.toISOString ? formatIsoNative : utcFormat(isoSpecifier);
const formatIso$1 = formatIso;
function parseIsoNative(string) {
  var date2 = new Date(string);
  return isNaN(date2) ? null : date2;
}
var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : utcParse(isoSpecifier);
const parseIso$1 = parseIso;
var durationSecond = 1e3, durationMinute = durationSecond * 60, durationHour = durationMinute * 60, durationDay = durationHour * 24, durationWeek = durationDay * 7, durationMonth = durationDay * 30, durationYear = durationDay * 365;
function date(t) {
  return new Date(t);
}
function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}
function calendar(year2, month2, week, day2, hour2, minute2, second2, millisecond2, format2) {
  var scale = continuous(identity$3, identity$3), invert2 = scale.invert, domain = scale.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  var tickIntervals = [
    [second2, 1, durationSecond],
    [second2, 5, 5 * durationSecond],
    [second2, 15, 15 * durationSecond],
    [second2, 30, 30 * durationSecond],
    [minute2, 1, durationMinute],
    [minute2, 5, 5 * durationMinute],
    [minute2, 15, 15 * durationMinute],
    [minute2, 30, 30 * durationMinute],
    [hour2, 1, durationHour],
    [hour2, 3, 3 * durationHour],
    [hour2, 6, 6 * durationHour],
    [hour2, 12, 12 * durationHour],
    [day2, 1, durationDay],
    [day2, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month2, 1, durationMonth],
    [month2, 3, 3 * durationMonth],
    [year2, 1, durationYear]
  ];
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute2(date2) < date2 ? formatSecond : hour2(date2) < date2 ? formatMinute : day2(date2) < date2 ? formatHour : month2(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year2(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  function tickInterval(interval2, start2, stop, step2) {
    if (interval2 == null)
      interval2 = 10;
    if (typeof interval2 === "number") {
      var target = Math.abs(stop - start2) / interval2, i = bisector(function(i2) {
        return i2[2];
      }).right(tickIntervals, target);
      if (i === tickIntervals.length) {
        step2 = tickStep(start2 / durationYear, stop / durationYear, interval2);
        interval2 = year2;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step2 = i[1];
        interval2 = i[0];
      } else {
        step2 = Math.max(tickStep(start2, stop, interval2), 1);
        interval2 = millisecond2;
      }
    }
    return step2 == null ? interval2 : interval2.every(step2);
  }
  scale.invert = function(y2) {
    return new Date(invert2(y2));
  };
  scale.domain = function(_2) {
    return arguments.length ? domain(map.call(_2, number)) : domain().map(date);
  };
  scale.ticks = function(interval2, step2) {
    var d = domain(), t02 = d[0], t12 = d[d.length - 1], r = t12 < t02, t;
    if (r)
      t = t02, t02 = t12, t12 = t;
    t = tickInterval(interval2, t02, t12, step2);
    t = t ? t.range(t02, t12 + 1) : [];
    return r ? t.reverse() : t;
  };
  scale.tickFormat = function(count2, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale.nice = function(interval2, step2) {
    var d = domain();
    return (interval2 = tickInterval(interval2, d[0], d[d.length - 1], step2)) ? domain(nice(d, interval2)) : scale;
  };
  scale.copy = function() {
    return copy$2(scale, calendar(year2, month2, week, day2, hour2, minute2, second2, millisecond2, format2));
  };
  return scale;
}
function time() {
  return initRange.apply(calendar(timeYear, timeMonth, sunday, timeDay, timeHour, timeMinute, utcSecond, utcMillisecond, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcYear$1, utcMonth$1, utcSunday, utcDay$1, utcHour$1, utcMinute$1, utcSecond, utcMillisecond, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
  var x02 = 0, x12 = 1, t02, t12, k10, transform2, interpolator = identity$3, clamp = false, unknown;
  function scale(x2) {
    return isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform2(x2) - t02) * k10, clamp ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale.domain = function(_2) {
    return arguments.length ? (t02 = transform2(x02 = +_2[0]), t12 = transform2(x12 = +_2[1]), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale) : [x02, x12];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t) {
    transform2 = t, t02 = t(x02), t12 = t(x12), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale;
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale = linearish(transformer$1()(identity$3));
  scale.copy = function() {
    return copy$1(scale, sequential());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialLog() {
  var scale = loggish(transformer$1()).domain([1, 10]);
  scale.copy = function() {
    return copy$1(scale, sequentialLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSymlog() {
  var scale = symlogish(transformer$1());
  scale.copy = function() {
    return copy$1(scale, sequentialSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialPow() {
  var scale = powish(transformer$1());
  scale.copy = function() {
    return copy$1(scale, sequentialPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function sequentialQuantile() {
  var domain = [], interpolator = identity$3;
  function scale(x2) {
    if (!isNaN(x2 = +x2))
      return interpolator((bisectRight(domain, x2) - 1) / (domain.length - 1));
  }
  scale.domain = function(_2) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (var i = 0, n = _2.length, d; i < n; ++i)
      if (d = _2[i], d != null && !isNaN(d = +d))
        domain.push(d);
    domain.sort(ascending$3);
    return scale;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale, arguments);
}
function transformer() {
  var x02 = 0, x12 = 0.5, x2 = 1, t02, t12, t22, k10, k21, interpolator = identity$3, transform2, clamp = false, unknown;
  function scale(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform2(x3)) - t12) * (x3 < t12 ? k10 : k21), interpolator(clamp ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale.domain = function(_2) {
    return arguments.length ? (t02 = transform2(x02 = +_2[0]), t12 = transform2(x12 = +_2[1]), t22 = transform2(x2 = +_2[2]), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12), scale) : [x02, x12, x2];
  };
  scale.clamp = function(_2) {
    return arguments.length ? (clamp = !!_2, scale) : clamp;
  };
  scale.interpolator = function(_2) {
    return arguments.length ? (interpolator = _2, scale) : interpolator;
  };
  scale.unknown = function(_2) {
    return arguments.length ? (unknown = _2, scale) : unknown;
  };
  return function(t) {
    transform2 = t, t02 = t(x02), t12 = t(x12), t22 = t(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t22 ? 0 : 0.5 / (t22 - t12);
    return scale;
  };
}
function diverging$1() {
  var scale = linearish(transformer()(identity$3));
  scale.copy = function() {
    return copy$1(scale, diverging$1());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingLog() {
  var scale = loggish(transformer()).domain([0.1, 1, 10]);
  scale.copy = function() {
    return copy$1(scale, divergingLog()).base(scale.base());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSymlog() {
  var scale = symlogish(transformer());
  scale.copy = function() {
    return copy$1(scale, divergingSymlog()).constant(scale.constant());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingPow() {
  var scale = powish(transformer());
  scale.copy = function() {
    return copy$1(scale, divergingPow()).exponent(scale.exponent());
  };
  return initInterpolator.apply(scale, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
function colors(specifier) {
  var n = specifier.length / 6 | 0, colors2 = new Array(n), i = 0;
  while (i < n)
    colors2[i] = "#" + specifier.slice(i * 6, ++i * 6);
  return colors2;
}
const category10 = colors("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");
const Accent = colors("7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666");
const Dark2 = colors("1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666");
const Paired = colors("a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928");
const Pastel1 = colors("fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2");
const Pastel2 = colors("b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc");
const Set1 = colors("e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999");
const Set2 = colors("66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3");
const Set3 = colors("8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f");
const Tableau10 = colors("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
function ramp$1(scheme2) {
  return rgbBasis(scheme2[scheme2.length - 1]);
}
var scheme$q = new Array(3).concat(
  "d8b365f5f5f55ab4ac",
  "a6611adfc27d80cdc1018571",
  "a6611adfc27df5f5f580cdc1018571",
  "8c510ad8b365f6e8c3c7eae55ab4ac01665e",
  "8c510ad8b365f6e8c3f5f5f5c7eae55ab4ac01665e",
  "8c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e",
  "8c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e",
  "5430058c510abf812ddfc27df6e8c3c7eae580cdc135978f01665e003c30",
  "5430058c510abf812ddfc27df6e8c3f5f5f5c7eae580cdc135978f01665e003c30"
).map(colors);
const BrBG = ramp$1(scheme$q);
var scheme$p = new Array(3).concat(
  "af8dc3f7f7f77fbf7b",
  "7b3294c2a5cfa6dba0008837",
  "7b3294c2a5cff7f7f7a6dba0008837",
  "762a83af8dc3e7d4e8d9f0d37fbf7b1b7837",
  "762a83af8dc3e7d4e8f7f7f7d9f0d37fbf7b1b7837",
  "762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b7837",
  "762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b7837",
  "40004b762a839970abc2a5cfe7d4e8d9f0d3a6dba05aae611b783700441b",
  "40004b762a839970abc2a5cfe7d4e8f7f7f7d9f0d3a6dba05aae611b783700441b"
).map(colors);
const PRGn = ramp$1(scheme$p);
var scheme$o = new Array(3).concat(
  "e9a3c9f7f7f7a1d76a",
  "d01c8bf1b6dab8e1864dac26",
  "d01c8bf1b6daf7f7f7b8e1864dac26",
  "c51b7de9a3c9fde0efe6f5d0a1d76a4d9221",
  "c51b7de9a3c9fde0eff7f7f7e6f5d0a1d76a4d9221",
  "c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221",
  "c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221",
  "8e0152c51b7dde77aef1b6dafde0efe6f5d0b8e1867fbc414d9221276419",
  "8e0152c51b7dde77aef1b6dafde0eff7f7f7e6f5d0b8e1867fbc414d9221276419"
).map(colors);
const PiYG = ramp$1(scheme$o);
var scheme$n = new Array(3).concat(
  "998ec3f7f7f7f1a340",
  "5e3c99b2abd2fdb863e66101",
  "5e3c99b2abd2f7f7f7fdb863e66101",
  "542788998ec3d8daebfee0b6f1a340b35806",
  "542788998ec3d8daebf7f7f7fee0b6f1a340b35806",
  "5427888073acb2abd2d8daebfee0b6fdb863e08214b35806",
  "5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b35806",
  "2d004b5427888073acb2abd2d8daebfee0b6fdb863e08214b358067f3b08",
  "2d004b5427888073acb2abd2d8daebf7f7f7fee0b6fdb863e08214b358067f3b08"
).map(colors);
const PuOr = ramp$1(scheme$n);
var scheme$m = new Array(3).concat(
  "ef8a62f7f7f767a9cf",
  "ca0020f4a58292c5de0571b0",
  "ca0020f4a582f7f7f792c5de0571b0",
  "b2182bef8a62fddbc7d1e5f067a9cf2166ac",
  "b2182bef8a62fddbc7f7f7f7d1e5f067a9cf2166ac",
  "b2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac",
  "b2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac",
  "67001fb2182bd6604df4a582fddbc7d1e5f092c5de4393c32166ac053061",
  "67001fb2182bd6604df4a582fddbc7f7f7f7d1e5f092c5de4393c32166ac053061"
).map(colors);
const RdBu = ramp$1(scheme$m);
var scheme$l = new Array(3).concat(
  "ef8a62ffffff999999",
  "ca0020f4a582bababa404040",
  "ca0020f4a582ffffffbababa404040",
  "b2182bef8a62fddbc7e0e0e09999994d4d4d",
  "b2182bef8a62fddbc7ffffffe0e0e09999994d4d4d",
  "b2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d",
  "b2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d",
  "67001fb2182bd6604df4a582fddbc7e0e0e0bababa8787874d4d4d1a1a1a",
  "67001fb2182bd6604df4a582fddbc7ffffffe0e0e0bababa8787874d4d4d1a1a1a"
).map(colors);
const RdGy = ramp$1(scheme$l);
var scheme$k = new Array(3).concat(
  "fc8d59ffffbf91bfdb",
  "d7191cfdae61abd9e92c7bb6",
  "d7191cfdae61ffffbfabd9e92c7bb6",
  "d73027fc8d59fee090e0f3f891bfdb4575b4",
  "d73027fc8d59fee090ffffbfe0f3f891bfdb4575b4",
  "d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4",
  "d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4",
  "a50026d73027f46d43fdae61fee090e0f3f8abd9e974add14575b4313695",
  "a50026d73027f46d43fdae61fee090ffffbfe0f3f8abd9e974add14575b4313695"
).map(colors);
const RdYlBu = ramp$1(scheme$k);
var scheme$j = new Array(3).concat(
  "fc8d59ffffbf91cf60",
  "d7191cfdae61a6d96a1a9641",
  "d7191cfdae61ffffbfa6d96a1a9641",
  "d73027fc8d59fee08bd9ef8b91cf601a9850",
  "d73027fc8d59fee08bffffbfd9ef8b91cf601a9850",
  "d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850",
  "d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850",
  "a50026d73027f46d43fdae61fee08bd9ef8ba6d96a66bd631a9850006837",
  "a50026d73027f46d43fdae61fee08bffffbfd9ef8ba6d96a66bd631a9850006837"
).map(colors);
const RdYlGn = ramp$1(scheme$j);
var scheme$i = new Array(3).concat(
  "fc8d59ffffbf99d594",
  "d7191cfdae61abdda42b83ba",
  "d7191cfdae61ffffbfabdda42b83ba",
  "d53e4ffc8d59fee08be6f59899d5943288bd",
  "d53e4ffc8d59fee08bffffbfe6f59899d5943288bd",
  "d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd",
  "d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd",
  "9e0142d53e4ff46d43fdae61fee08be6f598abdda466c2a53288bd5e4fa2",
  "9e0142d53e4ff46d43fdae61fee08bffffbfe6f598abdda466c2a53288bd5e4fa2"
).map(colors);
const Spectral = ramp$1(scheme$i);
var scheme$h = new Array(3).concat(
  "e5f5f999d8c92ca25f",
  "edf8fbb2e2e266c2a4238b45",
  "edf8fbb2e2e266c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a42ca25f006d2c",
  "edf8fbccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45005824",
  "f7fcfde5f5f9ccece699d8c966c2a441ae76238b45006d2c00441b"
).map(colors);
const BuGn = ramp$1(scheme$h);
var scheme$g = new Array(3).concat(
  "e0ecf49ebcda8856a7",
  "edf8fbb3cde38c96c688419d",
  "edf8fbb3cde38c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68856a7810f7c",
  "edf8fbbfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d6e016b",
  "f7fcfde0ecf4bfd3e69ebcda8c96c68c6bb188419d810f7c4d004b"
).map(colors);
const BuPu = ramp$1(scheme$g);
var scheme$f = new Array(3).concat(
  "e0f3dba8ddb543a2ca",
  "f0f9e8bae4bc7bccc42b8cbe",
  "f0f9e8bae4bc7bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc443a2ca0868ac",
  "f0f9e8ccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe08589e",
  "f7fcf0e0f3dbccebc5a8ddb57bccc44eb3d32b8cbe0868ac084081"
).map(colors);
const GnBu = ramp$1(scheme$f);
var scheme$e = new Array(3).concat(
  "fee8c8fdbb84e34a33",
  "fef0d9fdcc8afc8d59d7301f",
  "fef0d9fdcc8afc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59e34a33b30000",
  "fef0d9fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301f990000",
  "fff7ecfee8c8fdd49efdbb84fc8d59ef6548d7301fb300007f0000"
).map(colors);
const OrRd = ramp$1(scheme$e);
var scheme$d = new Array(3).concat(
  "ece2f0a6bddb1c9099",
  "f6eff7bdc9e167a9cf02818a",
  "f6eff7bdc9e167a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf1c9099016c59",
  "f6eff7d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016450",
  "fff7fbece2f0d0d1e6a6bddb67a9cf3690c002818a016c59014636"
).map(colors);
const PuBuGn = ramp$1(scheme$d);
var scheme$c = new Array(3).concat(
  "ece7f2a6bddb2b8cbe",
  "f1eef6bdc9e174a9cf0570b0",
  "f1eef6bdc9e174a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf2b8cbe045a8d",
  "f1eef6d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0034e7b",
  "fff7fbece7f2d0d1e6a6bddb74a9cf3690c00570b0045a8d023858"
).map(colors);
const PuBu = ramp$1(scheme$c);
var scheme$b = new Array(3).concat(
  "e7e1efc994c7dd1c77",
  "f1eef6d7b5d8df65b0ce1256",
  "f1eef6d7b5d8df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0dd1c77980043",
  "f1eef6d4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125691003f",
  "f7f4f9e7e1efd4b9dac994c7df65b0e7298ace125698004367001f"
).map(colors);
const PuRd = ramp$1(scheme$b);
var scheme$a = new Array(3).concat(
  "fde0ddfa9fb5c51b8a",
  "feebe2fbb4b9f768a1ae017e",
  "feebe2fbb4b9f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1c51b8a7a0177",
  "feebe2fcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a0177",
  "fff7f3fde0ddfcc5c0fa9fb5f768a1dd3497ae017e7a017749006a"
).map(colors);
const RdPu = ramp$1(scheme$a);
var scheme$9 = new Array(3).concat(
  "edf8b17fcdbb2c7fb8",
  "ffffcca1dab441b6c4225ea8",
  "ffffcca1dab441b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c42c7fb8253494",
  "ffffccc7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea80c2c84",
  "ffffd9edf8b1c7e9b47fcdbb41b6c41d91c0225ea8253494081d58"
).map(colors);
const YlGnBu = ramp$1(scheme$9);
var scheme$8 = new Array(3).concat(
  "f7fcb9addd8e31a354",
  "ffffccc2e69978c679238443",
  "ffffccc2e69978c67931a354006837",
  "ffffccd9f0a3addd8e78c67931a354006837",
  "ffffccd9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443005a32",
  "ffffe5f7fcb9d9f0a3addd8e78c67941ab5d238443006837004529"
).map(colors);
const YlGn = ramp$1(scheme$8);
var scheme$7 = new Array(3).concat(
  "fff7bcfec44fd95f0e",
  "ffffd4fed98efe9929cc4c02",
  "ffffd4fed98efe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929d95f0e993404",
  "ffffd4fee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c028c2d04",
  "ffffe5fff7bcfee391fec44ffe9929ec7014cc4c02993404662506"
).map(colors);
const YlOrBr = ramp$1(scheme$7);
var scheme$6 = new Array(3).concat(
  "ffeda0feb24cf03b20",
  "ffffb2fecc5cfd8d3ce31a1c",
  "ffffb2fecc5cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cf03b20bd0026",
  "ffffb2fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cb10026",
  "ffffccffeda0fed976feb24cfd8d3cfc4e2ae31a1cbd0026800026"
).map(colors);
const YlOrRd = ramp$1(scheme$6);
var scheme$5 = new Array(3).concat(
  "deebf79ecae13182bd",
  "eff3ffbdd7e76baed62171b5",
  "eff3ffbdd7e76baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed63182bd08519c",
  "eff3ffc6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b5084594",
  "f7fbffdeebf7c6dbef9ecae16baed64292c62171b508519c08306b"
).map(colors);
const Blues = ramp$1(scheme$5);
var scheme$4 = new Array(3).concat(
  "e5f5e0a1d99b31a354",
  "edf8e9bae4b374c476238b45",
  "edf8e9bae4b374c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47631a354006d2c",
  "edf8e9c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45005a32",
  "f7fcf5e5f5e0c7e9c0a1d99b74c47641ab5d238b45006d2c00441b"
).map(colors);
const Greens = ramp$1(scheme$4);
var scheme$3 = new Array(3).concat(
  "f0f0f0bdbdbd636363",
  "f7f7f7cccccc969696525252",
  "f7f7f7cccccc969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696636363252525",
  "f7f7f7d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525",
  "fffffff0f0f0d9d9d9bdbdbd969696737373525252252525000000"
).map(colors);
const Greys = ramp$1(scheme$3);
var scheme$2 = new Array(3).concat(
  "efedf5bcbddc756bb1",
  "f2f0f7cbc9e29e9ac86a51a3",
  "f2f0f7cbc9e29e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8756bb154278f",
  "f2f0f7dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a34a1486",
  "fcfbfdefedf5dadaebbcbddc9e9ac8807dba6a51a354278f3f007d"
).map(colors);
const Purples = ramp$1(scheme$2);
var scheme$1 = new Array(3).concat(
  "fee0d2fc9272de2d26",
  "fee5d9fcae91fb6a4acb181d",
  "fee5d9fcae91fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4ade2d26a50f15",
  "fee5d9fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181d99000d",
  "fff5f0fee0d2fcbba1fc9272fb6a4aef3b2ccb181da50f1567000d"
).map(colors);
const Reds = ramp$1(scheme$1);
var scheme = new Array(3).concat(
  "fee6cefdae6be6550d",
  "feeddefdbe85fd8d3cd94701",
  "feeddefdbe85fd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3ce6550da63603",
  "feeddefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d948018c2d04",
  "fff5ebfee6cefdd0a2fdae6bfd8d3cf16913d94801a636037f2704"
).map(colors);
const Oranges = ramp$1(scheme);
function cividis(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(-4.54 - t * (35.34 - t * (2381.73 - t * (6402.7 - t * (7024.72 - t * 2710.57))))))) + ", " + Math.max(0, Math.min(255, Math.round(32.49 + t * (170.73 + t * (52.82 - t * (131.46 - t * (176.58 - t * 67.37))))))) + ", " + Math.max(0, Math.min(255, Math.round(81.24 + t * (442.36 - t * (2482.43 - t * (6167.24 - t * (6614.94 - t * 2475.67))))))) + ")";
}
const cubehelix = cubehelixLong(cubehelix$3(300, 0.5, 0), cubehelix$3(-240, 0.5, 1));
var warm = cubehelixLong(cubehelix$3(-100, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
var cool = cubehelixLong(cubehelix$3(260, 0.75, 0.35), cubehelix$3(80, 1.5, 0.8));
var c$3 = cubehelix$3();
function rainbow(t) {
  if (t < 0 || t > 1)
    t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  c$3.h = 360 * t - 100;
  c$3.s = 1.5 - 1.5 * ts;
  c$3.l = 0.8 - 0.9 * ts;
  return c$3 + "";
}
var c$2 = rgb(), pi_1_3 = Math.PI / 3, pi_2_3 = Math.PI * 2 / 3;
function sinebow(t) {
  var x2;
  t = (0.5 - t) * Math.PI;
  c$2.r = 255 * (x2 = Math.sin(t)) * x2;
  c$2.g = 255 * (x2 = Math.sin(t + pi_1_3)) * x2;
  c$2.b = 255 * (x2 = Math.sin(t + pi_2_3)) * x2;
  return c$2 + "";
}
function turbo(t) {
  t = Math.max(0, Math.min(1, t));
  return "rgb(" + Math.max(0, Math.min(255, Math.round(34.61 + t * (1172.33 - t * (10793.56 - t * (33300.12 - t * (38394.49 - t * 14825.05))))))) + ", " + Math.max(0, Math.min(255, Math.round(23.31 + t * (557.33 + t * (1225.33 - t * (3574.96 - t * (1073.77 + t * 707.56))))))) + ", " + Math.max(0, Math.min(255, Math.round(27.2 + t * (3211.1 - t * (15327.97 - t * (27814 - t * (22569.18 - t * 6838.66))))))) + ")";
}
function ramp(range2) {
  var n = range2.length;
  return function(t) {
    return range2[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}
const viridis = ramp(colors("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));
var magma = ramp(colors("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
var inferno = ramp(colors("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
var plasma = ramp(colors("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
function constant$2(x2) {
  return function constant2() {
    return x2;
  };
}
var abs = Math.abs;
var atan2 = Math.atan2;
var cos = Math.cos;
var max = Math.max;
var min = Math.min;
var sin = Math.sin;
var sqrt = Math.sqrt;
var epsilon$1 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var tau = 2 * pi;
function acos(x2) {
  return x2 > 1 ? 0 : x2 < -1 ? pi : Math.acos(x2);
}
function asin(x2) {
  return x2 >= 1 ? halfPi : x2 <= -1 ? -halfPi : Math.asin(x2);
}
function arcInnerRadius(d) {
  return d.innerRadius;
}
function arcOuterRadius(d) {
  return d.outerRadius;
}
function arcStartAngle(d) {
  return d.startAngle;
}
function arcEndAngle(d) {
  return d.endAngle;
}
function arcPadAngle(d) {
  return d && d.padAngle;
}
function intersect$1(x02, y02, x12, y12, x2, y2, x3, y3) {
  var x10 = x12 - x02, y10 = y12 - y02, x32 = x3 - x2, y32 = y3 - y2, t = y32 * x10 - x32 * y10;
  if (t * t < epsilon$1)
    return;
  t = (x32 * (y02 - y2) - y32 * (x02 - x2)) / t;
  return [x02 + t * x10, y02 + t * y10];
}
function cornerTangents(x02, y02, x12, y12, r1, rc, cw) {
  var x01 = x02 - x12, y01 = y02 - y12, lo = (cw ? rc : -rc) / sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x11 = x02 + ox, y11 = y02 + oy, x10 = x12 + ox, y10 = y12 + oy, x002 = (x11 + x10) / 2, y002 = (y11 + y10) / 2, dx = x10 - x11, dy = y10 - y11, d2 = dx * dx + dy * dy, r = r1 - rc, D2 = x11 * y10 - x10 * y11, d = (dy < 0 ? -1 : 1) * sqrt(max(0, r * r * d2 - D2 * D2)), cx0 = (D2 * dy - dx * d) / d2, cy0 = (-D2 * dx - dy * d) / d2, cx1 = (D2 * dy + dx * d) / d2, cy1 = (-D2 * dx + dy * d) / d2, dx0 = cx0 - x002, dy0 = cy0 - y002, dx1 = cx1 - x002, dy1 = cy1 - y002;
  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1)
    cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function arc() {
  var innerRadius = arcInnerRadius, outerRadius = arcOuterRadius, cornerRadius = constant$2(0), padRadius = null, startAngle = arcStartAngle, endAngle = arcEndAngle, padAngle = arcPadAngle, context = null;
  function arc2() {
    var buffer2, r, r0 = +innerRadius.apply(this, arguments), r1 = +outerRadius.apply(this, arguments), a0 = startAngle.apply(this, arguments) - halfPi, a1 = endAngle.apply(this, arguments) - halfPi, da = abs(a1 - a0), cw = a1 > a0;
    if (!context)
      context = buffer2 = path();
    if (r1 < r0)
      r = r1, r1 = r0, r0 = r;
    if (!(r1 > epsilon$1))
      context.moveTo(0, 0);
    else if (da > tau - epsilon$1) {
      context.moveTo(r1 * cos(a0), r1 * sin(a0));
      context.arc(0, 0, r1, a0, a1, !cw);
      if (r0 > epsilon$1) {
        context.moveTo(r0 * cos(a1), r0 * sin(a1));
        context.arc(0, 0, r0, a1, a0, cw);
      }
    } else {
      var a01 = a0, a11 = a1, a00 = a0, a10 = a1, da0 = da, da1 = da, ap = padAngle.apply(this, arguments) / 2, rp = ap > epsilon$1 && (padRadius ? +padRadius.apply(this, arguments) : sqrt(r0 * r0 + r1 * r1)), rc = min(abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments)), rc0 = rc, rc1 = rc, t02, t12;
      if (rp > epsilon$1) {
        var p02 = asin(rp / r0 * sin(ap)), p1 = asin(rp / r1 * sin(ap));
        if ((da0 -= p02 * 2) > epsilon$1)
          p02 *= cw ? 1 : -1, a00 += p02, a10 -= p02;
        else
          da0 = 0, a00 = a10 = (a0 + a1) / 2;
        if ((da1 -= p1 * 2) > epsilon$1)
          p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;
        else
          da1 = 0, a01 = a11 = (a0 + a1) / 2;
      }
      var x01 = r1 * cos(a01), y01 = r1 * sin(a01), x10 = r0 * cos(a10), y10 = r0 * sin(a10);
      if (rc > epsilon$1) {
        var x11 = r1 * cos(a11), y11 = r1 * sin(a11), x002 = r0 * cos(a00), y002 = r0 * sin(a00), oc;
        if (da < pi && (oc = intersect$1(x01, y01, x002, y002, x11, y11, x10, y10))) {
          var ax = x01 - oc[0], ay = y01 - oc[1], bx = x11 - oc[0], by = y11 - oc[1], kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2), lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
          rc0 = min(rc, (r0 - lc) / (kc - 1));
          rc1 = min(rc, (r1 - lc) / (kc + 1));
        }
      }
      if (!(da1 > epsilon$1))
        context.moveTo(x01, y01);
      else if (rc1 > epsilon$1) {
        t02 = cornerTangents(x002, y002, x01, y01, r1, rc1, cw);
        t12 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
        context.moveTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc1 < rc)
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc1, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r1, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), !cw);
          context.arc(t12.cx, t12.cy, rc1, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else
        context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw);
      if (!(r0 > epsilon$1) || !(da0 > epsilon$1))
        context.lineTo(x10, y10);
      else if (rc0 > epsilon$1) {
        t02 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
        t12 = cornerTangents(x01, y01, x002, y002, r0, -rc0, cw);
        context.lineTo(t02.cx + t02.x01, t02.cy + t02.y01);
        if (rc0 < rc)
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t12.y01, t12.x01), !cw);
        else {
          context.arc(t02.cx, t02.cy, rc0, atan2(t02.y01, t02.x01), atan2(t02.y11, t02.x11), !cw);
          context.arc(0, 0, r0, atan2(t02.cy + t02.y11, t02.cx + t02.x11), atan2(t12.cy + t12.y11, t12.cx + t12.x11), cw);
          context.arc(t12.cx, t12.cy, rc0, atan2(t12.y11, t12.x11), atan2(t12.y01, t12.x01), !cw);
        }
      } else
        context.arc(0, 0, r0, a10, a00, cw);
    }
    context.closePath();
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  arc2.centroid = function() {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a2 = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - pi / 2;
    return [cos(a2) * r, sin(a2) * r];
  };
  arc2.innerRadius = function(_2) {
    return arguments.length ? (innerRadius = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : innerRadius;
  };
  arc2.outerRadius = function(_2) {
    return arguments.length ? (outerRadius = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : outerRadius;
  };
  arc2.cornerRadius = function(_2) {
    return arguments.length ? (cornerRadius = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : cornerRadius;
  };
  arc2.padRadius = function(_2) {
    return arguments.length ? (padRadius = _2 == null ? null : typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : padRadius;
  };
  arc2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : startAngle;
  };
  arc2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : endAngle;
  };
  arc2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$2(+_2), arc2) : padAngle;
  };
  arc2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, arc2) : context;
  };
  return arc2;
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x$1(p) {
  return p[0];
}
function y$1(p) {
  return p[1];
}
function line() {
  var x2 = x$1, y2 = y$1, defined = constant$2(true), context = null, curve = curveLinear, output = null;
  function line2(data) {
    var i, n = data.length, d, defined0 = false, buffer2;
    if (context == null)
      output = curve(buffer2 = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x2(d, i, data), +y2(d, i, data));
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  line2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$2(+_2), line2) : x2;
  };
  line2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$2(+_2), line2) : y2;
  };
  line2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$2(!!_2), line2) : defined;
  };
  line2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), line2) : curve;
  };
  line2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), line2) : context;
  };
  return line2;
}
function area() {
  var x02 = x$1, x12 = null, y02 = constant$2(0), y12 = y$1, defined = constant$2(true), context = null, curve = curveLinear, output = null;
  function area2(data) {
    var i, j, k2, n = data.length, d, defined0 = false, buffer2, x0z = new Array(n), y0z = new Array(n);
    if (context == null)
      output = curve(buffer2 = path());
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x02(d, i, data), y0z[i] = +y02(d, i, data);
        output.point(x12 ? +x12(d, i, data) : x0z[i], y12 ? +y12(d, i, data) : y0z[i]);
      }
    }
    if (buffer2)
      return output = null, buffer2 + "" || null;
  }
  function arealine() {
    return line().defined(defined).curve(curve).context(context);
  }
  area2.x = function(_2) {
    return arguments.length ? (x02 = typeof _2 === "function" ? _2 : constant$2(+_2), x12 = null, area2) : x02;
  };
  area2.x0 = function(_2) {
    return arguments.length ? (x02 = typeof _2 === "function" ? _2 : constant$2(+_2), area2) : x02;
  };
  area2.x1 = function(_2) {
    return arguments.length ? (x12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$2(+_2), area2) : x12;
  };
  area2.y = function(_2) {
    return arguments.length ? (y02 = typeof _2 === "function" ? _2 : constant$2(+_2), y12 = null, area2) : y02;
  };
  area2.y0 = function(_2) {
    return arguments.length ? (y02 = typeof _2 === "function" ? _2 : constant$2(+_2), area2) : y02;
  };
  area2.y1 = function(_2) {
    return arguments.length ? (y12 = _2 == null ? null : typeof _2 === "function" ? _2 : constant$2(+_2), area2) : y12;
  };
  area2.lineX0 = area2.lineY0 = function() {
    return arealine().x(x02).y(y02);
  };
  area2.lineY1 = function() {
    return arealine().x(x02).y(y12);
  };
  area2.lineX1 = function() {
    return arealine().x(x12).y(y02);
  };
  area2.defined = function(_2) {
    return arguments.length ? (defined = typeof _2 === "function" ? _2 : constant$2(!!_2), area2) : defined;
  };
  area2.curve = function(_2) {
    return arguments.length ? (curve = _2, context != null && (output = curve(context)), area2) : curve;
  };
  area2.context = function(_2) {
    return arguments.length ? (_2 == null ? context = output = null : output = curve(context = _2), area2) : context;
  };
  return area2;
}
function descending$1(a2, b) {
  return b < a2 ? -1 : b > a2 ? 1 : b >= a2 ? 0 : NaN;
}
function identity$1(d) {
  return d;
}
function pie() {
  var value = identity$1, sortValues = descending$1, sort2 = null, startAngle = constant$2(0), endAngle = constant$2(tau), padAngle = constant$2(0);
  function pie2(data) {
    var i, n = data.length, j, k2, sum2 = 0, index2 = new Array(n), arcs = new Array(n), a0 = +startAngle.apply(this, arguments), da = Math.min(tau, Math.max(-tau, endAngle.apply(this, arguments) - a0)), a1, p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)), pa = p * (da < 0 ? -1 : 1), v;
    for (i = 0; i < n; ++i) {
      if ((v = arcs[index2[i] = i] = +value(data[i], i, data)) > 0) {
        sum2 += v;
      }
    }
    if (sortValues != null)
      index2.sort(function(i2, j2) {
        return sortValues(arcs[i2], arcs[j2]);
      });
    else if (sort2 != null)
      index2.sort(function(i2, j2) {
        return sort2(data[i2], data[j2]);
      });
    for (i = 0, k2 = sum2 ? (da - n * pa) / sum2 : 0; i < n; ++i, a0 = a1) {
      j = index2[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k2 : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }
    return arcs;
  }
  pie2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : value;
  };
  pie2.sortValues = function(_2) {
    return arguments.length ? (sortValues = _2, sort2 = null, pie2) : sortValues;
  };
  pie2.sort = function(_2) {
    return arguments.length ? (sort2 = _2, sortValues = null, pie2) : sort2;
  };
  pie2.startAngle = function(_2) {
    return arguments.length ? (startAngle = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : startAngle;
  };
  pie2.endAngle = function(_2) {
    return arguments.length ? (endAngle = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : endAngle;
  };
  pie2.padAngle = function(_2) {
    return arguments.length ? (padAngle = typeof _2 === "function" ? _2 : constant$2(+_2), pie2) : padAngle;
  };
  return pie2;
}
var curveRadialLinear = curveRadial$1(curveLinear);
function Radial(curve) {
  this._curve = curve;
}
Radial.prototype = {
  areaStart: function() {
    this._curve.areaStart();
  },
  areaEnd: function() {
    this._curve.areaEnd();
  },
  lineStart: function() {
    this._curve.lineStart();
  },
  lineEnd: function() {
    this._curve.lineEnd();
  },
  point: function(a2, r) {
    this._curve.point(r * Math.sin(a2), r * -Math.cos(a2));
  }
};
function curveRadial$1(curve) {
  function radial2(context) {
    return new Radial(curve(context));
  }
  radial2._curve = curve;
  return radial2;
}
function lineRadial(l) {
  var c2 = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  l.curve = function(_2) {
    return arguments.length ? c2(curveRadial$1(_2)) : c2()._curve;
  };
  return l;
}
function lineRadial$1() {
  return lineRadial(line().curve(curveRadialLinear));
}
function areaRadial() {
  var a2 = area().curve(curveRadialLinear), c2 = a2.curve, x02 = a2.lineX0, x12 = a2.lineX1, y02 = a2.lineY0, y12 = a2.lineY1;
  a2.angle = a2.x, delete a2.x;
  a2.startAngle = a2.x0, delete a2.x0;
  a2.endAngle = a2.x1, delete a2.x1;
  a2.radius = a2.y, delete a2.y;
  a2.innerRadius = a2.y0, delete a2.y0;
  a2.outerRadius = a2.y1, delete a2.y1;
  a2.lineStartAngle = function() {
    return lineRadial(x02());
  }, delete a2.lineX0;
  a2.lineEndAngle = function() {
    return lineRadial(x12());
  }, delete a2.lineX1;
  a2.lineInnerRadius = function() {
    return lineRadial(y02());
  }, delete a2.lineY0;
  a2.lineOuterRadius = function() {
    return lineRadial(y12());
  }, delete a2.lineY1;
  a2.curve = function(_2) {
    return arguments.length ? c2(curveRadial$1(_2)) : c2()._curve;
  };
  return a2;
}
function pointRadial(x2, y2) {
  return [(y2 = +y2) * Math.cos(x2 -= Math.PI / 2), y2 * Math.sin(x2)];
}
var slice = Array.prototype.slice;
function linkSource(d) {
  return d.source;
}
function linkTarget(d) {
  return d.target;
}
function link(curve) {
  var source = linkSource, target = linkTarget, x2 = x$1, y2 = y$1, context = null;
  function link2() {
    var buffer2, argv = slice.call(arguments), s2 = source.apply(this, argv), t = target.apply(this, argv);
    if (!context)
      context = buffer2 = path();
    curve(context, +x2.apply(this, (argv[0] = s2, argv)), +y2.apply(this, argv), +x2.apply(this, (argv[0] = t, argv)), +y2.apply(this, argv));
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  link2.source = function(_2) {
    return arguments.length ? (source = _2, link2) : source;
  };
  link2.target = function(_2) {
    return arguments.length ? (target = _2, link2) : target;
  };
  link2.x = function(_2) {
    return arguments.length ? (x2 = typeof _2 === "function" ? _2 : constant$2(+_2), link2) : x2;
  };
  link2.y = function(_2) {
    return arguments.length ? (y2 = typeof _2 === "function" ? _2 : constant$2(+_2), link2) : y2;
  };
  link2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, link2) : context;
  };
  return link2;
}
function curveHorizontal(context, x02, y02, x12, y12) {
  context.moveTo(x02, y02);
  context.bezierCurveTo(x02 = (x02 + x12) / 2, y02, x02, y12, x12, y12);
}
function curveVertical(context, x02, y02, x12, y12) {
  context.moveTo(x02, y02);
  context.bezierCurveTo(x02, y02 = (y02 + y12) / 2, x12, y02, x12, y12);
}
function curveRadial(context, x02, y02, x12, y12) {
  var p02 = pointRadial(x02, y02), p1 = pointRadial(x02, y02 = (y02 + y12) / 2), p2 = pointRadial(x12, y02), p3 = pointRadial(x12, y12);
  context.moveTo(p02[0], p02[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}
function linkHorizontal() {
  return link(curveHorizontal);
}
function linkVertical() {
  return link(curveVertical);
}
function linkRadial() {
  var l = link(curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}
const circle$2 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, tau);
  }
};
const cross$1 = {
  draw: function(context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};
var tan30 = Math.sqrt(1 / 3), tan30_2 = tan30 * 2;
const diamond = {
  draw: function(context, size) {
    var y2 = Math.sqrt(size / tan30_2), x2 = y2 * tan30;
    context.moveTo(0, -y2);
    context.lineTo(x2, 0);
    context.lineTo(0, y2);
    context.lineTo(-x2, 0);
    context.closePath();
  }
};
var ka = 0.8908130915292852, kr = Math.sin(pi / 10) / Math.sin(7 * pi / 10), kx = Math.sin(tau / 10) * kr, ky = -Math.cos(tau / 10) * kr;
const star = {
  draw: function(context, size) {
    var r = Math.sqrt(size * ka), x2 = kx * r, y2 = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x2, y2);
    for (var i = 1; i < 5; ++i) {
      var a2 = tau * i / 5, c2 = Math.cos(a2), s2 = Math.sin(a2);
      context.lineTo(s2 * r, -c2 * r);
      context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
    }
    context.closePath();
  }
};
const square = {
  draw: function(context, size) {
    var w2 = Math.sqrt(size), x2 = -w2 / 2;
    context.rect(x2, x2, w2, w2);
  }
};
var sqrt3 = Math.sqrt(3);
const triangle = {
  draw: function(context, size) {
    var y2 = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt3 * y2, -y2);
    context.lineTo(sqrt3 * y2, -y2);
    context.closePath();
  }
};
var c$1 = -0.5, s = Math.sqrt(3) / 2, k = 1 / Math.sqrt(12), a = (k / 2 + 1) * 3;
const wye = {
  draw: function(context, size) {
    var r = Math.sqrt(size / a), x02 = r / 2, y02 = r * k, x12 = x02, y12 = r * k + r, x2 = -x12, y2 = y12;
    context.moveTo(x02, y02);
    context.lineTo(x12, y12);
    context.lineTo(x2, y2);
    context.lineTo(c$1 * x02 - s * y02, s * x02 + c$1 * y02);
    context.lineTo(c$1 * x12 - s * y12, s * x12 + c$1 * y12);
    context.lineTo(c$1 * x2 - s * y2, s * x2 + c$1 * y2);
    context.lineTo(c$1 * x02 + s * y02, c$1 * y02 - s * x02);
    context.lineTo(c$1 * x12 + s * y12, c$1 * y12 - s * x12);
    context.lineTo(c$1 * x2 + s * y2, c$1 * y2 - s * x2);
    context.closePath();
  }
};
var symbols = [
  circle$2,
  cross$1,
  diamond,
  square,
  star,
  triangle,
  wye
];
function symbol() {
  var type2 = constant$2(circle$2), size = constant$2(64), context = null;
  function symbol2() {
    var buffer2;
    if (!context)
      context = buffer2 = path();
    type2.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer2)
      return context = null, buffer2 + "" || null;
  }
  symbol2.type = function(_2) {
    return arguments.length ? (type2 = typeof _2 === "function" ? _2 : constant$2(_2), symbol2) : type2;
  };
  symbol2.size = function(_2) {
    return arguments.length ? (size = typeof _2 === "function" ? _2 : constant$2(+_2), symbol2) : size;
  };
  symbol2.context = function(_2) {
    return arguments.length ? (context = _2 == null ? null : _2, symbol2) : context;
  };
  return symbol2;
}
function noop() {
}
function point$4(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$4(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$4(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basis(context) {
  return new Basis(context);
}
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$4(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisClosed(context) {
  return new BasisClosed(context);
}
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x02 = (this._x0 + 4 * this._x1 + x2) / 6, y02 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x02, y02) : this._context.moveTo(x02, y02);
        break;
      case 3:
        this._point = 4;
      default:
        point$4(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function basisOpen(context) {
  return new BasisOpen(context);
}
function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}
Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, j = x2.length - 1;
    if (j > 0) {
      var x02 = x2[0], y02 = y2[0], dx = x2[j] - x02, dy = y2[j] - y02, i = -1, t;
      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x2[i] + (1 - this._beta) * (x02 + t * dx),
          this._beta * y2[i] + (1 - this._beta) * (y02 + t * dy)
        );
      }
    }
    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
const bundle = function custom12(beta) {
  function bundle2(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }
  bundle2.beta = function(beta2) {
    return custom12(+beta2);
  };
  return bundle2;
}(0.85);
function point$3(that, x2, y2) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x2),
    that._y2 + that._k * (that._y1 - y2),
    that._x2,
    that._y2
  );
}
function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        point$3(this, this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        this._x1 = x2, this._y1 = y2;
        break;
      case 2:
        this._point = 3;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinal = function custom13(tension) {
  function cardinal2(context) {
    return new Cardinal(context, tension);
  }
  cardinal2.tension = function(tension2) {
    return custom13(+tension2);
  };
  return cardinal2;
}(0);
function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinalClosed = function custom14(tension) {
  function cardinal2(context) {
    return new CardinalClosed(context, tension);
  }
  cardinal2.tension = function(tension2) {
    return custom14(+tension2);
  };
  return cardinal2;
}(0);
function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}
CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$3(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const cardinalOpen = function custom15(tension) {
  function cardinal2(context) {
    return new CardinalOpen(context, tension);
  }
  cardinal2.tension = function(tension2) {
    return custom15(+tension2);
  };
  return cardinal2;
}(0);
function point$2(that, x2, y2) {
  var x12 = that._x1, y12 = that._y1, x22 = that._x2, y22 = that._y2;
  if (that._l01_a > epsilon$1) {
    var a2 = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a, n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x12 = (x12 * a2 - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y12 = (y12 * a2 - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }
  if (that._l23_a > epsilon$1) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a, m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x22 = (x22 * b + that._x1 * that._l23_2a - x2 * that._l12_2a) / m;
    y22 = (y22 * b + that._y1 * that._l23_2a - y2 * that._l12_2a) / m;
  }
  that._context.bezierCurveTo(x12, y12, x22, y22, that._x2, that._y2);
}
function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);
        break;
      case 3:
        this.point(this._x2, this._y2);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRom = function custom16(alpha) {
  function catmullRom2(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }
  catmullRom2.alpha = function(alpha2) {
    return custom16(+alpha2);
  };
  return catmullRom2;
}(0.5);
function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x2, this._y3 = y2;
        break;
      case 1:
        this._point = 2;
        this._context.moveTo(this._x4 = x2, this._y4 = y2);
        break;
      case 2:
        this._point = 3;
        this._x5 = x2, this._y5 = y2;
        break;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRomClosed = function custom17(alpha) {
  function catmullRom2(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }
  catmullRom2.alpha = function(alpha2) {
    return custom17(+alpha2);
  };
  return catmullRom2;
}(0.5);
function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}
CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point) {
      var x23 = this._x2 - x2, y23 = this._y2 - y2;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;
      case 3:
        this._point = 4;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x2;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y2;
  }
};
const catmullRomOpen = function custom18(alpha) {
  function catmullRom2(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }
  catmullRom2.alpha = function(alpha2) {
    return custom18(+alpha2);
  };
  return catmullRom2;
}(0.5);
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};
function linearClosed(context) {
  return new LinearClosed(context);
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}
function point$1(that, t02, t12) {
  var x02 = that._x0, y02 = that._y0, x12 = that._x1, y12 = that._y1, dx = (x12 - x02) / 3;
  that._context.bezierCurveTo(x02 + dx, y02 + dx * t02, x12 - dx, y12 - dx * t12, x12, y12);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$1(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point$1(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x12, y12, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y12, x12, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n = x2.length;
    if (n) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n = x2.length - 1, m, a2 = new Array(n), b = new Array(n), r = new Array(n);
  a2[0] = 0, b[0] = 2, r[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n - 1; ++i)
    a2[i] = 1, b[i] = 4, r[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x2[n - 1] + x2[n];
  for (i = 1; i < n; ++i)
    m = a2[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a2[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i)
    a2[i] = (r[i] - a2[i + 1]) / b[i];
  b[n - 1] = (x2[n] + a2[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i)
    b[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b];
}
function natural(context) {
  return new Natural(context);
}
function Step(context, t) {
  this._context = context;
  this._t = t;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x12 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x12, this._y);
          this._context.lineTo(x12, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function step(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function none$1(series, order2) {
  if (!((n = series.length) > 1))
    return;
  for (var i = 1, j, s0, s1 = series[order2[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order2[i]];
    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
function none(series) {
  var n = series.length, o = new Array(n);
  while (--n >= 0)
    o[n] = n;
  return o;
}
function stackValue(d, key) {
  return d[key];
}
function stack() {
  var keys2 = constant$2([]), order2 = none, offset = none$1, value = stackValue;
  function stack2(data) {
    var kz = keys2.apply(this, arguments), i, m = data.length, n = kz.length, sz = new Array(n), oz;
    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }
      si.key = ki;
    }
    for (i = 0, oz = order2(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack2.keys = function(_2) {
    return arguments.length ? (keys2 = typeof _2 === "function" ? _2 : constant$2(slice.call(_2)), stack2) : keys2;
  };
  stack2.value = function(_2) {
    return arguments.length ? (value = typeof _2 === "function" ? _2 : constant$2(+_2), stack2) : value;
  };
  stack2.order = function(_2) {
    return arguments.length ? (order2 = _2 == null ? none : typeof _2 === "function" ? _2 : constant$2(slice.call(_2)), stack2) : order2;
  };
  stack2.offset = function(_2) {
    return arguments.length ? (offset = _2 == null ? none$1 : _2, stack2) : offset;
  };
  return stack2;
}
function expand(series, order2) {
  if (!((n = series.length) > 0))
    return;
  for (var i, n, j = 0, m = series[0].length, y2; j < m; ++j) {
    for (y2 = i = 0; i < n; ++i)
      y2 += series[i][j][1] || 0;
    if (y2)
      for (i = 0; i < n; ++i)
        series[i][j][1] /= y2;
  }
  none$1(series, order2);
}
function diverging(series, order2) {
  if (!((n = series.length) > 0))
    return;
  for (var i, j = 0, d, dy, yp, yn, n, m = series[order2[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order2[i]][j])[1] - d[0]) > 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = 0, d[1] = dy;
      }
    }
  }
}
function silhouette(series, order2) {
  if (!((n = series.length) > 0))
    return;
  for (var j = 0, s0 = series[order2[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y2 = 0; i < n; ++i)
      y2 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y2 / 2;
  }
  none$1(series, order2);
}
function wiggle(series, order2) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order2[0]]).length) > 0))
    return;
  for (var y2 = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order2[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order2[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    if (s1)
      y2 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y2;
  none$1(series, order2);
}
function appearance(series) {
  var peaks = series.map(peak);
  return none(series).sort(function(a2, b) {
    return peaks[a2] - peaks[b];
  });
}
function peak(series) {
  var i = -1, j = 0, n = series.length, vi, vj = -Infinity;
  while (++i < n)
    if ((vi = +series[i][1]) > vj)
      vj = vi, j = i;
  return j;
}
function ascending(series) {
  var sums = series.map(sum);
  return none(series).sort(function(a2, b) {
    return sums[a2] - sums[b];
  });
}
function sum(series) {
  var s2 = 0, i = -1, n = series.length, v;
  while (++i < n)
    if (v = +series[i][1])
      s2 += v;
  return s2;
}
function descending(series) {
  return ascending(series).reverse();
}
function insideOut(series) {
  var n = series.length, i, j, sums = series.map(sum), order2 = appearance(series), top2 = 0, bottom2 = 0, tops = [], bottoms = [];
  for (i = 0; i < n; ++i) {
    j = order2[i];
    if (top2 < bottom2) {
      top2 += sums[j];
      tops.push(j);
    } else {
      bottom2 += sums[j];
      bottoms.push(j);
    }
  }
  return bottoms.reverse().concat(tops);
}
function reverse(series) {
  return none(series).reverse();
}
function constant$1(x2) {
  return function() {
    return x2;
  };
}
function x(d) {
  return d[0];
}
function y(d) {
  return d[1];
}
function RedBlackTree() {
  this._ = null;
}
function RedBlackNode(node2) {
  node2.U = node2.C = node2.L = node2.R = node2.P = node2.N = null;
}
RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function(after, node2) {
    var parent, grandpa, uncle;
    if (after) {
      node2.P = after;
      node2.N = after.N;
      if (after.N)
        after.N.P = node2;
      after.N = node2;
      if (after.R) {
        after = after.R;
        while (after.L)
          after = after.L;
        after.L = node2;
      } else {
        after.R = node2;
      }
      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node2.P = null;
      node2.N = after;
      after.P = after.L = node2;
      parent = after;
    } else {
      node2.P = node2.N = null;
      this._ = node2;
      parent = null;
    }
    node2.L = node2.R = null;
    node2.U = parent;
    node2.C = true;
    after = node2;
    while (parent && parent.C) {
      grandpa = parent.U;
      if (parent === grandpa.L) {
        uncle = grandpa.R;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;
        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }
          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }
      parent = after.U;
    }
    this._.C = false;
  },
  remove: function(node2) {
    if (node2.N)
      node2.N.P = node2.P;
    if (node2.P)
      node2.P.N = node2.N;
    node2.N = node2.P = null;
    var parent = node2.U, sibling, left2 = node2.L, right2 = node2.R, next2, red;
    if (!left2)
      next2 = right2;
    else if (!right2)
      next2 = left2;
    else
      next2 = RedBlackFirst(right2);
    if (parent) {
      if (parent.L === node2)
        parent.L = next2;
      else
        parent.R = next2;
    } else {
      this._ = next2;
    }
    if (left2 && right2) {
      red = next2.C;
      next2.C = node2.C;
      next2.L = left2;
      left2.U = next2;
      if (next2 !== right2) {
        parent = next2.U;
        next2.U = node2.U;
        node2 = next2.R;
        parent.L = node2;
        next2.R = right2;
        right2.U = next2;
      } else {
        next2.U = parent;
        parent = next2;
        node2 = next2.R;
      }
    } else {
      red = node2.C;
      node2 = next2;
    }
    if (node2)
      node2.U = parent;
    if (red)
      return;
    if (node2 && node2.C) {
      node2.C = false;
      return;
    }
    do {
      if (node2 === this._)
        break;
      if (node2 === parent.L) {
        sibling = parent.R;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }
          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node2 = this._;
          break;
        }
      } else {
        sibling = parent.L;
        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }
        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }
          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node2 = this._;
          break;
        }
      }
      sibling.C = true;
      node2 = parent;
      parent = parent.U;
    } while (!node2.C);
    if (node2)
      node2.C = false;
  }
};
function RedBlackRotateLeft(tree2, node2) {
  var p = node2, q = node2.R, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree2._ = q;
  }
  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R)
    p.R.U = p;
  q.L = p;
}
function RedBlackRotateRight(tree2, node2) {
  var p = node2, q = node2.L, parent = p.U;
  if (parent) {
    if (parent.L === p)
      parent.L = q;
    else
      parent.R = q;
  } else {
    tree2._ = q;
  }
  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L)
    p.L.U = p;
  q.R = p;
}
function RedBlackFirst(node2) {
  while (node2.L)
    node2 = node2.L;
  return node2;
}
function createEdge(left2, right2, v0, v1) {
  var edge = [null, null], index2 = edges$1.push(edge) - 1;
  edge.left = left2;
  edge.right = right2;
  if (v0)
    setEdgeEnd(edge, left2, right2, v0);
  if (v1)
    setEdgeEnd(edge, right2, left2, v1);
  cells[left2.index].halfedges.push(index2);
  cells[right2.index].halfedges.push(index2);
  return edge;
}
function createBorderEdge(left2, v0, v1) {
  var edge = [v0, v1];
  edge.left = left2;
  return edge;
}
function setEdgeEnd(edge, left2, right2, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left2;
    edge.right = right2;
  } else if (edge.left === right2) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
}
function clipEdge(edge, x02, y02, x12, y12) {
  var a2 = edge[0], b = edge[1], ax = a2[0], ay = a2[1], bx = b[0], by = b[1], t02 = 0, t12 = 1, dx = bx - ax, dy = by - ay, r;
  r = x02 - ax;
  if (!dx && r > 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dx > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = x12 - ax;
  if (!dx && r < 0)
    return;
  r /= dx;
  if (dx < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dx > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  r = y02 - ay;
  if (!dy && r > 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  } else if (dy > 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  }
  r = y12 - ay;
  if (!dy && r < 0)
    return;
  r /= dy;
  if (dy < 0) {
    if (r > t12)
      return;
    if (r > t02)
      t02 = r;
  } else if (dy > 0) {
    if (r < t02)
      return;
    if (r < t12)
      t12 = r;
  }
  if (!(t02 > 0) && !(t12 < 1))
    return true;
  if (t02 > 0)
    edge[0] = [ax + t02 * dx, ay + t02 * dy];
  if (t12 < 1)
    edge[1] = [ax + t12 * dx, ay + t12 * dy];
  return true;
}
function connectEdge(edge, x02, y02, x12, y12) {
  var v1 = edge[1];
  if (v1)
    return true;
  var v0 = edge[0], left2 = edge.left, right2 = edge.right, lx = left2[0], ly = left2[1], rx = right2[0], ry = right2[1], fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;
  if (ry === ly) {
    if (fx < x02 || fx >= x12)
      return;
    if (lx > rx) {
      if (!v0)
        v0 = [fx, y02];
      else if (v0[1] >= y12)
        return;
      v1 = [fx, y12];
    } else {
      if (!v0)
        v0 = [fx, y12];
      else if (v0[1] < y02)
        return;
      v1 = [fx, y02];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;
    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0)
          v0 = [(y02 - fb) / fm, y02];
        else if (v0[1] >= y12)
          return;
        v1 = [(y12 - fb) / fm, y12];
      } else {
        if (!v0)
          v0 = [(y12 - fb) / fm, y12];
        else if (v0[1] < y02)
          return;
        v1 = [(y02 - fb) / fm, y02];
      }
    } else {
      if (ly < ry) {
        if (!v0)
          v0 = [x02, fm * x02 + fb];
        else if (v0[0] >= x12)
          return;
        v1 = [x12, fm * x12 + fb];
      } else {
        if (!v0)
          v0 = [x12, fm * x12 + fb];
        else if (v0[0] < x02)
          return;
        v1 = [x02, fm * x02 + fb];
      }
    }
  }
  edge[0] = v0;
  edge[1] = v1;
  return true;
}
function clipEdges(x02, y02, x12, y12) {
  var i = edges$1.length, edge;
  while (i--) {
    if (!connectEdge(edge = edges$1[i], x02, y02, x12, y12) || !clipEdge(edge, x02, y02, x12, y12) || !(Math.abs(edge[0][0] - edge[1][0]) > epsilon || Math.abs(edge[0][1] - edge[1][1]) > epsilon)) {
      delete edges$1[i];
    }
  }
}
function createCell(site) {
  return cells[site.index] = {
    site,
    halfedges: []
  };
}
function cellHalfedgeAngle(cell, edge) {
  var site = cell.site, va = edge.left, vb = edge.right;
  if (site === vb)
    vb = va, va = site;
  if (vb)
    return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va)
    va = edge[1], vb = edge[0];
  else
    va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}
function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}
function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}
function sortCellHalfedges() {
  for (var i = 0, n = cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index2 = new Array(m), array2 = new Array(m);
      for (j = 0; j < m; ++j)
        index2[j] = j, array2[j] = cellHalfedgeAngle(cell, edges$1[halfedges[j]]);
      index2.sort(function(i2, j2) {
        return array2[j2] - array2[i2];
      });
      for (j = 0; j < m; ++j)
        array2[j] = halfedges[index2[j]];
      for (j = 0; j < m; ++j)
        halfedges[j] = array2[j];
    }
  }
}
function clipCells(x02, y02, x12, y12) {
  var nCells = cells.length, iCell, cell, site, iHalfedge, halfedges, nHalfedges, start2, startX, startY, end2, endX, endY, cover = true;
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length;
      while (iHalfedge--) {
        if (!edges$1[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      }
      iHalfedge = 0, nHalfedges = halfedges.length;
      while (iHalfedge < nHalfedges) {
        end2 = cellHalfedgeEnd(cell, edges$1[halfedges[iHalfedge]]), endX = end2[0], endY = end2[1];
        start2 = cellHalfedgeStart(cell, edges$1[halfedges[++iHalfedge % nHalfedges]]), startX = start2[0], startY = start2[1];
        if (Math.abs(endX - startX) > epsilon || Math.abs(endY - startY) > epsilon) {
          halfedges.splice(iHalfedge, 0, edges$1.push(createBorderEdge(
            site,
            end2,
            Math.abs(endX - x02) < epsilon && y12 - endY > epsilon ? [x02, Math.abs(startX - x02) < epsilon ? startY : y12] : Math.abs(endY - y12) < epsilon && x12 - endX > epsilon ? [Math.abs(startY - y12) < epsilon ? startX : x12, y12] : Math.abs(endX - x12) < epsilon && endY - y02 > epsilon ? [x12, Math.abs(startX - x12) < epsilon ? startY : y02] : Math.abs(endY - y02) < epsilon && endX - x02 > epsilon ? [Math.abs(startY - y02) < epsilon ? startX : x02, y02] : null
          )) - 1);
          ++nHalfedges;
        }
      }
      if (nHalfedges)
        cover = false;
    }
  }
  if (cover) {
    var dx, dy, d2, dc = Infinity;
    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = cells[iCell]) {
        site = cell.site;
        dx = site[0] - x02;
        dy = site[1] - y02;
        d2 = dx * dx + dy * dy;
        if (d2 < dc)
          dc = d2, cover = cell;
      }
    }
    if (cover) {
      var v00 = [x02, y02], v01 = [x02, y12], v11 = [x12, y12], v10 = [x12, y02];
      cover.halfedges.push(
        edges$1.push(createBorderEdge(site = cover.site, v00, v01)) - 1,
        edges$1.push(createBorderEdge(site, v01, v11)) - 1,
        edges$1.push(createBorderEdge(site, v11, v10)) - 1,
        edges$1.push(createBorderEdge(site, v10, v00)) - 1
      );
    }
  }
  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = cells[iCell]) {
      if (!cell.halfedges.length) {
        delete cells[iCell];
      }
    }
  }
}
var circlePool = [];
var firstCircle;
function Circle() {
  RedBlackNode(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}
function attachCircle(arc2) {
  var lArc = arc2.P, rArc = arc2.N;
  if (!lArc || !rArc)
    return;
  var lSite = lArc.site, cSite = arc2.site, rSite = rArc.site;
  if (lSite === rSite)
    return;
  var bx = cSite[0], by = cSite[1], ax = lSite[0] - bx, ay = lSite[1] - by, cx = rSite[0] - bx, cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -epsilon2)
    return;
  var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x2 = (cy * ha - ay * hc) / d, y2 = (ax * hc - cx * ha) / d;
  var circle2 = circlePool.pop() || new Circle();
  circle2.arc = arc2;
  circle2.site = cSite;
  circle2.x = x2 + bx;
  circle2.y = (circle2.cy = y2 + by) + Math.sqrt(x2 * x2 + y2 * y2);
  arc2.circle = circle2;
  var before = null, node2 = circles._;
  while (node2) {
    if (circle2.y < node2.y || circle2.y === node2.y && circle2.x <= node2.x) {
      if (node2.L)
        node2 = node2.L;
      else {
        before = node2.P;
        break;
      }
    } else {
      if (node2.R)
        node2 = node2.R;
      else {
        before = node2;
        break;
      }
    }
  }
  circles.insert(before, circle2);
  if (!before)
    firstCircle = circle2;
}
function detachCircle(arc2) {
  var circle2 = arc2.circle;
  if (circle2) {
    if (!circle2.P)
      firstCircle = circle2.N;
    circles.remove(circle2);
    circlePool.push(circle2);
    RedBlackNode(circle2);
    arc2.circle = null;
  }
}
var beachPool = [];
function Beach() {
  RedBlackNode(this);
  this.edge = this.site = this.circle = null;
}
function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}
function detachBeach(beach) {
  detachCircle(beach);
  beaches.remove(beach);
  beachPool.push(beach);
  RedBlackNode(beach);
}
function removeBeach(beach) {
  var circle2 = beach.circle, x2 = circle2.x, y2 = circle2.cy, vertex = [x2, y2], previous = beach.P, next2 = beach.N, disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;
  while (lArc.circle && Math.abs(x2 - lArc.circle.x) < epsilon && Math.abs(y2 - lArc.circle.cy) < epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }
  disappearing.unshift(lArc);
  detachCircle(lArc);
  var rArc = next2;
  while (rArc.circle && Math.abs(x2 - rArc.circle.x) < epsilon && Math.abs(y2 - rArc.circle.cy) < epsilon) {
    next2 = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next2;
  }
  disappearing.push(rArc);
  detachCircle(rArc);
  var nArcs = disappearing.length, iArc;
  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    setEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);
  }
  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = createEdge(lArc.site, rArc.site, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function addBeach(site) {
  var x2 = site[0], directrix = site[1], lArc, rArc, dxl, dxr, node2 = beaches._;
  while (node2) {
    dxl = leftBreakPoint(node2, directrix) - x2;
    if (dxl > epsilon)
      node2 = node2.L;
    else {
      dxr = x2 - rightBreakPoint(node2, directrix);
      if (dxr > epsilon) {
        if (!node2.R) {
          lArc = node2;
          break;
        }
        node2 = node2.R;
      } else {
        if (dxl > -epsilon) {
          lArc = node2.P;
          rArc = node2;
        } else if (dxr > -epsilon) {
          lArc = node2;
          rArc = node2.N;
        } else {
          lArc = rArc = node2;
        }
        break;
      }
    }
  }
  createCell(site);
  var newArc = createBeach(site);
  beaches.insert(lArc, newArc);
  if (!lArc && !rArc)
    return;
  if (lArc === rArc) {
    detachCircle(lArc);
    rArc = createBeach(lArc.site);
    beaches.insert(newArc, rArc);
    newArc.edge = rArc.edge = createEdge(lArc.site, newArc.site);
    attachCircle(lArc);
    attachCircle(rArc);
    return;
  }
  if (!rArc) {
    newArc.edge = createEdge(lArc.site, newArc.site);
    return;
  }
  detachCircle(lArc);
  detachCircle(rArc);
  var lSite = lArc.site, ax = lSite[0], ay = lSite[1], bx = site[0] - ax, by = site[1] - ay, rSite = rArc.site, cx = rSite[0] - ax, cy = rSite[1] - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  setEdgeEnd(rArc.edge, lSite, rSite, vertex);
  newArc.edge = createEdge(lSite, site, null, vertex);
  rArc.edge = createEdge(site, rSite, null, vertex);
  attachCircle(lArc);
  attachCircle(rArc);
}
function leftBreakPoint(arc2, directrix) {
  var site = arc2.site, rfocx = site[0], rfocy = site[1], pby2 = rfocy - directrix;
  if (!pby2)
    return rfocx;
  var lArc = arc2.P;
  if (!lArc)
    return -Infinity;
  site = lArc.site;
  var lfocx = site[0], lfocy = site[1], plby2 = lfocy - directrix;
  if (!plby2)
    return lfocx;
  var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;
  if (aby2)
    return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}
function rightBreakPoint(arc2, directrix) {
  var rArc = arc2.N;
  if (rArc)
    return leftBreakPoint(rArc, directrix);
  var site = arc2.site;
  return site[1] === directrix ? site[0] : Infinity;
}
var epsilon = 1e-6;
var epsilon2 = 1e-12;
var beaches;
var cells;
var circles;
var edges$1;
function triangleArea(a2, b, c2) {
  return (a2[0] - c2[0]) * (b[1] - a2[1]) - (a2[0] - b[0]) * (c2[1] - a2[1]);
}
function lexicographic(a2, b) {
  return b[1] - a2[1] || b[0] - a2[0];
}
function Diagram$1(sites, extent2) {
  var site = sites.sort(lexicographic).pop(), x2, y2, circle2;
  edges$1 = [];
  cells = new Array(sites.length);
  beaches = new RedBlackTree();
  circles = new RedBlackTree();
  while (true) {
    circle2 = firstCircle;
    if (site && (!circle2 || site[1] < circle2.y || site[1] === circle2.y && site[0] < circle2.x)) {
      if (site[0] !== x2 || site[1] !== y2) {
        addBeach(site);
        x2 = site[0], y2 = site[1];
      }
      site = sites.pop();
    } else if (circle2) {
      removeBeach(circle2.arc);
    } else {
      break;
    }
  }
  sortCellHalfedges();
  if (extent2) {
    var x02 = +extent2[0][0], y02 = +extent2[0][1], x12 = +extent2[1][0], y12 = +extent2[1][1];
    clipEdges(x02, y02, x12, y12);
    clipCells(x02, y02, x12, y12);
  }
  this.edges = edges$1;
  this.cells = cells;
  beaches = circles = edges$1 = cells = null;
}
Diagram$1.prototype = {
  constructor: Diagram$1,
  polygons: function() {
    var edges2 = this.edges;
    return this.cells.map(function(cell) {
      var polygon = cell.halfedges.map(function(i) {
        return cellHalfedgeStart(cell, edges2[i]);
      });
      polygon.data = cell.site.data;
      return polygon;
    });
  },
  triangles: function() {
    var triangles = [], edges2 = this.edges;
    this.cells.forEach(function(cell, i) {
      if (!(m = (halfedges = cell.halfedges).length))
        return;
      var site = cell.site, halfedges, j = -1, m, s0, e1 = edges2[halfedges[m - 1]], s1 = e1.left === site ? e1.right : e1.left;
      while (++j < m) {
        s0 = s1;
        e1 = edges2[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;
        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function() {
    return this.edges.filter(function(edge) {
      return edge.right;
    }).map(function(edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function(x2, y2, radius) {
    var that = this, i0, i1 = that._found || 0, n = that.cells.length, cell;
    while (!(cell = that.cells[i1]))
      if (++i1 >= n)
        return null;
    var dx = x2 - cell.site[0], dy = y2 - cell.site[1], d2 = dx * dx + dy * dy;
    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function(e) {
        var edge = that.edges[e], v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right))
          return;
        var vx = x2 - v[0], vy = y2 - v[1], v2 = vx * vx + vy * vy;
        if (v2 < d2)
          d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);
    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};
function voronoi() {
  var x$12 = x, y$12 = y, extent2 = null;
  function voronoi2(data) {
    return new Diagram$1(data.map(function(d, i) {
      var s2 = [Math.round(x$12(d, i, data) / epsilon) * epsilon, Math.round(y$12(d, i, data) / epsilon) * epsilon];
      s2.index = i;
      s2.data = d;
      return s2;
    }), extent2);
  }
  voronoi2.polygons = function(data) {
    return voronoi2(data).polygons();
  };
  voronoi2.links = function(data) {
    return voronoi2(data).links();
  };
  voronoi2.triangles = function(data) {
    return voronoi2(data).triangles();
  };
  voronoi2.x = function(_2) {
    return arguments.length ? (x$12 = typeof _2 === "function" ? _2 : constant$1(+_2), voronoi2) : x$12;
  };
  voronoi2.y = function(_2) {
    return arguments.length ? (y$12 = typeof _2 === "function" ? _2 : constant$1(+_2), voronoi2) : y$12;
  };
  voronoi2.extent = function(_2) {
    return arguments.length ? (extent2 = _2 == null ? null : [[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]], voronoi2) : extent2 && [[extent2[0][0], extent2[0][1]], [extent2[1][0], extent2[1][1]]];
  };
  voronoi2.size = function(_2) {
    return arguments.length ? (extent2 = _2 == null ? null : [[0, 0], [+_2[0], +_2[1]]], voronoi2) : extent2 && [extent2[1][0] - extent2[0][0], extent2[1][1] - extent2[0][1]];
  };
  return voronoi2;
}
function constant(x2) {
  return function() {
    return x2;
  };
}
function ZoomEvent(target, type2, transform2) {
  this.target = target;
  this.type = type2;
  this.transform = transform2;
}
function Transform(k2, x2, y2) {
  this.k = k2;
  this.x = x2;
  this.y = y2;
}
Transform.prototype = {
  constructor: Transform,
  scale: function(k2) {
    return k2 === 1 ? this : new Transform(this.k * k2, this.x, this.y);
  },
  translate: function(x2, y2) {
    return x2 === 0 & y2 === 0 ? this : new Transform(this.k, this.x + this.k * x2, this.y + this.k * y2);
  },
  apply: function(point2) {
    return [point2[0] * this.k + this.x, point2[1] * this.k + this.y];
  },
  applyX: function(x2) {
    return x2 * this.k + this.x;
  },
  applyY: function(y2) {
    return y2 * this.k + this.y;
  },
  invert: function(location2) {
    return [(location2[0] - this.x) / this.k, (location2[1] - this.y) / this.k];
  },
  invertX: function(x2) {
    return (x2 - this.x) / this.k;
  },
  invertY: function(y2) {
    return (y2 - this.y) / this.k;
  },
  rescaleX: function(x2) {
    return x2.copy().domain(x2.range().map(this.invertX, this).map(x2.invert, x2));
  },
  rescaleY: function(y2) {
    return y2.copy().domain(y2.range().map(this.invertY, this).map(y2.invert, y2));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
transform.prototype = Transform.prototype;
function transform(node2) {
  while (!node2.__zoom)
    if (!(node2 = node2.parentNode))
      return identity;
  return node2.__zoom;
}
function nopropagation() {
  event.stopImmediatePropagation();
}
function noevent() {
  event.preventDefault();
  event.stopImmediatePropagation();
}
function defaultFilter() {
  return !event.ctrlKey && !event.button;
}
function defaultExtent() {
  var e = this;
  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    if (e.hasAttribute("viewBox")) {
      e = e.viewBox.baseVal;
      return [[e.x, e.y], [e.x + e.width, e.y + e.height]];
    }
    return [[0, 0], [e.width.baseVal.value, e.height.baseVal.value]];
  }
  return [[0, 0], [e.clientWidth, e.clientHeight]];
}
function defaultTransform() {
  return this.__zoom || identity;
}
function defaultWheelDelta() {
  return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 2e-3);
}
function defaultTouchable() {
  return navigator.maxTouchPoints || "ontouchstart" in this;
}
function defaultConstrain(transform2, extent2, translateExtent) {
  var dx0 = transform2.invertX(extent2[0][0]) - translateExtent[0][0], dx1 = transform2.invertX(extent2[1][0]) - translateExtent[1][0], dy0 = transform2.invertY(extent2[0][1]) - translateExtent[0][1], dy1 = transform2.invertY(extent2[1][1]) - translateExtent[1][1];
  return transform2.translate(
    dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1),
    dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1)
  );
}
function zoom() {
  var filter = defaultFilter, extent2 = defaultExtent, constrain = defaultConstrain, wheelDelta = defaultWheelDelta, touchable = defaultTouchable, scaleExtent = [0, Infinity], translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]], duration = 250, interpolate2 = interpolateZoom, listeners = dispatch("start", "zoom", "end"), touchstarting, touchending, touchDelay = 500, wheelDelay = 150, clickDistance2 = 0;
  function zoom2(selection2) {
    selection2.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }
  zoom2.transform = function(collection, transform2, point2) {
    var selection2 = collection.selection ? collection.selection() : collection;
    selection2.property("__zoom", defaultTransform);
    if (collection !== selection2) {
      schedule2(collection, transform2, point2);
    } else {
      selection2.interrupt().each(function() {
        gesture(this, arguments).start().zoom(null, typeof transform2 === "function" ? transform2.apply(this, arguments) : transform2).end();
      });
    }
  };
  zoom2.scaleBy = function(selection2, k2, p) {
    zoom2.scaleTo(selection2, function() {
      var k0 = this.__zoom.k, k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return k0 * k1;
    }, p);
  };
  zoom2.scaleTo = function(selection2, k2, p) {
    zoom2.transform(selection2, function() {
      var e = extent2.apply(this, arguments), t02 = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p, p1 = t02.invert(p02), k1 = typeof k2 === "function" ? k2.apply(this, arguments) : k2;
      return constrain(translate(scale(t02, k1), p02, p1), e, translateExtent);
    }, p);
  };
  zoom2.translateBy = function(selection2, x2, y2) {
    zoom2.transform(selection2, function() {
      return constrain(this.__zoom.translate(
        typeof x2 === "function" ? x2.apply(this, arguments) : x2,
        typeof y2 === "function" ? y2.apply(this, arguments) : y2
      ), extent2.apply(this, arguments), translateExtent);
    });
  };
  zoom2.translateTo = function(selection2, x2, y2, p) {
    zoom2.transform(selection2, function() {
      var e = extent2.apply(this, arguments), t = this.__zoom, p02 = p == null ? centroid2(e) : typeof p === "function" ? p.apply(this, arguments) : p;
      return constrain(identity.translate(p02[0], p02[1]).scale(t.k).translate(
        typeof x2 === "function" ? -x2.apply(this, arguments) : -x2,
        typeof y2 === "function" ? -y2.apply(this, arguments) : -y2
      ), e, translateExtent);
    }, p);
  };
  function scale(transform2, k2) {
    k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k2));
    return k2 === transform2.k ? transform2 : new Transform(k2, transform2.x, transform2.y);
  }
  function translate(transform2, p02, p1) {
    var x2 = p02[0] - p1[0] * transform2.k, y2 = p02[1] - p1[1] * transform2.k;
    return x2 === transform2.x && y2 === transform2.y ? transform2 : new Transform(transform2.k, x2, y2);
  }
  function centroid2(extent3) {
    return [(+extent3[0][0] + +extent3[1][0]) / 2, (+extent3[0][1] + +extent3[1][1]) / 2];
  }
  function schedule2(transition2, transform2, point2) {
    transition2.on("start.zoom", function() {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function() {
      gesture(this, arguments).end();
    }).tween("zoom", function() {
      var that = this, args = arguments, g = gesture(that, args), e = extent2.apply(that, args), p = point2 == null ? centroid2(e) : typeof point2 === "function" ? point2.apply(that, args) : point2, w2 = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]), a2 = that.__zoom, b = typeof transform2 === "function" ? transform2.apply(that, args) : transform2, i = interpolate2(a2.invert(p).concat(w2 / a2.k), b.invert(p).concat(w2 / b.k));
      return function(t) {
        if (t === 1)
          t = b;
        else {
          var l = i(t), k2 = w2 / l[2];
          t = new Transform(k2, p[0] - l[0] * k2, p[1] - l[1] * k2);
        }
        g.zoom(null, t);
      };
    });
  }
  function gesture(that, args, clean) {
    return !clean && that.__zooming || new Gesture(that, args);
  }
  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.active = 0;
    this.extent = extent2.apply(that, args);
    this.taps = 0;
  }
  Gesture.prototype = {
    start: function() {
      if (++this.active === 1) {
        this.that.__zooming = this;
        this.emit("start");
      }
      return this;
    },
    zoom: function(key, transform2) {
      if (this.mouse && key !== "mouse")
        this.mouse[1] = transform2.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch")
        this.touch0[1] = transform2.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch")
        this.touch1[1] = transform2.invert(this.touch1[0]);
      this.that.__zoom = transform2;
      this.emit("zoom");
      return this;
    },
    end: function() {
      if (--this.active === 0) {
        delete this.that.__zooming;
        this.emit("end");
      }
      return this;
    },
    emit: function(type2) {
      customEvent(new ZoomEvent(zoom2, type2, this.that.__zoom), listeners.apply, listeners, [type2, this.that, this.args]);
    }
  };
  function wheeled() {
    if (!filter.apply(this, arguments))
      return;
    var g = gesture(this, arguments), t = this.__zoom, k2 = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))), p = mouse(this);
    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }
      clearTimeout(g.wheel);
    } else if (t.k === k2)
      return;
    else {
      g.mouse = [p, t.invert(p)];
      interrupt(this);
      g.start();
    }
    noevent();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k2), g.mouse[0], g.mouse[1]), g.extent, translateExtent));
    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }
  function mousedowned() {
    if (touchending || !filter.apply(this, arguments))
      return;
    var g = gesture(this, arguments, true), v = select(event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true), p = mouse(this), x02 = event.clientX, y02 = event.clientY;
    dragDisable(event.view);
    nopropagation();
    g.mouse = [p, this.__zoom.invert(p)];
    interrupt(this);
    g.start();
    function mousemoved() {
      noevent();
      if (!g.moved) {
        var dx = event.clientX - x02, dy = event.clientY - y02;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }
      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = mouse(g.that), g.mouse[1]), g.extent, translateExtent));
    }
    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      yesdrag(event.view, g.moved);
      noevent();
      g.end();
    }
  }
  function dblclicked() {
    if (!filter.apply(this, arguments))
      return;
    var t02 = this.__zoom, p02 = mouse(this), p1 = t02.invert(p02), k1 = t02.k * (event.shiftKey ? 0.5 : 2), t12 = constrain(translate(scale(t02, k1), p02, p1), extent2.apply(this, arguments), translateExtent);
    noevent();
    if (duration > 0)
      select(this).transition().duration(duration).call(schedule2, t12, p02);
    else
      select(this).call(zoom2.transform, t12);
  }
  function touchstarted() {
    if (!filter.apply(this, arguments))
      return;
    var touches2 = event.touches, n = touches2.length, g = gesture(this, arguments, event.changedTouches.length === n), started, i, t, p;
    nopropagation();
    for (i = 0; i < n; ++i) {
      t = touches2[i], p = touch(this, touches2, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0)
        g.touch0 = p, started = true, g.taps = 1 + !!touchstarting;
      else if (!g.touch1 && g.touch0[2] !== p[2])
        g.touch1 = p, g.taps = 0;
    }
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    if (started) {
      if (g.taps < 2)
        touchstarting = setTimeout(function() {
          touchstarting = null;
        }, touchDelay);
      interrupt(this);
      g.start();
    }
  }
  function touchmoved() {
    if (!this.__zooming)
      return;
    var g = gesture(this, arguments), touches2 = event.changedTouches, n = touches2.length, i, t, p, l;
    noevent();
    if (touchstarting)
      touchstarting = clearTimeout(touchstarting);
    g.taps = 0;
    for (i = 0; i < n; ++i) {
      t = touches2[i], p = touch(this, touches2, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier)
        g.touch0[0] = p;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        g.touch1[0] = p;
    }
    t = g.that.__zoom;
    if (g.touch1) {
      var p02 = g.touch0[0], l0 = g.touch0[1], p1 = g.touch1[0], l1 = g.touch1[1], dp = (dp = p1[0] - p02[0]) * dp + (dp = p1[1] - p02[1]) * dp, dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p02[0] + p1[0]) / 2, (p02[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0)
      p = g.touch0[0], l = g.touch0[1];
    else
      return;
    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }
  function touchended() {
    if (!this.__zooming)
      return;
    var g = gesture(this, arguments), touches2 = event.changedTouches, n = touches2.length, i, t;
    nopropagation();
    if (touchending)
      clearTimeout(touchending);
    touchending = setTimeout(function() {
      touchending = null;
    }, touchDelay);
    for (i = 0; i < n; ++i) {
      t = touches2[i];
      if (g.touch0 && g.touch0[2] === t.identifier)
        delete g.touch0;
      else if (g.touch1 && g.touch1[2] === t.identifier)
        delete g.touch1;
    }
    if (g.touch1 && !g.touch0)
      g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0)
      g.touch0[1] = this.__zoom.invert(g.touch0[0]);
    else {
      g.end();
      if (g.taps === 2) {
        var p = select(this).on("dblclick.zoom");
        if (p)
          p.apply(this, arguments);
      }
    }
  }
  zoom2.wheelDelta = function(_2) {
    return arguments.length ? (wheelDelta = typeof _2 === "function" ? _2 : constant(+_2), zoom2) : wheelDelta;
  };
  zoom2.filter = function(_2) {
    return arguments.length ? (filter = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : filter;
  };
  zoom2.touchable = function(_2) {
    return arguments.length ? (touchable = typeof _2 === "function" ? _2 : constant(!!_2), zoom2) : touchable;
  };
  zoom2.extent = function(_2) {
    return arguments.length ? (extent2 = typeof _2 === "function" ? _2 : constant([[+_2[0][0], +_2[0][1]], [+_2[1][0], +_2[1][1]]]), zoom2) : extent2;
  };
  zoom2.scaleExtent = function(_2) {
    return arguments.length ? (scaleExtent[0] = +_2[0], scaleExtent[1] = +_2[1], zoom2) : [scaleExtent[0], scaleExtent[1]];
  };
  zoom2.translateExtent = function(_2) {
    return arguments.length ? (translateExtent[0][0] = +_2[0][0], translateExtent[1][0] = +_2[1][0], translateExtent[0][1] = +_2[0][1], translateExtent[1][1] = +_2[1][1], zoom2) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };
  zoom2.constrain = function(_2) {
    return arguments.length ? (constrain = _2, zoom2) : constrain;
  };
  zoom2.duration = function(_2) {
    return arguments.length ? (duration = +_2, zoom2) : duration;
  };
  zoom2.interpolate = function(_2) {
    return arguments.length ? (interpolate2 = _2, zoom2) : interpolate2;
  };
  zoom2.on = function() {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom2 : value;
  };
  zoom2.clickDistance = function(_2) {
    return arguments.length ? (clickDistance2 = (_2 = +_2) * _2, zoom2) : Math.sqrt(clickDistance2);
  };
  return zoom2;
}
const d3$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  version: version$3,
  bisect: bisectRight,
  bisectRight,
  bisectLeft,
  ascending: ascending$3,
  bisector,
  cross: cross$3,
  descending: descending$2,
  deviation,
  extent: extent$1,
  histogram,
  thresholdFreedmanDiaconis: freedmanDiaconis,
  thresholdScott: scott,
  thresholdSturges,
  max: max$2,
  mean,
  median,
  merge: merge$1,
  min: min$1,
  pairs,
  permute,
  quantile: threshold$1,
  range: sequence,
  scan,
  shuffle: shuffle$1,
  sum: sum$2,
  ticks,
  tickIncrement,
  tickStep,
  transpose,
  variance,
  zip,
  axisTop,
  axisRight,
  axisBottom,
  axisLeft,
  brush,
  brushX,
  brushY,
  brushSelection,
  chord,
  ribbon,
  nest,
  set,
  map: map$2,
  keys,
  values,
  entries,
  color,
  rgb,
  hsl: hsl$2,
  lab: lab$1,
  hcl: hcl$2,
  lch,
  gray,
  cubehelix: cubehelix$3,
  contours,
  contourDensity: density,
  dispatch,
  drag,
  dragDisable,
  dragEnable: yesdrag,
  dsvFormat,
  csvParse,
  csvParseRows,
  csvFormat,
  csvFormatBody,
  csvFormatRows,
  csvFormatRow,
  csvFormatValue,
  tsvParse,
  tsvParseRows,
  tsvFormat,
  tsvFormatBody,
  tsvFormatRows,
  tsvFormatRow,
  tsvFormatValue,
  autoType,
  easeLinear: linear$1,
  easeQuad: quadInOut,
  easeQuadIn: quadIn,
  easeQuadOut: quadOut,
  easeQuadInOut: quadInOut,
  easeCubic: cubicInOut,
  easeCubicIn: cubicIn,
  easeCubicOut: cubicOut,
  easeCubicInOut: cubicInOut,
  easePoly: polyInOut,
  easePolyIn: polyIn,
  easePolyOut: polyOut,
  easePolyInOut: polyInOut,
  easeSin: sinInOut,
  easeSinIn: sinIn,
  easeSinOut: sinOut,
  easeSinInOut: sinInOut,
  easeExp: expInOut,
  easeExpIn: expIn,
  easeExpOut: expOut,
  easeExpInOut: expInOut,
  easeCircle: circleInOut,
  easeCircleIn: circleIn,
  easeCircleOut: circleOut,
  easeCircleInOut: circleInOut,
  easeBounce: bounceOut,
  easeBounceIn: bounceIn,
  easeBounceOut: bounceOut,
  easeBounceInOut: bounceInOut,
  easeBack: backInOut,
  easeBackIn: backIn,
  easeBackOut: backOut,
  easeBackInOut: backInOut,
  easeElastic: elasticOut,
  easeElasticIn: elasticIn,
  easeElasticOut: elasticOut,
  easeElasticInOut: elasticInOut,
  blob,
  buffer,
  dsv,
  csv,
  tsv,
  image,
  json,
  text,
  xml,
  html,
  svg,
  forceCenter: center,
  forceCollide: collide,
  forceLink: link$2,
  forceManyBody: manyBody,
  forceRadial: radial,
  forceSimulation: simulation,
  forceX: x$2,
  forceY: y$2,
  formatDefaultLocale: defaultLocale$1,
  get format() {
    return format$1;
  },
  get formatPrefix() {
    return formatPrefix;
  },
  formatLocale: formatLocale$1,
  formatSpecifier,
  FormatSpecifier,
  precisionFixed,
  precisionPrefix,
  precisionRound,
  geoArea: area$2,
  geoBounds: bounds$2,
  geoCentroid: centroid$1,
  geoCircle: circle$4,
  geoClipAntimeridian: clipAntimeridian,
  geoClipCircle: clipCircle,
  geoClipExtent: extent,
  geoClipRectangle: clipRectangle,
  geoContains: contains$1,
  geoDistance: distance$1,
  geoGraticule: graticule,
  geoGraticule10: graticule10,
  geoInterpolate: interpolate,
  geoLength: length$1,
  geoPath: index$2,
  geoAlbers: albers,
  geoAlbersUsa: albersUsa,
  geoAzimuthalEqualArea: azimuthalEqualArea,
  geoAzimuthalEqualAreaRaw: azimuthalEqualAreaRaw,
  geoAzimuthalEquidistant: azimuthalEquidistant,
  geoAzimuthalEquidistantRaw: azimuthalEquidistantRaw,
  geoConicConformal: conicConformal,
  geoConicConformalRaw: conicConformalRaw,
  geoConicEqualArea: conicEqualArea,
  geoConicEqualAreaRaw: conicEqualAreaRaw,
  geoConicEquidistant: conicEquidistant,
  geoConicEquidistantRaw: conicEquidistantRaw,
  geoEqualEarth: equalEarth,
  geoEqualEarthRaw: equalEarthRaw,
  geoEquirectangular: equirectangular,
  geoEquirectangularRaw: equirectangularRaw,
  geoGnomonic: gnomonic,
  geoGnomonicRaw: gnomonicRaw,
  geoIdentity: identity$4,
  geoProjection: projection,
  geoProjectionMutator: projectionMutator,
  geoMercator: mercator,
  geoMercatorRaw: mercatorRaw,
  geoNaturalEarth1: naturalEarth1,
  geoNaturalEarth1Raw: naturalEarth1Raw,
  geoOrthographic: orthographic,
  geoOrthographicRaw: orthographicRaw,
  geoStereographic: stereographic,
  geoStereographicRaw: stereographicRaw,
  geoTransverseMercator: transverseMercator,
  geoTransverseMercatorRaw: transverseMercatorRaw,
  geoRotation: rotation,
  geoStream,
  geoTransform: transform$1,
  cluster,
  hierarchy,
  pack: index$1,
  packSiblings: siblings,
  packEnclose: enclose,
  partition,
  stratify,
  tree,
  treemap: index,
  treemapBinary: binary,
  treemapDice,
  treemapSlice,
  treemapSliceDice: sliceDice,
  treemapSquarify: squarify,
  treemapResquarify: resquarify,
  interpolate: interpolateValue,
  interpolateArray: array$2,
  interpolateBasis: basis$2,
  interpolateBasisClosed: basisClosed$1,
  interpolateDate: date$1,
  interpolateDiscrete: discrete,
  interpolateHue: hue,
  interpolateNumber,
  interpolateNumberArray: numberArray,
  interpolateObject: object$1,
  interpolateRound,
  interpolateString,
  interpolateTransformCss,
  interpolateTransformSvg,
  interpolateZoom,
  interpolateRgb,
  interpolateRgbBasis: rgbBasis,
  interpolateRgbBasisClosed: rgbBasisClosed,
  interpolateHsl: hsl$1,
  interpolateHslLong: hslLong,
  interpolateLab: lab,
  interpolateHcl: hcl$1,
  interpolateHclLong: hclLong,
  interpolateCubehelix: cubehelix$2,
  interpolateCubehelixLong: cubehelixLong,
  piecewise,
  quantize: quantize$1,
  path,
  polygonArea: area$1,
  polygonCentroid: centroid,
  polygonHull: hull,
  polygonContains: contains,
  polygonLength: length,
  quadtree,
  randomUniform: uniform,
  randomNormal: normal,
  randomLogNormal: logNormal,
  randomBates: bates,
  randomIrwinHall: irwinHall,
  randomExponential: exponential,
  scaleBand: band,
  scalePoint: point$5,
  scaleIdentity: identity$2,
  scaleLinear: linear,
  scaleLog: log$2,
  scaleSymlog: symlog,
  scaleOrdinal: ordinal,
  scaleImplicit: implicit,
  scalePow: pow,
  scaleSqrt: sqrt$1,
  scaleQuantile: quantile,
  scaleQuantize: quantize,
  scaleThreshold: threshold,
  scaleTime: time,
  scaleUtc: utcTime,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSequentialQuantile: sequentialQuantile,
  scaleDiverging: diverging$1,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  tickFormat,
  schemeCategory10: category10,
  schemeAccent: Accent,
  schemeDark2: Dark2,
  schemePaired: Paired,
  schemePastel1: Pastel1,
  schemePastel2: Pastel2,
  schemeSet1: Set1,
  schemeSet2: Set2,
  schemeSet3: Set3,
  schemeTableau10: Tableau10,
  interpolateBrBG: BrBG,
  schemeBrBG: scheme$q,
  interpolatePRGn: PRGn,
  schemePRGn: scheme$p,
  interpolatePiYG: PiYG,
  schemePiYG: scheme$o,
  interpolatePuOr: PuOr,
  schemePuOr: scheme$n,
  interpolateRdBu: RdBu,
  schemeRdBu: scheme$m,
  interpolateRdGy: RdGy,
  schemeRdGy: scheme$l,
  interpolateRdYlBu: RdYlBu,
  schemeRdYlBu: scheme$k,
  interpolateRdYlGn: RdYlGn,
  schemeRdYlGn: scheme$j,
  interpolateSpectral: Spectral,
  schemeSpectral: scheme$i,
  interpolateBuGn: BuGn,
  schemeBuGn: scheme$h,
  interpolateBuPu: BuPu,
  schemeBuPu: scheme$g,
  interpolateGnBu: GnBu,
  schemeGnBu: scheme$f,
  interpolateOrRd: OrRd,
  schemeOrRd: scheme$e,
  interpolatePuBuGn: PuBuGn,
  schemePuBuGn: scheme$d,
  interpolatePuBu: PuBu,
  schemePuBu: scheme$c,
  interpolatePuRd: PuRd,
  schemePuRd: scheme$b,
  interpolateRdPu: RdPu,
  schemeRdPu: scheme$a,
  interpolateYlGnBu: YlGnBu,
  schemeYlGnBu: scheme$9,
  interpolateYlGn: YlGn,
  schemeYlGn: scheme$8,
  interpolateYlOrBr: YlOrBr,
  schemeYlOrBr: scheme$7,
  interpolateYlOrRd: YlOrRd,
  schemeYlOrRd: scheme$6,
  interpolateBlues: Blues,
  schemeBlues: scheme$5,
  interpolateGreens: Greens,
  schemeGreens: scheme$4,
  interpolateGreys: Greys,
  schemeGreys: scheme$3,
  interpolatePurples: Purples,
  schemePurples: scheme$2,
  interpolateReds: Reds,
  schemeReds: scheme$1,
  interpolateOranges: Oranges,
  schemeOranges: scheme,
  interpolateCividis: cividis,
  interpolateCubehelixDefault: cubehelix,
  interpolateRainbow: rainbow,
  interpolateWarm: warm,
  interpolateCool: cool,
  interpolateSinebow: sinebow,
  interpolateTurbo: turbo,
  interpolateViridis: viridis,
  interpolateMagma: magma,
  interpolateInferno: inferno,
  interpolatePlasma: plasma,
  create: create$1,
  creator,
  local: local$1,
  matcher,
  mouse,
  namespace,
  namespaces,
  clientPoint: point$6,
  select,
  selectAll,
  selection,
  selector,
  selectorAll,
  style: styleValue,
  touch,
  touches,
  window: defaultView,
  get event() {
    return event;
  },
  customEvent,
  arc,
  area,
  line,
  pie,
  areaRadial,
  radialArea: areaRadial,
  lineRadial: lineRadial$1,
  radialLine: lineRadial$1,
  pointRadial,
  linkHorizontal,
  linkVertical,
  linkRadial,
  symbol,
  symbols,
  symbolCircle: circle$2,
  symbolCross: cross$1,
  symbolDiamond: diamond,
  symbolSquare: square,
  symbolStar: star,
  symbolTriangle: triangle,
  symbolWye: wye,
  curveBasisClosed: basisClosed,
  curveBasisOpen: basisOpen,
  curveBasis: basis,
  curveBundle: bundle,
  curveCardinalClosed: cardinalClosed,
  curveCardinalOpen: cardinalOpen,
  curveCardinal: cardinal,
  curveCatmullRomClosed: catmullRomClosed,
  curveCatmullRomOpen: catmullRomOpen,
  curveCatmullRom: catmullRom,
  curveLinearClosed: linearClosed,
  curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural: natural,
  curveStep: step,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore,
  stack,
  stackOffsetExpand: expand,
  stackOffsetDiverging: diverging,
  stackOffsetNone: none$1,
  stackOffsetSilhouette: silhouette,
  stackOffsetWiggle: wiggle,
  stackOrderAppearance: appearance,
  stackOrderAscending: ascending,
  stackOrderDescending: descending,
  stackOrderInsideOut: insideOut,
  stackOrderNone: none,
  stackOrderReverse: reverse,
  timeInterval: newInterval,
  timeMillisecond: utcMillisecond,
  timeMilliseconds: milliseconds,
  utcMillisecond,
  utcMilliseconds: milliseconds,
  timeSecond: utcSecond,
  timeSeconds: seconds,
  utcSecond,
  utcSeconds: seconds,
  timeMinute,
  timeMinutes: minutes,
  timeHour,
  timeHours: hours,
  timeDay,
  timeDays: days,
  timeWeek: sunday,
  timeWeeks: sundays,
  timeSunday: sunday,
  timeSundays: sundays,
  timeMonday: monday,
  timeMondays: mondays,
  timeTuesday: tuesday,
  timeTuesdays: tuesdays,
  timeWednesday: wednesday,
  timeWednesdays: wednesdays,
  timeThursday: thursday,
  timeThursdays: thursdays,
  timeFriday: friday,
  timeFridays: fridays,
  timeSaturday: saturday,
  timeSaturdays: saturdays,
  timeMonth,
  timeMonths: months,
  timeYear,
  timeYears: years,
  utcMinute: utcMinute$1,
  utcMinutes,
  utcHour: utcHour$1,
  utcHours,
  utcDay: utcDay$1,
  utcDays,
  utcWeek: utcSunday,
  utcWeeks: utcSundays,
  utcSunday,
  utcSundays,
  utcMonday,
  utcMondays,
  utcTuesday,
  utcTuesdays,
  utcWednesday,
  utcWednesdays,
  utcThursday,
  utcThursdays,
  utcFriday,
  utcFridays,
  utcSaturday,
  utcSaturdays,
  utcMonth: utcMonth$1,
  utcMonths,
  utcYear: utcYear$1,
  utcYears,
  timeFormatDefaultLocale: defaultLocale,
  get timeFormat() {
    return timeFormat;
  },
  get timeParse() {
    return timeParse;
  },
  get utcFormat() {
    return utcFormat;
  },
  get utcParse() {
    return utcParse;
  },
  timeFormatLocale: formatLocale,
  isoFormat: formatIso$1,
  isoParse: parseIso$1,
  now,
  timer,
  timerFlush,
  timeout,
  interval,
  transition,
  active,
  interrupt,
  voronoi,
  zoom,
  zoomTransform: transform,
  zoomIdentity: identity
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(d3$2);
var d3$1;
if (!d3$1) {
  if (typeof commonjsRequire$1 === "function") {
    try {
      d3$1 = require$$0;
    } catch (e) {
    }
  }
}
if (!d3$1) {
  d3$1 = window.d3;
}
var d3_1 = d3$1;
var _$2 = lodash_1$1;
var util$2 = {
  isSubgraph: isSubgraph$1,
  edgeToId: edgeToId$1,
  applyStyle: applyStyle$2,
  applyClass: applyClass$1,
  applyTransition: applyTransition$1
};
function isSubgraph$1(g, v) {
  return !!g.children(v).length;
}
function edgeToId$1(e) {
  return escapeId$1(e.v) + ":" + escapeId$1(e.w) + ":" + escapeId$1(e.name);
}
var ID_DELIM$1 = /:/g;
function escapeId$1(str) {
  return str ? String(str).replace(ID_DELIM$1, "\\:") : "";
}
function applyStyle$2(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
function applyClass$1(dom, classFn, otherClasses) {
  if (classFn) {
    dom.attr("class", classFn).attr("class", otherClasses + " " + dom.attr("class"));
  }
}
function applyTransition$1(selection2, g) {
  var graph2 = g.graph();
  if (_$2.isPlainObject(graph2)) {
    var transition2 = graph2.transition;
    if (_$2.isFunction(transition2)) {
      return transition2(selection2);
    }
  }
  return selection2;
}
var addTextLabel_1;
var hasRequiredAddTextLabel;
function requireAddTextLabel() {
  if (hasRequiredAddTextLabel)
    return addTextLabel_1;
  hasRequiredAddTextLabel = 1;
  var util2 = util$2;
  addTextLabel_1 = addTextLabel;
  function addTextLabel(root2, node2) {
    var domNode = root2.append("text");
    var lines = processEscapeSequences(node2.label).split("\n");
    for (var i = 0; i < lines.length; i++) {
      domNode.append("tspan").attr("xml:space", "preserve").attr("dy", "1em").attr("x", "1").text(lines[i]);
    }
    util2.applyStyle(domNode, node2.labelStyle);
    return domNode;
  }
  function processEscapeSequences(text2) {
    var newText = "";
    var escaped = false;
    var ch;
    for (var i = 0; i < text2.length; ++i) {
      ch = text2[i];
      if (escaped) {
        switch (ch) {
          case "n":
            newText += "\n";
            break;
          default:
            newText += ch;
        }
        escaped = false;
      } else if (ch === "\\") {
        escaped = true;
      } else {
        newText += ch;
      }
    }
    return newText;
  }
  return addTextLabel_1;
}
var addHtmlLabel_1$1;
var hasRequiredAddHtmlLabel;
function requireAddHtmlLabel() {
  if (hasRequiredAddHtmlLabel)
    return addHtmlLabel_1$1;
  hasRequiredAddHtmlLabel = 1;
  var util2 = util$2;
  addHtmlLabel_1$1 = addHtmlLabel2;
  function addHtmlLabel2(root2, node2) {
    var fo = root2.append("foreignObject").attr("width", "100000");
    var div = fo.append("xhtml:div");
    div.attr("xmlns", "http://www.w3.org/1999/xhtml");
    var label = node2.label;
    switch (typeof label) {
      case "function":
        div.insert(label);
        break;
      case "object":
        div.insert(function() {
          return label;
        });
        break;
      default:
        div.html(label);
    }
    util2.applyStyle(div, node2.labelStyle);
    div.style("display", "inline-block");
    div.style("white-space", "nowrap");
    var client = div.node().getBoundingClientRect();
    fo.attr("width", client.width).attr("height", client.height);
    return fo;
  }
  return addHtmlLabel_1$1;
}
var addSvgLabel;
var hasRequiredAddSvgLabel;
function requireAddSvgLabel() {
  if (hasRequiredAddSvgLabel)
    return addSvgLabel;
  hasRequiredAddSvgLabel = 1;
  var util2 = util$2;
  addSvgLabel = addSVGLabel;
  function addSVGLabel(root2, node2) {
    var domNode = root2;
    domNode.node().appendChild(node2.label);
    util2.applyStyle(domNode, node2.labelStyle);
    return domNode;
  }
  return addSvgLabel;
}
var addLabel_1;
var hasRequiredAddLabel;
function requireAddLabel() {
  if (hasRequiredAddLabel)
    return addLabel_1;
  hasRequiredAddLabel = 1;
  var addTextLabel = requireAddTextLabel();
  var addHtmlLabel2 = requireAddHtmlLabel();
  var addSVGLabel = requireAddSvgLabel();
  addLabel_1 = addLabel;
  function addLabel(root2, node2, location2) {
    var label = node2.label;
    var labelSvg = root2.append("g");
    if (node2.labelType === "svg") {
      addSVGLabel(labelSvg, node2);
    } else if (typeof label !== "string" || node2.labelType === "html") {
      addHtmlLabel2(labelSvg, node2);
    } else {
      addTextLabel(labelSvg, node2);
    }
    var labelBBox = labelSvg.node().getBBox();
    var y2;
    switch (location2) {
      case "top":
        y2 = -node2.height / 2;
        break;
      case "bottom":
        y2 = node2.height / 2 - labelBBox.height;
        break;
      default:
        y2 = -labelBBox.height / 2;
    }
    labelSvg.attr(
      "transform",
      "translate(" + -labelBBox.width / 2 + "," + y2 + ")"
    );
    return labelSvg;
  }
  return addLabel_1;
}
var createNodes_1;
var hasRequiredCreateNodes;
function requireCreateNodes() {
  if (hasRequiredCreateNodes)
    return createNodes_1;
  hasRequiredCreateNodes = 1;
  var _2 = lodash_1$1;
  var addLabel = requireAddLabel();
  var util2 = util$2;
  var d32 = d3_1;
  createNodes_1 = createNodes;
  function createNodes(selection2, g, shapes2) {
    var simpleNodes = g.nodes().filter(function(v) {
      return !util2.isSubgraph(g, v);
    });
    var svgNodes = selection2.selectAll("g.node").data(simpleNodes, function(v) {
      return v;
    }).classed("update", true);
    svgNodes.exit().remove();
    svgNodes.enter().append("g").attr("class", "node").style("opacity", 0);
    svgNodes = selection2.selectAll("g.node");
    svgNodes.each(function(v) {
      var node2 = g.node(v);
      var thisGroup = d32.select(this);
      util2.applyClass(
        thisGroup,
        node2["class"],
        (thisGroup.classed("update") ? "update " : "") + "node"
      );
      thisGroup.select("g.label").remove();
      var labelGroup = thisGroup.append("g").attr("class", "label");
      var labelDom = addLabel(labelGroup, node2);
      var shape = shapes2[node2.shape];
      var bbox = _2.pick(labelDom.node().getBBox(), "width", "height");
      node2.elem = this;
      if (node2.id) {
        thisGroup.attr("id", node2.id);
      }
      if (node2.labelId) {
        labelGroup.attr("id", node2.labelId);
      }
      if (_2.has(node2, "width")) {
        bbox.width = node2.width;
      }
      if (_2.has(node2, "height")) {
        bbox.height = node2.height;
      }
      bbox.width += node2.paddingLeft + node2.paddingRight;
      bbox.height += node2.paddingTop + node2.paddingBottom;
      labelGroup.attr("transform", "translate(" + (node2.paddingLeft - node2.paddingRight) / 2 + "," + (node2.paddingTop - node2.paddingBottom) / 2 + ")");
      var root2 = d32.select(this);
      root2.select(".label-container").remove();
      var shapeSvg = shape(root2, bbox, node2).classed("label-container", true);
      util2.applyStyle(shapeSvg, node2.style);
      var shapeBBox = shapeSvg.node().getBBox();
      node2.width = shapeBBox.width;
      node2.height = shapeBBox.height;
    });
    var exitSelection;
    if (svgNodes.exit) {
      exitSelection = svgNodes.exit();
    } else {
      exitSelection = svgNodes.selectAll(null);
    }
    util2.applyTransition(exitSelection, g).style("opacity", 0).remove();
    return svgNodes;
  }
  return createNodes_1;
}
var createClusters_1;
var hasRequiredCreateClusters;
function requireCreateClusters() {
  if (hasRequiredCreateClusters)
    return createClusters_1;
  hasRequiredCreateClusters = 1;
  var util2 = util$2;
  var d32 = d3_1;
  var addLabel = requireAddLabel();
  createClusters_1 = createClusters;
  function createClusters(selection2, g) {
    var clusters = g.nodes().filter(function(v) {
      return util2.isSubgraph(g, v);
    });
    var svgClusters = selection2.selectAll("g.cluster").data(clusters, function(v) {
      return v;
    });
    svgClusters.selectAll("*").remove();
    svgClusters.enter().append("g").attr("class", "cluster").attr("id", function(v) {
      var node2 = g.node(v);
      return node2.id;
    }).style("opacity", 0);
    svgClusters = selection2.selectAll("g.cluster");
    util2.applyTransition(svgClusters, g).style("opacity", 1);
    svgClusters.each(function(v) {
      var node2 = g.node(v);
      var thisGroup = d32.select(this);
      d32.select(this).append("rect");
      var labelGroup = thisGroup.append("g").attr("class", "label");
      addLabel(labelGroup, node2, node2.clusterLabelPos);
    });
    svgClusters.selectAll("rect").each(function(c2) {
      var node2 = g.node(c2);
      var domCluster = d32.select(this);
      util2.applyStyle(domCluster, node2.style);
    });
    var exitSelection;
    if (svgClusters.exit) {
      exitSelection = svgClusters.exit();
    } else {
      exitSelection = svgClusters.selectAll(null);
    }
    util2.applyTransition(exitSelection, g).style("opacity", 0).remove();
    return svgClusters;
  }
  return createClusters_1;
}
var createEdgeLabels_1;
var hasRequiredCreateEdgeLabels;
function requireCreateEdgeLabels() {
  if (hasRequiredCreateEdgeLabels)
    return createEdgeLabels_1;
  hasRequiredCreateEdgeLabels = 1;
  var _2 = lodash_1$1;
  var addLabel = requireAddLabel();
  var util2 = util$2;
  var d32 = d3_1;
  createEdgeLabels_1 = createEdgeLabels;
  function createEdgeLabels(selection2, g) {
    var svgEdgeLabels = selection2.selectAll("g.edgeLabel").data(g.edges(), function(e) {
      return util2.edgeToId(e);
    }).classed("update", true);
    svgEdgeLabels.exit().remove();
    svgEdgeLabels.enter().append("g").classed("edgeLabel", true).style("opacity", 0);
    svgEdgeLabels = selection2.selectAll("g.edgeLabel");
    svgEdgeLabels.each(function(e) {
      var root2 = d32.select(this);
      root2.select(".label").remove();
      var edge = g.edge(e);
      var label = addLabel(root2, g.edge(e), 0, 0).classed("label", true);
      var bbox = label.node().getBBox();
      if (edge.labelId) {
        label.attr("id", edge.labelId);
      }
      if (!_2.has(edge, "width")) {
        edge.width = bbox.width;
      }
      if (!_2.has(edge, "height")) {
        edge.height = bbox.height;
      }
    });
    var exitSelection;
    if (svgEdgeLabels.exit) {
      exitSelection = svgEdgeLabels.exit();
    } else {
      exitSelection = svgEdgeLabels.selectAll(null);
    }
    util2.applyTransition(exitSelection, g).style("opacity", 0).remove();
    return svgEdgeLabels;
  }
  return createEdgeLabels_1;
}
var createEdgePaths_1;
var hasRequiredCreateEdgePaths;
function requireCreateEdgePaths() {
  if (hasRequiredCreateEdgePaths)
    return createEdgePaths_1;
  hasRequiredCreateEdgePaths = 1;
  var _2 = lodash_1$1;
  var intersectNode2 = intersectNode_1;
  var util2 = util$2;
  var d32 = d3_1;
  createEdgePaths_1 = createEdgePaths;
  function createEdgePaths(selection2, g, arrows2) {
    var previousPaths = selection2.selectAll("g.edgePath").data(g.edges(), function(e) {
      return util2.edgeToId(e);
    }).classed("update", true);
    var newPaths = enter(previousPaths, g);
    exit(previousPaths, g);
    var svgPaths = previousPaths.merge !== void 0 ? previousPaths.merge(newPaths) : previousPaths;
    util2.applyTransition(svgPaths, g).style("opacity", 1);
    svgPaths.each(function(e) {
      var domEdge = d32.select(this);
      var edge = g.edge(e);
      edge.elem = this;
      if (edge.id) {
        domEdge.attr("id", edge.id);
      }
      util2.applyClass(
        domEdge,
        edge["class"],
        (domEdge.classed("update") ? "update " : "") + "edgePath"
      );
    });
    svgPaths.selectAll("path.path").each(function(e) {
      var edge = g.edge(e);
      edge.arrowheadId = _2.uniqueId("arrowhead");
      var domEdge = d32.select(this).attr("marker-end", function() {
        return "url(" + makeFragmentRef(location.href, edge.arrowheadId) + ")";
      }).style("fill", "none");
      util2.applyTransition(domEdge, g).attr("d", function(e3) {
        return calcPoints(g, e3);
      });
      util2.applyStyle(domEdge, edge.style);
    });
    svgPaths.selectAll("defs *").remove();
    svgPaths.selectAll("defs").each(function(e) {
      var edge = g.edge(e);
      var arrowhead = arrows2[edge.arrowhead];
      arrowhead(d32.select(this), edge.arrowheadId, edge, "arrowhead");
    });
    return svgPaths;
  }
  function makeFragmentRef(url, fragmentId) {
    var baseUrl = url.split("#")[0];
    return baseUrl + "#" + fragmentId;
  }
  function calcPoints(g, e) {
    var edge = g.edge(e);
    var tail = g.node(e.v);
    var head2 = g.node(e.w);
    var points = edge.points.slice(1, edge.points.length - 1);
    points.unshift(intersectNode2(tail, points[0]));
    points.push(intersectNode2(head2, points[points.length - 1]));
    return createLine(edge, points);
  }
  function createLine(edge, points) {
    var line2 = (d32.line || d32.svg.line)().x(function(d) {
      return d.x;
    }).y(function(d) {
      return d.y;
    });
    (line2.curve || line2.interpolate)(edge.curve);
    return line2(points);
  }
  function getCoords(elem) {
    var bbox = elem.getBBox();
    var matrix = elem.ownerSVGElement.getScreenCTM().inverse().multiply(elem.getScreenCTM()).translate(bbox.width / 2, bbox.height / 2);
    return { x: matrix.e, y: matrix.f };
  }
  function enter(svgPaths, g) {
    var svgPathsEnter = svgPaths.enter().append("g").attr("class", "edgePath").style("opacity", 0);
    svgPathsEnter.append("path").attr("class", "path").attr("d", function(e) {
      var edge = g.edge(e);
      var sourceElem = g.node(e.v).elem;
      var points = _2.range(edge.points.length).map(function() {
        return getCoords(sourceElem);
      });
      return createLine(edge, points);
    });
    svgPathsEnter.append("defs");
    return svgPathsEnter;
  }
  function exit(svgPaths, g) {
    var svgPathExit = svgPaths.exit();
    util2.applyTransition(svgPathExit, g).style("opacity", 0).remove();
  }
  return createEdgePaths_1;
}
var positionNodes_1;
var hasRequiredPositionNodes;
function requirePositionNodes() {
  if (hasRequiredPositionNodes)
    return positionNodes_1;
  hasRequiredPositionNodes = 1;
  var util2 = util$2;
  var d32 = d3_1;
  positionNodes_1 = positionNodes;
  function positionNodes(selection2, g) {
    var created = selection2.filter(function() {
      return !d32.select(this).classed("update");
    });
    function translate(v) {
      var node2 = g.node(v);
      return "translate(" + node2.x + "," + node2.y + ")";
    }
    created.attr("transform", translate);
    util2.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
  }
  return positionNodes_1;
}
var positionEdgeLabels_1;
var hasRequiredPositionEdgeLabels;
function requirePositionEdgeLabels() {
  if (hasRequiredPositionEdgeLabels)
    return positionEdgeLabels_1;
  hasRequiredPositionEdgeLabels = 1;
  var util2 = util$2;
  var d32 = d3_1;
  var _2 = lodash_1$1;
  positionEdgeLabels_1 = positionEdgeLabels;
  function positionEdgeLabels(selection2, g) {
    var created = selection2.filter(function() {
      return !d32.select(this).classed("update");
    });
    function translate(e) {
      var edge = g.edge(e);
      return _2.has(edge, "x") ? "translate(" + edge.x + "," + edge.y + ")" : "";
    }
    created.attr("transform", translate);
    util2.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
  }
  return positionEdgeLabels_1;
}
var positionClusters_1;
var hasRequiredPositionClusters;
function requirePositionClusters() {
  if (hasRequiredPositionClusters)
    return positionClusters_1;
  hasRequiredPositionClusters = 1;
  var util2 = util$2;
  var d32 = d3_1;
  positionClusters_1 = positionClusters;
  function positionClusters(selection2, g) {
    var created = selection2.filter(function() {
      return !d32.select(this).classed("update");
    });
    function translate(v) {
      var node2 = g.node(v);
      return "translate(" + node2.x + "," + node2.y + ")";
    }
    created.attr("transform", translate);
    util2.applyTransition(selection2, g).style("opacity", 1).attr("transform", translate);
    util2.applyTransition(created.selectAll("rect"), g).attr("width", function(v) {
      return g.node(v).width;
    }).attr("height", function(v) {
      return g.node(v).height;
    }).attr("x", function(v) {
      var node2 = g.node(v);
      return -node2.width / 2;
    }).attr("y", function(v) {
      var node2 = g.node(v);
      return -node2.height / 2;
    });
  }
  return positionClusters_1;
}
var shapes$2;
var hasRequiredShapes;
function requireShapes() {
  if (hasRequiredShapes)
    return shapes$2;
  hasRequiredShapes = 1;
  var intersectRect2 = intersectRect_1;
  var intersectEllipse2 = intersectEllipse_1;
  var intersectCircle2 = intersectCircle_1;
  var intersectPolygon2 = intersectPolygon_1;
  shapes$2 = {
    rect: rect2,
    ellipse,
    circle: circle2,
    diamond: diamond2
  };
  function rect2(parent, bbox, node2) {
    var shapeSvg = parent.insert("rect", ":first-child").attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("width", bbox.width).attr("height", bbox.height);
    node2.intersect = function(point2) {
      return intersectRect2(node2, point2);
    };
    return shapeSvg;
  }
  function ellipse(parent, bbox, node2) {
    var rx = bbox.width / 2;
    var ry = bbox.height / 2;
    var shapeSvg = parent.insert("ellipse", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("rx", rx).attr("ry", ry);
    node2.intersect = function(point2) {
      return intersectEllipse2(node2, rx, ry, point2);
    };
    return shapeSvg;
  }
  function circle2(parent, bbox, node2) {
    var r = Math.max(bbox.width, bbox.height) / 2;
    var shapeSvg = parent.insert("circle", ":first-child").attr("x", -bbox.width / 2).attr("y", -bbox.height / 2).attr("r", r);
    node2.intersect = function(point2) {
      return intersectCircle2(node2, r, point2);
    };
    return shapeSvg;
  }
  function diamond2(parent, bbox, node2) {
    var w2 = bbox.width * Math.SQRT2 / 2;
    var h = bbox.height * Math.SQRT2 / 2;
    var points = [
      { x: 0, y: -h },
      { x: -w2, y: 0 },
      { x: 0, y: h },
      { x: w2, y: 0 }
    ];
    var shapeSvg = parent.insert("polygon", ":first-child").attr("points", points.map(function(p) {
      return p.x + "," + p.y;
    }).join(" "));
    node2.intersect = function(p) {
      return intersectPolygon2(node2, points, p);
    };
    return shapeSvg;
  }
  return shapes$2;
}
var arrows;
var hasRequiredArrows;
function requireArrows() {
  if (hasRequiredArrows)
    return arrows;
  hasRequiredArrows = 1;
  var util2 = util$2;
  arrows = {
    "default": normal2,
    "normal": normal2,
    "vee": vee,
    "undirected": undirected
  };
  function normal2(parent, id2, edge, type2) {
    var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    var path2 = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    util2.applyStyle(path2, edge[type2 + "Style"]);
    if (edge[type2 + "Class"]) {
      path2.attr("class", edge[type2 + "Class"]);
    }
  }
  function vee(parent, id2, edge, type2) {
    var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    var path2 = marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 L 4 5 z").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    util2.applyStyle(path2, edge[type2 + "Style"]);
    if (edge[type2 + "Class"]) {
      path2.attr("class", edge[type2 + "Class"]);
    }
  }
  function undirected(parent, id2, edge, type2) {
    var marker = parent.append("marker").attr("id", id2).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    var path2 = marker.append("path").attr("d", "M 0 5 L 10 5").style("stroke-width", 1).style("stroke-dasharray", "1,0");
    util2.applyStyle(path2, edge[type2 + "Style"]);
    if (edge[type2 + "Class"]) {
      path2.attr("class", edge[type2 + "Class"]);
    }
  }
  return arrows;
}
var _$1 = lodash_1$1;
var d3 = d3_1;
var layout = dagre_1.layout;
var render_1 = render$2;
function render$2() {
  var createNodes = requireCreateNodes();
  var createClusters = requireCreateClusters();
  var createEdgeLabels = requireCreateEdgeLabels();
  var createEdgePaths = requireCreateEdgePaths();
  var positionNodes = requirePositionNodes();
  var positionEdgeLabels = requirePositionEdgeLabels();
  var positionClusters = requirePositionClusters();
  var shapes2 = requireShapes();
  var arrows2 = requireArrows();
  var fn = function(svg2, g) {
    preProcessGraph(g);
    var outputGroup = createOrSelectGroup(svg2, "output");
    var clustersGroup = createOrSelectGroup(outputGroup, "clusters");
    var edgePathsGroup = createOrSelectGroup(outputGroup, "edgePaths");
    var edgeLabels2 = createEdgeLabels(createOrSelectGroup(outputGroup, "edgeLabels"), g);
    var nodes = createNodes(createOrSelectGroup(outputGroup, "nodes"), g, shapes2);
    layout(g);
    positionNodes(nodes, g);
    positionEdgeLabels(edgeLabels2, g);
    createEdgePaths(edgePathsGroup, g, arrows2);
    var clusters = createClusters(clustersGroup, g);
    positionClusters(clusters, g);
    postProcessGraph(g);
  };
  fn.createNodes = function(value) {
    if (!arguments.length)
      return createNodes;
    createNodes = value;
    return fn;
  };
  fn.createClusters = function(value) {
    if (!arguments.length)
      return createClusters;
    createClusters = value;
    return fn;
  };
  fn.createEdgeLabels = function(value) {
    if (!arguments.length)
      return createEdgeLabels;
    createEdgeLabels = value;
    return fn;
  };
  fn.createEdgePaths = function(value) {
    if (!arguments.length)
      return createEdgePaths;
    createEdgePaths = value;
    return fn;
  };
  fn.shapes = function(value) {
    if (!arguments.length)
      return shapes2;
    shapes2 = value;
    return fn;
  };
  fn.arrows = function(value) {
    if (!arguments.length)
      return arrows2;
    arrows2 = value;
    return fn;
  };
  return fn;
}
var NODE_DEFAULT_ATTRS = {
  paddingLeft: 10,
  paddingRight: 10,
  paddingTop: 10,
  paddingBottom: 10,
  rx: 0,
  ry: 0,
  shape: "rect"
};
var EDGE_DEFAULT_ATTRS = {
  arrowhead: "normal",
  curve: d3.curveLinear
};
function preProcessGraph(g) {
  g.nodes().forEach(function(v) {
    var node2 = g.node(v);
    if (!_$1.has(node2, "label") && !g.children(v).length) {
      node2.label = v;
    }
    if (_$1.has(node2, "paddingX")) {
      _$1.defaults(node2, {
        paddingLeft: node2.paddingX,
        paddingRight: node2.paddingX
      });
    }
    if (_$1.has(node2, "paddingY")) {
      _$1.defaults(node2, {
        paddingTop: node2.paddingY,
        paddingBottom: node2.paddingY
      });
    }
    if (_$1.has(node2, "padding")) {
      _$1.defaults(node2, {
        paddingLeft: node2.padding,
        paddingRight: node2.padding,
        paddingTop: node2.padding,
        paddingBottom: node2.padding
      });
    }
    _$1.defaults(node2, NODE_DEFAULT_ATTRS);
    _$1.each(["paddingLeft", "paddingRight", "paddingTop", "paddingBottom"], function(k2) {
      node2[k2] = Number(node2[k2]);
    });
    if (_$1.has(node2, "width")) {
      node2._prevWidth = node2.width;
    }
    if (_$1.has(node2, "height")) {
      node2._prevHeight = node2.height;
    }
  });
  g.edges().forEach(function(e) {
    var edge = g.edge(e);
    if (!_$1.has(edge, "label")) {
      edge.label = "";
    }
    _$1.defaults(edge, EDGE_DEFAULT_ATTRS);
  });
}
function postProcessGraph(g) {
  _$1.each(g.nodes(), function(v) {
    var node2 = g.node(v);
    if (_$1.has(node2, "_prevWidth")) {
      node2.width = node2._prevWidth;
    } else {
      delete node2.width;
    }
    if (_$1.has(node2, "_prevHeight")) {
      node2.height = node2._prevHeight;
    } else {
      delete node2.height;
    }
    delete node2._prevWidth;
    delete node2._prevHeight;
  });
}
function createOrSelectGroup(root2, name2) {
  var selection2 = root2.select("g." + name2);
  if (selection2.empty()) {
    selection2 = root2.append("g").attr("class", name2);
  }
  return selection2;
}
var version$2 = "0.6.4";
/**
 * @license
 * Copyright (c) 2012-2013 Chris Pettitt
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
var dagreD3 = {
  graphlib: graphlib_1,
  dagre: dagre_1,
  intersect: intersect$2,
  render: render_1,
  util: util$2,
  version: version$2
};
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
const LEVELS = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
};
const log$1 = {
  trace: (..._args) => {
  },
  debug: (..._args) => {
  },
  info: (..._args) => {
  },
  warn: (..._args) => {
  },
  error: (..._args) => {
  },
  fatal: (..._args) => {
  }
};
const setLogLevel$1 = function(level = "fatal") {
  let numericLevel = LEVELS.fatal;
  if (typeof level === "string") {
    level = level.toLowerCase();
    if (level in LEVELS) {
      numericLevel = LEVELS[level];
    }
  } else if (typeof level === "number") {
    numericLevel = level;
  }
  log$1.trace = () => {
  };
  log$1.debug = () => {
  };
  log$1.info = () => {
  };
  log$1.warn = () => {
  };
  log$1.error = () => {
  };
  log$1.fatal = () => {
  };
  if (numericLevel <= LEVELS.fatal) {
    log$1.fatal = console.error ? console.error.bind(console, format("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", format("FATAL"));
  }
  if (numericLevel <= LEVELS.error) {
    log$1.error = console.error ? console.error.bind(console, format("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", format("ERROR"));
  }
  if (numericLevel <= LEVELS.warn) {
    log$1.warn = console.warn ? console.warn.bind(console, format("WARN"), "color: orange") : console.log.bind(console, `\x1B[33m`, format("WARN"));
  }
  if (numericLevel <= LEVELS.info) {
    log$1.info = console.info ? console.info.bind(console, format("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", format("INFO"));
  }
  if (numericLevel <= LEVELS.debug) {
    log$1.debug = console.debug ? console.debug.bind(console, format("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("DEBUG"));
  }
  if (numericLevel <= LEVELS.trace) {
    log$1.trace = console.debug ? console.debug.bind(console, format("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("TRACE"));
  }
};
const format = (level) => {
  const time2 = moment().format("ss.SSS");
  return `%c${time2} : ${level} : `;
};
const getRows = (s2) => {
  if (!s2)
    return [""];
  const str = breakToPlaceholder(s2).replace(/\\n/g, "#br#");
  return str.split("#br#");
};
const removeScript = (txt) => {
  return purify.sanitize(txt);
};
const sanitizeMore = (text2, config2) => {
  var _a;
  if (((_a = config2.flowchart) == null ? void 0 : _a.htmlLabels) !== false) {
    const level = config2.securityLevel;
    if (level === "antiscript" || level === "strict") {
      text2 = removeScript(text2);
    } else if (level !== "loose") {
      text2 = breakToPlaceholder(text2);
      text2 = text2.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      text2 = text2.replace(/=/g, "&equals;");
      text2 = placeholderToBreak(text2);
    }
  }
  return text2;
};
const sanitizeText$5 = (text2, config2) => {
  if (!text2)
    return text2;
  if (config2.dompurifyConfig) {
    text2 = purify.sanitize(sanitizeMore(text2, config2), config2.dompurifyConfig).toString();
  } else {
    text2 = purify.sanitize(sanitizeMore(text2, config2));
  }
  return text2;
};
const sanitizeTextOrArray = (a2, config2) => {
  if (typeof a2 === "string")
    return sanitizeText$5(a2, config2);
  return a2.flat().map((x2) => sanitizeText$5(x2, config2));
};
const lineBreakRegex = /<br\s*\/?>/gi;
const hasBreaks = (text2) => {
  return lineBreakRegex.test(text2);
};
const splitBreaks = (text2) => {
  return text2.split(lineBreakRegex);
};
const placeholderToBreak = (s2) => {
  return s2.replace(/#br#/g, "<br/>");
};
const breakToPlaceholder = (s2) => {
  return s2.replace(lineBreakRegex, "#br#");
};
const getUrl = (useAbsolute) => {
  let url = "";
  if (useAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replaceAll(/\(/g, "\\(");
    url = url.replaceAll(/\)/g, "\\)");
  }
  return url;
};
const evaluate = (val) => val === false || ["false", "null", "0"].includes(String(val).trim().toLowerCase()) ? false : true;
const parseGenericTypes = function(text2) {
  let cleanedText = text2;
  if (text2.indexOf("~") !== -1) {
    cleanedText = cleanedText.replace(/~([^~].*)/, "<$1");
    cleanedText = cleanedText.replace(/~([^~]*)$/, ">$1");
    return parseGenericTypes(cleanedText);
  } else {
    return cleanedText;
  }
};
const common = {
  getRows,
  sanitizeText: sanitizeText$5,
  sanitizeTextOrArray,
  hasBreaks,
  splitBreaks,
  lineBreakRegex,
  removeScript,
  getUrl,
  evaluate
};
const mkBorder = (col, darkMode) => darkMode ? adjust$1(col, { s: -40, l: 10 }) : adjust$1(col, { s: -40, l: -10 });
const oldAttributeBackgroundColorOdd = "#ffffff";
const oldAttributeBackgroundColorEven = "#f2f2f2";
class Theme$4 {
  constructor() {
    this.background = "#f4f4f4";
    this.darkMode = false;
    this.primaryColor = "#fff4dd";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "#333";
    this.THEME_COLOR_LIMIT = 12;
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
  }
  updateColors() {
    this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333");
    this.secondaryColor = this.secondaryColor || adjust$1(this.primaryColor, { h: -120 });
    this.tertiaryColor = this.tertiaryColor || adjust$1(this.primaryColor, { h: 180, l: 5 });
    this.primaryBorderColor = this.primaryBorderColor || mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = this.secondaryBorderColor || mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = this.tertiaryBorderColor || mkBorder(this.tertiaryColor, this.darkMode);
    this.noteBorderColor = this.noteBorderColor || mkBorder(this.noteBkgColor, this.darkMode);
    this.noteBkgColor = this.noteBkgColor || "#fff5ad";
    this.noteTextColor = this.noteTextColor || "#333";
    this.secondaryTextColor = this.secondaryTextColor || invert(this.secondaryColor);
    this.tertiaryTextColor = this.tertiaryTextColor || invert(this.tertiaryColor);
    this.lineColor = this.lineColor || invert(this.background);
    this.textColor = this.textColor || this.primaryTextColor;
    this.nodeBkg = this.nodeBkg || this.primaryColor;
    this.mainBkg = this.mainBkg || this.primaryColor;
    this.nodeBorder = this.nodeBorder || this.primaryBorderColor;
    this.clusterBkg = this.clusterBkg || this.tertiaryColor;
    this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor;
    this.defaultLinkColor = this.defaultLinkColor || this.lineColor;
    this.titleColor = this.titleColor || this.tertiaryTextColor;
    this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? darken(this.secondaryColor, 30) : this.secondaryColor);
    this.nodeTextColor = this.nodeTextColor || this.primaryTextColor;
    this.actorBorder = this.actorBorder || this.primaryBorderColor;
    this.actorBkg = this.actorBkg || this.mainBkg;
    this.actorTextColor = this.actorTextColor || this.primaryTextColor;
    this.actorLineColor = this.actorLineColor || "grey";
    this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg;
    this.signalColor = this.signalColor || this.textColor;
    this.signalTextColor = this.signalTextColor || this.textColor;
    this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder;
    this.labelTextColor = this.labelTextColor || this.actorTextColor;
    this.loopTextColor = this.loopTextColor || this.actorTextColor;
    this.activationBorderColor = this.activationBorderColor || darken(this.secondaryColor, 10);
    this.activationBkgColor = this.activationBkgColor || this.secondaryColor;
    this.sequenceNumberColor = this.sequenceNumberColor || invert(this.lineColor);
    this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor;
    this.altSectionBkgColor = this.altSectionBkgColor || "white";
    this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor;
    this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor;
    this.excludeBkgColor = this.excludeBkgColor || "#eeeeee";
    this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor;
    this.taskBkgColor = this.taskBkgColor || this.primaryColor;
    this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor;
    this.activeTaskBkgColor = this.activeTaskBkgColor || lighten(this.primaryColor, 23);
    this.gridColor = this.gridColor || "lightgrey";
    this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey";
    this.doneTaskBorderColor = this.doneTaskBorderColor || "grey";
    this.critBorderColor = this.critBorderColor || "#ff8888";
    this.critBkgColor = this.critBkgColor || "red";
    this.todayLineColor = this.todayLineColor || "red";
    this.taskTextColor = this.taskTextColor || this.textColor;
    this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor;
    this.taskTextLightColor = this.taskTextLightColor || this.textColor;
    this.taskTextColor = this.taskTextColor || this.primaryTextColor;
    this.taskTextDarkColor = this.taskTextDarkColor || this.textColor;
    this.taskTextClickableColor = this.taskTextClickableColor || "#003163";
    this.personBorder = this.personBorder || this.primaryBorderColor;
    this.personBkg = this.personBkg || this.mainBkg;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || this.tertiaryColor;
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.nodeBorder;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.specialStateColor = this.lineColor;
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210, l: 150 });
    this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
    if (this.darkMode) {
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken(this["cScale" + i], 75);
      }
    } else {
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken(this["cScale" + i], 25);
      }
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      if (this.darkMode) {
        this["cScalePeer" + i] = this["cScalePeer" + i] || lighten(this["cScale" + i], 10);
      } else {
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 10);
      }
    }
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    this.classText = this.classText || this.textColor;
    this.fillType0 = this.fillType0 || this.primaryColor;
    this.fillType1 = this.fillType1 || this.secondaryColor;
    this.fillType2 = this.fillType2 || adjust$1(this.primaryColor, { h: 64 });
    this.fillType3 = this.fillType3 || adjust$1(this.secondaryColor, { h: 64 });
    this.fillType4 = this.fillType4 || adjust$1(this.primaryColor, { h: -64 });
    this.fillType5 = this.fillType5 || adjust$1(this.secondaryColor, { h: -64 });
    this.fillType6 = this.fillType6 || adjust$1(this.primaryColor, { h: 128 });
    this.fillType7 = this.fillType7 || adjust$1(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || this.tertiaryColor;
    this.pie4 = this.pie4 || adjust$1(this.primaryColor, { l: -10 });
    this.pie5 = this.pie5 || adjust$1(this.secondaryColor, { l: -10 });
    this.pie6 = this.pie6 || adjust$1(this.tertiaryColor, { l: -10 });
    this.pie7 = this.pie7 || adjust$1(this.primaryColor, { h: 60, l: -10 });
    this.pie8 = this.pie8 || adjust$1(this.primaryColor, { h: -60, l: -10 });
    this.pie9 = this.pie9 || adjust$1(this.primaryColor, { h: 120, l: 0 });
    this.pie10 = this.pie10 || adjust$1(this.primaryColor, { h: 60, l: -20 });
    this.pie11 = this.pie11 || adjust$1(this.primaryColor, { h: -60, l: -20 });
    this.pie12 = this.pie12 || adjust$1(this.primaryColor, { h: 120, l: -10 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken(this.secondaryColor, 30) : this.secondaryColor);
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust$1(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust$1(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust$1(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust$1(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust$1(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten(this.git0, 25);
      this.git1 = lighten(this.git1, 25);
      this.git2 = lighten(this.git2, 25);
      this.git3 = lighten(this.git3, 25);
      this.git4 = lighten(this.git4, 25);
      this.git5 = lighten(this.git5, 25);
      this.git6 = lighten(this.git6, 25);
      this.git7 = lighten(this.git7, 25);
    } else {
      this.git0 = darken(this.git0, 25);
      this.git1 = darken(this.git1, 25);
      this.git2 = darken(this.git2, 25);
      this.git3 = darken(this.git3, 25);
      this.git4 = darken(this.git4, 25);
      this.git5 = darken(this.git5, 25);
      this.git6 = darken(this.git6, 25);
      this.git7 = darken(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor;
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor;
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$4 = (userOverrides) => {
  const theme2 = new Theme$4();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme$3 {
  constructor() {
    this.background = "#333";
    this.primaryColor = "#1f2020";
    this.secondaryColor = lighten(this.primaryColor, 16);
    this.tertiaryColor = adjust$1(this.primaryColor, { h: -160 });
    this.primaryBorderColor = invert(this.background);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.tertiaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.mainBkg = "#1f2020";
    this.secondBkg = "calculated";
    this.mainContrastColor = "lightgrey";
    this.darkTextColor = lighten(invert("#323D47"), 10);
    this.lineColor = "calculated";
    this.border1 = "#81B1DB";
    this.border2 = rgba$1(255, 255, 255, 0.25);
    this.arrowheadColor = "calculated";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.labelBackground = "#181818";
    this.textColor = "#ccc";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "#F9FFFE";
    this.edgeLabelBackground = "calculated";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "calculated";
    this.actorLineColor = "calculated";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "calculated";
    this.activationBkgColor = "calculated";
    this.sequenceNumberColor = "black";
    this.sectionBkgColor = darken("#EAE8D9", 30);
    this.altSectionBkgColor = "calculated";
    this.sectionBkgColor2 = "#EAE8D9";
    this.taskBorderColor = rgba$1(255, 255, 255, 70);
    this.taskBkgColor = "calculated";
    this.taskTextColor = "calculated";
    this.taskTextLightColor = "calculated";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = rgba$1(255, 255, 255, 50);
    this.activeTaskBkgColor = "#81B1DB";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#E83737";
    this.critBkgColor = "#E83737";
    this.taskTextDarkColor = "calculated";
    this.todayLineColor = "#DB5757";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "calculated";
    this.errorBkgColor = "#a44141";
    this.errorTextColor = "#ddd";
  }
  updateColors() {
    this.secondBkg = lighten(this.mainBkg, 16);
    this.lineColor = this.mainContrastColor;
    this.arrowheadColor = this.mainContrastColor;
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.edgeLabelBackground = lighten(this.labelBackground, 25);
    this.actorBorder = this.border1;
    this.actorBkg = this.mainBkg;
    this.actorTextColor = this.mainContrastColor;
    this.actorLineColor = this.mainContrastColor;
    this.signalColor = this.mainContrastColor;
    this.signalTextColor = this.mainContrastColor;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.mainContrastColor;
    this.loopTextColor = this.mainContrastColor;
    this.noteBorderColor = this.secondaryBorderColor;
    this.noteBkgColor = this.secondBkg;
    this.noteTextColor = this.secondaryTextColor;
    this.activationBorderColor = this.border1;
    this.activationBkgColor = this.secondBkg;
    this.altSectionBkgColor = this.background;
    this.taskBkgColor = lighten(this.mainBkg, 23);
    this.taskTextColor = this.darkTextColor;
    this.taskTextLightColor = this.mainContrastColor;
    this.taskTextOutsideColor = this.taskTextLightColor;
    this.gridColor = this.mainContrastColor;
    this.doneTaskBkgColor = this.mainContrastColor;
    this.taskTextDarkColor = this.darkTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#555";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = "#f4f4f4";
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
    this.cScale1 = this.cScale1 || "#0b0000";
    this.cScale2 = this.cScale2 || "#4d1037";
    this.cScale3 = this.cScale3 || "#3f5258";
    this.cScale4 = this.cScale4 || "#4f2f1b";
    this.cScale5 = this.cScale5 || "#6e0a0a";
    this.cScale6 = this.cScale6 || "#3b0048";
    this.cScale7 = this.cScale7 || "#995a01";
    this.cScale8 = this.cScale8 || "#154706";
    this.cScale9 = this.cScale9 || "#161722";
    this.cScale10 = this.cScale10 || "#00296f";
    this.cScale11 = this.cScale11 || "#01629c";
    this.cScale12 = this.cScale12 || "#010029";
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScalePeer" + i] = this["cScalePeer" + i] || lighten(this["cScale" + i], 10);
    }
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["pie" + i] = this["cScale" + i];
    }
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.classText = this.primaryTextColor;
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken(this.secondaryColor, 30) : this.secondaryColor);
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = lighten(this.secondaryColor, 20);
    this.git1 = lighten(this.pie2 || this.secondaryColor, 20);
    this.git2 = lighten(this.pie3 || this.tertiaryColor, 20);
    this.git3 = lighten(this.pie4 || adjust$1(this.primaryColor, { h: -30 }), 20);
    this.git4 = lighten(this.pie5 || adjust$1(this.primaryColor, { h: -60 }), 20);
    this.git5 = lighten(this.pie6 || adjust$1(this.primaryColor, { h: -90 }), 10);
    this.git6 = lighten(this.pie7 || adjust$1(this.primaryColor, { h: 60 }), 10);
    this.git7 = lighten(this.pie8 || adjust$1(this.primaryColor, { h: 120 }), 20);
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || lighten(this.background, 12);
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || lighten(this.background, 2);
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$3 = (userOverrides) => {
  const theme2 = new Theme$3();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme$2 {
  constructor() {
    this.background = "#f4f4f4";
    this.primaryColor = "#ECECFF";
    this.secondaryColor = adjust$1(this.primaryColor, { h: 120 });
    this.secondaryColor = "#ffffde";
    this.tertiaryColor = adjust$1(this.primaryColor, { h: -160 });
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.tertiaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.background = "white";
    this.mainBkg = "#ECECFF";
    this.secondBkg = "#ffffde";
    this.lineColor = "#333333";
    this.border1 = "#9370DB";
    this.border2 = "#aaaa33";
    this.arrowheadColor = "#333333";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.labelBackground = "#e8e8e8";
    this.textColor = "#333";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "calculated";
    this.edgeLabelBackground = "calculated";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "black";
    this.actorLineColor = "grey";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "calculated";
    this.altSectionBkgColor = "calculated";
    this.sectionBkgColor2 = "calculated";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "calculated";
    this.taskTextLightColor = "calculated";
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextDarkColor = "calculated";
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.taskTextClickableColor = "calculated";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "calculated";
    this.critBorderColor = "calculated";
    this.critBkgColor = "calculated";
    this.todayLineColor = "calculated";
    this.sectionBkgColor = rgba$1(102, 102, 255, 0.49);
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "#fff400";
    this.taskBorderColor = "#534fbc";
    this.taskBkgColor = "#8a90dd";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "black";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "#534fbc";
    this.activeTaskBkgColor = "#bfc7ff";
    this.gridColor = "lightgrey";
    this.doneTaskBkgColor = "lightgrey";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#ff8888";
    this.critBkgColor = "red";
    this.todayLineColor = "red";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
    this.updateColors();
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
    this["cScalePeer" + 1] = this["cScalePeer" + 1] || darken(this.secondaryColor, 45);
    this["cScalePeer" + 2] = this["cScalePeer" + 2] || darken(this.tertiaryColor, 40);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScale" + i] = darken(this["cScale" + i], 10);
      this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 25);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || adjust$1(this["cScale" + i], { h: 180 });
    }
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    if (this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || invert(this.labelTextColor);
      this.cScaleLabel3 = this.cScaleLabel3 || invert(this.labelTextColor);
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.labelTextColor;
      }
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.titleColor = this.textColor;
    this.edgeLabelBackground = this.labelBackground;
    this.actorBorder = lighten(this.border1, 23);
    this.actorBkg = this.mainBkg;
    this.labelBoxBkgColor = this.actorBkg;
    this.signalColor = this.textColor;
    this.signalTextColor = this.textColor;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.actorTextColor;
    this.loopTextColor = this.actorTextColor;
    this.noteBorderColor = this.border2;
    this.noteTextColor = this.actorTextColor;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f0f0f0";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.nodeBorder;
    this.specialStateColor = this.lineColor;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || adjust$1(this.tertiaryColor, { l: -40 });
    this.pie4 = this.pie4 || adjust$1(this.primaryColor, { l: -10 });
    this.pie5 = this.pie5 || adjust$1(this.secondaryColor, { l: -30 });
    this.pie6 = this.pie6 || adjust$1(this.tertiaryColor, { l: -20 });
    this.pie7 = this.pie7 || adjust$1(this.primaryColor, { h: 60, l: -20 });
    this.pie8 = this.pie8 || adjust$1(this.primaryColor, { h: -60, l: -40 });
    this.pie9 = this.pie9 || adjust$1(this.primaryColor, { h: 120, l: -40 });
    this.pie10 = this.pie10 || adjust$1(this.primaryColor, { h: 60, l: -40 });
    this.pie11 = this.pie11 || adjust$1(this.primaryColor, { h: -90, l: -40 });
    this.pie12 = this.pie12 || adjust$1(this.primaryColor, { h: 120, l: -30 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.labelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust$1(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust$1(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust$1(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust$1(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust$1(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten(this.git0, 25);
      this.git1 = lighten(this.git1, 25);
      this.git2 = lighten(this.git2, 25);
      this.git3 = lighten(this.git3, 25);
      this.git4 = lighten(this.git4, 25);
      this.git5 = lighten(this.git5, 25);
      this.git6 = lighten(this.git6, 25);
      this.git7 = lighten(this.git7, 25);
    } else {
      this.git0 = darken(this.git0, 25);
      this.git1 = darken(this.git1, 25);
      this.git2 = darken(this.git2, 25);
      this.git3 = darken(this.git3, 25);
      this.git4 = darken(this.git4, 25);
      this.git5 = darken(this.git5, 25);
      this.git6 = darken(this.git6, 25);
      this.git7 = darken(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || darken(invert(this.git0), 25);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.gitBranchLabel0 = this.gitBranchLabel0 || invert(this.labelTextColor);
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || invert(this.labelTextColor);
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$2 = (userOverrides) => {
  const theme2 = new Theme$2();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme$1 {
  constructor() {
    this.background = "#f4f4f4";
    this.primaryColor = "#cde498";
    this.secondaryColor = "#cdffb2";
    this.background = "white";
    this.mainBkg = "#cde498";
    this.secondBkg = "#cdffb2";
    this.lineColor = "green";
    this.border1 = "#13540c";
    this.border2 = "#6eaa49";
    this.arrowheadColor = "green";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.tertiaryColor = lighten("#cde498", 10);
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.primaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "#333";
    this.edgeLabelBackground = "#e8e8e8";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "black";
    this.actorLineColor = "grey";
    this.signalColor = "#333";
    this.signalTextColor = "#333";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "#326932";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "#6eaa49";
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "#6eaa49";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "#487e3a";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "black";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "lightgrey";
    this.doneTaskBkgColor = "lightgrey";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#ff8888";
    this.critBkgColor = "red";
    this.todayLineColor = "red";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust$1(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust$1(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust$1(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust$1(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust$1(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust$1(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust$1(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust$1(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust$1(this.primaryColor, { h: 330 });
    this["cScalePeer" + 1] = this["cScalePeer" + 1] || darken(this.secondaryColor, 45);
    this["cScalePeer" + 2] = this["cScalePeer" + 2] || darken(this.tertiaryColor, 40);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScale" + i] = darken(this["cScale" + i], 10);
      this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 25);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || adjust$1(this["cScale" + i], { h: 180 });
    }
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.actorBorder = darken(this.mainBkg, 20);
    this.actorBkg = this.mainBkg;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelTextColor = this.actorTextColor;
    this.loopTextColor = this.actorTextColor;
    this.noteBorderColor = this.border2;
    this.noteTextColor = this.actorTextColor;
    this.taskBorderColor = this.border1;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.activeTaskBorderColor = this.taskBorderColor;
    this.activeTaskBkgColor = this.mainBkg;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f0f0f0";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = this.lineColor;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || this.tertiaryColor;
    this.pie4 = this.pie4 || adjust$1(this.primaryColor, { l: -30 });
    this.pie5 = this.pie5 || adjust$1(this.secondaryColor, { l: -30 });
    this.pie6 = this.pie6 || adjust$1(this.tertiaryColor, { h: 40, l: -40 });
    this.pie7 = this.pie7 || adjust$1(this.primaryColor, { h: 60, l: -10 });
    this.pie8 = this.pie8 || adjust$1(this.primaryColor, { h: -60, l: -10 });
    this.pie9 = this.pie9 || adjust$1(this.primaryColor, { h: 120, l: 0 });
    this.pie10 = this.pie10 || adjust$1(this.primaryColor, { h: 60, l: -50 });
    this.pie11 = this.pie11 || adjust$1(this.primaryColor, { h: -60, l: -50 });
    this.pie12 = this.pie12 || adjust$1(this.primaryColor, { h: 120, l: -50 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust$1(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust$1(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust$1(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust$1(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust$1(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten(this.git0, 25);
      this.git1 = lighten(this.git1, 25);
      this.git2 = lighten(this.git2, 25);
      this.git3 = lighten(this.git3, 25);
      this.git4 = lighten(this.git4, 25);
      this.git5 = lighten(this.git5, 25);
      this.git6 = lighten(this.git6, 25);
      this.git7 = lighten(this.git7, 25);
    } else {
      this.git0 = darken(this.git0, 25);
      this.git1 = darken(this.git1, 25);
      this.git2 = darken(this.git2, 25);
      this.git3 = darken(this.git3, 25);
      this.git4 = darken(this.git4, 25);
      this.git5 = darken(this.git5, 25);
      this.git6 = darken(this.git6, 25);
      this.git7 = darken(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables$1 = (userOverrides) => {
  const theme2 = new Theme$1();
  theme2.calculate(userOverrides);
  return theme2;
};
class Theme {
  constructor() {
    this.primaryColor = "#eee";
    this.contrast = "#707070";
    this.secondaryColor = lighten(this.contrast, 55);
    this.background = "#ffffff";
    this.tertiaryColor = adjust$1(this.primaryColor, { h: -160 });
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.tertiaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.mainBkg = "#eee";
    this.secondBkg = "calculated";
    this.lineColor = "#666";
    this.border1 = "#999";
    this.border2 = "calculated";
    this.note = "#ffa";
    this.text = "#333";
    this.critical = "#d42";
    this.done = "#bbb";
    this.arrowheadColor = "#333333";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "calculated";
    this.edgeLabelBackground = "white";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "calculated";
    this.actorLineColor = "calculated";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "calculated";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "calculated";
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "calculated";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "calculated";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "calculated";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "calculated";
    this.critBkgColor = "calculated";
    this.critBorderColor = "calculated";
    this.todayLineColor = "calculated";
    this.personBorder = "calculated";
    this.personBkg = "calculated";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
  }
  updateColors() {
    this.secondBkg = lighten(this.contrast, 55);
    this.border2 = this.contrast;
    this.cScale0 = this.cScale0 || "#555";
    this.cScale1 = this.cScale1 || "#F4F4F4";
    this.cScale2 = this.cScale2 || "#555";
    this.cScale3 = this.cScale3 || "#BBB";
    this.cScale4 = this.cScale4 || "#777";
    this.cScale5 = this.cScale5 || "#999";
    this.cScale6 = this.cScale6 || "#DDD";
    this.cScale7 = this.cScale7 || "#FFF";
    this.cScale8 = this.cScale8 || "#DDD";
    this.cScale9 = this.cScale9 || "#BBB";
    this.cScale10 = this.cScale10 || "#999";
    this.cScale11 = this.cScale11 || "#777";
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      if (this.darkMode) {
        this["cScalePeer" + i] = this["cScalePeer" + i] || lighten(this["cScale" + i], 10);
      } else {
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 10);
      }
    }
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    this["cScaleLabel0"] = this["cScaleLabel0"] || this.cScale1;
    this["cScaleLabel2"] = this["cScaleLabel2"] || this.cScale1;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.titleColor = this.text;
    this.actorBorder = lighten(this.border1, 23);
    this.actorBkg = this.mainBkg;
    this.actorTextColor = this.text;
    this.actorLineColor = this.lineColor;
    this.signalColor = this.text;
    this.signalTextColor = this.text;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.text;
    this.loopTextColor = this.text;
    this.noteBorderColor = "#999";
    this.noteBkgColor = "#666";
    this.noteTextColor = "#fff";
    this.sectionBkgColor = lighten(this.contrast, 30);
    this.sectionBkgColor2 = lighten(this.contrast, 30);
    this.taskBorderColor = darken(this.contrast, 10);
    this.taskBkgColor = this.contrast;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextDarkColor = this.text;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.activeTaskBorderColor = this.taskBorderColor;
    this.activeTaskBkgColor = this.mainBkg;
    this.gridColor = lighten(this.border1, 30);
    this.doneTaskBkgColor = this.done;
    this.doneTaskBorderColor = this.lineColor;
    this.critBkgColor = this.critical;
    this.critBorderColor = darken(this.critBkgColor, 10);
    this.todayLineColor = this.critBkgColor;
    this.transitionColor = this.transitionColor || "#000";
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f4f4f4";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.stateBorder = this.stateBorder || "#000";
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = "#222";
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust$1(this.primaryColor, { h: 64 });
    this.fillType3 = adjust$1(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust$1(this.primaryColor, { h: -64 });
    this.fillType5 = adjust$1(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust$1(this.primaryColor, { h: 128 });
    this.fillType7 = adjust$1(this.secondaryColor, { h: 128 });
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["pie" + i] = this["cScale" + i];
    }
    this.pie12 = this.pie0;
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || this.primaryBorderColor;
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = darken(this.pie1, 25) || this.primaryColor;
    this.git1 = this.pie2 || this.secondaryColor;
    this.git2 = this.pie3 || this.tertiaryColor;
    this.git3 = this.pie4 || adjust$1(this.primaryColor, { h: -30 });
    this.git4 = this.pie5 || adjust$1(this.primaryColor, { h: -60 });
    this.git5 = this.pie6 || adjust$1(this.primaryColor, { h: -90 });
    this.git6 = this.pie7 || adjust$1(this.primaryColor, { h: 60 });
    this.git7 = this.pie8 || adjust$1(this.primaryColor, { h: 120 });
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.branchLabelColor = this.branchLabelColor || this.labelTextColor;
    this.gitBranchLabel0 = this.branchLabelColor;
    this.gitBranchLabel1 = "white";
    this.gitBranchLabel2 = this.branchLabelColor;
    this.gitBranchLabel3 = "white";
    this.gitBranchLabel4 = this.branchLabelColor;
    this.gitBranchLabel5 = this.branchLabelColor;
    this.gitBranchLabel6 = this.branchLabelColor;
    this.gitBranchLabel7 = this.branchLabelColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys2 = Object.keys(overrides);
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
    this.updateColors();
    keys2.forEach((k2) => {
      this[k2] = overrides[k2];
    });
  }
}
const getThemeVariables = (userOverrides) => {
  const theme2 = new Theme();
  theme2.calculate(userOverrides);
  return theme2;
};
const theme = {
  base: {
    getThemeVariables: getThemeVariables$4
  },
  dark: {
    getThemeVariables: getThemeVariables$3
  },
  default: {
    getThemeVariables: getThemeVariables$2
  },
  forest: {
    getThemeVariables: getThemeVariables$1
  },
  neutral: {
    getThemeVariables
  }
};
const config$1 = {
  theme: "default",
  themeVariables: theme["default"].getThemeVariables(),
  themeCSS: void 0,
  maxTextSize: 5e4,
  darkMode: false,
  fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
  logLevel: 5,
  securityLevel: "strict",
  startOnLoad: true,
  arrowMarkerAbsolute: false,
  secure: ["secure", "securityLevel", "startOnLoad", "maxTextSize"],
  deterministicIds: false,
  deterministicIDSeed: void 0,
  flowchart: {
    diagramPadding: 8,
    htmlLabels: true,
    nodeSpacing: 50,
    rankSpacing: 50,
    curve: "basis",
    padding: 15,
    useMaxWidth: true,
    defaultRenderer: "dagre-wrapper"
  },
  sequence: {
    hideUnusedParticipants: false,
    activationWidth: 10,
    diagramMarginX: 50,
    diagramMarginY: 10,
    actorMargin: 50,
    width: 150,
    height: 65,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    mirrorActors: true,
    forceMenus: false,
    bottomMarginAdj: 1,
    useMaxWidth: true,
    rightAngles: false,
    showSequenceNumbers: false,
    actorFontSize: 14,
    actorFontFamily: '"Open Sans", sans-serif',
    actorFontWeight: 400,
    noteFontSize: 14,
    noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    noteFontWeight: 400,
    noteAlign: "center",
    messageFontSize: 16,
    messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
    messageFontWeight: 400,
    wrap: false,
    wrapPadding: 10,
    labelBoxWidth: 50,
    labelBoxHeight: 20,
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    noteFont: function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    },
    actorFont: function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }
  },
  gantt: {
    titleTopMargin: 25,
    barHeight: 20,
    barGap: 4,
    topPadding: 50,
    rightPadding: 75,
    leftPadding: 75,
    gridLineStartPadding: 35,
    fontSize: 11,
    sectionFontSize: 11,
    numberSectionStyles: 4,
    axisFormat: "%Y-%m-%d",
    useMaxWidth: true,
    topAxis: false,
    useWidth: void 0
  },
  journey: {
    diagramMarginX: 50,
    diagramMarginY: 10,
    leftMargin: 150,
    width: 150,
    height: 50,
    boxMargin: 10,
    boxTextMargin: 5,
    noteMargin: 10,
    messageMargin: 35,
    messageAlign: "center",
    bottomMarginAdj: 1,
    useMaxWidth: true,
    rightAngles: false,
    taskFontSize: 14,
    taskFontFamily: '"Open Sans", sans-serif',
    taskMargin: 50,
    activationWidth: 10,
    textPlacement: "fo",
    actorColours: ["#8FBC8F", "#7CFC00", "#00FFFF", "#20B2AA", "#B0E0E6", "#FFFFE0"],
    sectionFills: ["#191970", "#8B008B", "#4B0082", "#2F4F4F", "#800000", "#8B4513", "#00008B"],
    sectionColours: ["#fff"]
  },
  class: {
    arrowMarkerAbsolute: false,
    dividerMargin: 10,
    padding: 5,
    textHeight: 10,
    useMaxWidth: true,
    defaultRenderer: "dagre-wrapper"
  },
  state: {
    dividerMargin: 10,
    sizeUnit: 5,
    padding: 8,
    textHeight: 10,
    titleShift: -15,
    noteMargin: 10,
    forkWidth: 70,
    forkHeight: 7,
    miniPadding: 2,
    fontSizeFactor: 5.02,
    fontSize: 24,
    labelHeight: 16,
    edgeLengthFactor: "20",
    compositTitleSize: 35,
    radius: 5,
    useMaxWidth: true,
    defaultRenderer: "dagre-wrapper"
  },
  er: {
    diagramPadding: 20,
    layoutDirection: "TB",
    minEntityWidth: 100,
    minEntityHeight: 75,
    entityPadding: 15,
    stroke: "gray",
    fill: "honeydew",
    fontSize: 12,
    useMaxWidth: true
  },
  pie: {
    useWidth: void 0,
    useMaxWidth: true
  },
  requirement: {
    useWidth: void 0,
    useMaxWidth: true,
    rect_fill: "#f9f9f9",
    text_color: "#333",
    rect_border_size: "0.5px",
    rect_border_color: "#bbb",
    rect_min_width: 200,
    rect_min_height: 200,
    fontSize: 14,
    rect_padding: 10,
    line_height: 20
  },
  gitGraph: {
    diagramPadding: 8,
    nodeLabel: {
      width: 75,
      height: 100,
      x: -25,
      y: 0
    },
    mainBranchName: "main",
    mainBranchOrder: 0,
    showCommitLabel: true,
    showBranches: true,
    rotateCommitLabel: true
  },
  c4: {
    useWidth: void 0,
    diagramMarginX: 50,
    diagramMarginY: 10,
    c4ShapeMargin: 50,
    c4ShapePadding: 20,
    width: 216,
    height: 60,
    boxMargin: 10,
    useMaxWidth: true,
    c4ShapeInRow: 4,
    nextLinePaddingX: 0,
    c4BoundaryInRow: 2,
    personFontSize: 14,
    personFontFamily: '"Open Sans", sans-serif',
    personFontWeight: "normal",
    external_personFontSize: 14,
    external_personFontFamily: '"Open Sans", sans-serif',
    external_personFontWeight: "normal",
    systemFontSize: 14,
    systemFontFamily: '"Open Sans", sans-serif',
    systemFontWeight: "normal",
    external_systemFontSize: 14,
    external_systemFontFamily: '"Open Sans", sans-serif',
    external_systemFontWeight: "normal",
    system_dbFontSize: 14,
    system_dbFontFamily: '"Open Sans", sans-serif',
    system_dbFontWeight: "normal",
    external_system_dbFontSize: 14,
    external_system_dbFontFamily: '"Open Sans", sans-serif',
    external_system_dbFontWeight: "normal",
    system_queueFontSize: 14,
    system_queueFontFamily: '"Open Sans", sans-serif',
    system_queueFontWeight: "normal",
    external_system_queueFontSize: 14,
    external_system_queueFontFamily: '"Open Sans", sans-serif',
    external_system_queueFontWeight: "normal",
    boundaryFontSize: 14,
    boundaryFontFamily: '"Open Sans", sans-serif',
    boundaryFontWeight: "normal",
    messageFontSize: 12,
    messageFontFamily: '"Open Sans", sans-serif',
    messageFontWeight: "normal",
    containerFontSize: 14,
    containerFontFamily: '"Open Sans", sans-serif',
    containerFontWeight: "normal",
    external_containerFontSize: 14,
    external_containerFontFamily: '"Open Sans", sans-serif',
    external_containerFontWeight: "normal",
    container_dbFontSize: 14,
    container_dbFontFamily: '"Open Sans", sans-serif',
    container_dbFontWeight: "normal",
    external_container_dbFontSize: 14,
    external_container_dbFontFamily: '"Open Sans", sans-serif',
    external_container_dbFontWeight: "normal",
    container_queueFontSize: 14,
    container_queueFontFamily: '"Open Sans", sans-serif',
    container_queueFontWeight: "normal",
    external_container_queueFontSize: 14,
    external_container_queueFontFamily: '"Open Sans", sans-serif',
    external_container_queueFontWeight: "normal",
    componentFontSize: 14,
    componentFontFamily: '"Open Sans", sans-serif',
    componentFontWeight: "normal",
    external_componentFontSize: 14,
    external_componentFontFamily: '"Open Sans", sans-serif',
    external_componentFontWeight: "normal",
    component_dbFontSize: 14,
    component_dbFontFamily: '"Open Sans", sans-serif',
    component_dbFontWeight: "normal",
    external_component_dbFontSize: 14,
    external_component_dbFontFamily: '"Open Sans", sans-serif',
    external_component_dbFontWeight: "normal",
    component_queueFontSize: 14,
    component_queueFontFamily: '"Open Sans", sans-serif',
    component_queueFontWeight: "normal",
    external_component_queueFontSize: 14,
    external_component_queueFontFamily: '"Open Sans", sans-serif',
    external_component_queueFontWeight: "normal",
    wrap: true,
    wrapPadding: 10,
    personFont: function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    },
    external_personFont: function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    },
    systemFont: function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    },
    external_systemFont: function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    },
    system_dbFont: function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    },
    external_system_dbFont: function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    },
    system_queueFont: function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    },
    external_system_queueFont: function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    },
    containerFont: function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    },
    external_containerFont: function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    },
    container_dbFont: function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    },
    external_container_dbFont: function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    },
    container_queueFont: function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    },
    external_container_queueFont: function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    },
    componentFont: function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    },
    external_componentFont: function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    },
    component_dbFont: function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    },
    external_component_dbFont: function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    },
    component_queueFont: function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    },
    external_component_queueFont: function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    },
    boundaryFont: function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    },
    messageFont: function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    },
    person_bg_color: "#08427B",
    person_border_color: "#073B6F",
    external_person_bg_color: "#686868",
    external_person_border_color: "#8A8A8A",
    system_bg_color: "#1168BD",
    system_border_color: "#3C7FC0",
    system_db_bg_color: "#1168BD",
    system_db_border_color: "#3C7FC0",
    system_queue_bg_color: "#1168BD",
    system_queue_border_color: "#3C7FC0",
    external_system_bg_color: "#999999",
    external_system_border_color: "#8A8A8A",
    external_system_db_bg_color: "#999999",
    external_system_db_border_color: "#8A8A8A",
    external_system_queue_bg_color: "#999999",
    external_system_queue_border_color: "#8A8A8A",
    container_bg_color: "#438DD5",
    container_border_color: "#3C7FC0",
    container_db_bg_color: "#438DD5",
    container_db_border_color: "#3C7FC0",
    container_queue_bg_color: "#438DD5",
    container_queue_border_color: "#3C7FC0",
    external_container_bg_color: "#B3B3B3",
    external_container_border_color: "#A6A6A6",
    external_container_db_bg_color: "#B3B3B3",
    external_container_db_border_color: "#A6A6A6",
    external_container_queue_bg_color: "#B3B3B3",
    external_container_queue_border_color: "#A6A6A6",
    component_bg_color: "#85BBF0",
    component_border_color: "#78A8D8",
    component_db_bg_color: "#85BBF0",
    component_db_border_color: "#78A8D8",
    component_queue_bg_color: "#85BBF0",
    component_queue_border_color: "#78A8D8",
    external_component_bg_color: "#CCCCCC",
    external_component_border_color: "#BFBFBF",
    external_component_db_bg_color: "#CCCCCC",
    external_component_db_border_color: "#BFBFBF",
    external_component_queue_bg_color: "#CCCCCC",
    external_component_queue_border_color: "#BFBFBF"
  },
  mindmap: {
    useMaxWidth: true,
    padding: 10,
    maxNodeWidth: 200
  },
  fontSize: 16
};
if (config$1.class)
  config$1.class.arrowMarkerAbsolute = config$1.arrowMarkerAbsolute;
if (config$1.gitGraph)
  config$1.gitGraph.arrowMarkerAbsolute = config$1.arrowMarkerAbsolute;
const keyify = (obj, prefix2 = "") => Object.keys(obj).reduce((res, el) => {
  if (Array.isArray(obj[el])) {
    return res;
  } else if (typeof obj[el] === "object" && obj[el] !== null) {
    return [...res, prefix2 + el, ...keyify(obj[el], "")];
  }
  return [...res, prefix2 + el];
}, []);
const configKeys = keyify(config$1, "");
const directive$1 = /[%]{2}[{]\s*(?:(?:(\w+)\s*:|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
const anyComment = /\s*%%.*\n/gm;
const detectors = {};
const detectType = function(text2, config2) {
  text2 = text2.replace(directive$1, "").replace(anyComment, "\n");
  for (const [key, { detector }] of Object.entries(detectors)) {
    const diagram = detector(text2, config2);
    if (diagram) {
      return key;
    }
  }
  throw new Error(`No diagram type detected for text: ${text2}`);
};
const addDetector = (key, detector, loader) => {
  if (detectors[key]) {
    throw new Error(`Detector with key ${key} already exists`);
  }
  detectors[key] = { detector, loader };
  log$1.debug(`Detector with key ${key} added${loader ? " with loader" : ""}`);
};
const getDiagramLoader = (key) => detectors[key].loader;
const assignWithDepth = function(dst, src, config2) {
  const { depth, clobber } = Object.assign({ depth: 2, clobber: false }, config2);
  if (Array.isArray(src) && !Array.isArray(dst)) {
    src.forEach((s2) => assignWithDepth(dst, s2, config2));
    return dst;
  } else if (Array.isArray(src) && Array.isArray(dst)) {
    src.forEach((s2) => {
      if (dst.indexOf(s2) === -1) {
        dst.push(s2);
      }
    });
    return dst;
  }
  if (typeof dst === "undefined" || depth <= 0) {
    if (dst !== void 0 && dst !== null && typeof dst === "object" && typeof src === "object") {
      return Object.assign(dst, src);
    } else {
      return src;
    }
  }
  if (typeof src !== "undefined" && typeof dst === "object" && typeof src === "object") {
    Object.keys(src).forEach((key) => {
      if (typeof src[key] === "object" && (dst[key] === void 0 || typeof dst[key] === "object")) {
        if (dst[key] === void 0) {
          dst[key] = Array.isArray(src[key]) ? [] : {};
        }
        dst[key] = assignWithDepth(dst[key], src[key], { depth: depth - 1, clobber });
      } else if (clobber || typeof dst[key] !== "object" && typeof src[key] !== "object") {
        dst[key] = src[key];
      }
    });
  }
  return dst;
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var _freeGlobal;
var hasRequired_freeGlobal;
function require_freeGlobal() {
  if (hasRequired_freeGlobal)
    return _freeGlobal;
  hasRequired_freeGlobal = 1;
  var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  _freeGlobal = freeGlobal;
  return _freeGlobal;
}
var _root;
var hasRequired_root;
function require_root() {
  if (hasRequired_root)
    return _root;
  hasRequired_root = 1;
  var freeGlobal = require_freeGlobal();
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root2 = freeGlobal || freeSelf || Function("return this")();
  _root = root2;
  return _root;
}
var _Symbol;
var hasRequired_Symbol;
function require_Symbol() {
  if (hasRequired_Symbol)
    return _Symbol;
  hasRequired_Symbol = 1;
  var root2 = require_root();
  var Symbol2 = root2.Symbol;
  _Symbol = Symbol2;
  return _Symbol;
}
var _getRawTag;
var hasRequired_getRawTag;
function require_getRawTag() {
  if (hasRequired_getRawTag)
    return _getRawTag;
  hasRequired_getRawTag = 1;
  var Symbol2 = require_Symbol();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var nativeObjectToString = objectProto2.toString;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function getRawTag(value) {
    var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  _getRawTag = getRawTag;
  return _getRawTag;
}
var _objectToString;
var hasRequired_objectToString;
function require_objectToString() {
  if (hasRequired_objectToString)
    return _objectToString;
  hasRequired_objectToString = 1;
  var objectProto2 = Object.prototype;
  var nativeObjectToString = objectProto2.toString;
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  _objectToString = objectToString;
  return _objectToString;
}
var _baseGetTag;
var hasRequired_baseGetTag;
function require_baseGetTag() {
  if (hasRequired_baseGetTag)
    return _baseGetTag;
  hasRequired_baseGetTag = 1;
  var Symbol2 = require_Symbol(), getRawTag = require_getRawTag(), objectToString = require_objectToString();
  var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  _baseGetTag = baseGetTag;
  return _baseGetTag;
}
var isObject_1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject)
    return isObject_1;
  hasRequiredIsObject = 1;
  function isObject(value) {
    var type2 = typeof value;
    return value != null && (type2 == "object" || type2 == "function");
  }
  isObject_1 = isObject;
  return isObject_1;
}
var isFunction_1;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction)
    return isFunction_1;
  hasRequiredIsFunction = 1;
  var baseGetTag = require_baseGetTag(), isObject = requireIsObject();
  var asyncTag = "[object AsyncFunction]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  isFunction_1 = isFunction;
  return isFunction_1;
}
var _coreJsData;
var hasRequired_coreJsData;
function require_coreJsData() {
  if (hasRequired_coreJsData)
    return _coreJsData;
  hasRequired_coreJsData = 1;
  var root2 = require_root();
  var coreJsData = root2["__core-js_shared__"];
  _coreJsData = coreJsData;
  return _coreJsData;
}
var _isMasked;
var hasRequired_isMasked;
function require_isMasked() {
  if (hasRequired_isMasked)
    return _isMasked;
  hasRequired_isMasked = 1;
  var coreJsData = require_coreJsData();
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  _isMasked = isMasked;
  return _isMasked;
}
var _toSource;
var hasRequired_toSource;
function require_toSource() {
  if (hasRequired_toSource)
    return _toSource;
  hasRequired_toSource = 1;
  var funcProto = Function.prototype;
  var funcToString = funcProto.toString;
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  _toSource = toSource;
  return _toSource;
}
var _baseIsNative;
var hasRequired_baseIsNative;
function require_baseIsNative() {
  if (hasRequired_baseIsNative)
    return _baseIsNative;
  hasRequired_baseIsNative = 1;
  var isFunction = requireIsFunction(), isMasked = require_isMasked(), isObject = requireIsObject(), toSource = require_toSource();
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var funcProto = Function.prototype, objectProto2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var reIsNative = RegExp(
    "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  );
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  _baseIsNative = baseIsNative;
  return _baseIsNative;
}
var _getValue;
var hasRequired_getValue;
function require_getValue() {
  if (hasRequired_getValue)
    return _getValue;
  hasRequired_getValue = 1;
  function getValue(object2, key) {
    return object2 == null ? void 0 : object2[key];
  }
  _getValue = getValue;
  return _getValue;
}
var _getNative;
var hasRequired_getNative;
function require_getNative() {
  if (hasRequired_getNative)
    return _getNative;
  hasRequired_getNative = 1;
  var baseIsNative = require_baseIsNative(), getValue = require_getValue();
  function getNative2(object2, key) {
    var value = getValue(object2, key);
    return baseIsNative(value) ? value : void 0;
  }
  _getNative = getNative2;
  return _getNative;
}
var getNative$1 = require_getNative();
var nativeCreate$4 = getNative$1(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? void 0 : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
var eq_1;
var hasRequiredEq;
function requireEq() {
  if (hasRequiredEq)
    return eq_1;
  hasRequiredEq = 1;
  function eq2(value, other) {
    return value === other || value !== value && other !== other;
  }
  eq_1 = eq2;
  return eq_1;
}
var eq = requireEq();
function assocIndexOf$4(array2, key) {
  var length2 = array2.length;
  while (length2--) {
    if (eq(array2[length2][0], key)) {
      return length2;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index2 = assocIndexOf$3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index2 = assocIndexOf$2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index2 = assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$1(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache$1.prototype.clear = listCacheClear;
ListCache$1.prototype["delete"] = listCacheDelete;
ListCache$1.prototype.get = listCacheGet;
ListCache$1.prototype.has = listCacheHas;
ListCache$1.prototype.set = listCacheSet;
var _ListCache = ListCache$1;
var getNative = require_getNative(), root = require_root();
var Map$2 = getNative(root, "Map");
var _Map = Map$2;
var Hash = _Hash, ListCache = _ListCache, Map$1 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$1 || ListCache)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type2 = typeof value;
  return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$1(entries2) {
  var index2 = -1, length2 = entries2 == null ? 0 : entries2.length;
  this.clear();
  while (++index2 < length2) {
    var entry = entries2[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache$1.prototype.clear = mapCacheClear;
MapCache$1.prototype["delete"] = mapCacheDelete;
MapCache$1.prototype.get = mapCacheGet;
MapCache$1.prototype.has = mapCacheHas;
MapCache$1.prototype.set = mapCacheSet;
var _MapCache = MapCache$1;
var MapCache = _MapCache;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache)();
  return memoized;
}
memoize.Cache = MapCache;
var memoize_1 = memoize;
const d3CurveTypes = {
  curveBasis,
  curveBasisClosed,
  curveBasisOpen,
  curveLinear: curveLinear$1,
  curveLinearClosed,
  curveMonotoneX: monotoneX$1,
  curveMonotoneY: monotoneY$1,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter$1,
  curveStepBefore: stepBefore$1
};
const directive = /[%]{2}[{]\s*(?:(?:(\w+)\s*:|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
const directiveWithoutOpen = /\s*(?:(?:(\w+)(?=:):|(\w+))\s*(?:(?:(\w+))|((?:(?![}][%]{2}).|\r?\n)*))?\s*)(?:[}][%]{2})?/gi;
const detectInit = function(text2, config2) {
  const inits = detectDirective(text2, /(?:init\b)|(?:initialize\b)/);
  let results = {};
  if (Array.isArray(inits)) {
    const args = inits.map((init2) => init2.args);
    directiveSanitizer(args);
    results = assignWithDepth(results, [...args]);
  } else {
    results = inits.args;
  }
  if (results) {
    let type2 = detectType(text2, config2);
    ["config"].forEach((prop) => {
      if (typeof results[prop] !== "undefined") {
        if (type2 === "flowchart-v2") {
          type2 = "flowchart";
        }
        results[type2] = results[prop];
        delete results[prop];
      }
    });
  }
  return results;
};
const detectDirective = function(text2, type2 = null) {
  try {
    const commentWithoutDirectives = new RegExp(
      `[%]{2}(?![{]${directiveWithoutOpen.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    text2 = text2.trim().replace(commentWithoutDirectives, "").replace(/'/gm, '"');
    log$1.debug(
      `Detecting diagram directive${type2 !== null ? " type:" + type2 : ""} based on the text:${text2}`
    );
    let match;
    const result = [];
    while ((match = directive.exec(text2)) !== null) {
      if (match.index === directive.lastIndex) {
        directive.lastIndex++;
      }
      if (match && !type2 || type2 && match[1] && match[1].match(type2) || type2 && match[2] && match[2].match(type2)) {
        const type22 = match[1] ? match[1] : match[2];
        const args = match[3] ? match[3].trim() : match[4] ? JSON.parse(match[4].trim()) : null;
        result.push({ type: type22, args });
      }
    }
    if (result.length === 0) {
      result.push({ type: text2, args: null });
    }
    return result.length === 1 ? result[0] : result;
  } catch (error) {
    log$1.error(
      `ERROR: ${error.message} - Unable to parse directive
      ${type2 !== null ? " type:" + type2 : ""} based on the text:${text2}`
    );
    return { type: null, args: null };
  }
};
const isSubstringInArray = function(str, arr) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i].match(str))
      return i;
  }
  return -1;
};
const interpolateToCurve = (interpolate2, defaultCurve) => {
  if (!interpolate2) {
    return defaultCurve;
  }
  const curveName = `curve${interpolate2.charAt(0).toUpperCase() + interpolate2.slice(1)}`;
  return d3CurveTypes[curveName] || defaultCurve;
};
const formatUrl = (linkStr, config2) => {
  const url = linkStr.trim();
  if (url) {
    if (config2.securityLevel !== "loose") {
      return sanitizeUrl_1(url);
    }
    return url;
  }
};
const runFunc = (functionName, ...params) => {
  const arrPaths = functionName.split(".");
  const len = arrPaths.length - 1;
  const fnName = arrPaths[len];
  let obj = window;
  for (let i = 0; i < len; i++) {
    obj = obj[arrPaths[i]];
    if (!obj)
      return;
  }
  obj[fnName](...params);
};
const distance = (p1, p2) => p1 && p2 ? Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2)) : 0;
const traverseEdge = (points) => {
  let prevPoint;
  let totalDistance2 = 0;
  points.forEach((point2) => {
    totalDistance2 += distance(point2, prevPoint);
    prevPoint = point2;
  });
  let remainingDistance = totalDistance2 / 2;
  let center2 = void 0;
  prevPoint = void 0;
  points.forEach((point2) => {
    if (prevPoint && !center2) {
      const vectorDistance = distance(point2, prevPoint);
      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        const distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0)
          center2 = prevPoint;
        if (distanceRatio >= 1)
          center2 = { x: point2.x, y: point2.y };
        if (distanceRatio > 0 && distanceRatio < 1) {
          center2 = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
          };
        }
      }
    }
    prevPoint = point2;
  });
  return center2;
};
const calcLabelPosition = (points) => {
  if (points.length === 1) {
    return points[0];
  }
  return traverseEdge(points);
};
const calcCardinalityPosition = (isRelationTypePresent, points, initialPosition) => {
  let prevPoint;
  log$1.info("our points", points);
  if (points[0] !== initialPosition) {
    points = points.reverse();
  }
  points.forEach((point2) => {
    totalDistance += distance(point2, prevPoint);
    prevPoint = point2;
  });
  const distanceToCardinalityPoint = 25;
  let remainingDistance = distanceToCardinalityPoint;
  let center2;
  prevPoint = void 0;
  points.forEach((point2) => {
    if (prevPoint && !center2) {
      const vectorDistance = distance(point2, prevPoint);
      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        const distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0)
          center2 = prevPoint;
        if (distanceRatio >= 1)
          center2 = { x: point2.x, y: point2.y };
        if (distanceRatio > 0 && distanceRatio < 1) {
          center2 = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
          };
        }
      }
    }
    prevPoint = point2;
  });
  const d = isRelationTypePresent ? 10 : 5;
  const angle2 = Math.atan2(points[0].y - center2.y, points[0].x - center2.x);
  const cardinalityPosition = { x: 0, y: 0 };
  cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2;
  cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2;
  return cardinalityPosition;
};
const calcTerminalLabelPosition = (terminalMarkerSize, position2, _points) => {
  let points = JSON.parse(JSON.stringify(_points));
  let prevPoint;
  log$1.info("our points", points);
  if (position2 !== "start_left" && position2 !== "start_right") {
    points = points.reverse();
  }
  points.forEach((point2) => {
    prevPoint = point2;
  });
  const distanceToCardinalityPoint = 25 + terminalMarkerSize;
  let remainingDistance = distanceToCardinalityPoint;
  let center2;
  prevPoint = void 0;
  points.forEach((point2) => {
    if (prevPoint && !center2) {
      const vectorDistance = distance(point2, prevPoint);
      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        const distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0)
          center2 = prevPoint;
        if (distanceRatio >= 1)
          center2 = { x: point2.x, y: point2.y };
        if (distanceRatio > 0 && distanceRatio < 1) {
          center2 = {
            x: (1 - distanceRatio) * prevPoint.x + distanceRatio * point2.x,
            y: (1 - distanceRatio) * prevPoint.y + distanceRatio * point2.y
          };
        }
      }
    }
    prevPoint = point2;
  });
  const d = 10 + terminalMarkerSize * 0.5;
  const angle2 = Math.atan2(points[0].y - center2.y, points[0].x - center2.x);
  const cardinalityPosition = { x: 0, y: 0 };
  cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2;
  cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2;
  if (position2 === "start_left") {
    cardinalityPosition.x = Math.sin(angle2 + Math.PI) * d + (points[0].x + center2.x) / 2;
    cardinalityPosition.y = -Math.cos(angle2 + Math.PI) * d + (points[0].y + center2.y) / 2;
  }
  if (position2 === "end_right") {
    cardinalityPosition.x = Math.sin(angle2 - Math.PI) * d + (points[0].x + center2.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle2 - Math.PI) * d + (points[0].y + center2.y) / 2 - 5;
  }
  if (position2 === "end_left") {
    cardinalityPosition.x = Math.sin(angle2) * d + (points[0].x + center2.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle2) * d + (points[0].y + center2.y) / 2 - 5;
  }
  return cardinalityPosition;
};
const getStylesFromArray = (arr) => {
  let style = "";
  let labelStyle = "";
  for (let i = 0; i < arr.length; i++) {
    if (typeof arr[i] !== "undefined") {
      if (arr[i].startsWith("color:") || arr[i].startsWith("text-align:")) {
        labelStyle = labelStyle + arr[i] + ";";
      } else {
        style = style + arr[i] + ";";
      }
    }
  }
  return { style, labelStyle };
};
let cnt$1 = 0;
const generateId$1 = () => {
  cnt$1++;
  return "id-" + Math.random().toString(36).substr(2, 12) + "-" + cnt$1;
};
function makeid(length2) {
  let result = "";
  const characters2 = "0123456789abcdef";
  const charactersLength = characters2.length;
  for (let i = 0; i < length2; i++) {
    result += characters2.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
const random = (options2) => {
  return makeid(options2.length);
};
const getTextObj$3 = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0
  };
};
const drawSimpleText = function(elem, textData) {
  const nText = textData.text.replace(common.lineBreakRegex, " ");
  const textElem = elem.append("text");
  textElem.attr("x", textData.x);
  textElem.attr("y", textData.y);
  textElem.style("text-anchor", textData.anchor);
  textElem.style("font-family", textData.fontFamily);
  textElem.style("font-size", textData.fontSize);
  textElem.style("font-weight", textData.fontWeight);
  textElem.attr("fill", textData.fill);
  if (typeof textData.class !== "undefined") {
    textElem.attr("class", textData.class);
  }
  const span = textElem.append("tspan");
  span.attr("x", textData.x + textData.textMargin * 2);
  span.attr("fill", textData.fill);
  span.text(nText);
  return textElem;
};
const wrapLabel = memoize_1(
  (label, maxWidth, config2) => {
    if (!label) {
      return label;
    }
    config2 = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      config2
    );
    if (common.lineBreakRegex.test(label)) {
      return label;
    }
    const words = label.split(" ");
    const completedLines = [];
    let nextLine = "";
    words.forEach((word, index2) => {
      const wordLength = calculateTextWidth(`${word} `, config2);
      const nextLineLength = calculateTextWidth(nextLine, config2);
      if (wordLength > maxWidth) {
        const { hyphenatedStrings, remainingWord } = breakString(word, maxWidth, "-", config2);
        completedLines.push(nextLine, ...hyphenatedStrings);
        nextLine = remainingWord;
      } else if (nextLineLength + wordLength >= maxWidth) {
        completedLines.push(nextLine);
        nextLine = word;
      } else {
        nextLine = [nextLine, word].filter(Boolean).join(" ");
      }
      const currentWord = index2 + 1;
      const isLastWord = currentWord === words.length;
      if (isLastWord) {
        completedLines.push(nextLine);
      }
    });
    return completedLines.filter((line2) => line2 !== "").join(config2.joinWith);
  },
  (label, maxWidth, config2) => `${label}${maxWidth}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}${config2.joinWith}`
);
const breakString = memoize_1(
  (word, maxWidth, hyphenCharacter = "-", config2) => {
    config2 = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      config2
    );
    const characters2 = word.split("");
    const lines = [];
    let currentLine = "";
    characters2.forEach((character2, index2) => {
      const nextLine = `${currentLine}${character2}`;
      const lineWidth = calculateTextWidth(nextLine, config2);
      if (lineWidth >= maxWidth) {
        const currentCharacter = index2 + 1;
        const isLastLine = characters2.length === currentCharacter;
        const hyphenatedNextLine = `${nextLine}${hyphenCharacter}`;
        lines.push(isLastLine ? nextLine : hyphenatedNextLine);
        currentLine = "";
      } else {
        currentLine = nextLine;
      }
    });
    return { hyphenatedStrings: lines, remainingWord: currentLine };
  },
  (word, maxWidth, hyphenCharacter = "-", config2) => `${word}${maxWidth}${hyphenCharacter}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}`
);
const calculateTextHeight = function(text2, config2) {
  config2 = Object.assign(
    { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 15 },
    config2
  );
  return calculateTextDimensions(text2, config2).height;
};
const calculateTextWidth = function(text2, config2) {
  config2 = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, config2);
  return calculateTextDimensions(text2, config2).width;
};
const calculateTextDimensions = memoize_1(
  function(text2, config2) {
    config2 = Object.assign({ fontSize: 12, fontWeight: 400, fontFamily: "Arial" }, config2);
    const { fontSize, fontFamily, fontWeight } = config2;
    if (!text2) {
      return { width: 0, height: 0 };
    }
    const fontFamilies = ["sans-serif", fontFamily];
    const lines = text2.split(common.lineBreakRegex);
    const dims = [];
    const body = select$1("body");
    if (!body.remove) {
      return { width: 0, height: 0, lineHeight: 0 };
    }
    const g = body.append("svg");
    for (const fontFamily2 of fontFamilies) {
      let cheight = 0;
      const dim = { width: 0, height: 0, lineHeight: 0 };
      for (const line2 of lines) {
        const textObj = getTextObj$3();
        textObj.text = line2;
        const textElem = drawSimpleText(g, textObj).style("font-size", fontSize).style("font-weight", fontWeight).style("font-family", fontFamily2);
        const bBox = (textElem._groups || textElem)[0][0].getBBox();
        dim.width = Math.round(Math.max(dim.width, bBox.width));
        cheight = Math.round(bBox.height);
        dim.height += cheight;
        dim.lineHeight = Math.round(Math.max(dim.lineHeight, cheight));
      }
      dims.push(dim);
    }
    g.remove();
    const index2 = isNaN(dims[1].height) || isNaN(dims[1].width) || isNaN(dims[1].lineHeight) || dims[0].height > dims[1].height && dims[0].width > dims[1].width && dims[0].lineHeight > dims[1].lineHeight ? 0 : 1;
    return dims[index2];
  },
  (text2, config2) => `${text2}${config2.fontSize}${config2.fontWeight}${config2.fontFamily}`
);
const initIdGenerator = class iterator {
  constructor(deterministic, seed) {
    this.deterministic = deterministic;
    this.seed = seed;
    this.count = seed ? seed.length : 0;
  }
  next() {
    if (!this.deterministic)
      return Date.now();
    return this.count++;
  }
};
let decoder;
const entityDecode = function(html2) {
  decoder = decoder || document.createElement("div");
  html2 = escape(html2).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";");
  decoder.innerHTML = html2;
  return unescape(decoder.textContent);
};
const directiveSanitizer = (args) => {
  log$1.debug("directiveSanitizer called with", args);
  if (typeof args === "object") {
    if (args.length) {
      args.forEach((arg) => directiveSanitizer(arg));
    } else {
      Object.keys(args).forEach((key) => {
        log$1.debug("Checking key", key);
        if (key.indexOf("__") === 0) {
          log$1.debug("sanitize deleting __ option", key);
          delete args[key];
        }
        if (key.indexOf("proto") >= 0) {
          log$1.debug("sanitize deleting proto option", key);
          delete args[key];
        }
        if (key.indexOf("constr") >= 0) {
          log$1.debug("sanitize deleting constr option", key);
          delete args[key];
        }
        if (key.indexOf("themeCSS") >= 0) {
          log$1.debug("sanitizing themeCss option");
          args[key] = sanitizeCss(args[key]);
        }
        if (key.indexOf("fontFamily") >= 0) {
          log$1.debug("sanitizing fontFamily option");
          args[key] = sanitizeCss(args[key]);
        }
        if (key.indexOf("altFontFamily") >= 0) {
          log$1.debug("sanitizing altFontFamily option");
          args[key] = sanitizeCss(args[key]);
        }
        if (configKeys.indexOf(key) < 0) {
          log$1.debug("sanitize deleting option", key);
          delete args[key];
        } else {
          if (typeof args[key] === "object") {
            log$1.debug("sanitize deleting object", key);
            directiveSanitizer(args[key]);
          }
        }
      });
    }
  }
  if (args.themeVariables) {
    const kArr = Object.keys(args.themeVariables);
    for (let i = 0; i < kArr.length; i++) {
      const k2 = kArr[i];
      const val = args.themeVariables[k2];
      if (val && val.match && !val.match(/^[a-zA-Z0-9#,";()%. ]+$/)) {
        args.themeVariables[k2] = "";
      }
    }
  }
  log$1.debug("After sanitization", args);
};
const sanitizeCss = (str) => {
  let startCnt2 = 0;
  let endCnt = 0;
  for (let i = 0; i < str.length; i++) {
    if (startCnt2 < endCnt) {
      return "{ /* ERROR: Unbalanced CSS */ }";
    }
    if (str[i] === "{") {
      startCnt2++;
    } else if (str[i] === "}") {
      endCnt++;
    }
  }
  if (startCnt2 !== endCnt) {
    return "{ /* ERROR: Unbalanced CSS */ }";
  }
  return str;
};
function isDetailedError(error) {
  return "str" in error;
}
function getErrorMessage(error) {
  if (error instanceof Error)
    return error.message;
  return String(error);
}
const utils = {
  assignWithDepth,
  wrapLabel,
  calculateTextHeight,
  calculateTextWidth,
  calculateTextDimensions,
  detectInit,
  detectDirective,
  isSubstringInArray,
  interpolateToCurve,
  calcLabelPosition,
  calcCardinalityPosition,
  calcTerminalLabelPosition,
  formatUrl,
  getStylesFromArray,
  generateId: generateId$1,
  random,
  runFunc,
  entityDecode,
  initIdGenerator,
  directiveSanitizer,
  sanitizeCss
};
const name = "mermaid";
const version$1 = "9.2.2";
const description$1 = "Markdownish syntax for generating flowcharts, sequence diagrams, class diagrams, gantt charts and git graphs.";
const main = "./dist/mermaid.min.js";
const module = "./dist/mermaid.core.mjs";
const types = "./dist/mermaid.d.ts";
const type = "commonjs";
const exports = {
  ".": {
    require: "./dist/mermaid.min.js",
    "import": "./dist/mermaid.core.mjs",
    types: "./dist/mermaid.d.ts"
  },
  "./*": "./*"
};
const keywords = [
  "diagram",
  "markdown",
  "flowchart",
  "sequence diagram",
  "gantt",
  "class diagram",
  "git graph"
];
const scripts = {
  clean: "rimraf dist",
  "build:code": "node .esbuild/esbuild.cjs",
  "build:types": "tsc -p ./tsconfig.json --emitDeclarationOnly",
  "build:watch": "yarn build:code --watch",
  "build:esbuild": 'concurrently "yarn build:code" "yarn build:types"',
  build: "yarn clean; yarn build:esbuild",
  dev: "node .esbuild/serve.cjs",
  "docs:build": "ts-node-esm src/docs.mts",
  "docs:verify": "yarn docs:build --verify",
  "todo-postbuild": "documentation build src/mermaidAPI.ts src/config.ts src/defaultConfig.ts --shallow -f md --markdown-toc false > src/docs/Setup.md && prettier --write src/docs/Setup.md",
  release: "yarn build",
  lint: "eslint --cache --ignore-path .gitignore . && yarn lint:jison && prettier --check .",
  "lint:fix": "eslint --fix --ignore-path .gitignore . && prettier --write .",
  "lint:jison": "ts-node-esm src/jison/lint.mts",
  cypress: "cypress run",
  "cypress:open": "cypress open",
  e2e: "start-server-and-test dev http://localhost:9000/ cypress",
  "todo-prepare": 'concurrently "husky install" "yarn build"',
  "pre-commit": "lint-staged"
};
const repository = {
  type: "git",
  url: "https://github.com/mermaid-js/mermaid"
};
const author = "Knut Sveidqvist";
const license = "MIT";
const standard = {
  ignore: [
    "**/parser/*.js",
    "dist/**/*.js",
    "cypress/**/*.js"
  ],
  globals: [
    "page"
  ]
};
const dependencies = {
  "@braintree/sanitize-url": "^6.0.0",
  d3: "^7.0.0",
  dagre: "^0.8.5",
  "dagre-d3": "^0.6.4",
  dompurify: "2.4.0",
  "fast-clone": "^1.5.13",
  graphlib: "^2.1.8",
  khroma: "^2.0.0",
  lodash: "^4.17.21",
  "moment-mini": "^2.24.0",
  "non-layered-tidy-tree-layout": "^2.0.2",
  stylis: "^4.1.2",
  uuid: "^9.0.0"
};
const devDependencies = {
  "@applitools/eyes-cypress": "^3.25.7",
  "@commitlint/cli": "^17.1.2",
  "@commitlint/config-conventional": "^17.0.0",
  "@types/d3": "^7.4.0",
  "@types/dompurify": "^2.3.4",
  "@types/eslint": "^8.4.6",
  "@types/express": "^4.17.13",
  "@types/jsdom": "^20.0.0",
  "@types/lodash": "^4.14.185",
  "@types/prettier": "^2.7.0",
  "@types/stylis": "^4.0.2",
  "@types/uuid": "^8.3.4",
  "@typescript-eslint/eslint-plugin": "^5.37.0",
  "@typescript-eslint/parser": "^5.37.0",
  concurrently: "^7.4.0",
  coveralls: "^3.1.1",
  cypress: "^10.0.0",
  "cypress-image-snapshot": "^4.0.1",
  documentation: "13.2.0",
  esbuild: "^0.15.8",
  eslint: "^8.23.1",
  "eslint-config-prettier": "^8.5.0",
  "eslint-plugin-cypress": "^2.12.1",
  "eslint-plugin-html": "^7.1.0",
  "eslint-plugin-jest": "^27.0.4",
  "eslint-plugin-jsdoc": "^39.3.6",
  "eslint-plugin-json": "^3.1.0",
  "eslint-plugin-markdown": "^3.0.0",
  express: "^4.18.1",
  globby: "^13.1.2",
  husky: "^8.0.0",
  "identity-obj-proxy": "^3.0.0",
  jison: "^0.4.18",
  "js-base64": "3.7.2",
  jsdom: "^20.0.0",
  "lint-staged": "^13.0.0",
  moment: "^2.23.0",
  "path-browserify": "^1.0.1",
  prettier: "^2.7.1",
  "prettier-plugin-jsdoc": "^0.4.2",
  remark: "^14.0.2",
  rimraf: "^3.0.2",
  "start-server-and-test": "^1.12.6",
  "ts-node": "^10.9.1",
  typescript: "^4.8.3",
  "unist-util-flatmap": "^1.0.0"
};
const resolutions = {
  d3: "^7.0.0"
};
const files = [
  "dist",
  "README.md"
];
const sideEffects = [
  "**/*.css",
  "**/*.scss"
];
const pkg = {
  name,
  version: version$1,
  description: description$1,
  main,
  module,
  types,
  type,
  exports,
  keywords,
  scripts,
  repository,
  author,
  license,
  standard,
  dependencies,
  devDependencies,
  resolutions,
  files,
  sideEffects
};
const defaultConfig = Object.freeze(config$1);
let siteConfig = assignWithDepth({}, defaultConfig);
let configFromInitialize;
let directives = [];
let currentConfig = assignWithDepth({}, defaultConfig);
const updateCurrentConfig = (siteCfg, _directives) => {
  let cfg = assignWithDepth({}, siteCfg);
  let sumOfDirectives = {};
  for (let i = 0; i < _directives.length; i++) {
    const d = _directives[i];
    sanitize(d);
    sumOfDirectives = assignWithDepth(sumOfDirectives, d);
  }
  cfg = assignWithDepth(cfg, sumOfDirectives);
  if (sumOfDirectives.theme && sumOfDirectives.theme in theme) {
    const tmpConfigFromInitialize = assignWithDepth({}, configFromInitialize);
    const themeVariables = assignWithDepth(
      tmpConfigFromInitialize.themeVariables || {},
      sumOfDirectives.themeVariables
    );
    if (cfg.theme && cfg.theme in theme) {
      cfg.themeVariables = theme[cfg.theme].getThemeVariables(themeVariables);
    }
  }
  currentConfig = cfg;
  checkConfig(currentConfig);
  return currentConfig;
};
const setSiteConfig = (conf2) => {
  siteConfig = assignWithDepth({}, defaultConfig);
  siteConfig = assignWithDepth(siteConfig, conf2);
  if (conf2.theme && theme[conf2.theme]) {
    siteConfig.themeVariables = theme[conf2.theme].getThemeVariables(conf2.themeVariables);
  }
  updateCurrentConfig(siteConfig, directives);
  return siteConfig;
};
const saveConfigFromInitialize = (conf2) => {
  configFromInitialize = assignWithDepth({}, conf2);
};
const updateSiteConfig = (conf2) => {
  siteConfig = assignWithDepth(siteConfig, conf2);
  updateCurrentConfig(siteConfig, directives);
  return siteConfig;
};
const getSiteConfig = () => {
  return assignWithDepth({}, siteConfig);
};
const setConfig = (conf2) => {
  checkConfig(conf2);
  assignWithDepth(currentConfig, conf2);
  return getConfig$1();
};
const getConfig$1 = () => {
  return assignWithDepth({}, currentConfig);
};
const sanitize = (options2) => {
  var _a;
  ["secure", ...(_a = siteConfig.secure) != null ? _a : []].forEach((key) => {
    if (typeof options2[key] !== "undefined") {
      log$1.debug(`Denied attempt to modify a secure key ${key}`, options2[key]);
      delete options2[key];
    }
  });
  Object.keys(options2).forEach((key) => {
    if (key.indexOf("__") === 0) {
      delete options2[key];
    }
  });
  Object.keys(options2).forEach((key) => {
    if (typeof options2[key] === "string") {
      if (options2[key].indexOf("<") > -1 || options2[key].indexOf(">") > -1 || options2[key].indexOf("url(data:") > -1) {
        delete options2[key];
      }
    }
    if (typeof options2[key] === "object") {
      sanitize(options2[key]);
    }
  });
};
const addDirective = (directive2) => {
  if (directive2.fontFamily) {
    if (!directive2.themeVariables) {
      directive2.themeVariables = { fontFamily: directive2.fontFamily };
    } else {
      if (!directive2.themeVariables.fontFamily) {
        directive2.themeVariables = { fontFamily: directive2.fontFamily };
      }
    }
  }
  directives.push(directive2);
  updateCurrentConfig(siteConfig, directives);
};
const reset = (config2 = siteConfig) => {
  directives = [];
  updateCurrentConfig(config2, directives);
};
var ConfigWarning = /* @__PURE__ */ ((ConfigWarning2) => {
  ConfigWarning2["LAZY_LOAD_DEPRECATED"] = "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead.";
  return ConfigWarning2;
})(ConfigWarning || {});
const issuedWarnings = {};
const issueWarning = (warning) => {
  if (issuedWarnings[warning]) {
    return;
  }
  log$1.warn(ConfigWarning[warning]);
  issuedWarnings[warning] = true;
};
const checkConfig = (config2) => {
  if (!config2) {
    return;
  }
  if (config2.lazyLoadedDiagrams || config2.loadExternalDiagramsAtStartup) {
    issueWarning("LAZY_LOAD_DEPRECATED");
  }
};
const d3Attrs = function(d3Elem, attrs) {
  for (let attr of attrs) {
    d3Elem.attr(attr[0], attr[1]);
  }
};
const calculateSvgSizeAttrs = function(height2, width2, useMaxWidth) {
  let attrs = /* @__PURE__ */ new Map();
  if (useMaxWidth) {
    attrs.set("width", "100%");
    attrs.set("style", `max-width: ${width2}px;`);
  } else {
    attrs.set("width", width2);
  }
  return attrs;
};
const configureSvgSize = function(svgElem, height2, width2, useMaxWidth) {
  const attrs = calculateSvgSizeAttrs(height2, width2, useMaxWidth);
  d3Attrs(svgElem, attrs);
};
const setupGraphViewbox$1 = function(graph2, svgElem, padding2, useMaxWidth) {
  const svgBounds = svgElem.node().getBBox();
  const sWidth = svgBounds.width;
  const sHeight = svgBounds.height;
  log$1.info(`SVG bounds: ${sWidth}x${sHeight}`, svgBounds);
  let width2 = 0;
  let height2 = 0;
  log$1.info(`Graph bounds: ${width2}x${height2}`, graph2);
  width2 = sWidth + padding2 * 2;
  height2 = sHeight + padding2 * 2;
  log$1.info(`Calculated bounds: ${width2}x${height2}`);
  configureSvgSize(svgElem, height2, width2, useMaxWidth);
  const vBox = `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${svgBounds.width + 2 * padding2} ${svgBounds.height + 2 * padding2}`;
  svgElem.attr("viewBox", vBox);
};
const getStyles$d = (options2) => `g.classGroup text {
  fill: ${options2.nodeBorder};
  fill: ${options2.classText};
  stroke: none;
  font-family: ${options2.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${options2.classText};
}
.edgeLabel .label rect {
  fill: ${options2.mainBkg};
}
.label text {
  fill: ${options2.classText};
}
.edgeLabel .label span {
  background: ${options2.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${options2.nodeBorder};
  stroke: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${options2.mainBkg};
  stroke: ${options2.nodeBorder};
}

g.classGroup line {
  stroke: ${options2.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${options2.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${options2.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${options2.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

#compositionStart, .composition {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: ${options2.lineColor} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${options2.mainBkg} !important;
  stroke: ${options2.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
}

`;
const getStyles$c = (options2) => `
  .entityBox {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
  }

  .attributeBoxOdd {
    fill: ${options2.attributeBackgroundColorOdd};
    stroke: ${options2.nodeBorder};
  }

  .attributeBoxEven {
    fill:  ${options2.attributeBackgroundColorEven};
    stroke: ${options2.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${options2.tertiaryColor};
    opacity: 0.7;
    background-color: ${options2.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

    .relationshipLine {
      stroke: ${options2.lineColor};
    }
`;
const getStyles$b = () => ``;
const getStyles$a = (options2) => `.label {
    font-family: ${options2.fontFamily};
    color: ${options2.nodeTextColor || options2.textColor};
  }
  .cluster-label text {
    fill: ${options2.titleColor};
  }
  .cluster-label span {
    color: ${options2.titleColor};
  }

  .label text,span {
    fill: ${options2.nodeTextColor || options2.textColor};
    color: ${options2.nodeTextColor || options2.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${options2.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${options2.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${options2.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${options2.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${options2.edgeLabelBackground};
      fill: ${options2.edgeLabelBackground};
    }
    text-align: center;
  }

  .cluster rect {
    fill: ${options2.clusterBkg};
    stroke: ${options2.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${options2.titleColor};
  }

  .cluster span {
    color: ${options2.titleColor};
  }
  /* .cluster div {
    color: ${options2.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${options2.fontFamily};
    font-size: 12px;
    background: ${options2.tertiaryColor};
    border: 1px solid ${options2.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }
`;
const getStyles$9 = (options2) => `
  .mermaid-main-font {
    font-family: "trebuchet ms", verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  .exclude-range {
    fill: ${options2.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${options2.sectionBkgColor};
  }

  .section2 {
    fill: ${options2.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${options2.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${options2.titleColor};
  }

  .sectionTitle1 {
    fill: ${options2.titleColor};
  }

  .sectionTitle2 {
    fill: ${options2.titleColor};
  }

  .sectionTitle3 {
    fill: ${options2.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    // font-size: ${options2.ganttFontSize};
    // text-height: 14px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${options2.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
    text {
      font-family: ${options2.fontFamily};
      fill: ${options2.textColor};
    }
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${options2.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }

  // .taskText:not([font-size]) {
  //   font-size: ${options2.ganttFontSize};
  // }

  .taskTextOutsideRight {
    fill: ${options2.taskTextDarkColor};
    text-anchor: start;
    // font-size: ${options2.ganttFontSize};
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);

  }

  .taskTextOutsideLeft {
    fill: ${options2.taskTextDarkColor};
    text-anchor: end;
    // font-size: ${options2.ganttFontSize};
  }

  /* Special case clickable */
  .task.clickable {
    cursor: pointer;
  }
  .taskText.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${options2.taskTextClickableColor} !important;
    font-weight: bold;
  }

  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${options2.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${options2.taskBkgColor};
    stroke: ${options2.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${options2.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${options2.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${options2.activeTaskBkgColor};
    stroke: ${options2.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${options2.doneTaskBorderColor};
    fill: ${options2.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${options2.critBorderColor};
    fill: ${options2.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${options2.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${options2.textColor}    ;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
`;
const getStyles$8 = () => ``;
const getStyles$7 = (options2) => `
  .pieCircle{
    stroke: ${options2.pieStrokeColor};
    stroke-width : ${options2.pieStrokeWidth};
    opacity : ${options2.pieOpacity};
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${options2.pieTitleTextSize};
    fill: ${options2.pieTitleTextColor};
    font-family: ${options2.fontFamily};
  }
  .slice {
    font-family: ${options2.fontFamily};
    fill: ${options2.pieSectionTextColor};
    font-size:${options2.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${options2.pieLegendTextColor};
    font-family: ${options2.fontFamily};
    font-size: ${options2.pieLegendTextSize};
  }
`;
const getStyles$6 = (options2) => `

  marker {
    fill: ${options2.relationColor};
    stroke: ${options2.relationColor};
  }

  marker.cross {
    stroke: ${options2.lineColor};
  }

  svg {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
  }

  .reqBox {
    fill: ${options2.requirementBackground};
    fill-opacity: 100%;
    stroke: ${options2.requirementBorderColor};
    stroke-width: ${options2.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${options2.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${options2.relationLabelBackground};
    fill-opacity: 100%;
  }

  .req-title-line {
    stroke: ${options2.requirementBorderColor};
    stroke-width: ${options2.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${options2.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${options2.relationLabelColor};
  }

`;
const getStyles$5 = (options2) => `.actor {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
  }

  text.actor > tspan {
    fill: ${options2.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${options2.actorLineColor};
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${options2.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${options2.signalColor};
  }

  #arrowhead path {
    fill: ${options2.signalColor};
    stroke: ${options2.signalColor};
  }

  .sequenceNumber {
    fill: ${options2.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${options2.signalColor};
  }

  #crosshead path {
    fill: ${options2.signalColor};
    stroke: ${options2.signalColor};
  }

  .messageText {
    fill: ${options2.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${options2.labelBoxBorderColor};
    fill: ${options2.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${options2.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${options2.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${options2.labelBoxBorderColor};
    fill: ${options2.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${options2.noteBorderColor};
    fill: ${options2.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${options2.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .activation1 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .activation2 {
    fill: ${options2.activationBkgColor};
    stroke: ${options2.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${options2.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${options2.actorBorder};
    fill: ${options2.actorBkg};
    stroke-width: 2px;
  }
`;
const getStyles$4 = (options2) => `
defs #statediagram-barbEnd {
    fill: ${options2.transitionColor};
    stroke: ${options2.transitionColor};
  }
g.stateGroup text {
  fill: ${options2.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${options2.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${options2.stateLabelColor};
}

g.stateGroup rect {
  fill: ${options2.mainBkg};
  stroke: ${options2.nodeBorder};
}

g.stateGroup line {
  stroke: ${options2.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${options2.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${options2.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${options2.noteBorderColor};
  fill: ${options2.noteBkgColor};

  text {
    fill: ${options2.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${options2.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${options2.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel .label text {
  fill: ${options2.transitionLabelColor || options2.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${options2.transitionLabelColor || options2.tertiaryTextColor};
}

.stateLabel text {
  fill: ${options2.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${options2.specialStateColor};
  stroke: ${options2.specialStateColor};
}

.node .fork-join {
  fill: ${options2.specialStateColor};
  stroke: ${options2.specialStateColor};
}

.node circle.state-end {
  fill: ${options2.innerEndBackground};
  stroke: ${options2.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${options2.compositeBackground || options2.background};
  // stroke: ${options2.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${options2.stateBkg || options2.mainBkg};
  stroke: ${options2.stateBorder || options2.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${options2.mainBkg};
  stroke: ${options2.stateBorder || options2.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${options2.lineColor};
}

.statediagram-cluster rect {
  fill: ${options2.compositeTitleBackground};
  stroke: ${options2.stateBorder || options2.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${options2.stateLabelColor};
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${options2.stateBorder || options2.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${options2.compositeBackground || options2.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${options2.altBackground ? options2.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${options2.altBackground ? options2.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${options2.noteBkgColor};
  stroke: ${options2.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${options2.noteBkgColor};
  stroke: ${options2.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${options2.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${options2.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${options2.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${options2.lineColor};
  stroke: ${options2.lineColor};
  stroke-width: 1;
}
`;
const getStyles$3 = (options2) => `.label {
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    color: ${options2.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${options2.textColor}
  }

  .legend {
    fill: ${options2.textColor};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${options2.textColor}
  }

  .face {
    ${options2.faceColor ? `fill: ${options2.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${options2.mainBkg};
    stroke: ${options2.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${options2.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${options2.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${options2.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${options2.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${options2.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
    font-size: 12px;
    background: ${options2.tertiaryColor};
    border: 1px solid ${options2.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${options2.fillType0 ? `fill: ${options2.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${options2.fillType0 ? `fill: ${options2.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${options2.fillType0 ? `fill: ${options2.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${options2.fillType0 ? `fill: ${options2.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${options2.fillType0 ? `fill: ${options2.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${options2.fillType0 ? `fill: ${options2.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${options2.fillType0 ? `fill: ${options2.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${options2.fillType0 ? `fill: ${options2.fillType7}` : ""};
  }

  .actor-0 {
    ${options2.actor0 ? `fill: ${options2.actor0}` : ""};
  }
  .actor-1 {
    ${options2.actor1 ? `fill: ${options2.actor1}` : ""};
  }
  .actor-2 {
    ${options2.actor2 ? `fill: ${options2.actor2}` : ""};
  }
  .actor-3 {
    ${options2.actor3 ? `fill: ${options2.actor3}` : ""};
  }
  .actor-4 {
    ${options2.actor4 ? `fill: ${options2.actor4}` : ""};
  }
  .actor-5 {
    ${options2.actor5 ? `fill: ${options2.actor5}` : ""};
  }
`;
const getStyles$2 = (options2) => `.person {
    stroke: ${options2.personBorder};
    fill: ${options2.personBkg};
  }
`;
const themes = {
  flowchart: getStyles$a,
  "flowchart-v2": getStyles$a,
  sequence: getStyles$5,
  gantt: getStyles$9,
  classDiagram: getStyles$d,
  "classDiagram-v2": getStyles$d,
  class: getStyles$d,
  stateDiagram: getStyles$4,
  state: getStyles$4,
  info: getStyles$8,
  pie: getStyles$7,
  er: getStyles$c,
  error: getStyles$b,
  journey: getStyles$3,
  requirement: getStyles$6,
  c4: getStyles$2
};
const getStyles$1 = (type2, userStyles, options2) => {
  let diagramStyles = "";
  if (type2 in themes && themes[type2]) {
    diagramStyles = themes[type2](options2);
  } else {
    log$1.warn(`No theme found for ${type2}`);
  }
  return ` {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
    fill: ${options2.textColor}
  }

  /* Classes common for multiple diagrams */

  .error-icon {
    fill: ${options2.errorBkgColor};
  }
  .error-text {
    fill: ${options2.errorTextColor};
    stroke: ${options2.errorTextColor};
  }

  .edge-thickness-normal {
    stroke-width: 2px;
  }
  .edge-thickness-thick {
    stroke-width: 3.5px
  }
  .edge-pattern-solid {
    stroke-dasharray: 0;
  }

  .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  .marker {
    fill: ${options2.lineColor};
    stroke: ${options2.lineColor};
  }
  .marker.cross {
    stroke: ${options2.lineColor};
  }

  svg {
    font-family: ${options2.fontFamily};
    font-size: ${options2.fontSize};
  }

  ${diagramStyles}

  ${userStyles}
`;
};
const addStylesForDiagram = (type2, diagramTheme) => {
  themes[type2] = diagramTheme;
};
const log = log$1;
const setLogLevel = setLogLevel$1;
const getConfig = getConfig$1;
const sanitizeText$4 = (text2) => sanitizeText$5(text2, getConfig());
const setupGraphViewbox = setupGraphViewbox$1;
const diagrams = {};
const registerDiagram = (id2, diagram, detector) => {
  log.debug(`Registering diagram ${id2}`);
  if (diagrams[id2]) {
    log.warn(`Diagram ${id2} already registered.`);
  }
  diagrams[id2] = diagram;
  if (detector) {
    addDetector(id2, detector);
  }
  addStylesForDiagram(id2, diagram.styles);
  if (diagram.injectUtils) {
    diagram.injectUtils(log, setLogLevel, getConfig, sanitizeText$4, setupGraphViewbox);
  }
  log.debug(`Registered diagram ${id2}. ${Object.keys(diagrams).join(", ")} diagrams registered.`);
};
const getDiagram = (name2) => {
  log.debug(`Getting diagram ${name2}. ${Object.keys(diagrams).join(", ")} diagrams registered.`);
  if (name2 in diagrams) {
    return diagrams[name2];
  }
  throw new DiagramNotFoundError(name2);
};
class DiagramNotFoundError extends Error {
  constructor(message2) {
    super(`Diagram ${message2} not found.`);
  }
}
var parser$b = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 4], $V1 = [1, 7], $V2 = [1, 5], $V3 = [1, 9], $V4 = [1, 6], $V5 = [2, 6], $V6 = [1, 16], $V7 = [6, 8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40, 50, 54], $V8 = [8, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], $V9 = [8, 13, 14, 20, 22, 24, 25, 27, 29, 32, 37, 40], $Va = [1, 26], $Vb = [6, 8, 14, 50, 54], $Vc = [8, 14, 54], $Vd = [1, 65], $Ve = [1, 66], $Vf = [1, 67], $Vg = [8, 14, 33, 35, 42, 54];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "eol": 4, "directive": 5, "GG": 6, "document": 7, "EOF": 8, ":": 9, "DIR": 10, "options": 11, "body": 12, "OPT": 13, "NL": 14, "line": 15, "statement": 16, "commitStatement": 17, "mergeStatement": 18, "cherryPickStatement": 19, "acc_title": 20, "acc_title_value": 21, "acc_descr": 22, "acc_descr_value": 23, "acc_descr_multiline_value": 24, "section": 25, "branchStatement": 26, "CHECKOUT": 27, "ID": 28, "BRANCH": 29, "ORDER": 30, "NUM": 31, "CHERRY_PICK": 32, "COMMIT_ID": 33, "STR": 34, "COMMIT_TAG": 35, "EMPTYSTR": 36, "MERGE": 37, "COMMIT_TYPE": 38, "commitType": 39, "COMMIT": 40, "commit_arg": 41, "COMMIT_MSG": 42, "NORMAL": 43, "REVERSE": 44, "HIGHLIGHT": 45, "openDirective": 46, "typeDirective": 47, "closeDirective": 48, "argDirective": 49, "open_directive": 50, "type_directive": 51, "arg_directive": 52, "close_directive": 53, ";": 54, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 6: "GG", 8: "EOF", 9: ":", 10: "DIR", 13: "OPT", 14: "NL", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "CHECKOUT", 28: "ID", 29: "BRANCH", 30: "ORDER", 31: "NUM", 32: "CHERRY_PICK", 33: "COMMIT_ID", 34: "STR", 35: "COMMIT_TAG", 36: "EMPTYSTR", 37: "MERGE", 38: "COMMIT_TYPE", 40: "COMMIT", 42: "COMMIT_MSG", 43: "NORMAL", 44: "REVERSE", 45: "HIGHLIGHT", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive", 54: ";" },
    productions_: [0, [3, 2], [3, 2], [3, 3], [3, 4], [3, 5], [7, 0], [7, 2], [11, 2], [11, 1], [12, 0], [12, 2], [15, 2], [15, 1], [16, 1], [16, 1], [16, 1], [16, 2], [16, 2], [16, 1], [16, 1], [16, 1], [16, 2], [26, 2], [26, 4], [19, 3], [19, 5], [19, 5], [19, 5], [19, 5], [18, 2], [18, 4], [18, 4], [18, 4], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 6], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [18, 8], [17, 2], [17, 3], [17, 3], [17, 5], [17, 5], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 3], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 5], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 7], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [17, 9], [41, 0], [41, 1], [39, 1], [39, 1], [39, 1], [5, 3], [5, 5], [46, 1], [47, 1], [49, 1], [48, 1], [4, 1], [4, 1], [4, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 3:
          return $$[$0];
        case 4:
          return $$[$0 - 1];
        case 5:
          yy.setDirection($$[$0 - 3]);
          return $$[$0 - 1];
        case 7:
          yy.setOptions($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 8:
          $$[$0 - 1] += $$[$0];
          this.$ = $$[$0 - 1];
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 12:
          this.$ = $$[$0 - 1];
          break;
        case 17:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 20:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 22:
          yy.checkout($$[$0]);
          break;
        case 23:
          yy.branch($$[$0]);
          break;
        case 24:
          yy.branch($$[$0 - 2], $$[$0]);
          break;
        case 25:
          yy.cherryPick($$[$0], "", void 0);
          break;
        case 26:
          yy.cherryPick($$[$0 - 2], "", $$[$0]);
          break;
        case 27:
        case 29:
          yy.cherryPick($$[$0 - 2], "", "");
          break;
        case 28:
          yy.cherryPick($$[$0], "", $$[$0 - 2]);
          break;
        case 30:
          yy.merge($$[$0], "", "", "");
          break;
        case 31:
          yy.merge($$[$0 - 2], $$[$0], "", "");
          break;
        case 32:
          yy.merge($$[$0 - 2], "", $$[$0], "");
          break;
        case 33:
          yy.merge($$[$0 - 2], "", "", $$[$0]);
          break;
        case 34:
          yy.merge($$[$0 - 4], $$[$0], "", $$[$0 - 2]);
          break;
        case 35:
          yy.merge($$[$0 - 4], "", $$[$0], $$[$0 - 2]);
          break;
        case 36:
          yy.merge($$[$0 - 4], "", $$[$0 - 2], $$[$0]);
          break;
        case 37:
          yy.merge($$[$0 - 4], $$[$0 - 2], $$[$0], "");
          break;
        case 38:
          yy.merge($$[$0 - 4], $$[$0 - 2], "", $$[$0]);
          break;
        case 39:
          yy.merge($$[$0 - 4], $$[$0], $$[$0 - 2], "");
          break;
        case 40:
          yy.merge($$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 41:
          yy.merge($$[$0 - 6], $$[$0], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 42:
          yy.merge($$[$0 - 6], $$[$0 - 4], $$[$0], $$[$0 - 2]);
          break;
        case 43:
          yy.merge($$[$0 - 6], $$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 44:
          yy.merge($$[$0 - 6], $$[$0], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 45:
          yy.merge($$[$0 - 6], $$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 46:
          yy.commit($$[$0]);
          break;
        case 47:
          yy.commit("", "", yy.commitType.NORMAL, $$[$0]);
          break;
        case 48:
          yy.commit("", "", $$[$0], "");
          break;
        case 49:
          yy.commit("", "", $$[$0], $$[$0 - 2]);
          break;
        case 50:
          yy.commit("", "", $$[$0 - 2], $$[$0]);
          break;
        case 51:
          yy.commit("", $$[$0], yy.commitType.NORMAL, "");
          break;
        case 52:
          yy.commit("", $$[$0 - 2], yy.commitType.NORMAL, $$[$0]);
          break;
        case 53:
          yy.commit("", $$[$0], yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 54:
          yy.commit("", $$[$0 - 2], $$[$0], "");
          break;
        case 55:
          yy.commit("", $$[$0], $$[$0 - 2], "");
          break;
        case 56:
          yy.commit("", $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 57:
          yy.commit("", $$[$0 - 4], $$[$0], $$[$0 - 2]);
          break;
        case 58:
          yy.commit("", $$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 59:
          yy.commit("", $$[$0], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 60:
          yy.commit("", $$[$0], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 61:
          yy.commit("", $$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 62:
          yy.commit($$[$0], "", yy.commitType.NORMAL, "");
          break;
        case 63:
          yy.commit($$[$0], "", yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 64:
          yy.commit($$[$0 - 2], "", yy.commitType.NORMAL, $$[$0]);
          break;
        case 65:
          yy.commit($$[$0 - 2], "", $$[$0], "");
          break;
        case 66:
          yy.commit($$[$0], "", $$[$0 - 2], "");
          break;
        case 67:
          yy.commit($$[$0], $$[$0 - 2], yy.commitType.NORMAL, "");
          break;
        case 68:
          yy.commit($$[$0 - 2], $$[$0], yy.commitType.NORMAL, "");
          break;
        case 69:
          yy.commit($$[$0 - 4], "", $$[$0 - 2], $$[$0]);
          break;
        case 70:
          yy.commit($$[$0 - 4], "", $$[$0], $$[$0 - 2]);
          break;
        case 71:
          yy.commit($$[$0 - 2], "", $$[$0 - 4], $$[$0]);
          break;
        case 72:
          yy.commit($$[$0], "", $$[$0 - 4], $$[$0 - 2]);
          break;
        case 73:
          yy.commit($$[$0], "", $$[$0 - 2], $$[$0 - 4]);
          break;
        case 74:
          yy.commit($$[$0 - 2], "", $$[$0], $$[$0 - 4]);
          break;
        case 75:
          yy.commit($$[$0 - 4], $$[$0], $$[$0 - 2], "");
          break;
        case 76:
          yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0], "");
          break;
        case 77:
          yy.commit($$[$0 - 2], $$[$0], $$[$0 - 4], "");
          break;
        case 78:
          yy.commit($$[$0], $$[$0 - 2], $$[$0 - 4], "");
          break;
        case 79:
          yy.commit($$[$0], $$[$0 - 4], $$[$0 - 2], "");
          break;
        case 80:
          yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0], "");
          break;
        case 81:
          yy.commit($$[$0 - 4], $$[$0], yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 82:
          yy.commit($$[$0 - 4], $$[$0 - 2], yy.commitType.NORMAL, $$[$0]);
          break;
        case 83:
          yy.commit($$[$0 - 2], $$[$0], yy.commitType.NORMAL, $$[$0 - 4]);
          break;
        case 84:
          yy.commit($$[$0], $$[$0 - 2], yy.commitType.NORMAL, $$[$0 - 4]);
          break;
        case 85:
          yy.commit($$[$0], $$[$0 - 4], yy.commitType.NORMAL, $$[$0 - 2]);
          break;
        case 86:
          yy.commit($$[$0 - 2], $$[$0 - 4], yy.commitType.NORMAL, $$[$0]);
          break;
        case 87:
          yy.commit($$[$0 - 6], $$[$0 - 4], $$[$0 - 2], $$[$0]);
          break;
        case 88:
          yy.commit($$[$0 - 6], $$[$0 - 4], $$[$0], $$[$0 - 2]);
          break;
        case 89:
          yy.commit($$[$0 - 6], $$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 90:
          yy.commit($$[$0 - 6], $$[$0], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 91:
          yy.commit($$[$0 - 6], $$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 92:
          yy.commit($$[$0 - 6], $$[$0], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 93:
          yy.commit($$[$0 - 4], $$[$0 - 6], $$[$0 - 2], $$[$0]);
          break;
        case 94:
          yy.commit($$[$0 - 4], $$[$0 - 6], $$[$0], $$[$0 - 2]);
          break;
        case 95:
          yy.commit($$[$0 - 2], $$[$0 - 6], $$[$0 - 4], $$[$0]);
          break;
        case 96:
          yy.commit($$[$0], $$[$0 - 6], $$[$0 - 4], $$[$0 - 2]);
          break;
        case 97:
          yy.commit($$[$0 - 2], $$[$0 - 6], $$[$0], $$[$0 - 4]);
          break;
        case 98:
          yy.commit($$[$0], $$[$0 - 6], $$[$0 - 2], $$[$0 - 4]);
          break;
        case 99:
          yy.commit($$[$0], $$[$0 - 4], $$[$0 - 2], $$[$0 - 6]);
          break;
        case 100:
          yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0], $$[$0 - 6]);
          break;
        case 101:
          yy.commit($$[$0], $$[$0 - 2], $$[$0 - 4], $$[$0 - 6]);
          break;
        case 102:
          yy.commit($$[$0 - 2], $$[$0], $$[$0 - 4], $$[$0 - 6]);
          break;
        case 103:
          yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0], $$[$0 - 6]);
          break;
        case 104:
          yy.commit($$[$0 - 4], $$[$0], $$[$0 - 2], $$[$0 - 6]);
          break;
        case 105:
          yy.commit($$[$0 - 2], $$[$0 - 4], $$[$0 - 6], $$[$0]);
          break;
        case 106:
          yy.commit($$[$0], $$[$0 - 4], $$[$0 - 6], $$[$0 - 2]);
          break;
        case 107:
          yy.commit($$[$0 - 2], $$[$0], $$[$0 - 6], $$[$0 - 4]);
          break;
        case 108:
          yy.commit($$[$0], $$[$0 - 2], $$[$0 - 6], $$[$0 - 4]);
          break;
        case 109:
          yy.commit($$[$0 - 4], $$[$0 - 2], $$[$0 - 6], $$[$0]);
          break;
        case 110:
          yy.commit($$[$0 - 4], $$[$0], $$[$0 - 6], $$[$0 - 2]);
          break;
        case 111:
          this.$ = "";
          break;
        case 112:
          this.$ = $$[$0];
          break;
        case 113:
          this.$ = yy.commitType.NORMAL;
          break;
        case 114:
          this.$ = yy.commitType.REVERSE;
          break;
        case 115:
          this.$ = yy.commitType.HIGHLIGHT;
          break;
        case 118:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 119:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 120:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 121:
          yy.parseDirective("}%%", "close_directive", "gitGraph");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 3: 11, 4: 2, 5: 3, 6: $V0, 8: $V1, 14: $V2, 46: 8, 50: $V3, 54: $V4 }, { 7: 12, 8: $V5, 9: [1, 13], 10: [1, 14], 11: 15, 14: $V6 }, o($V7, [2, 122]), o($V7, [2, 123]), o($V7, [2, 124]), { 47: 17, 51: [1, 18] }, { 51: [2, 118] }, { 1: [2, 1] }, { 1: [2, 2] }, { 8: [1, 19] }, { 7: 20, 8: $V5, 11: 15, 14: $V6 }, { 9: [1, 21] }, o($V8, [2, 10], { 12: 22, 13: [1, 23] }), o($V9, [2, 9]), { 9: [1, 25], 48: 24, 53: $Va }, o([9, 53], [2, 119]), { 1: [2, 3] }, { 8: [1, 27] }, { 7: 28, 8: $V5, 11: 15, 14: $V6 }, { 8: [2, 7], 14: [1, 31], 15: 29, 16: 30, 17: 32, 18: 33, 19: 34, 20: [1, 35], 22: [1, 36], 24: [1, 37], 25: [1, 38], 26: 39, 27: [1, 40], 29: [1, 44], 32: [1, 43], 37: [1, 42], 40: [1, 41] }, o($V9, [2, 8]), o($Vb, [2, 116]), { 49: 45, 52: [1, 46] }, o($Vb, [2, 121]), { 1: [2, 4] }, { 8: [1, 47] }, o($V8, [2, 11]), { 4: 48, 8: $V1, 14: $V2, 54: $V4 }, o($V8, [2, 13]), o($Vc, [2, 14]), o($Vc, [2, 15]), o($Vc, [2, 16]), { 21: [1, 49] }, { 23: [1, 50] }, o($Vc, [2, 19]), o($Vc, [2, 20]), o($Vc, [2, 21]), { 28: [1, 51] }, o($Vc, [2, 111], { 41: 52, 33: [1, 55], 34: [1, 57], 35: [1, 53], 38: [1, 54], 42: [1, 56] }), { 28: [1, 58] }, { 33: [1, 59], 35: [1, 60] }, { 28: [1, 61] }, { 48: 62, 53: $Va }, { 53: [2, 120] }, { 1: [2, 5] }, o($V8, [2, 12]), o($Vc, [2, 17]), o($Vc, [2, 18]), o($Vc, [2, 22]), o($Vc, [2, 46]), { 34: [1, 63] }, { 39: 64, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 68] }, { 34: [1, 69] }, o($Vc, [2, 112]), o($Vc, [2, 30], { 33: [1, 70], 35: [1, 72], 38: [1, 71] }), { 34: [1, 73] }, { 34: [1, 74], 36: [1, 75] }, o($Vc, [2, 23], { 30: [1, 76] }), o($Vb, [2, 117]), o($Vc, [2, 47], { 33: [1, 78], 38: [1, 77], 42: [1, 79] }), o($Vc, [2, 48], { 33: [1, 81], 35: [1, 80], 42: [1, 82] }), o($Vg, [2, 113]), o($Vg, [2, 114]), o($Vg, [2, 115]), o($Vc, [2, 51], { 35: [1, 83], 38: [1, 84], 42: [1, 85] }), o($Vc, [2, 62], { 33: [1, 88], 35: [1, 86], 38: [1, 87] }), { 34: [1, 89] }, { 39: 90, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 91] }, o($Vc, [2, 25], { 35: [1, 92] }), { 33: [1, 93] }, { 33: [1, 94] }, { 31: [1, 95] }, { 39: 96, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 97] }, { 34: [1, 98] }, { 34: [1, 99] }, { 34: [1, 100] }, { 34: [1, 101] }, { 34: [1, 102] }, { 39: 103, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 104] }, { 34: [1, 105] }, { 39: 106, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 107] }, o($Vc, [2, 31], { 35: [1, 109], 38: [1, 108] }), o($Vc, [2, 32], { 33: [1, 111], 35: [1, 110] }), o($Vc, [2, 33], { 33: [1, 112], 38: [1, 113] }), { 34: [1, 114], 36: [1, 115] }, { 34: [1, 116] }, { 34: [1, 117] }, o($Vc, [2, 24]), o($Vc, [2, 49], { 33: [1, 118], 42: [1, 119] }), o($Vc, [2, 53], { 38: [1, 120], 42: [1, 121] }), o($Vc, [2, 63], { 33: [1, 123], 38: [1, 122] }), o($Vc, [2, 50], { 33: [1, 124], 42: [1, 125] }), o($Vc, [2, 55], { 35: [1, 126], 42: [1, 127] }), o($Vc, [2, 66], { 33: [1, 129], 35: [1, 128] }), o($Vc, [2, 52], { 38: [1, 130], 42: [1, 131] }), o($Vc, [2, 54], { 35: [1, 132], 42: [1, 133] }), o($Vc, [2, 67], { 35: [1, 135], 38: [1, 134] }), o($Vc, [2, 64], { 33: [1, 137], 38: [1, 136] }), o($Vc, [2, 65], { 33: [1, 139], 35: [1, 138] }), o($Vc, [2, 68], { 35: [1, 141], 38: [1, 140] }), { 39: 142, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 143] }, { 34: [1, 144] }, { 34: [1, 145] }, { 34: [1, 146] }, { 39: 147, 43: $Vd, 44: $Ve, 45: $Vf }, o($Vc, [2, 26]), o($Vc, [2, 27]), o($Vc, [2, 28]), o($Vc, [2, 29]), { 34: [1, 148] }, { 34: [1, 149] }, { 39: 150, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 151] }, { 39: 152, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 153] }, { 34: [1, 154] }, { 34: [1, 155] }, { 34: [1, 156] }, { 34: [1, 157] }, { 34: [1, 158] }, { 34: [1, 159] }, { 39: 160, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 161] }, { 34: [1, 162] }, { 34: [1, 163] }, { 39: 164, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 165] }, { 39: 166, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 167] }, { 34: [1, 168] }, { 34: [1, 169] }, { 39: 170, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 171] }, o($Vc, [2, 37], { 35: [1, 172] }), o($Vc, [2, 38], { 38: [1, 173] }), o($Vc, [2, 36], { 33: [1, 174] }), o($Vc, [2, 39], { 35: [1, 175] }), o($Vc, [2, 34], { 38: [1, 176] }), o($Vc, [2, 35], { 33: [1, 177] }), o($Vc, [2, 60], { 42: [1, 178] }), o($Vc, [2, 73], { 33: [1, 179] }), o($Vc, [2, 61], { 42: [1, 180] }), o($Vc, [2, 84], { 38: [1, 181] }), o($Vc, [2, 74], { 33: [1, 182] }), o($Vc, [2, 83], { 38: [1, 183] }), o($Vc, [2, 59], { 42: [1, 184] }), o($Vc, [2, 72], { 33: [1, 185] }), o($Vc, [2, 58], { 42: [1, 186] }), o($Vc, [2, 78], { 35: [1, 187] }), o($Vc, [2, 71], { 33: [1, 188] }), o($Vc, [2, 77], { 35: [1, 189] }), o($Vc, [2, 57], { 42: [1, 190] }), o($Vc, [2, 85], { 38: [1, 191] }), o($Vc, [2, 56], { 42: [1, 192] }), o($Vc, [2, 79], { 35: [1, 193] }), o($Vc, [2, 80], { 35: [1, 194] }), o($Vc, [2, 86], { 38: [1, 195] }), o($Vc, [2, 70], { 33: [1, 196] }), o($Vc, [2, 81], { 38: [1, 197] }), o($Vc, [2, 69], { 33: [1, 198] }), o($Vc, [2, 75], { 35: [1, 199] }), o($Vc, [2, 76], { 35: [1, 200] }), o($Vc, [2, 82], { 38: [1, 201] }), { 34: [1, 202] }, { 39: 203, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 204] }, { 34: [1, 205] }, { 39: 206, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 207] }, { 34: [1, 208] }, { 34: [1, 209] }, { 34: [1, 210] }, { 39: 211, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 212] }, { 39: 213, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 214] }, { 34: [1, 215] }, { 34: [1, 216] }, { 34: [1, 217] }, { 34: [1, 218] }, { 34: [1, 219] }, { 34: [1, 220] }, { 39: 221, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 222] }, { 34: [1, 223] }, { 34: [1, 224] }, { 39: 225, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 226] }, { 39: 227, 43: $Vd, 44: $Ve, 45: $Vf }, { 34: [1, 228] }, { 34: [1, 229] }, { 34: [1, 230] }, { 39: 231, 43: $Vd, 44: $Ve, 45: $Vf }, o($Vc, [2, 40]), o($Vc, [2, 42]), o($Vc, [2, 41]), o($Vc, [2, 43]), o($Vc, [2, 45]), o($Vc, [2, 44]), o($Vc, [2, 101]), o($Vc, [2, 102]), o($Vc, [2, 99]), o($Vc, [2, 100]), o($Vc, [2, 104]), o($Vc, [2, 103]), o($Vc, [2, 108]), o($Vc, [2, 107]), o($Vc, [2, 106]), o($Vc, [2, 105]), o($Vc, [2, 110]), o($Vc, [2, 109]), o($Vc, [2, 98]), o($Vc, [2, 97]), o($Vc, [2, 96]), o($Vc, [2, 95]), o($Vc, [2, 93]), o($Vc, [2, 94]), o($Vc, [2, 92]), o($Vc, [2, 91]), o($Vc, [2, 90]), o($Vc, [2, 89]), o($Vc, [2, 87]), o($Vc, [2, 88])],
    defaultActions: { 9: [2, 118], 10: [2, 1], 11: [2, 2], 19: [2, 3], 27: [2, 4], 46: [2, 120], 47: [2, 5] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 50;
          case 1:
            this.begin("type_directive");
            return 51;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 9;
          case 3:
            this.popState();
            this.popState();
            return 53;
          case 4:
            return 52;
          case 5:
            this.begin("acc_title");
            return 20;
          case 6:
            this.popState();
            return "acc_title_value";
          case 7:
            this.begin("acc_descr");
            return 22;
          case 8:
            this.popState();
            return "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            return 14;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 6;
          case 16:
            return 40;
          case 17:
            return 33;
          case 18:
            return 38;
          case 19:
            return 42;
          case 20:
            return 43;
          case 21:
            return 44;
          case 22:
            return 45;
          case 23:
            return 35;
          case 24:
            return 29;
          case 25:
            return 30;
          case 26:
            return 37;
          case 27:
            return 32;
          case 28:
            return 27;
          case 29:
            return 10;
          case 30:
            return 10;
          case 31:
            return 9;
          case 32:
            return "CARET";
          case 33:
            this.begin("options");
            break;
          case 34:
            this.popState();
            break;
          case 35:
            return 13;
          case 36:
            return 36;
          case 37:
            this.begin("string");
            break;
          case 38:
            this.popState();
            break;
          case 39:
            return 34;
          case 40:
            return 31;
          case 41:
            return 28;
          case 42:
            return 8;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:gitGraph\b)/i, /^(?:commit(?=\s|$))/i, /^(?:id:)/i, /^(?:type:)/i, /^(?:msg:)/i, /^(?:NORMAL\b)/i, /^(?:REVERSE\b)/i, /^(?:HIGHLIGHT\b)/i, /^(?:tag:)/i, /^(?:branch(?=\s|$))/i, /^(?:order:)/i, /^(?:merge(?=\s|$))/i, /^(?:cherry-pick(?=\s|$))/i, /^(?:checkout(?=\s|$))/i, /^(?:LR\b)/i, /^(?:BT\b)/i, /^(?::)/i, /^(?:\^)/i, /^(?:options\r?\n)/i, /^(?:[ \r\n\t]+end\b)/i, /^(?:[\s\S]+(?=[ \r\n\t]+end))/i, /^(?:["]["])/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[0-9]+(?=\s|$))/i, /^(?:\w([-\./\w]*[-\w])?)/i, /^(?:$)/i, /^(?:\s+)/i],
      conditions: { "acc_descr_multiline": { "rules": [10, 11], "inclusive": false }, "acc_descr": { "rules": [8], "inclusive": false }, "acc_title": { "rules": [6], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "options": { "rules": [34, 35], "inclusive": false }, "string": { "rules": [38, 39], "inclusive": false }, "INITIAL": { "rules": [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 36, 37, 40, 41, 42, 43], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$b.parser = parser$b;
const gitGraphDetector = (txt) => {
  return txt.match(/^\s*gitGraph/) !== null;
};
let title$1 = "";
let diagramTitle = "";
let description = "";
const sanitizeText$3 = (txt) => sanitizeText$5(txt, getConfig$1());
const clear$g = function() {
  title$1 = "";
  description = "";
  diagramTitle = "";
};
const setAccTitle = function(txt) {
  title$1 = sanitizeText$3(txt).replace(/^\s+/g, "");
};
const getAccTitle = function() {
  return title$1 || diagramTitle;
};
const setAccDescription = function(txt) {
  description = sanitizeText$3(txt).replace(/\n\s+/g, "\n");
};
const getAccDescription = function() {
  return description;
};
const setDiagramTitle = function(txt) {
  diagramTitle = sanitizeText$3(txt);
};
const getDiagramTitle = function() {
  return diagramTitle;
};
let mainBranchName = getConfig$1().gitGraph.mainBranchName;
let mainBranchOrder = getConfig$1().gitGraph.mainBranchOrder;
let commits = {};
let head = null;
let branchesConfig = {};
branchesConfig[mainBranchName] = { name: mainBranchName, order: mainBranchOrder };
let branches = {};
branches[mainBranchName] = head;
let curBranch = mainBranchName;
let direction$3 = "LR";
let seq = 0;
function getId() {
  return random({ length: 7 });
}
const parseDirective$b = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
function uniqBy(list2, fn) {
  const recordMap = /* @__PURE__ */ Object.create(null);
  return list2.reduce((out, item) => {
    const key = fn(item);
    if (!recordMap[key]) {
      recordMap[key] = true;
      out.push(item);
    }
    return out;
  }, []);
}
const setDirection$3 = function(dir) {
  direction$3 = dir;
};
let options = {};
const setOptions = function(rawOptString) {
  log$1.debug("options str", rawOptString);
  rawOptString = rawOptString && rawOptString.trim();
  rawOptString = rawOptString || "{}";
  try {
    options = JSON.parse(rawOptString);
  } catch (e) {
    log$1.error("error while parsing gitGraph options", e.message);
  }
};
const getOptions = function() {
  return options;
};
const commit = function(msg, id2, type2, tag) {
  log$1.debug("Entering commit:", msg, id2, type2, tag);
  id2 = common.sanitizeText(id2, getConfig$1());
  msg = common.sanitizeText(msg, getConfig$1());
  tag = common.sanitizeText(tag, getConfig$1());
  const commit2 = {
    id: id2 ? id2 : seq + "-" + getId(),
    message: msg,
    seq: seq++,
    type: type2 ? type2 : commitType$1.NORMAL,
    tag: tag ? tag : "",
    parents: head == null ? [] : [head.id],
    branch: curBranch
  };
  head = commit2;
  commits[commit2.id] = commit2;
  branches[curBranch] = commit2.id;
  log$1.debug("in pushCommit " + commit2.id);
};
const branch = function(name2, order2) {
  name2 = common.sanitizeText(name2, getConfig$1());
  if (typeof branches[name2] === "undefined") {
    branches[name2] = head != null ? head.id : null;
    branchesConfig[name2] = { name: name2, order: order2 ? parseInt(order2, 10) : null };
    checkout(name2);
    log$1.debug("in createBranch");
  } else {
    let error = new Error(
      'Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ' + name2 + '")'
    );
    error.hash = {
      text: "branch " + name2,
      token: "branch " + name2,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"checkout ' + name2 + '"']
    };
    throw error;
  }
};
const merge = function(otherBranch, custom_id, override_type, custom_tag) {
  otherBranch = common.sanitizeText(otherBranch, getConfig$1());
  custom_id = common.sanitizeText(custom_id, getConfig$1());
  const currentCommit = commits[branches[curBranch]];
  const otherCommit = commits[branches[otherBranch]];
  if (curBranch === otherBranch) {
    let error = new Error('Incorrect usage of "merge". Cannot merge a branch to itself');
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    };
    throw error;
  } else if (typeof currentCommit === "undefined" || !currentCommit) {
    let error = new Error(
      'Incorrect usage of "merge". Current branch (' + curBranch + ")has no commits"
    );
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["commit"]
    };
    throw error;
  } else if (typeof branches[otherBranch] === "undefined") {
    let error = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + otherBranch + ") does not exist"
    );
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch " + otherBranch]
    };
    throw error;
  } else if (typeof otherCommit === "undefined" || !otherCommit) {
    let error = new Error(
      'Incorrect usage of "merge". Branch to be merged (' + otherBranch + ") has no commits"
    );
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"commit"']
    };
    throw error;
  } else if (currentCommit === otherCommit) {
    let error = new Error('Incorrect usage of "merge". Both branches have same head');
    error.hash = {
      text: "merge " + otherBranch,
      token: "merge " + otherBranch,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["branch abc"]
    };
    throw error;
  } else if (custom_id && typeof commits[custom_id] !== "undefined") {
    let error = new Error(
      'Incorrect usage of "merge". Commit with id:' + custom_id + " already exists, use different custom Id"
    );
    error.hash = {
      text: "merge " + otherBranch + custom_id + override_type + custom_tag,
      token: "merge " + otherBranch + custom_id + override_type + custom_tag,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: [
        "merge " + otherBranch + " " + custom_id + "_UNIQUE " + override_type + " " + custom_tag
      ]
    };
    throw error;
  }
  const commit2 = {
    id: custom_id ? custom_id : seq + "-" + getId(),
    message: "merged branch " + otherBranch + " into " + curBranch,
    seq: seq++,
    parents: [head == null ? null : head.id, branches[otherBranch]],
    branch: curBranch,
    type: commitType$1.MERGE,
    customType: override_type,
    customId: custom_id ? true : false,
    tag: custom_tag ? custom_tag : ""
  };
  head = commit2;
  commits[commit2.id] = commit2;
  branches[curBranch] = commit2.id;
  log$1.debug(branches);
  log$1.debug("in mergeBranch");
};
const cherryPick = function(sourceId, targetId, tag) {
  log$1.debug("Entering cherryPick:", sourceId, targetId, tag);
  sourceId = common.sanitizeText(sourceId, getConfig$1());
  targetId = common.sanitizeText(targetId, getConfig$1());
  tag = common.sanitizeText(tag, getConfig$1());
  if (!sourceId || typeof commits[sourceId] === "undefined") {
    let error = new Error(
      'Incorrect usage of "cherryPick". Source commit id should exist and provided'
    );
    error.hash = {
      text: "cherryPick " + sourceId + " " + targetId,
      token: "cherryPick " + sourceId + " " + targetId,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    };
    throw error;
  }
  let sourceCommit = commits[sourceId];
  let sourceCommitBranch = sourceCommit.branch;
  if (sourceCommit.type === commitType$1.MERGE) {
    let error = new Error(
      'Incorrect usage of "cherryPick". Source commit should not be a merge commit'
    );
    error.hash = {
      text: "cherryPick " + sourceId + " " + targetId,
      token: "cherryPick " + sourceId + " " + targetId,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ["cherry-pick abc"]
    };
    throw error;
  }
  if (!targetId || typeof commits[targetId] === "undefined") {
    if (sourceCommitBranch === curBranch) {
      let error = new Error(
        'Incorrect usage of "cherryPick". Source commit is already on current branch'
      );
      error.hash = {
        text: "cherryPick " + sourceId + " " + targetId,
        token: "cherryPick " + sourceId + " " + targetId,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      };
      throw error;
    }
    const currentCommit = commits[branches[curBranch]];
    if (typeof currentCommit === "undefined" || !currentCommit) {
      let error = new Error(
        'Incorrect usage of "cherry-pick". Current branch (' + curBranch + ")has no commits"
      );
      error.hash = {
        text: "cherryPick " + sourceId + " " + targetId,
        token: "cherryPick " + sourceId + " " + targetId,
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["cherry-pick abc"]
      };
      throw error;
    }
    const commit2 = {
      id: seq + "-" + getId(),
      message: "cherry-picked " + sourceCommit + " into " + curBranch,
      seq: seq++,
      parents: [head == null ? null : head.id, sourceCommit.id],
      branch: curBranch,
      type: commitType$1.CHERRY_PICK,
      tag: tag != null ? tag : "cherry-pick:" + sourceCommit.id
    };
    head = commit2;
    commits[commit2.id] = commit2;
    branches[curBranch] = commit2.id;
    log$1.debug(branches);
    log$1.debug("in cherryPick");
  }
};
const checkout = function(branch2) {
  branch2 = common.sanitizeText(branch2, getConfig$1());
  if (typeof branches[branch2] === "undefined") {
    let error = new Error(
      'Trying to checkout branch which is not yet created. (Help try using "branch ' + branch2 + '")'
    );
    error.hash = {
      text: "checkout " + branch2,
      token: "checkout " + branch2,
      line: "1",
      loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
      expected: ['"branch ' + branch2 + '"']
    };
    throw error;
  } else {
    curBranch = branch2;
    const id2 = branches[curBranch];
    head = commits[id2];
  }
};
function upsert(arr, key, newval) {
  const index2 = arr.indexOf(key);
  if (index2 === -1) {
    arr.push(newval);
  } else {
    arr.splice(index2, 1, newval);
  }
}
function prettyPrintCommitHistory(commitArr) {
  const commit2 = commitArr.reduce((out, commit3) => {
    if (out.seq > commit3.seq)
      return out;
    return commit3;
  }, commitArr[0]);
  let line2 = "";
  commitArr.forEach(function(c2) {
    if (c2 === commit2) {
      line2 += "	*";
    } else {
      line2 += "	|";
    }
  });
  const label = [line2, commit2.id, commit2.seq];
  for (let branch2 in branches) {
    if (branches[branch2] === commit2.id)
      label.push(branch2);
  }
  log$1.debug(label.join(" "));
  if (commit2.parents && commit2.parents.length == 2) {
    const newCommit = commits[commit2.parents[0]];
    upsert(commitArr, commit2, newCommit);
    commitArr.push(commits[commit2.parents[1]]);
  } else if (commit2.parents.length == 0) {
    return;
  } else {
    const nextCommit = commits[commit2.parents];
    upsert(commitArr, commit2, nextCommit);
  }
  commitArr = uniqBy(commitArr, (c2) => c2.id);
  prettyPrintCommitHistory(commitArr);
}
const prettyPrint = function() {
  log$1.debug(commits);
  const node2 = getCommitsArray()[0];
  prettyPrintCommitHistory([node2]);
};
const clear$f = function() {
  commits = {};
  head = null;
  let mainBranch = getConfig$1().gitGraph.mainBranchName;
  let mainBranchOrder2 = getConfig$1().gitGraph.mainBranchOrder;
  branches = {};
  branches[mainBranch] = null;
  branchesConfig = {};
  branchesConfig[mainBranch] = { name: mainBranch, order: mainBranchOrder2 };
  curBranch = mainBranch;
  seq = 0;
  clear$g();
};
const getBranchesAsObjArray = function() {
  const branchesArray = Object.values(branchesConfig).map((branchConfig, i) => {
    if (branchConfig.order !== null)
      return branchConfig;
    return {
      ...branchConfig,
      order: parseFloat(`0.${i}`, 10)
    };
  }).sort((a2, b) => a2.order - b.order).map(({ name: name2 }) => ({ name: name2 }));
  return branchesArray;
};
const getBranches = function() {
  return branches;
};
const getCommits = function() {
  return commits;
};
const getCommitsArray = function() {
  const commitArr = Object.keys(commits).map(function(key) {
    return commits[key];
  });
  commitArr.forEach(function(o) {
    log$1.debug(o.id);
  });
  commitArr.sort((a2, b) => a2.seq - b.seq);
  return commitArr;
};
const getCurrentBranch = function() {
  return curBranch;
};
const getDirection$3 = function() {
  return direction$3;
};
const getHead = function() {
  return head;
};
const commitType$1 = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
};
const gitGraphDb = {
  parseDirective: parseDirective$b,
  getConfig: () => getConfig$1().gitGraph,
  setDirection: setDirection$3,
  setOptions,
  getOptions,
  commit,
  branch,
  merge,
  cherryPick,
  checkout,
  prettyPrint,
  clear: clear$f,
  getBranchesAsObjArray,
  getBranches,
  getCommits,
  getCommitsArray,
  getCurrentBranch,
  getDirection: getDirection$3,
  getHead,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  commitType: commitType$1
};
function addSVGAccessibilityFields(yy_parser, svg2, id2) {
  if (typeof svg2.insert === "undefined") {
    return;
  }
  let title_string = yy_parser.getAccTitle();
  let description2 = yy_parser.getAccDescription();
  svg2.attr("role", "img").attr("aria-labelledby", "chart-title-" + id2 + " chart-desc-" + id2);
  svg2.insert("desc", ":first-child").attr("id", "chart-desc-" + id2).text(description2);
  svg2.insert("title", ":first-child").attr("id", "chart-title-" + id2).text(title_string);
}
let allCommitsDict = {};
const commitType = {
  NORMAL: 0,
  REVERSE: 1,
  HIGHLIGHT: 2,
  MERGE: 3,
  CHERRY_PICK: 4
};
const THEME_COLOR_LIMIT = 8;
let branchPos = {};
let commitPos = {};
let lanes = [];
let maxPos = 0;
const clear$e = () => {
  branchPos = {};
  commitPos = {};
  allCommitsDict = {};
  maxPos = 0;
  lanes = [];
};
const drawText$3 = (txt) => {
  const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
  let rows = [];
  if (typeof txt === "string") {
    rows = txt.split(/\\n|\n|<br\s*\/?>/gi);
  } else if (Array.isArray(txt)) {
    rows = txt;
  } else {
    rows = [];
  }
  for (let j = 0; j < rows.length; j++) {
    const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
    tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
    tspan.setAttribute("dy", "1em");
    tspan.setAttribute("x", "0");
    tspan.setAttribute("class", "row");
    tspan.textContent = rows[j].trim();
    svgLabel.appendChild(tspan);
  }
  return svgLabel;
};
const drawCommits = (svg2, commits2, modifyGraph) => {
  const gitGraphConfig = getConfig().gitGraph;
  const gBullets = svg2.append("g").attr("class", "commit-bullets");
  const gLabels = svg2.append("g").attr("class", "commit-labels");
  let pos = 0;
  const keys2 = Object.keys(commits2);
  const sortedKeys = keys2.sort((a2, b) => {
    return commits2[a2].seq - commits2[b].seq;
  });
  sortedKeys.forEach((key) => {
    const commit2 = commits2[key];
    const y2 = branchPos[commit2.branch].pos;
    const x2 = pos + 10;
    if (modifyGraph) {
      let typeClass;
      let commitSymbolType = typeof commit2.customType !== "undefined" && commit2.customType !== "" ? commit2.customType : commit2.type;
      switch (commitSymbolType) {
        case commitType.NORMAL:
          typeClass = "commit-normal";
          break;
        case commitType.REVERSE:
          typeClass = "commit-reverse";
          break;
        case commitType.HIGHLIGHT:
          typeClass = "commit-highlight";
          break;
        case commitType.MERGE:
          typeClass = "commit-merge";
          break;
        case commitType.CHERRY_PICK:
          typeClass = "commit-cherry-pick";
          break;
        default:
          typeClass = "commit-normal";
      }
      if (commitSymbolType === commitType.HIGHLIGHT) {
        const circle2 = gBullets.append("rect");
        circle2.attr("x", x2 - 10);
        circle2.attr("y", y2 - 10);
        circle2.attr("height", 20);
        circle2.attr("width", 20);
        circle2.attr(
          "class",
          `commit ${commit2.id} commit-highlight${branchPos[commit2.branch].index % THEME_COLOR_LIMIT} ${typeClass}-outer`
        );
        gBullets.append("rect").attr("x", x2 - 6).attr("y", y2 - 6).attr("height", 12).attr("width", 12).attr(
          "class",
          `commit ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT} ${typeClass}-inner`
        );
      } else if (commitSymbolType === commitType.CHERRY_PICK) {
        gBullets.append("circle").attr("cx", x2).attr("cy", y2).attr("r", 10).attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("circle").attr("cx", x2 - 3).attr("cy", y2 + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("circle").attr("cx", x2 + 3).attr("cy", y2 + 2).attr("r", 2.75).attr("fill", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("line").attr("x1", x2 + 3).attr("y1", y2 + 1).attr("x2", x2).attr("y2", y2 - 5).attr("stroke", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
        gBullets.append("line").attr("x1", x2 - 3).attr("y1", y2 + 1).attr("x2", x2).attr("y2", y2 - 5).attr("stroke", "#fff").attr("class", `commit ${commit2.id} ${typeClass}`);
      } else {
        const circle2 = gBullets.append("circle");
        circle2.attr("cx", x2);
        circle2.attr("cy", y2);
        circle2.attr("r", commit2.type === commitType.MERGE ? 9 : 10);
        circle2.attr(
          "class",
          `commit ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
        );
        if (commitSymbolType === commitType.MERGE) {
          const circle22 = gBullets.append("circle");
          circle22.attr("cx", x2);
          circle22.attr("cy", y2);
          circle22.attr("r", 6);
          circle22.attr(
            "class",
            `commit ${typeClass} ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
          );
        }
        if (commitSymbolType === commitType.REVERSE) {
          const cross2 = gBullets.append("path");
          cross2.attr("d", `M ${x2 - 5},${y2 - 5}L${x2 + 5},${y2 + 5}M${x2 - 5},${y2 + 5}L${x2 + 5},${y2 - 5}`).attr(
            "class",
            `commit ${typeClass} ${commit2.id} commit${branchPos[commit2.branch].index % THEME_COLOR_LIMIT}`
          );
        }
      }
    }
    commitPos[commit2.id] = { x: pos + 10, y: y2 };
    if (modifyGraph) {
      const px = 4;
      const py = 2;
      if (commit2.type !== commitType.CHERRY_PICK && (commit2.customId && commit2.type === commitType.MERGE || commit2.type !== commitType.MERGE) && gitGraphConfig.showCommitLabel) {
        const wrapper = gLabels.append("g");
        const labelBkg = wrapper.insert("rect").attr("class", "commit-label-bkg");
        const text2 = wrapper.append("text").attr("x", pos).attr("y", y2 + 25).attr("class", "commit-label").text(commit2.id);
        let bbox = text2.node().getBBox();
        labelBkg.attr("x", pos + 10 - bbox.width / 2 - py).attr("y", y2 + 13.5).attr("width", bbox.width + 2 * py).attr("height", bbox.height + 2 * py);
        text2.attr("x", pos + 10 - bbox.width / 2);
        if (gitGraphConfig.rotateCommitLabel) {
          let r_x = -7.5 - (bbox.width + 10) / 25 * 9.5;
          let r_y = 10 + bbox.width / 25 * 8.5;
          wrapper.attr(
            "transform",
            "translate(" + r_x + ", " + r_y + ") rotate(" + -45 + ", " + pos + ", " + y2 + ")"
          );
        }
      }
      if (commit2.tag) {
        const rect2 = gLabels.insert("polygon");
        const hole = gLabels.append("circle");
        const tag = gLabels.append("text").attr("y", y2 - 16).attr("class", "tag-label").text(commit2.tag);
        let tagBbox = tag.node().getBBox();
        tag.attr("x", pos + 10 - tagBbox.width / 2);
        const h2 = tagBbox.height / 2;
        const ly = y2 - 19.2;
        rect2.attr("class", "tag-label-bkg").attr(
          "points",
          `
          ${pos - tagBbox.width / 2 - px / 2},${ly + py}
          ${pos - tagBbox.width / 2 - px / 2},${ly - py}
          ${pos + 10 - tagBbox.width / 2 - px},${ly - h2 - py}
          ${pos + 10 + tagBbox.width / 2 + px},${ly - h2 - py}
          ${pos + 10 + tagBbox.width / 2 + px},${ly + h2 + py}
          ${pos + 10 - tagBbox.width / 2 - px},${ly + h2 + py}`
        );
        hole.attr("cx", pos - tagBbox.width / 2 + px / 2).attr("cy", ly).attr("r", 1.5).attr("class", "tag-hole");
      }
    }
    pos += 50;
    if (pos > maxPos) {
      maxPos = pos;
    }
  });
};
const hasOverlappingCommits = (commit1, commit2, allCommits) => {
  const keys2 = Object.keys(allCommits);
  const overlappingComits = keys2.filter((key) => {
    return allCommits[key].branch === commit2.branch && allCommits[key].seq > commit1.seq && allCommits[key].seq < commit2.seq;
  });
  return overlappingComits.length > 0;
};
const findLane = (y12, y2, _depth) => {
  const depth = _depth || 0;
  const candidate = y12 + Math.abs(y12 - y2) / 2;
  if (depth > 5) {
    return candidate;
  }
  let ok = true;
  for (let i = 0; i < lanes.length; i++) {
    if (Math.abs(lanes[i] - candidate) < 10) {
      ok = false;
    }
  }
  if (ok) {
    lanes.push(candidate);
    return candidate;
  }
  const diff = Math.abs(y12 - y2);
  return findLane(y12, y2 - diff / 5, depth + 1);
};
const drawArrow = (svg2, commit1, commit2, allCommits) => {
  const p1 = commitPos[commit1.id];
  const p2 = commitPos[commit2.id];
  const overlappingCommits = hasOverlappingCommits(commit1, commit2, allCommits);
  let arc2 = "";
  let arc22 = "";
  let radius = 0;
  let offset = 0;
  let colorClassNum = branchPos[commit2.branch].index;
  let lineDef;
  if (overlappingCommits) {
    arc2 = "A 10 10, 0, 0, 0,";
    arc22 = "A 10 10, 0, 0, 1,";
    radius = 10;
    offset = 10;
    colorClassNum = branchPos[commit2.branch].index;
    const lineY = p1.y < p2.y ? findLane(p1.y, p2.y) : findLane(p2.y, p1.y);
    if (p1.y < p2.y) {
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${lineY - radius} ${arc2} ${p1.x + offset} ${lineY} L ${p2.x - radius} ${lineY} ${arc22} ${p2.x} ${lineY + offset} L ${p2.x} ${p2.y}`;
    } else {
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${lineY + radius} ${arc22} ${p1.x + offset} ${lineY} L ${p2.x - radius} ${lineY} ${arc2} ${p2.x} ${lineY - offset} L ${p2.x} ${p2.y}`;
    }
  } else {
    if (p1.y < p2.y) {
      arc2 = "A 20 20, 0, 0, 0,";
      radius = 20;
      offset = 20;
      colorClassNum = branchPos[commit2.branch].index;
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${p2.y - radius} ${arc2} ${p1.x + offset} ${p2.y} L ${p2.x} ${p2.y}`;
    }
    if (p1.y > p2.y) {
      arc2 = "A 20 20, 0, 0, 0,";
      radius = 20;
      offset = 20;
      colorClassNum = branchPos[commit1.branch].index;
      lineDef = `M ${p1.x} ${p1.y} L ${p2.x - radius} ${p1.y} ${arc2} ${p2.x} ${p1.y - offset} L ${p2.x} ${p2.y}`;
    }
    if (p1.y === p2.y) {
      colorClassNum = branchPos[commit1.branch].index;
      lineDef = `M ${p1.x} ${p1.y} L ${p1.x} ${p2.y - radius} ${arc2} ${p1.x + offset} ${p2.y} L ${p2.x} ${p2.y}`;
    }
  }
  svg2.append("path").attr("d", lineDef).attr("class", "arrow arrow" + colorClassNum % THEME_COLOR_LIMIT);
};
const drawArrows = (svg2, commits2) => {
  const gArrows = svg2.append("g").attr("class", "commit-arrows");
  Object.keys(commits2).forEach((key) => {
    const commit2 = commits2[key];
    if (commit2.parents && commit2.parents.length > 0) {
      commit2.parents.forEach((parent) => {
        drawArrow(gArrows, commits2[parent], commit2, commits2);
      });
    }
  });
};
const drawBranches = (svg2, branches2) => {
  const gitGraphConfig = getConfig().gitGraph;
  const g = svg2.append("g");
  branches2.forEach((branch2, index2) => {
    const adjustIndexForTheme = index2 % THEME_COLOR_LIMIT;
    const pos = branchPos[branch2.name].pos;
    const line2 = g.append("line");
    line2.attr("x1", 0);
    line2.attr("y1", pos);
    line2.attr("x2", maxPos);
    line2.attr("y2", pos);
    line2.attr("class", "branch branch" + adjustIndexForTheme);
    lanes.push(pos);
    let name2 = branch2.name;
    const labelElement = drawText$3(name2);
    const bkg = g.insert("rect");
    const branchLabel = g.insert("g").attr("class", "branchLabel");
    const label = branchLabel.insert("g").attr("class", "label branch-label" + adjustIndexForTheme);
    label.node().appendChild(labelElement);
    let bbox = labelElement.getBBox();
    bkg.attr("class", "branchLabelBkg label" + adjustIndexForTheme).attr("rx", 4).attr("ry", 4).attr("x", -bbox.width - 4 - (gitGraphConfig.rotateCommitLabel === true ? 30 : 0)).attr("y", -bbox.height / 2 + 8).attr("width", bbox.width + 18).attr("height", bbox.height + 4);
    label.attr(
      "transform",
      "translate(" + (-bbox.width - 14 - (gitGraphConfig.rotateCommitLabel === true ? 30 : 0)) + ", " + (pos - bbox.height / 2 - 1) + ")"
    );
    bkg.attr("transform", "translate(" + -19 + ", " + (pos - bbox.height / 2) + ")");
  });
};
const draw$f = function(txt, id2, ver, diagObj) {
  clear$e();
  const conf2 = getConfig();
  const gitGraphConfig = getConfig().gitGraph;
  log$1.debug("in gitgraph renderer", txt + "\n", "id:", id2, ver);
  allCommitsDict = diagObj.db.getCommits();
  const branches2 = diagObj.db.getBranchesAsObjArray();
  let pos = 0;
  branches2.forEach((branch2, index2) => {
    branchPos[branch2.name] = { pos, index: index2 };
    pos += 50 + (gitGraphConfig.rotateCommitLabel ? 40 : 0);
  });
  const diagram = select$1(`[id="${id2}"]`);
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
  drawCommits(diagram, allCommitsDict, false);
  if (gitGraphConfig.showBranches) {
    drawBranches(diagram, branches2);
  }
  drawArrows(diagram, allCommitsDict);
  drawCommits(diagram, allCommitsDict, true);
  setupGraphViewbox(void 0, diagram, gitGraphConfig.diagramPadding, conf2.useMaxWidth);
};
const gitGraphRenderer = {
  draw: draw$f
};
const getStyles = (options2) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
  (i) => `
        .branch-label${i} { fill: ${options2["gitBranchLabel" + i]}; }
        .commit${i} { stroke: ${options2["git" + i]}; fill: ${options2["git" + i]}; }
        .commit-highlight${i} { stroke: ${options2["gitInv" + i]}; fill: ${options2["gitInv" + i]}; }
        .label${i}  { fill: ${options2["git" + i]}; }
        .arrow${i} { stroke: ${options2["git" + i]}; }
        `
).join("\n")}

  .branch {
    stroke-width: 1;
    stroke: ${options2.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${options2.commitLabelFontSize}; fill: ${options2.commitLabelColor};}
  .commit-label-bkg { font-size: ${options2.commitLabelFontSize}; fill: ${options2.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${options2.tagLabelFontSize}; fill: ${options2.tagLabelColor};}
  .tag-label-bkg { fill: ${options2.tagLabelBackground}; stroke: ${options2.tagLabelBorder}; }
  .tag-hole { fill: ${options2.textColor}; }

  .commit-merge {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
  }
  .commit-reverse {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${options2.primaryColor};
    fill: ${options2.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  }
`;
var parser$a = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 6], $V1 = [1, 7], $V2 = [1, 8], $V3 = [1, 9], $V4 = [1, 16], $V5 = [1, 11], $V6 = [1, 12], $V7 = [1, 13], $V8 = [1, 14], $V9 = [1, 15], $Va = [1, 27], $Vb = [1, 33], $Vc = [1, 34], $Vd = [1, 35], $Ve = [1, 36], $Vf = [1, 37], $Vg = [1, 72], $Vh = [1, 73], $Vi = [1, 74], $Vj = [1, 75], $Vk = [1, 76], $Vl = [1, 77], $Vm = [1, 78], $Vn = [1, 38], $Vo = [1, 39], $Vp = [1, 40], $Vq = [1, 41], $Vr = [1, 42], $Vs = [1, 43], $Vt = [1, 44], $Vu = [1, 45], $Vv = [1, 46], $Vw = [1, 47], $Vx = [1, 48], $Vy = [1, 49], $Vz = [1, 50], $VA = [1, 51], $VB = [1, 52], $VC = [1, 53], $VD = [1, 54], $VE = [1, 55], $VF = [1, 56], $VG = [1, 57], $VH = [1, 59], $VI = [1, 60], $VJ = [1, 61], $VK = [1, 62], $VL = [1, 63], $VM = [1, 64], $VN = [1, 65], $VO = [1, 66], $VP = [1, 67], $VQ = [1, 68], $VR = [1, 69], $VS = [24, 52], $VT = [24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], $VU = [15, 24, 44, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84], $VV = [1, 94], $VW = [1, 95], $VX = [1, 96], $VY = [1, 97], $VZ = [15, 24, 52], $V_ = [7, 8, 9, 10, 18, 22, 25, 26, 27, 28], $V$ = [15, 24, 43, 52], $V01 = [15, 24, 43, 52, 86, 87, 89, 90], $V11 = [15, 43], $V21 = [44, 46, 47, 48, 49, 50, 51, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "direction": 5, "directive": 6, "direction_tb": 7, "direction_bt": 8, "direction_rl": 9, "direction_lr": 10, "graphConfig": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, "NEWLINE": 15, ":": 16, "argDirective": 17, "open_directive": 18, "type_directive": 19, "arg_directive": 20, "close_directive": 21, "C4_CONTEXT": 22, "statements": 23, "EOF": 24, "C4_CONTAINER": 25, "C4_COMPONENT": 26, "C4_DYNAMIC": 27, "C4_DEPLOYMENT": 28, "otherStatements": 29, "diagramStatements": 30, "otherStatement": 31, "title": 32, "accDescription": 33, "acc_title": 34, "acc_title_value": 35, "acc_descr": 36, "acc_descr_value": 37, "acc_descr_multiline_value": 38, "boundaryStatement": 39, "boundaryStartStatement": 40, "boundaryStopStatement": 41, "boundaryStart": 42, "LBRACE": 43, "ENTERPRISE_BOUNDARY": 44, "attributes": 45, "SYSTEM_BOUNDARY": 46, "BOUNDARY": 47, "CONTAINER_BOUNDARY": 48, "NODE": 49, "NODE_L": 50, "NODE_R": 51, "RBRACE": 52, "diagramStatement": 53, "PERSON": 54, "PERSON_EXT": 55, "SYSTEM": 56, "SYSTEM_DB": 57, "SYSTEM_QUEUE": 58, "SYSTEM_EXT": 59, "SYSTEM_EXT_DB": 60, "SYSTEM_EXT_QUEUE": 61, "CONTAINER": 62, "CONTAINER_DB": 63, "CONTAINER_QUEUE": 64, "CONTAINER_EXT": 65, "CONTAINER_EXT_DB": 66, "CONTAINER_EXT_QUEUE": 67, "COMPONENT": 68, "COMPONENT_DB": 69, "COMPONENT_QUEUE": 70, "COMPONENT_EXT": 71, "COMPONENT_EXT_DB": 72, "COMPONENT_EXT_QUEUE": 73, "REL": 74, "BIREL": 75, "REL_U": 76, "REL_D": 77, "REL_L": 78, "REL_R": 79, "REL_B": 80, "REL_INDEX": 81, "UPDATE_EL_STYLE": 82, "UPDATE_REL_STYLE": 83, "UPDATE_LAYOUT_CONFIG": 84, "attribute": 85, "STR": 86, "STR_KEY": 87, "STR_VALUE": 88, "ATTRIBUTE": 89, "ATTRIBUTE_EMPTY": 90, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 7: "direction_tb", 8: "direction_bt", 9: "direction_rl", 10: "direction_lr", 15: "NEWLINE", 16: ":", 18: "open_directive", 19: "type_directive", 20: "arg_directive", 21: "close_directive", 22: "C4_CONTEXT", 24: "EOF", 25: "C4_CONTAINER", 26: "C4_COMPONENT", 27: "C4_DYNAMIC", 28: "C4_DEPLOYMENT", 32: "title", 33: "accDescription", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 43: "LBRACE", 44: "ENTERPRISE_BOUNDARY", 46: "SYSTEM_BOUNDARY", 47: "BOUNDARY", 48: "CONTAINER_BOUNDARY", 49: "NODE", 50: "NODE_L", 51: "NODE_R", 52: "RBRACE", 54: "PERSON", 55: "PERSON_EXT", 56: "SYSTEM", 57: "SYSTEM_DB", 58: "SYSTEM_QUEUE", 59: "SYSTEM_EXT", 60: "SYSTEM_EXT_DB", 61: "SYSTEM_EXT_QUEUE", 62: "CONTAINER", 63: "CONTAINER_DB", 64: "CONTAINER_QUEUE", 65: "CONTAINER_EXT", 66: "CONTAINER_EXT_DB", 67: "CONTAINER_EXT_QUEUE", 68: "COMPONENT", 69: "COMPONENT_DB", 70: "COMPONENT_QUEUE", 71: "COMPONENT_EXT", 72: "COMPONENT_EXT_DB", 73: "COMPONENT_EXT_QUEUE", 74: "REL", 75: "BIREL", 76: "REL_U", 77: "REL_D", 78: "REL_L", 79: "REL_R", 80: "REL_B", 81: "REL_INDEX", 82: "UPDATE_EL_STYLE", 83: "UPDATE_REL_STYLE", 84: "UPDATE_LAYOUT_CONFIG", 86: "STR", 87: "STR_KEY", 88: "STR_VALUE", 89: "ATTRIBUTE", 90: "ATTRIBUTE_EMPTY" },
    productions_: [0, [3, 1], [3, 1], [3, 2], [5, 1], [5, 1], [5, 1], [5, 1], [4, 1], [6, 4], [6, 6], [12, 1], [13, 1], [17, 1], [14, 1], [11, 4], [11, 4], [11, 4], [11, 4], [11, 4], [23, 1], [23, 1], [23, 2], [29, 1], [29, 2], [29, 3], [31, 1], [31, 1], [31, 2], [31, 2], [31, 1], [39, 3], [40, 3], [40, 3], [40, 4], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [42, 2], [41, 1], [30, 1], [30, 2], [30, 3], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 1], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [53, 2], [45, 1], [45, 2], [85, 1], [85, 2], [85, 1], [85, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.setDirection("TB");
          break;
        case 5:
          yy.setDirection("BT");
          break;
        case 6:
          yy.setDirection("RL");
          break;
        case 7:
          yy.setDirection("LR");
          break;
        case 11:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 12:
          break;
        case 13:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 14:
          yy.parseDirective("}%%", "close_directive", "c4Context");
          break;
        case 15:
        case 16:
        case 17:
        case 18:
        case 19:
          yy.setC4Type($$[$0 - 3]);
          break;
        case 26:
          yy.setTitle($$[$0].substring(6));
          this.$ = $$[$0].substring(6);
          break;
        case 27:
          yy.setAccDescription($$[$0].substring(15));
          this.$ = $$[$0].substring(15);
          break;
        case 28:
          this.$ = $$[$0].trim();
          yy.setTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 35:
        case 36:
          $$[$0].splice(2, 0, "ENTERPRISE");
          yy.addPersonOrSystemBoundary(...$$[$0]);
          this.$ = $$[$0];
          break;
        case 37:
          yy.addPersonOrSystemBoundary(...$$[$0]);
          this.$ = $$[$0];
          break;
        case 38:
          $$[$0].splice(2, 0, "CONTAINER");
          yy.addContainerBoundary(...$$[$0]);
          this.$ = $$[$0];
          break;
        case 39:
          yy.addDeploymentNode("node", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 40:
          yy.addDeploymentNode("nodeL", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 41:
          yy.addDeploymentNode("nodeR", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 42:
          yy.popBoundaryParseStack();
          break;
        case 46:
          yy.addPersonOrSystem("person", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 47:
          yy.addPersonOrSystem("external_person", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 48:
          yy.addPersonOrSystem("system", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 49:
          yy.addPersonOrSystem("system_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 50:
          yy.addPersonOrSystem("system_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 51:
          yy.addPersonOrSystem("external_system", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 52:
          yy.addPersonOrSystem("external_system_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 53:
          yy.addPersonOrSystem("external_system_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 54:
          yy.addContainer("container", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 55:
          yy.addContainer("container_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 56:
          yy.addContainer("container_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 57:
          yy.addContainer("external_container", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 58:
          yy.addContainer("external_container_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 59:
          yy.addContainer("external_container_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 60:
          yy.addComponent("component", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 61:
          yy.addComponent("component_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 62:
          yy.addComponent("component_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 63:
          yy.addComponent("external_component", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 64:
          yy.addComponent("external_component_db", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 65:
          yy.addComponent("external_component_queue", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 67:
          yy.addRel("rel", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 68:
          yy.addRel("birel", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 69:
          yy.addRel("rel_u", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 70:
          yy.addRel("rel_d", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 71:
          yy.addRel("rel_l", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 72:
          yy.addRel("rel_r", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 73:
          yy.addRel("rel_b", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 74:
          $$[$0].splice(0, 1);
          yy.addRel("rel", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 75:
          yy.updateElStyle("update_el_style", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 76:
          yy.updateRelStyle("update_rel_style", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 77:
          yy.updateLayoutConfig("update_layout_config", ...$$[$0]);
          this.$ = $$[$0];
          break;
        case 78:
          this.$ = [$$[$0]];
          break;
        case 79:
          $$[$0].unshift($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 80:
        case 82:
          this.$ = $$[$0].trim();
          break;
        case 81:
          let kv = {};
          kv[$$[$0 - 1].trim()] = $$[$0].trim();
          this.$ = kv;
          break;
        case 83:
          this.$ = "";
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 4, 7: $V0, 8: $V1, 9: $V2, 10: $V3, 11: 5, 12: 10, 18: $V4, 22: $V5, 25: $V6, 26: $V7, 27: $V8, 28: $V9 }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 3: 17, 4: 2, 5: 3, 6: 4, 7: $V0, 8: $V1, 9: $V2, 10: $V3, 11: 5, 12: 10, 18: $V4, 22: $V5, 25: $V6, 26: $V7, 27: $V8, 28: $V9 }, { 1: [2, 8] }, { 1: [2, 4] }, { 1: [2, 5] }, { 1: [2, 6] }, { 1: [2, 7] }, { 13: 18, 19: [1, 19] }, { 15: [1, 20] }, { 15: [1, 21] }, { 15: [1, 22] }, { 15: [1, 23] }, { 15: [1, 24] }, { 19: [2, 11] }, { 1: [2, 3] }, { 14: 25, 16: [1, 26], 21: $Va }, o([16, 21], [2, 12]), { 23: 28, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 79, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 80, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 81, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 23: 82, 29: 29, 30: 30, 31: 31, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 15: [1, 83] }, { 17: 84, 20: [1, 85] }, { 15: [2, 14] }, { 24: [1, 86] }, o($VS, [2, 20], { 53: 32, 39: 58, 40: 70, 42: 71, 30: 87, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }), o($VS, [2, 21]), o($VT, [2, 23], { 15: [1, 88] }), o($VS, [2, 43], { 15: [1, 89] }), o($VU, [2, 26]), o($VU, [2, 27]), { 35: [1, 90] }, { 37: [1, 91] }, o($VU, [2, 30]), { 45: 92, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 98, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 99, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 100, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 101, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 102, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 103, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 104, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 105, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 106, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 107, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 108, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 109, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 110, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 111, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 112, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 113, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 114, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 115, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 116, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, o($VZ, [2, 66]), { 45: 117, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 118, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 119, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 120, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 121, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 122, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 123, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 124, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 125, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 126, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 127, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 30: 128, 39: 58, 40: 70, 42: 71, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 53: 32, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }, { 15: [1, 130], 43: [1, 129] }, { 45: 131, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 132, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 133, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 134, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 135, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 136, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 45: 137, 85: 93, 86: $VV, 87: $VW, 89: $VX, 90: $VY }, { 24: [1, 138] }, { 24: [1, 139] }, { 24: [1, 140] }, { 24: [1, 141] }, o($V_, [2, 9]), { 14: 142, 21: $Va }, { 21: [2, 13] }, { 1: [2, 15] }, o($VS, [2, 22]), o($VT, [2, 24], { 31: 31, 29: 143, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf }), o($VS, [2, 44], { 29: 29, 30: 30, 31: 31, 53: 32, 39: 58, 40: 70, 42: 71, 23: 144, 32: $Vb, 33: $Vc, 34: $Vd, 36: $Ve, 38: $Vf, 44: $Vg, 46: $Vh, 47: $Vi, 48: $Vj, 49: $Vk, 50: $Vl, 51: $Vm, 54: $Vn, 55: $Vo, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv, 63: $Vw, 64: $Vx, 65: $Vy, 66: $Vz, 67: $VA, 68: $VB, 69: $VC, 70: $VD, 71: $VE, 72: $VF, 73: $VG, 74: $VH, 75: $VI, 76: $VJ, 77: $VK, 78: $VL, 79: $VM, 80: $VN, 81: $VO, 82: $VP, 83: $VQ, 84: $VR }), o($VU, [2, 28]), o($VU, [2, 29]), o($VZ, [2, 46]), o($V$, [2, 78], { 85: 93, 45: 145, 86: $VV, 87: $VW, 89: $VX, 90: $VY }), o($V01, [2, 80]), { 88: [1, 146] }, o($V01, [2, 82]), o($V01, [2, 83]), o($VZ, [2, 47]), o($VZ, [2, 48]), o($VZ, [2, 49]), o($VZ, [2, 50]), o($VZ, [2, 51]), o($VZ, [2, 52]), o($VZ, [2, 53]), o($VZ, [2, 54]), o($VZ, [2, 55]), o($VZ, [2, 56]), o($VZ, [2, 57]), o($VZ, [2, 58]), o($VZ, [2, 59]), o($VZ, [2, 60]), o($VZ, [2, 61]), o($VZ, [2, 62]), o($VZ, [2, 63]), o($VZ, [2, 64]), o($VZ, [2, 65]), o($VZ, [2, 67]), o($VZ, [2, 68]), o($VZ, [2, 69]), o($VZ, [2, 70]), o($VZ, [2, 71]), o($VZ, [2, 72]), o($VZ, [2, 73]), o($VZ, [2, 74]), o($VZ, [2, 75]), o($VZ, [2, 76]), o($VZ, [2, 77]), { 41: 147, 52: [1, 148] }, { 15: [1, 149] }, { 43: [1, 150] }, o($V11, [2, 35]), o($V11, [2, 36]), o($V11, [2, 37]), o($V11, [2, 38]), o($V11, [2, 39]), o($V11, [2, 40]), o($V11, [2, 41]), { 1: [2, 16] }, { 1: [2, 17] }, { 1: [2, 18] }, { 1: [2, 19] }, { 15: [1, 151] }, o($VT, [2, 25]), o($VS, [2, 45]), o($V$, [2, 79]), o($V01, [2, 81]), o($VZ, [2, 31]), o($VZ, [2, 42]), o($V21, [2, 32]), o($V21, [2, 33], { 15: [1, 152] }), o($V_, [2, 10]), o($V21, [2, 34])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 5: [2, 8], 6: [2, 4], 7: [2, 5], 8: [2, 6], 9: [2, 7], 16: [2, 11], 17: [2, 3], 27: [2, 14], 85: [2, 13], 86: [2, 15], 138: [2, 16], 139: [2, 17], 140: [2, 18], 141: [2, 19] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 18;
          case 1:
            return 7;
          case 2:
            return 8;
          case 3:
            return 9;
          case 4:
            return 10;
          case 5:
            this.begin("type_directive");
            return 19;
          case 6:
            this.popState();
            this.begin("arg_directive");
            return 16;
          case 7:
            this.popState();
            this.popState();
            return 21;
          case 8:
            return 20;
          case 9:
            return 32;
          case 10:
            return 33;
          case 11:
            this.begin("acc_title");
            return 34;
          case 12:
            this.popState();
            return "acc_title_value";
          case 13:
            this.begin("acc_descr");
            return 36;
          case 14:
            this.popState();
            return "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            break;
          case 19:
            c;
            break;
          case 20:
            return 15;
          case 21:
            break;
          case 22:
            return 22;
          case 23:
            return 25;
          case 24:
            return 26;
          case 25:
            return 27;
          case 26:
            return 28;
          case 27:
            this.begin("person_ext");
            return 55;
          case 28:
            this.begin("person");
            return 54;
          case 29:
            this.begin("system_ext_queue");
            return 61;
          case 30:
            this.begin("system_ext_db");
            return 60;
          case 31:
            this.begin("system_ext");
            return 59;
          case 32:
            this.begin("system_queue");
            return 58;
          case 33:
            this.begin("system_db");
            return 57;
          case 34:
            this.begin("system");
            return 56;
          case 35:
            this.begin("boundary");
            return 47;
          case 36:
            this.begin("enterprise_boundary");
            return 44;
          case 37:
            this.begin("system_boundary");
            return 46;
          case 38:
            this.begin("container_ext_queue");
            return 67;
          case 39:
            this.begin("container_ext_db");
            return 66;
          case 40:
            this.begin("container_ext");
            return 65;
          case 41:
            this.begin("container_queue");
            return 64;
          case 42:
            this.begin("container_db");
            return 63;
          case 43:
            this.begin("container");
            return 62;
          case 44:
            this.begin("container_boundary");
            return 48;
          case 45:
            this.begin("component_ext_queue");
            return 73;
          case 46:
            this.begin("component_ext_db");
            return 72;
          case 47:
            this.begin("component_ext");
            return 71;
          case 48:
            this.begin("component_queue");
            return 70;
          case 49:
            this.begin("component_db");
            return 69;
          case 50:
            this.begin("component");
            return 68;
          case 51:
            this.begin("node");
            return 49;
          case 52:
            this.begin("node");
            return 49;
          case 53:
            this.begin("node_l");
            return 50;
          case 54:
            this.begin("node_r");
            return 51;
          case 55:
            this.begin("rel");
            return 74;
          case 56:
            this.begin("birel");
            return 75;
          case 57:
            this.begin("rel_u");
            return 76;
          case 58:
            this.begin("rel_u");
            return 76;
          case 59:
            this.begin("rel_d");
            return 77;
          case 60:
            this.begin("rel_d");
            return 77;
          case 61:
            this.begin("rel_l");
            return 78;
          case 62:
            this.begin("rel_l");
            return 78;
          case 63:
            this.begin("rel_r");
            return 79;
          case 64:
            this.begin("rel_r");
            return 79;
          case 65:
            this.begin("rel_b");
            return 80;
          case 66:
            this.begin("rel_index");
            return 81;
          case 67:
            this.begin("update_el_style");
            return 82;
          case 68:
            this.begin("update_rel_style");
            return 83;
          case 69:
            this.begin("update_layout_config");
            return 84;
          case 70:
            return "EOF_IN_STRUCT";
          case 71:
            this.begin("attribute");
            return "ATTRIBUTE_EMPTY";
          case 72:
            this.begin("attribute");
            break;
          case 73:
            this.popState();
            this.popState();
            break;
          case 74:
            return 90;
          case 75:
            break;
          case 76:
            return 90;
          case 77:
            this.begin("string");
            break;
          case 78:
            this.popState();
            break;
          case 79:
            return "STR";
          case 80:
            this.begin("string_kv");
            break;
          case 81:
            this.begin("string_kv_key");
            return "STR_KEY";
          case 82:
            this.popState();
            this.begin("string_kv_value");
            break;
          case 83:
            return "STR_VALUE";
          case 84:
            this.popState();
            this.popState();
            break;
          case 85:
            return "STR";
          case 86:
            return "LBRACE";
          case 87:
            return "RBRACE";
          case 88:
            return "SPACE";
          case 89:
            return "EOL";
          case 90:
            return 24;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:title\s[^#\n;]+)/, /^(?:accDescription\s[^#\n;]+)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:C4Context\b)/, /^(?:C4Container\b)/, /^(?:C4Component\b)/, /^(?:C4Dynamic\b)/, /^(?:C4Deployment\b)/, /^(?:Person_Ext\b)/, /^(?:Person\b)/, /^(?:SystemQueue_Ext\b)/, /^(?:SystemDb_Ext\b)/, /^(?:System_Ext\b)/, /^(?:SystemQueue\b)/, /^(?:SystemDb\b)/, /^(?:System\b)/, /^(?:Boundary\b)/, /^(?:Enterprise_Boundary\b)/, /^(?:System_Boundary\b)/, /^(?:ContainerQueue_Ext\b)/, /^(?:ContainerDb_Ext\b)/, /^(?:Container_Ext\b)/, /^(?:ContainerQueue\b)/, /^(?:ContainerDb\b)/, /^(?:Container\b)/, /^(?:Container_Boundary\b)/, /^(?:ComponentQueue_Ext\b)/, /^(?:ComponentDb_Ext\b)/, /^(?:Component_Ext\b)/, /^(?:ComponentQueue\b)/, /^(?:ComponentDb\b)/, /^(?:Component\b)/, /^(?:Deployment_Node\b)/, /^(?:Node\b)/, /^(?:Node_L\b)/, /^(?:Node_R\b)/, /^(?:Rel\b)/, /^(?:BiRel\b)/, /^(?:Rel_Up\b)/, /^(?:Rel_U\b)/, /^(?:Rel_Down\b)/, /^(?:Rel_D\b)/, /^(?:Rel_Left\b)/, /^(?:Rel_L\b)/, /^(?:Rel_Right\b)/, /^(?:Rel_R\b)/, /^(?:Rel_Back\b)/, /^(?:RelIndex\b)/, /^(?:UpdateElementStyle\b)/, /^(?:UpdateRelStyle\b)/, /^(?:UpdateLayoutConfig\b)/, /^(?:$)/, /^(?:[(][ ]*[,])/, /^(?:[(])/, /^(?:[)])/, /^(?:,,)/, /^(?:,)/, /^(?:[ ]*["]["])/, /^(?:[ ]*["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[ ]*[\$])/, /^(?:[^=]*)/, /^(?:[=][ ]*["])/, /^(?:[^"]+)/, /^(?:["])/, /^(?:[^,]+)/, /^(?:\{)/, /^(?:\})/, /^(?:[\s]+)/, /^(?:[\n\r]+)/, /^(?:$)/],
      conditions: { "acc_descr_multiline": { "rules": [16, 17], "inclusive": false }, "acc_descr": { "rules": [14], "inclusive": false }, "acc_title": { "rules": [12], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [7, 8], "inclusive": false }, "type_directive": { "rules": [6, 7], "inclusive": false }, "open_directive": { "rules": [5], "inclusive": false }, "string_kv_value": { "rules": [83, 84], "inclusive": false }, "string_kv_key": { "rules": [82], "inclusive": false }, "string_kv": { "rules": [81], "inclusive": false }, "string": { "rules": [78, 79], "inclusive": false }, "attribute": { "rules": [73, 74, 75, 76, 77, 80, 85], "inclusive": false }, "update_layout_config": { "rules": [70, 71, 72, 73], "inclusive": false }, "update_rel_style": { "rules": [70, 71, 72, 73], "inclusive": false }, "update_el_style": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_b": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_r": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_l": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_d": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_u": { "rules": [70, 71, 72, 73], "inclusive": false }, "rel_bi": { "rules": [], "inclusive": false }, "rel": { "rules": [70, 71, 72, 73], "inclusive": false }, "node_r": { "rules": [70, 71, 72, 73], "inclusive": false }, "node_l": { "rules": [70, 71, 72, 73], "inclusive": false }, "node": { "rules": [70, 71, 72, 73], "inclusive": false }, "index": { "rules": [], "inclusive": false }, "rel_index": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_ext_queue": { "rules": [], "inclusive": false }, "component_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "component_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "component": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_ext_queue": { "rules": [], "inclusive": false }, "container_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "container_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "container": { "rules": [70, 71, 72, 73], "inclusive": false }, "birel": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "enterprise_boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "boundary": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_queue": { "rules": [70, 71, 72, 73], "inclusive": false }, "system_db": { "rules": [70, 71, 72, 73], "inclusive": false }, "system": { "rules": [70, 71, 72, 73], "inclusive": false }, "person_ext": { "rules": [70, 71, 72, 73], "inclusive": false }, "person": { "rules": [70, 71, 72, 73], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 86, 87, 88, 89, 90], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$a.parser = parser$a;
const c4Detector = (txt) => {
  return txt.match(/^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/) !== null;
};
let c4ShapeArray = [];
let boundaryParseStack = [""];
let currentBoundaryParse = "global";
let parentBoundaryParse = "";
let boundarys = [
  {
    alias: "global",
    label: { text: "global" },
    type: { text: "global" },
    tags: null,
    link: null,
    parentBoundary: ""
  }
];
let rels = [];
let title = "";
let wrapEnabled$1 = false;
let c4ShapeInRow$1 = 4;
let c4BoundaryInRow$1 = 2;
var c4Type;
const getC4Type = function() {
  return c4Type;
};
const setC4Type = function(c4TypeParam) {
  let sanitizedText = sanitizeText$5(c4TypeParam, getConfig$1());
  c4Type = sanitizedText;
};
const parseDirective$a = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addRel = function(type2, from2, to, label, techn, descr, sprite, tags2, link2) {
  if (type2 === void 0 || type2 === null || from2 === void 0 || from2 === null || to === void 0 || to === null || label === void 0 || label === null)
    return;
  let rel = {};
  const old = rels.find((rel2) => rel2.from === from2 && rel2.to === to);
  if (old) {
    rel = old;
  } else {
    rels.push(rel);
  }
  rel.type = type2;
  rel.from = from2;
  rel.to = to;
  rel.label = { text: label };
  if (techn === void 0 || techn === null) {
    rel.techn = { text: "" };
  } else {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      rel[key] = { text: value };
    } else {
      rel.techn = { text: techn };
    }
  }
  if (descr === void 0 || descr === null) {
    rel.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      rel[key] = { text: value };
    } else {
      rel.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    rel[key] = value;
  } else {
    rel.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    rel[key] = value;
  } else {
    rel.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    rel[key] = value;
  } else {
    rel.link = link2;
  }
  rel.wrap = autoWrap$1();
};
const addPersonOrSystem = function(typeC4Shape, alias, label, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let personOrSystem = {};
  const old = c4ShapeArray.find((personOrSystem2) => personOrSystem2.alias === alias);
  if (old && alias === old.alias) {
    personOrSystem = old;
  } else {
    personOrSystem.alias = alias;
    c4ShapeArray.push(personOrSystem);
  }
  if (label === void 0 || label === null) {
    personOrSystem.label = { text: "" };
  } else {
    personOrSystem.label = { text: label };
  }
  if (descr === void 0 || descr === null) {
    personOrSystem.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      personOrSystem[key] = { text: value };
    } else {
      personOrSystem.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    personOrSystem[key] = value;
  } else {
    personOrSystem.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    personOrSystem[key] = value;
  } else {
    personOrSystem.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    personOrSystem[key] = value;
  } else {
    personOrSystem.link = link2;
  }
  personOrSystem.typeC4Shape = { text: typeC4Shape };
  personOrSystem.parentBoundary = currentBoundaryParse;
  personOrSystem.wrap = autoWrap$1();
};
const addContainer = function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let container = {};
  const old = c4ShapeArray.find((container2) => container2.alias === alias);
  if (old && alias === old.alias) {
    container = old;
  } else {
    container.alias = alias;
    c4ShapeArray.push(container);
  }
  if (label === void 0 || label === null) {
    container.label = { text: "" };
  } else {
    container.label = { text: label };
  }
  if (techn === void 0 || techn === null) {
    container.techn = { text: "" };
  } else {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      container[key] = { text: value };
    } else {
      container.techn = { text: techn };
    }
  }
  if (descr === void 0 || descr === null) {
    container.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      container[key] = { text: value };
    } else {
      container.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    container[key] = value;
  } else {
    container.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    container[key] = value;
  } else {
    container.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    container[key] = value;
  } else {
    container.link = link2;
  }
  container.wrap = autoWrap$1();
  container.typeC4Shape = { text: typeC4Shape };
  container.parentBoundary = currentBoundaryParse;
};
const addComponent = function(typeC4Shape, alias, label, techn, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let component = {};
  const old = c4ShapeArray.find((component2) => component2.alias === alias);
  if (old && alias === old.alias) {
    component = old;
  } else {
    component.alias = alias;
    c4ShapeArray.push(component);
  }
  if (label === void 0 || label === null) {
    component.label = { text: "" };
  } else {
    component.label = { text: label };
  }
  if (techn === void 0 || techn === null) {
    component.techn = { text: "" };
  } else {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      component[key] = { text: value };
    } else {
      component.techn = { text: techn };
    }
  }
  if (descr === void 0 || descr === null) {
    component.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      component[key] = { text: value };
    } else {
      component.descr = { text: descr };
    }
  }
  if (typeof sprite === "object") {
    let [key, value] = Object.entries(sprite)[0];
    component[key] = value;
  } else {
    component.sprite = sprite;
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    component[key] = value;
  } else {
    component.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    component[key] = value;
  } else {
    component.link = link2;
  }
  component.wrap = autoWrap$1();
  component.typeC4Shape = { text: typeC4Shape };
  component.parentBoundary = currentBoundaryParse;
};
const addPersonOrSystemBoundary = function(alias, label, type2, tags2, link2) {
  if (alias === null || label === null)
    return;
  let boundary = {};
  const old = boundarys.find((boundary2) => boundary2.alias === alias);
  if (old && alias === old.alias) {
    boundary = old;
  } else {
    boundary.alias = alias;
    boundarys.push(boundary);
  }
  if (label === void 0 || label === null) {
    boundary.label = { text: "" };
  } else {
    boundary.label = { text: label };
  }
  if (type2 === void 0 || type2 === null) {
    boundary.type = { text: "system" };
  } else {
    if (typeof type2 === "object") {
      let [key, value] = Object.entries(type2)[0];
      boundary[key] = { text: value };
    } else {
      boundary.type = { text: type2 };
    }
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    boundary[key] = value;
  } else {
    boundary.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    boundary[key] = value;
  } else {
    boundary.link = link2;
  }
  boundary.parentBoundary = currentBoundaryParse;
  boundary.wrap = autoWrap$1();
  parentBoundaryParse = currentBoundaryParse;
  currentBoundaryParse = alias;
  boundaryParseStack.push(parentBoundaryParse);
};
const addContainerBoundary = function(alias, label, type2, tags2, link2) {
  if (alias === null || label === null)
    return;
  let boundary = {};
  const old = boundarys.find((boundary2) => boundary2.alias === alias);
  if (old && alias === old.alias) {
    boundary = old;
  } else {
    boundary.alias = alias;
    boundarys.push(boundary);
  }
  if (label === void 0 || label === null) {
    boundary.label = { text: "" };
  } else {
    boundary.label = { text: label };
  }
  if (type2 === void 0 || type2 === null) {
    boundary.type = { text: "container" };
  } else {
    if (typeof type2 === "object") {
      let [key, value] = Object.entries(type2)[0];
      boundary[key] = { text: value };
    } else {
      boundary.type = { text: type2 };
    }
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    boundary[key] = value;
  } else {
    boundary.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    boundary[key] = value;
  } else {
    boundary.link = link2;
  }
  boundary.parentBoundary = currentBoundaryParse;
  boundary.wrap = autoWrap$1();
  parentBoundaryParse = currentBoundaryParse;
  currentBoundaryParse = alias;
  boundaryParseStack.push(parentBoundaryParse);
};
const addDeploymentNode = function(nodeType, alias, label, type2, descr, sprite, tags2, link2) {
  if (alias === null || label === null)
    return;
  let boundary = {};
  const old = boundarys.find((boundary2) => boundary2.alias === alias);
  if (old && alias === old.alias) {
    boundary = old;
  } else {
    boundary.alias = alias;
    boundarys.push(boundary);
  }
  if (label === void 0 || label === null) {
    boundary.label = { text: "" };
  } else {
    boundary.label = { text: label };
  }
  if (type2 === void 0 || type2 === null) {
    boundary.type = { text: "node" };
  } else {
    if (typeof type2 === "object") {
      let [key, value] = Object.entries(type2)[0];
      boundary[key] = { text: value };
    } else {
      boundary.type = { text: type2 };
    }
  }
  if (descr === void 0 || descr === null) {
    boundary.descr = { text: "" };
  } else {
    if (typeof descr === "object") {
      let [key, value] = Object.entries(descr)[0];
      boundary[key] = { text: value };
    } else {
      boundary.descr = { text: descr };
    }
  }
  if (typeof tags2 === "object") {
    let [key, value] = Object.entries(tags2)[0];
    boundary[key] = value;
  } else {
    boundary.tags = tags2;
  }
  if (typeof link2 === "object") {
    let [key, value] = Object.entries(link2)[0];
    boundary[key] = value;
  } else {
    boundary.link = link2;
  }
  boundary.nodeType = nodeType;
  boundary.parentBoundary = currentBoundaryParse;
  boundary.wrap = autoWrap$1();
  parentBoundaryParse = currentBoundaryParse;
  currentBoundaryParse = alias;
  boundaryParseStack.push(parentBoundaryParse);
};
const popBoundaryParseStack = function() {
  currentBoundaryParse = parentBoundaryParse;
  boundaryParseStack.pop();
  parentBoundaryParse = boundaryParseStack.pop();
  boundaryParseStack.push(parentBoundaryParse);
};
const updateElStyle = function(typeC4Shape, elementName, bgColor, fontColor, borderColor, shadowing, shape, sprite, techn, legendText, legendSprite) {
  let old = c4ShapeArray.find((element) => element.alias === elementName);
  if (old === void 0) {
    old = boundarys.find((element) => element.alias === elementName);
    if (old === void 0) {
      return;
    }
  }
  if (bgColor !== void 0 && bgColor !== null) {
    if (typeof bgColor === "object") {
      let [key, value] = Object.entries(bgColor)[0];
      old[key] = value;
    } else {
      old.bgColor = bgColor;
    }
  }
  if (fontColor !== void 0 && fontColor !== null) {
    if (typeof fontColor === "object") {
      let [key, value] = Object.entries(fontColor)[0];
      old[key] = value;
    } else {
      old.fontColor = fontColor;
    }
  }
  if (borderColor !== void 0 && borderColor !== null) {
    if (typeof borderColor === "object") {
      let [key, value] = Object.entries(borderColor)[0];
      old[key] = value;
    } else {
      old.borderColor = borderColor;
    }
  }
  if (shadowing !== void 0 && shadowing !== null) {
    if (typeof shadowing === "object") {
      let [key, value] = Object.entries(shadowing)[0];
      old[key] = value;
    } else {
      old.shadowing = shadowing;
    }
  }
  if (shape !== void 0 && shape !== null) {
    if (typeof shape === "object") {
      let [key, value] = Object.entries(shape)[0];
      old[key] = value;
    } else {
      old.shape = shape;
    }
  }
  if (sprite !== void 0 && sprite !== null) {
    if (typeof sprite === "object") {
      let [key, value] = Object.entries(sprite)[0];
      old[key] = value;
    } else {
      old.sprite = sprite;
    }
  }
  if (techn !== void 0 && techn !== null) {
    if (typeof techn === "object") {
      let [key, value] = Object.entries(techn)[0];
      old[key] = value;
    } else {
      old.techn = techn;
    }
  }
  if (legendText !== void 0 && legendText !== null) {
    if (typeof legendText === "object") {
      let [key, value] = Object.entries(legendText)[0];
      old[key] = value;
    } else {
      old.legendText = legendText;
    }
  }
  if (legendSprite !== void 0 && legendSprite !== null) {
    if (typeof legendSprite === "object") {
      let [key, value] = Object.entries(legendSprite)[0];
      old[key] = value;
    } else {
      old.legendSprite = legendSprite;
    }
  }
};
const updateRelStyle = function(typeC4Shape, from2, to, textColor, lineColor, offsetX, offsetY) {
  const old = rels.find((rel) => rel.from === from2 && rel.to === to);
  if (old === void 0) {
    return;
  }
  if (textColor !== void 0 && textColor !== null) {
    if (typeof textColor === "object") {
      let [key, value] = Object.entries(textColor)[0];
      old[key] = value;
    } else {
      old.textColor = textColor;
    }
  }
  if (lineColor !== void 0 && lineColor !== null) {
    if (typeof lineColor === "object") {
      let [key, value] = Object.entries(lineColor)[0];
      old[key] = value;
    } else {
      old.lineColor = lineColor;
    }
  }
  if (offsetX !== void 0 && offsetX !== null) {
    if (typeof offsetX === "object") {
      let [key, value] = Object.entries(offsetX)[0];
      old[key] = parseInt(value);
    } else {
      old.offsetX = parseInt(offsetX);
    }
  }
  if (offsetY !== void 0 && offsetY !== null) {
    if (typeof offsetY === "object") {
      let [key, value] = Object.entries(offsetY)[0];
      old[key] = parseInt(value);
    } else {
      old.offsetY = parseInt(offsetY);
    }
  }
};
const updateLayoutConfig = function(typeC4Shape, c4ShapeInRowParam, c4BoundaryInRowParam) {
  let c4ShapeInRowValue = c4ShapeInRow$1;
  let c4BoundaryInRowValue = c4BoundaryInRow$1;
  if (typeof c4ShapeInRowParam === "object") {
    const value = Object.values(c4ShapeInRowParam)[0];
    c4ShapeInRowValue = parseInt(value);
  } else {
    c4ShapeInRowValue = parseInt(c4ShapeInRowParam);
  }
  if (typeof c4BoundaryInRowParam === "object") {
    const value = Object.values(c4BoundaryInRowParam)[0];
    c4BoundaryInRowValue = parseInt(value);
  } else {
    c4BoundaryInRowValue = parseInt(c4BoundaryInRowParam);
  }
  if (c4ShapeInRowValue >= 1)
    c4ShapeInRow$1 = c4ShapeInRowValue;
  if (c4BoundaryInRowValue >= 1)
    c4BoundaryInRow$1 = c4BoundaryInRowValue;
};
const getC4ShapeInRow = function() {
  return c4ShapeInRow$1;
};
const getC4BoundaryInRow = function() {
  return c4BoundaryInRow$1;
};
const getCurrentBoundaryParse = function() {
  return currentBoundaryParse;
};
const getParentBoundaryParse = function() {
  return parentBoundaryParse;
};
const getC4ShapeArray = function(parentBoundary) {
  if (parentBoundary === void 0 || parentBoundary === null)
    return c4ShapeArray;
  else
    return c4ShapeArray.filter((personOrSystem) => {
      return personOrSystem.parentBoundary === parentBoundary;
    });
};
const getC4Shape = function(alias) {
  return c4ShapeArray.find((personOrSystem) => personOrSystem.alias === alias);
};
const getC4ShapeKeys = function(parentBoundary) {
  return Object.keys(getC4ShapeArray(parentBoundary));
};
const getBoundarys = function(parentBoundary) {
  if (parentBoundary === void 0 || parentBoundary === null)
    return boundarys;
  else
    return boundarys.filter((boundary) => boundary.parentBoundary === parentBoundary);
};
const getRels = function() {
  return rels;
};
const getTitle = function() {
  return title;
};
const setWrap$1 = function(wrapSetting) {
  wrapEnabled$1 = wrapSetting;
};
const autoWrap$1 = function() {
  return wrapEnabled$1;
};
const clear$d = function() {
  c4ShapeArray = [];
  boundarys = [
    {
      alias: "global",
      label: { text: "global" },
      type: { text: "global" },
      tags: null,
      link: null,
      parentBoundary: ""
    }
  ];
  parentBoundaryParse = "";
  currentBoundaryParse = "global";
  boundaryParseStack = [""];
  rels = [];
  boundaryParseStack = [""];
  title = "";
  wrapEnabled$1 = false;
  c4ShapeInRow$1 = 4;
  c4BoundaryInRow$1 = 2;
};
const LINETYPE$1 = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25
};
const ARROWTYPE$1 = {
  FILLED: 0,
  OPEN: 1
};
const PLACEMENT$1 = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
};
const setTitle = function(txt) {
  let sanitizedText = sanitizeText$5(txt, getConfig$1());
  title = sanitizedText;
};
const c4Db = {
  addPersonOrSystem,
  addPersonOrSystemBoundary,
  addContainer,
  addContainerBoundary,
  addComponent,
  addDeploymentNode,
  popBoundaryParseStack,
  addRel,
  updateElStyle,
  updateRelStyle,
  updateLayoutConfig,
  autoWrap: autoWrap$1,
  setWrap: setWrap$1,
  getC4ShapeArray,
  getC4Shape,
  getC4ShapeKeys,
  getBoundarys,
  getCurrentBoundaryParse,
  getParentBoundaryParse,
  getRels,
  getTitle,
  getC4Type,
  getC4ShapeInRow,
  getC4BoundaryInRow,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  parseDirective: parseDirective$a,
  getConfig: () => getConfig$1().c4,
  clear: clear$d,
  LINETYPE: LINETYPE$1,
  ARROWTYPE: ARROWTYPE$1,
  PLACEMENT: PLACEMENT$1,
  setTitle,
  setC4Type
};
const drawRect$2 = function(elem, rectData) {
  const rectElem = elem.append("rect");
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.y);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", rectData.width);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (rectData.attrs !== "undefined" && rectData.attrs !== null) {
    for (let attrKey in rectData.attrs)
      rectElem.attr(attrKey, rectData.attrs[attrKey]);
  }
  if (rectData.class !== "undefined") {
    rectElem.attr("class", rectData.class);
  }
  return rectElem;
};
const drawImage$1 = function(elem, width2, height2, x2, y2, link2) {
  const imageElem = elem.append("image");
  imageElem.attr("width", width2);
  imageElem.attr("height", height2);
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  let sanitizedLink = link2.startsWith("data:image/png;base64") ? link2 : sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", sanitizedLink);
};
const drawEmbeddedImage$1 = function(elem, x2, y2, link2) {
  const imageElem = elem.append("use");
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  var sanitizedLink = sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", "#" + sanitizedLink);
};
const drawText$2 = function(elem, textData) {
  let prevTextHeight = 0, textHeight = 0;
  const lines = textData.text.split(common.lineBreakRegex);
  let textElems = [];
  let dy = 0;
  let yfunc = () => textData.y;
  if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
    switch (textData.valign) {
      case "top":
      case "start":
        yfunc = () => Math.round(textData.y + textData.textMargin);
        break;
      case "middle":
      case "center":
        yfunc = () => Math.round(textData.y + (prevTextHeight + textHeight + textData.textMargin) / 2);
        break;
      case "bottom":
      case "end":
        yfunc = () => Math.round(
          textData.y + (prevTextHeight + textHeight + 2 * textData.textMargin) - textData.textMargin
        );
        break;
    }
  }
  if (typeof textData.anchor !== "undefined" && typeof textData.textMargin !== "undefined" && typeof textData.width !== "undefined") {
    switch (textData.anchor) {
      case "left":
      case "start":
        textData.x = Math.round(textData.x + textData.textMargin);
        textData.anchor = "start";
        textData.dominantBaseline = "text-after-edge";
        textData.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        textData.x = Math.round(textData.x + textData.width / 2);
        textData.anchor = "middle";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        textData.x = Math.round(textData.x + textData.width - textData.textMargin);
        textData.anchor = "end";
        textData.dominantBaseline = "text-before-edge";
        textData.alignmentBaseline = "middle";
        break;
    }
  }
  for (let i = 0; i < lines.length; i++) {
    let line2 = lines[i];
    if (typeof textData.textMargin !== "undefined" && textData.textMargin === 0 && typeof textData.fontSize !== "undefined") {
      dy = i * textData.fontSize;
    }
    const textElem = elem.append("text");
    textElem.attr("x", textData.x);
    textElem.attr("y", yfunc());
    if (typeof textData.anchor !== "undefined") {
      textElem.attr("text-anchor", textData.anchor).attr("dominant-baseline", textData.dominantBaseline).attr("alignment-baseline", textData.alignmentBaseline);
    }
    if (typeof textData.fontFamily !== "undefined") {
      textElem.style("font-family", textData.fontFamily);
    }
    if (typeof textData.fontSize !== "undefined") {
      textElem.style("font-size", textData.fontSize);
    }
    if (typeof textData.fontWeight !== "undefined") {
      textElem.style("font-weight", textData.fontWeight);
    }
    if (typeof textData.fill !== "undefined") {
      textElem.attr("fill", textData.fill);
    }
    if (typeof textData.class !== "undefined") {
      textElem.attr("class", textData.class);
    }
    if (typeof textData.dy !== "undefined") {
      textElem.attr("dy", textData.dy);
    } else if (dy !== 0) {
      textElem.attr("dy", dy);
    }
    if (textData.tspan) {
      const span = textElem.append("tspan");
      span.attr("x", textData.x);
      if (typeof textData.fill !== "undefined") {
        span.attr("fill", textData.fill);
      }
      span.text(line2);
    } else {
      textElem.text(line2);
    }
    if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
      textHeight += (textElem._groups || textElem)[0][0].getBBox().height;
      prevTextHeight = textHeight;
    }
    textElems.push(textElem);
  }
  return textElems;
};
const drawLabel$2 = function(elem, txtObject) {
  function genPoints(x2, y2, width2, height2, cut) {
    return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
  }
  const polygon = elem.append("polygon");
  polygon.attr("points", genPoints(txtObject.x, txtObject.y, txtObject.width, txtObject.height, 7));
  polygon.attr("class", "labelBox");
  txtObject.y = txtObject.y + txtObject.height / 2;
  drawText$2(elem, txtObject);
  return polygon;
};
const drawRels$1 = (elem, rels2, conf2) => {
  const relsElem = elem.append("g");
  let i = 0;
  for (let rel of rels2) {
    let textColor = rel.textColor ? rel.textColor : "#444444";
    let strokeColor = rel.lineColor ? rel.lineColor : "#444444";
    let offsetX = rel.offsetX ? parseInt(rel.offsetX) : 0;
    let offsetY = rel.offsetY ? parseInt(rel.offsetY) : 0;
    let url = "";
    if (i === 0) {
      let line2 = relsElem.append("line");
      line2.attr("x1", rel.startPoint.x);
      line2.attr("y1", rel.startPoint.y);
      line2.attr("x2", rel.endPoint.x);
      line2.attr("y2", rel.endPoint.y);
      line2.attr("stroke-width", "1");
      line2.attr("stroke", strokeColor);
      line2.style("fill", "none");
      if (rel.type !== "rel_b")
        line2.attr("marker-end", "url(" + url + "#arrowhead)");
      if (rel.type === "birel" || rel.type === "rel_b")
        line2.attr("marker-start", "url(" + url + "#arrowend)");
      i = -1;
    } else {
      let line2 = relsElem.append("path");
      line2.attr("fill", "none").attr("stroke-width", "1").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,starty Qcontrolx,controly stopx,stopy ".replaceAll("startx", rel.startPoint.x).replaceAll("starty", rel.startPoint.y).replaceAll(
          "controlx",
          rel.startPoint.x + (rel.endPoint.x - rel.startPoint.x) / 2 - (rel.endPoint.x - rel.startPoint.x) / 4
        ).replaceAll("controly", rel.startPoint.y + (rel.endPoint.y - rel.startPoint.y) / 2).replaceAll("stopx", rel.endPoint.x).replaceAll("stopy", rel.endPoint.y)
      );
      if (rel.type !== "rel_b")
        line2.attr("marker-end", "url(" + url + "#arrowhead)");
      if (rel.type === "birel" || rel.type === "rel_b")
        line2.attr("marker-start", "url(" + url + "#arrowend)");
    }
    let messageConf = conf2.messageFont();
    _drawTextCandidateFunc$2(conf2)(
      rel.label.text,
      relsElem,
      Math.min(rel.startPoint.x, rel.endPoint.x) + Math.abs(rel.endPoint.x - rel.startPoint.x) / 2 + offsetX,
      Math.min(rel.startPoint.y, rel.endPoint.y) + Math.abs(rel.endPoint.y - rel.startPoint.y) / 2 + offsetY,
      rel.label.width,
      rel.label.height,
      { fill: textColor },
      messageConf
    );
    if (rel.techn && rel.techn.text !== "") {
      messageConf = conf2.messageFont();
      _drawTextCandidateFunc$2(conf2)(
        "[" + rel.techn.text + "]",
        relsElem,
        Math.min(rel.startPoint.x, rel.endPoint.x) + Math.abs(rel.endPoint.x - rel.startPoint.x) / 2 + offsetX,
        Math.min(rel.startPoint.y, rel.endPoint.y) + Math.abs(rel.endPoint.y - rel.startPoint.y) / 2 + conf2.messageFontSize + 5 + offsetY,
        Math.max(rel.label.width, rel.techn.width),
        rel.techn.height,
        { fill: textColor, "font-style": "italic" },
        messageConf
      );
    }
  }
};
const drawBoundary$1 = function(elem, boundary, conf2) {
  const boundaryElem = elem.append("g");
  let fillColor = boundary.bgColor ? boundary.bgColor : "none";
  let strokeColor = boundary.borderColor ? boundary.borderColor : "#444444";
  let fontColor = boundary.fontColor ? boundary.fontColor : "black";
  let attrsValue = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
  if (boundary.nodeType)
    attrsValue = { "stroke-width": 1 };
  let rectData = {
    x: boundary.x,
    y: boundary.y,
    fill: fillColor,
    stroke: strokeColor,
    width: boundary.width,
    height: boundary.height,
    rx: 2.5,
    ry: 2.5,
    attrs: attrsValue
  };
  drawRect$2(boundaryElem, rectData);
  let boundaryConf = conf2.boundaryFont();
  boundaryConf.fontWeight = "bold";
  boundaryConf.fontSize = boundaryConf.fontSize + 2;
  boundaryConf.fontColor = fontColor;
  _drawTextCandidateFunc$2(conf2)(
    boundary.label.text,
    boundaryElem,
    boundary.x,
    boundary.y + boundary.label.Y,
    boundary.width,
    boundary.height,
    { fill: "#444444" },
    boundaryConf
  );
  if (boundary.type && boundary.type.text !== "") {
    boundaryConf = conf2.boundaryFont();
    boundaryConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      boundary.type.text,
      boundaryElem,
      boundary.x,
      boundary.y + boundary.type.Y,
      boundary.width,
      boundary.height,
      { fill: "#444444" },
      boundaryConf
    );
  }
  if (boundary.descr && boundary.descr.text !== "") {
    boundaryConf = conf2.boundaryFont();
    boundaryConf.fontSize = boundaryConf.fontSize - 2;
    boundaryConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      boundary.descr.text,
      boundaryElem,
      boundary.x,
      boundary.y + boundary.descr.Y,
      boundary.width,
      boundary.height,
      { fill: "#444444" },
      boundaryConf
    );
  }
};
const drawC4Shape = function(elem, c4Shape, conf2) {
  let fillColor = c4Shape.bgColor ? c4Shape.bgColor : conf2[c4Shape.typeC4Shape.text + "_bg_color"];
  let strokeColor = c4Shape.borderColor ? c4Shape.borderColor : conf2[c4Shape.typeC4Shape.text + "_border_color"];
  let fontColor = c4Shape.fontColor ? c4Shape.fontColor : "#FFFFFF";
  let personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
  switch (c4Shape.typeC4Shape.text) {
    case "person":
      personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
      break;
    case "external_person":
      personImg = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
      break;
  }
  const c4ShapeElem = elem.append("g");
  c4ShapeElem.attr("class", "person-man");
  const rect2 = getNoteRect$2();
  switch (c4Shape.typeC4Shape.text) {
    case "person":
    case "external_person":
    case "system":
    case "external_system":
    case "container":
    case "external_container":
    case "component":
    case "external_component":
      rect2.x = c4Shape.x;
      rect2.y = c4Shape.y;
      rect2.fill = fillColor;
      rect2.width = c4Shape.width;
      rect2.height = c4Shape.height;
      rect2.style = "stroke:" + strokeColor + ";stroke-width:0.5;";
      rect2.rx = 2.5;
      rect2.ry = 2.5;
      drawRect$2(c4ShapeElem, rect2);
      break;
    case "system_db":
    case "external_system_db":
    case "container_db":
    case "external_container_db":
    case "component_db":
    case "external_component_db":
      c4ShapeElem.append("path").attr("fill", fillColor).attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.width / 2).replaceAll("height", c4Shape.height)
      );
      c4ShapeElem.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.width / 2)
      );
      break;
    case "system_queue":
    case "external_system_queue":
    case "container_queue":
    case "external_container_queue":
    case "component_queue":
    case "external_component_queue":
      c4ShapeElem.append("path").attr("fill", fillColor).attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half".replaceAll("startx", c4Shape.x).replaceAll("starty", c4Shape.y).replaceAll("width", c4Shape.width).replaceAll("half", c4Shape.height / 2)
      );
      c4ShapeElem.append("path").attr("fill", "none").attr("stroke-width", "0.5").attr("stroke", strokeColor).attr(
        "d",
        "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half".replaceAll("startx", c4Shape.x + c4Shape.width).replaceAll("starty", c4Shape.y).replaceAll("half", c4Shape.height / 2)
      );
      break;
  }
  let c4ShapeFontConf = getC4ShapeFont(conf2, c4Shape.typeC4Shape.text);
  c4ShapeElem.append("text").attr("fill", fontColor).attr("font-family", c4ShapeFontConf.fontFamily).attr("font-size", c4ShapeFontConf.fontSize - 2).attr("font-style", "italic").attr("lengthAdjust", "spacing").attr("textLength", c4Shape.typeC4Shape.width).attr("x", c4Shape.x + c4Shape.width / 2 - c4Shape.typeC4Shape.width / 2).attr("y", c4Shape.y + c4Shape.typeC4Shape.Y).text("<<" + c4Shape.typeC4Shape.text + ">>");
  switch (c4Shape.typeC4Shape.text) {
    case "person":
    case "external_person":
      drawImage$1(
        c4ShapeElem,
        48,
        48,
        c4Shape.x + c4Shape.width / 2 - 24,
        c4Shape.y + c4Shape.image.Y,
        personImg
      );
      break;
  }
  let textFontConf = conf2[c4Shape.typeC4Shape.text + "Font"]();
  textFontConf.fontWeight = "bold";
  textFontConf.fontSize = textFontConf.fontSize + 2;
  textFontConf.fontColor = fontColor;
  _drawTextCandidateFunc$2(conf2)(
    c4Shape.label.text,
    c4ShapeElem,
    c4Shape.x,
    c4Shape.y + c4Shape.label.Y,
    c4Shape.width,
    c4Shape.height,
    { fill: fontColor },
    textFontConf
  );
  textFontConf = conf2[c4Shape.typeC4Shape.text + "Font"]();
  textFontConf.fontColor = fontColor;
  if (c4Shape.thchn && c4Shape.thchn.text !== "") {
    _drawTextCandidateFunc$2(conf2)(
      c4Shape.thchn.text,
      c4ShapeElem,
      c4Shape.x,
      c4Shape.y + c4Shape.thchn.Y,
      c4Shape.width,
      c4Shape.height,
      { fill: fontColor, "font-style": "italic" },
      textFontConf
    );
  } else if (c4Shape.type && c4Shape.type.text !== "") {
    _drawTextCandidateFunc$2(conf2)(
      c4Shape.type.text,
      c4ShapeElem,
      c4Shape.x,
      c4Shape.y + c4Shape.type.Y,
      c4Shape.width,
      c4Shape.height,
      { fill: fontColor, "font-style": "italic" },
      textFontConf
    );
  }
  if (c4Shape.descr && c4Shape.descr.text !== "") {
    textFontConf = conf2.personFont();
    textFontConf.fontColor = fontColor;
    _drawTextCandidateFunc$2(conf2)(
      c4Shape.descr.text,
      c4ShapeElem,
      c4Shape.x,
      c4Shape.y + c4Shape.descr.Y,
      c4Shape.width,
      c4Shape.height,
      { fill: fontColor },
      textFontConf
    );
  }
  return c4Shape.height;
};
const insertDatabaseIcon$1 = function(elem) {
  elem.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
};
const insertComputerIcon$1 = function(elem) {
  elem.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
};
const insertClockIcon$1 = function(elem) {
  elem.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
};
const insertArrowHead$1 = function(elem) {
  elem.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
};
const insertArrowEnd = function(elem) {
  elem.append("defs").append("marker").attr("id", "arrowend").attr("refX", 1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 10 0 L 0 5 L 10 10 z");
};
const insertArrowFilledHead$1 = function(elem) {
  elem.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const insertDynamicNumber = function(elem) {
  elem.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
};
const insertArrowCrossHead$1 = function(elem) {
  const defs = elem.append("defs");
  const marker = defs.append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  marker.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z");
  marker.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
};
const getTextObj$2 = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: true,
    valign: void 0
  };
};
const getNoteRect$2 = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
};
const getC4ShapeFont = (cnf, typeC4Shape) => {
  return {
    fontFamily: cnf[typeC4Shape + "FontFamily"],
    fontSize: cnf[typeC4Shape + "FontSize"],
    fontWeight: cnf[typeC4Shape + "FontWeight"]
  };
};
const _drawTextCandidateFunc$2 = function() {
  function byText(content, g, x2, y2, width2, height2, textAttrs) {
    const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("text-anchor", "middle").text(content);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2) {
    const { fontSize, fontFamily, fontWeight } = conf2;
    const lines = content.split(common.lineBreakRegex);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * fontSize - fontSize * (lines.length - 1) / 2;
      const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2).style("text-anchor", "middle").attr("dominant-baseline", "middle").style("font-size", fontSize).style("font-weight", fontWeight).style("font-family", fontFamily);
      text2.append("tspan").attr("dy", dy).text(lines[i]).attr("alignment-baseline", "mathematical");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
    const s2 = g.append("switch");
    const f = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
    const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
    byTspan(content, s2, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (fromTextAttrsDict.hasOwnProperty(key)) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const svgDraw$3 = {
  drawRect: drawRect$2,
  drawText: drawText$2,
  drawLabel: drawLabel$2,
  drawBoundary: drawBoundary$1,
  drawC4Shape,
  drawRels: drawRels$1,
  drawImage: drawImage$1,
  drawEmbeddedImage: drawEmbeddedImage$1,
  insertArrowHead: insertArrowHead$1,
  insertArrowEnd,
  insertArrowFilledHead: insertArrowFilledHead$1,
  insertDynamicNumber,
  insertArrowCrossHead: insertArrowCrossHead$1,
  insertDatabaseIcon: insertDatabaseIcon$1,
  insertComputerIcon: insertComputerIcon$1,
  insertClockIcon: insertClockIcon$1,
  getTextObj: getTextObj$2,
  getNoteRect: getNoteRect$2,
  sanitizeUrl: sanitizeUrl_1
};
let globalBoundaryMaxX = 0, globalBoundaryMaxY = 0;
let c4ShapeInRow = 4;
let c4BoundaryInRow = 2;
parser$a.yy = c4Db;
let conf$a = {};
class Bounds {
  constructor(diagObj) {
    this.name = "";
    this.data = {};
    this.data.startx = void 0;
    this.data.stopx = void 0;
    this.data.starty = void 0;
    this.data.stopy = void 0;
    this.data.widthLimit = void 0;
    this.nextData = {};
    this.nextData.startx = void 0;
    this.nextData.stopx = void 0;
    this.nextData.starty = void 0;
    this.nextData.stopy = void 0;
    this.nextData.cnt = 0;
    setConf$a(diagObj.db.getConfig());
  }
  setData(startx, stopx, starty, stopy) {
    this.nextData.startx = this.data.startx = startx;
    this.nextData.stopx = this.data.stopx = stopx;
    this.nextData.starty = this.data.starty = starty;
    this.nextData.stopy = this.data.stopy = stopy;
  }
  updateVal(obj, key, val, fun) {
    if (typeof obj[key] === "undefined") {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  }
  insert(c4Shape) {
    this.nextData.cnt = this.nextData.cnt + 1;
    let _startx = this.nextData.startx === this.nextData.stopx ? this.nextData.stopx + c4Shape.margin : this.nextData.stopx + c4Shape.margin * 2;
    let _stopx = _startx + c4Shape.width;
    let _starty = this.nextData.starty + c4Shape.margin * 2;
    let _stopy = _starty + c4Shape.height;
    if (_startx >= this.data.widthLimit || _stopx >= this.data.widthLimit || this.nextData.cnt > c4ShapeInRow) {
      _startx = this.nextData.startx + c4Shape.margin + conf$a.nextLinePaddingX;
      _starty = this.nextData.stopy + c4Shape.margin * 2;
      this.nextData.stopx = _stopx = _startx + c4Shape.width;
      this.nextData.starty = this.nextData.stopy;
      this.nextData.stopy = _stopy = _starty + c4Shape.height;
      this.nextData.cnt = 1;
    }
    c4Shape.x = _startx;
    c4Shape.y = _starty;
    this.updateVal(this.data, "startx", _startx, Math.min);
    this.updateVal(this.data, "starty", _starty, Math.min);
    this.updateVal(this.data, "stopx", _stopx, Math.max);
    this.updateVal(this.data, "stopy", _stopy, Math.max);
    this.updateVal(this.nextData, "startx", _startx, Math.min);
    this.updateVal(this.nextData, "starty", _starty, Math.min);
    this.updateVal(this.nextData, "stopx", _stopx, Math.max);
    this.updateVal(this.nextData, "stopy", _stopy, Math.max);
  }
  init(diagObj) {
    this.name = "";
    this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      widthLimit: void 0
    };
    this.nextData = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0,
      cnt: 0
    };
    setConf$a(diagObj.db.getConfig());
  }
  bumpLastMargin(margin) {
    this.data.stopx += margin;
    this.data.stopy += margin;
  }
}
const setConf$a = function(cnf) {
  assignWithDepth(conf$a, cnf);
  if (cnf.fontFamily) {
    conf$a.personFontFamily = conf$a.systemFontFamily = conf$a.messageFontFamily = cnf.fontFamily;
  }
  if (cnf.fontSize) {
    conf$a.personFontSize = conf$a.systemFontSize = conf$a.messageFontSize = cnf.fontSize;
  }
  if (cnf.fontWeight) {
    conf$a.personFontWeight = conf$a.systemFontWeight = conf$a.messageFontWeight = cnf.fontWeight;
  }
};
const c4ShapeFont = (cnf, typeC4Shape) => {
  return {
    fontFamily: cnf[typeC4Shape + "FontFamily"],
    fontSize: cnf[typeC4Shape + "FontSize"],
    fontWeight: cnf[typeC4Shape + "FontWeight"]
  };
};
const boundaryFont = (cnf) => {
  return {
    fontFamily: cnf.boundaryFontFamily,
    fontSize: cnf.boundaryFontSize,
    fontWeight: cnf.boundaryFontWeight
  };
};
const messageFont$1 = (cnf) => {
  return {
    fontFamily: cnf.messageFontFamily,
    fontSize: cnf.messageFontSize,
    fontWeight: cnf.messageFontWeight
  };
};
function calcC4ShapeTextWH(textType, c4Shape, c4ShapeTextWrap, textConf, textLimitWidth) {
  if (!c4Shape[textType].width) {
    if (c4ShapeTextWrap) {
      c4Shape[textType].text = wrapLabel(c4Shape[textType].text, textLimitWidth, textConf);
      c4Shape[textType].textLines = c4Shape[textType].text.split(common.lineBreakRegex).length;
      c4Shape[textType].width = textLimitWidth;
      c4Shape[textType].height = calculateTextHeight(c4Shape[textType].text, textConf);
    } else {
      let lines = c4Shape[textType].text.split(common.lineBreakRegex);
      c4Shape[textType].textLines = lines.length;
      let lineHeight = 0;
      c4Shape[textType].height = 0;
      c4Shape[textType].width = 0;
      for (let i = 0; i < lines.length; i++) {
        c4Shape[textType].width = Math.max(
          calculateTextWidth(lines[i], textConf),
          c4Shape[textType].width
        );
        lineHeight = calculateTextHeight(lines[i], textConf);
        c4Shape[textType].height = c4Shape[textType].height + lineHeight;
      }
    }
  }
}
const drawBoundary = function(diagram, boundary, bounds2) {
  boundary.x = bounds2.data.startx;
  boundary.y = bounds2.data.starty;
  boundary.width = bounds2.data.stopx - bounds2.data.startx;
  boundary.height = bounds2.data.stopy - bounds2.data.starty;
  boundary.label.y = conf$a.c4ShapeMargin - 35;
  let boundaryTextWrap = boundary.wrap && conf$a.wrap;
  let boundaryLabelConf = boundaryFont(conf$a);
  boundaryLabelConf.fontSize = boundaryLabelConf.fontSize + 2;
  boundaryLabelConf.fontWeight = "bold";
  let textLimitWidth = calculateTextWidth(boundary.label.text, boundaryLabelConf);
  calcC4ShapeTextWH("label", boundary, boundaryTextWrap, boundaryLabelConf, textLimitWidth);
  svgDraw$3.drawBoundary(diagram, boundary, conf$a);
};
const drawC4ShapeArray = function(currentBounds, diagram, c4ShapeArray2, c4ShapeKeys) {
  let Y3 = 0;
  for (let i = 0; i < c4ShapeKeys.length; i++) {
    Y3 = 0;
    const c4Shape = c4ShapeArray2[c4ShapeKeys[i]];
    let c4ShapeTypeConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
    c4ShapeTypeConf.fontSize = c4ShapeTypeConf.fontSize - 2;
    c4Shape.typeC4Shape.width = calculateTextWidth(
      "<<" + c4Shape.typeC4Shape.text + ">>",
      c4ShapeTypeConf
    );
    c4Shape.typeC4Shape.height = c4ShapeTypeConf.fontSize + 2;
    c4Shape.typeC4Shape.Y = conf$a.c4ShapePadding;
    Y3 = c4Shape.typeC4Shape.Y + c4Shape.typeC4Shape.height - 4;
    c4Shape.image = { width: 0, height: 0, Y: 0 };
    switch (c4Shape.typeC4Shape.text) {
      case "person":
      case "external_person":
        c4Shape.image.width = 48;
        c4Shape.image.height = 48;
        c4Shape.image.Y = Y3;
        Y3 = c4Shape.image.Y + c4Shape.image.height;
        break;
    }
    if (c4Shape.sprite) {
      c4Shape.image.width = 48;
      c4Shape.image.height = 48;
      c4Shape.image.Y = Y3;
      Y3 = c4Shape.image.Y + c4Shape.image.height;
    }
    let c4ShapeTextWrap = c4Shape.wrap && conf$a.wrap;
    let textLimitWidth = conf$a.width - conf$a.c4ShapePadding * 2;
    let c4ShapeLabelConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
    c4ShapeLabelConf.fontSize = c4ShapeLabelConf.fontSize + 2;
    c4ShapeLabelConf.fontWeight = "bold";
    calcC4ShapeTextWH("label", c4Shape, c4ShapeTextWrap, c4ShapeLabelConf, textLimitWidth);
    c4Shape["label"].Y = Y3 + 8;
    Y3 = c4Shape["label"].Y + c4Shape["label"].height;
    if (c4Shape.type && c4Shape.type.text !== "") {
      c4Shape.type.text = "[" + c4Shape.type.text + "]";
      let c4ShapeTypeConf2 = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
      calcC4ShapeTextWH("type", c4Shape, c4ShapeTextWrap, c4ShapeTypeConf2, textLimitWidth);
      c4Shape["type"].Y = Y3 + 5;
      Y3 = c4Shape["type"].Y + c4Shape["type"].height;
    } else if (c4Shape.techn && c4Shape.techn.text !== "") {
      c4Shape.techn.text = "[" + c4Shape.techn.text + "]";
      let c4ShapeTechnConf = c4ShapeFont(conf$a, c4Shape.techn.text);
      calcC4ShapeTextWH("techn", c4Shape, c4ShapeTextWrap, c4ShapeTechnConf, textLimitWidth);
      c4Shape["techn"].Y = Y3 + 5;
      Y3 = c4Shape["techn"].Y + c4Shape["techn"].height;
    }
    let rectHeight = Y3;
    let rectWidth = c4Shape.label.width;
    if (c4Shape.descr && c4Shape.descr.text !== "") {
      let c4ShapeDescrConf = c4ShapeFont(conf$a, c4Shape.typeC4Shape.text);
      calcC4ShapeTextWH("descr", c4Shape, c4ShapeTextWrap, c4ShapeDescrConf, textLimitWidth);
      c4Shape["descr"].Y = Y3 + 20;
      Y3 = c4Shape["descr"].Y + c4Shape["descr"].height;
      rectWidth = Math.max(c4Shape.label.width, c4Shape.descr.width);
      rectHeight = Y3 - c4Shape["descr"].textLines * 5;
    }
    rectWidth = rectWidth + conf$a.c4ShapePadding;
    c4Shape.width = Math.max(c4Shape.width || conf$a.width, rectWidth, conf$a.width);
    c4Shape.height = Math.max(c4Shape.height || conf$a.height, rectHeight, conf$a.height);
    c4Shape.margin = c4Shape.margin || conf$a.c4ShapeMargin;
    currentBounds.insert(c4Shape);
    svgDraw$3.drawC4Shape(diagram, c4Shape, conf$a);
  }
  currentBounds.bumpLastMargin(conf$a.c4ShapeMargin);
};
class Point {
  constructor(x2, y2) {
    this.x = x2;
    this.y = y2;
  }
}
let getIntersectPoint = function(fromNode, endPoint) {
  let x12 = fromNode.x;
  let y12 = fromNode.y;
  let x2 = endPoint.x;
  let y2 = endPoint.y;
  let fromCenterX = x12 + fromNode.width / 2;
  let fromCenterY = y12 + fromNode.height / 2;
  let dx = Math.abs(x12 - x2);
  let dy = Math.abs(y12 - y2);
  let tanDYX = dy / dx;
  let fromDYX = fromNode.height / fromNode.width;
  let returnPoint = null;
  if (y12 == y2 && x12 < x2) {
    returnPoint = new Point(x12 + fromNode.width, fromCenterY);
  } else if (y12 == y2 && x12 > x2) {
    returnPoint = new Point(x12, fromCenterY);
  } else if (x12 == x2 && y12 < y2) {
    returnPoint = new Point(fromCenterX, y12 + fromNode.height);
  } else if (x12 == x2 && y12 > y2) {
    returnPoint = new Point(fromCenterX, y12);
  }
  if (x12 > x2 && y12 < y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12, fromCenterY + tanDYX * fromNode.width / 2);
    } else {
      returnPoint = new Point(
        fromCenterX - dx / dy * fromNode.height / 2,
        y12 + fromNode.height
      );
    }
  } else if (x12 < x2 && y12 < y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12 + fromNode.width, fromCenterY + tanDYX * fromNode.width / 2);
    } else {
      returnPoint = new Point(
        fromCenterX + dx / dy * fromNode.height / 2,
        y12 + fromNode.height
      );
    }
  } else if (x12 < x2 && y12 > y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12 + fromNode.width, fromCenterY - tanDYX * fromNode.width / 2);
    } else {
      returnPoint = new Point(fromCenterX + fromNode.height / 2 * dx / dy, y12);
    }
  } else if (x12 > x2 && y12 > y2) {
    if (fromDYX >= tanDYX) {
      returnPoint = new Point(x12, fromCenterY - fromNode.width / 2 * tanDYX);
    } else {
      returnPoint = new Point(fromCenterX - fromNode.height / 2 * dx / dy, y12);
    }
  }
  return returnPoint;
};
let getIntersectPoints = function(fromNode, endNode) {
  let endIntersectPoint = { x: 0, y: 0 };
  endIntersectPoint.x = endNode.x + endNode.width / 2;
  endIntersectPoint.y = endNode.y + endNode.height / 2;
  let startPoint = getIntersectPoint(fromNode, endIntersectPoint);
  endIntersectPoint.x = fromNode.x + fromNode.width / 2;
  endIntersectPoint.y = fromNode.y + fromNode.height / 2;
  let endPoint = getIntersectPoint(endNode, endIntersectPoint);
  return { startPoint, endPoint };
};
const drawRels = function(diagram, rels2, getC4ShapeObj, diagObj) {
  let i = 0;
  for (let rel of rels2) {
    i = i + 1;
    let relTextWrap = rel.wrap && conf$a.wrap;
    let relConf = messageFont$1(conf$a);
    let diagramType = diagObj.db.getC4Type();
    if (diagramType === "C4Dynamic")
      rel.label.text = i + ": " + rel.label.text;
    let textLimitWidth = calculateTextWidth(rel.label.text, relConf);
    calcC4ShapeTextWH("label", rel, relTextWrap, relConf, textLimitWidth);
    if (rel.techn && rel.techn.text !== "") {
      textLimitWidth = calculateTextWidth(rel.techn.text, relConf);
      calcC4ShapeTextWH("techn", rel, relTextWrap, relConf, textLimitWidth);
    }
    if (rel.descr && rel.descr.text !== "") {
      textLimitWidth = calculateTextWidth(rel.descr.text, relConf);
      calcC4ShapeTextWH("descr", rel, relTextWrap, relConf, textLimitWidth);
    }
    let fromNode = getC4ShapeObj(rel.from);
    let endNode = getC4ShapeObj(rel.to);
    let points = getIntersectPoints(fromNode, endNode);
    rel.startPoint = points.startPoint;
    rel.endPoint = points.endPoint;
  }
  svgDraw$3.drawRels(diagram, rels2, conf$a);
};
function drawInsideBoundary(diagram, parentBoundaryAlias, parentBounds, currentBoundarys, diagObj) {
  let currentBounds = new Bounds(diagObj);
  currentBounds.data.widthLimit = parentBounds.data.widthLimit / Math.min(c4BoundaryInRow, currentBoundarys.length);
  for (let i = 0; i < currentBoundarys.length; i++) {
    let currentBoundary = currentBoundarys[i];
    let Y3 = 0;
    currentBoundary.image = { width: 0, height: 0, Y: 0 };
    if (currentBoundary.sprite) {
      currentBoundary.image.width = 48;
      currentBoundary.image.height = 48;
      currentBoundary.image.Y = Y3;
      Y3 = currentBoundary.image.Y + currentBoundary.image.height;
    }
    let currentBoundaryTextWrap = currentBoundary.wrap && conf$a.wrap;
    let currentBoundaryLabelConf = boundaryFont(conf$a);
    currentBoundaryLabelConf.fontSize = currentBoundaryLabelConf.fontSize + 2;
    currentBoundaryLabelConf.fontWeight = "bold";
    calcC4ShapeTextWH(
      "label",
      currentBoundary,
      currentBoundaryTextWrap,
      currentBoundaryLabelConf,
      currentBounds.data.widthLimit
    );
    currentBoundary["label"].Y = Y3 + 8;
    Y3 = currentBoundary["label"].Y + currentBoundary["label"].height;
    if (currentBoundary.type && currentBoundary.type.text !== "") {
      currentBoundary.type.text = "[" + currentBoundary.type.text + "]";
      let currentBoundaryTypeConf = boundaryFont(conf$a);
      calcC4ShapeTextWH(
        "type",
        currentBoundary,
        currentBoundaryTextWrap,
        currentBoundaryTypeConf,
        currentBounds.data.widthLimit
      );
      currentBoundary["type"].Y = Y3 + 5;
      Y3 = currentBoundary["type"].Y + currentBoundary["type"].height;
    }
    if (currentBoundary.descr && currentBoundary.descr.text !== "") {
      let currentBoundaryDescrConf = boundaryFont(conf$a);
      currentBoundaryDescrConf.fontSize = currentBoundaryDescrConf.fontSize - 2;
      calcC4ShapeTextWH(
        "descr",
        currentBoundary,
        currentBoundaryTextWrap,
        currentBoundaryDescrConf,
        currentBounds.data.widthLimit
      );
      currentBoundary["descr"].Y = Y3 + 20;
      Y3 = currentBoundary["descr"].Y + currentBoundary["descr"].height;
    }
    if (i == 0 || i % c4BoundaryInRow === 0) {
      let _x = parentBounds.data.startx + conf$a.diagramMarginX;
      let _y = parentBounds.data.stopy + conf$a.diagramMarginY + Y3;
      currentBounds.setData(_x, _x, _y, _y);
    } else {
      let _x = currentBounds.data.stopx !== currentBounds.data.startx ? currentBounds.data.stopx + conf$a.diagramMarginX : currentBounds.data.startx;
      let _y = currentBounds.data.starty;
      currentBounds.setData(_x, _x, _y, _y);
    }
    currentBounds.name = currentBoundary.alias;
    let currentPersonOrSystemArray = diagObj.db.getC4ShapeArray(currentBoundary.alias);
    let currentPersonOrSystemKeys = diagObj.db.getC4ShapeKeys(currentBoundary.alias);
    if (currentPersonOrSystemKeys.length > 0) {
      drawC4ShapeArray(
        currentBounds,
        diagram,
        currentPersonOrSystemArray,
        currentPersonOrSystemKeys
      );
    }
    parentBoundaryAlias = currentBoundary.alias;
    let nextCurrentBoundarys = diagObj.db.getBoundarys(parentBoundaryAlias);
    if (nextCurrentBoundarys.length > 0) {
      drawInsideBoundary(
        diagram,
        parentBoundaryAlias,
        currentBounds,
        nextCurrentBoundarys,
        diagObj
      );
    }
    if (currentBoundary.alias !== "global")
      drawBoundary(diagram, currentBoundary, currentBounds);
    parentBounds.data.stopy = Math.max(
      currentBounds.data.stopy + conf$a.c4ShapeMargin,
      parentBounds.data.stopy
    );
    parentBounds.data.stopx = Math.max(
      currentBounds.data.stopx + conf$a.c4ShapeMargin,
      parentBounds.data.stopx
    );
    globalBoundaryMaxX = Math.max(globalBoundaryMaxX, parentBounds.data.stopx);
    globalBoundaryMaxY = Math.max(globalBoundaryMaxY, parentBounds.data.stopy);
  }
}
const draw$e = function(_text, id2, _version, diagObj) {
  conf$a = getConfig$1().c4;
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  let db = diagObj.db;
  diagObj.db.setWrap(conf$a.wrap);
  c4ShapeInRow = db.getC4ShapeInRow();
  c4BoundaryInRow = db.getC4BoundaryInRow();
  log$1.debug(`C:${JSON.stringify(conf$a, null, 2)}`);
  const diagram = securityLevel === "sandbox" ? root2.select(`[id="${id2}"]`) : select$1(`[id="${id2}"]`);
  svgDraw$3.insertComputerIcon(diagram);
  svgDraw$3.insertDatabaseIcon(diagram);
  svgDraw$3.insertClockIcon(diagram);
  let screenBounds = new Bounds(diagObj);
  screenBounds.setData(
    conf$a.diagramMarginX,
    conf$a.diagramMarginX,
    conf$a.diagramMarginY,
    conf$a.diagramMarginY
  );
  screenBounds.data.widthLimit = screen.availWidth;
  globalBoundaryMaxX = conf$a.diagramMarginX;
  globalBoundaryMaxY = conf$a.diagramMarginY;
  const title2 = diagObj.db.getTitle();
  let currentBoundarys = diagObj.db.getBoundarys("");
  drawInsideBoundary(diagram, "", screenBounds, currentBoundarys, diagObj);
  svgDraw$3.insertArrowHead(diagram);
  svgDraw$3.insertArrowEnd(diagram);
  svgDraw$3.insertArrowCrossHead(diagram);
  svgDraw$3.insertArrowFilledHead(diagram);
  drawRels(diagram, diagObj.db.getRels(), diagObj.db.getC4Shape, diagObj);
  screenBounds.data.stopx = globalBoundaryMaxX;
  screenBounds.data.stopy = globalBoundaryMaxY;
  const box = screenBounds.data;
  let boxHeight = box.stopy - box.starty;
  let height2 = boxHeight + 2 * conf$a.diagramMarginY;
  let boxWidth = box.stopx - box.startx;
  const width2 = boxWidth + 2 * conf$a.diagramMarginX;
  if (title2) {
    diagram.append("text").text(title2).attr("x", (box.stopx - box.startx) / 2 - 4 * conf$a.diagramMarginX).attr("y", box.starty + conf$a.diagramMarginY);
  }
  configureSvgSize(diagram, height2, width2, conf$a.useMaxWidth);
  const extraVertForTitle = title2 ? 60 : 0;
  diagram.attr(
    "viewBox",
    box.startx - conf$a.diagramMarginX + " -" + (conf$a.diagramMarginY + extraVertForTitle) + " " + width2 + " " + (height2 + extraVertForTitle)
  );
  addSVGAccessibilityFields(parser$a.yy, diagram, id2);
  log$1.debug(`models:`, box);
};
const c4Renderer = {
  drawPersonOrSystemArray: drawC4ShapeArray,
  drawBoundary,
  setConf: setConf$a,
  draw: draw$e
};
var parser$9 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 3], $V1 = [1, 7], $V2 = [1, 8], $V3 = [1, 9], $V4 = [1, 10], $V5 = [1, 13], $V6 = [1, 12], $V7 = [1, 16, 25], $V8 = [1, 20], $V9 = [1, 31], $Va = [1, 32], $Vb = [1, 33], $Vc = [1, 35], $Vd = [1, 38], $Ve = [1, 36], $Vf = [1, 37], $Vg = [1, 39], $Vh = [1, 40], $Vi = [1, 41], $Vj = [1, 42], $Vk = [1, 45], $Vl = [1, 46], $Vm = [1, 47], $Vn = [1, 48], $Vo = [16, 25], $Vp = [1, 62], $Vq = [1, 63], $Vr = [1, 64], $Vs = [1, 65], $Vt = [1, 66], $Vu = [1, 67], $Vv = [1, 68], $Vw = [16, 25, 32, 44, 45, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69], $Vx = [16, 25, 30, 32, 44, 45, 49, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69, 84, 85, 86, 87], $Vy = [5, 8, 9, 10, 11, 16, 19, 23, 25], $Vz = [53, 84, 85, 86, 87], $VA = [53, 61, 62, 84, 85, 86, 87], $VB = [53, 56, 57, 58, 59, 60, 84, 85, 86, 87], $VC = [16, 25, 32], $VD = [1, 100];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "statments": 5, "direction": 6, "directive": 7, "direction_tb": 8, "direction_bt": 9, "direction_rl": 10, "direction_lr": 11, "graphConfig": 12, "openDirective": 13, "typeDirective": 14, "closeDirective": 15, "NEWLINE": 16, ":": 17, "argDirective": 18, "open_directive": 19, "type_directive": 20, "arg_directive": 21, "close_directive": 22, "CLASS_DIAGRAM": 23, "statements": 24, "EOF": 25, "statement": 26, "className": 27, "alphaNumToken": 28, "classLiteralName": 29, "GENERICTYPE": 30, "relationStatement": 31, "LABEL": 32, "classStatement": 33, "methodStatement": 34, "annotationStatement": 35, "clickStatement": 36, "cssClassStatement": 37, "acc_title": 38, "acc_title_value": 39, "acc_descr": 40, "acc_descr_value": 41, "acc_descr_multiline_value": 42, "CLASS": 43, "STYLE_SEPARATOR": 44, "STRUCT_START": 45, "members": 46, "STRUCT_STOP": 47, "ANNOTATION_START": 48, "ANNOTATION_END": 49, "MEMBER": 50, "SEPARATOR": 51, "relation": 52, "STR": 53, "relationType": 54, "lineType": 55, "AGGREGATION": 56, "EXTENSION": 57, "COMPOSITION": 58, "DEPENDENCY": 59, "LOLLIPOP": 60, "LINE": 61, "DOTTED_LINE": 62, "CALLBACK": 63, "LINK": 64, "LINK_TARGET": 65, "CLICK": 66, "CALLBACK_NAME": 67, "CALLBACK_ARGS": 68, "HREF": 69, "CSSCLASS": 70, "commentToken": 71, "textToken": 72, "graphCodeTokens": 73, "textNoTagsToken": 74, "TAGSTART": 75, "TAGEND": 76, "==": 77, "--": 78, "PCT": 79, "DEFAULT": 80, "SPACE": 81, "MINUS": 82, "keywords": 83, "UNICODE_TEXT": 84, "NUM": 85, "ALPHA": 86, "BQUOTE_STR": 87, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "statments", 8: "direction_tb", 9: "direction_bt", 10: "direction_rl", 11: "direction_lr", 16: "NEWLINE", 17: ":", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 23: "CLASS_DIAGRAM", 25: "EOF", 30: "GENERICTYPE", 32: "LABEL", 38: "acc_title", 39: "acc_title_value", 40: "acc_descr", 41: "acc_descr_value", 42: "acc_descr_multiline_value", 43: "CLASS", 44: "STYLE_SEPARATOR", 45: "STRUCT_START", 47: "STRUCT_STOP", 48: "ANNOTATION_START", 49: "ANNOTATION_END", 50: "MEMBER", 51: "SEPARATOR", 53: "STR", 56: "AGGREGATION", 57: "EXTENSION", 58: "COMPOSITION", 59: "DEPENDENCY", 60: "LOLLIPOP", 61: "LINE", 62: "DOTTED_LINE", 63: "CALLBACK", 64: "LINK", 65: "LINK_TARGET", 66: "CLICK", 67: "CALLBACK_NAME", 68: "CALLBACK_ARGS", 69: "HREF", 70: "CSSCLASS", 73: "graphCodeTokens", 75: "TAGSTART", 76: "TAGEND", 77: "==", 78: "--", 79: "PCT", 80: "DEFAULT", 81: "SPACE", 82: "MINUS", 83: "keywords", 84: "UNICODE_TEXT", 85: "NUM", 86: "ALPHA", 87: "BQUOTE_STR" },
    productions_: [0, [3, 1], [3, 1], [3, 1], [3, 2], [6, 1], [6, 1], [6, 1], [6, 1], [4, 1], [7, 4], [7, 6], [13, 1], [14, 1], [18, 1], [15, 1], [12, 4], [24, 1], [24, 2], [24, 3], [27, 1], [27, 1], [27, 2], [27, 2], [27, 2], [26, 1], [26, 2], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 2], [26, 2], [26, 1], [33, 2], [33, 4], [33, 5], [33, 7], [35, 4], [46, 1], [46, 2], [34, 1], [34, 2], [34, 1], [34, 1], [31, 3], [31, 4], [31, 4], [31, 5], [52, 3], [52, 2], [52, 2], [52, 1], [54, 1], [54, 1], [54, 1], [54, 1], [54, 1], [55, 1], [55, 1], [36, 3], [36, 4], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [36, 3], [36, 4], [36, 4], [36, 5], [37, 3], [71, 1], [71, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [72, 1], [74, 1], [74, 1], [74, 1], [74, 1], [28, 1], [28, 1], [28, 1], [29, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 5:
          yy.setDirection("TB");
          break;
        case 6:
          yy.setDirection("BT");
          break;
        case 7:
          yy.setDirection("RL");
          break;
        case 8:
          yy.setDirection("LR");
          break;
        case 12:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 13:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 14:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 15:
          yy.parseDirective("}%%", "close_directive", "class");
          break;
        case 20:
        case 21:
          this.$ = $$[$0];
          break;
        case 22:
          this.$ = $$[$0 - 1] + $$[$0];
          break;
        case 23:
        case 24:
          this.$ = $$[$0 - 1] + "~" + $$[$0];
          break;
        case 25:
          yy.addRelation($$[$0]);
          break;
        case 26:
          $$[$0 - 1].title = yy.cleanupLabel($$[$0]);
          yy.addRelation($$[$0 - 1]);
          break;
        case 34:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 35:
        case 36:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 37:
          yy.addClass($$[$0]);
          break;
        case 38:
          yy.addClass($$[$0 - 2]);
          yy.setCssClass($$[$0 - 2], $$[$0]);
          break;
        case 39:
          yy.addClass($$[$0 - 3]);
          yy.addMembers($$[$0 - 3], $$[$0 - 1]);
          break;
        case 40:
          yy.addClass($$[$0 - 5]);
          yy.setCssClass($$[$0 - 5], $$[$0 - 3]);
          yy.addMembers($$[$0 - 5], $$[$0 - 1]);
          break;
        case 41:
          yy.addAnnotation($$[$0], $$[$0 - 2]);
          break;
        case 42:
          this.$ = [$$[$0]];
          break;
        case 43:
          $$[$0].push($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 44:
          break;
        case 45:
          yy.addMember($$[$0 - 1], yy.cleanupLabel($$[$0]));
          break;
        case 46:
          break;
        case 47:
          break;
        case 48:
          this.$ = { "id1": $$[$0 - 2], "id2": $$[$0], relation: $$[$0 - 1], relationTitle1: "none", relationTitle2: "none" };
          break;
        case 49:
          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 1], relationTitle1: $$[$0 - 2], relationTitle2: "none" };
          break;
        case 50:
          this.$ = { id1: $$[$0 - 3], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: "none", relationTitle2: $$[$0 - 1] };
          break;
        case 51:
          this.$ = { id1: $$[$0 - 4], id2: $$[$0], relation: $$[$0 - 2], relationTitle1: $$[$0 - 3], relationTitle2: $$[$0 - 1] };
          break;
        case 52:
          this.$ = { type1: $$[$0 - 2], type2: $$[$0], lineType: $$[$0 - 1] };
          break;
        case 53:
          this.$ = { type1: "none", type2: $$[$0], lineType: $$[$0 - 1] };
          break;
        case 54:
          this.$ = { type1: $$[$0 - 1], type2: "none", lineType: $$[$0] };
          break;
        case 55:
          this.$ = { type1: "none", type2: "none", lineType: $$[$0] };
          break;
        case 56:
          this.$ = yy.relationType.AGGREGATION;
          break;
        case 57:
          this.$ = yy.relationType.EXTENSION;
          break;
        case 58:
          this.$ = yy.relationType.COMPOSITION;
          break;
        case 59:
          this.$ = yy.relationType.DEPENDENCY;
          break;
        case 60:
          this.$ = yy.relationType.LOLLIPOP;
          break;
        case 61:
          this.$ = yy.lineType.LINE;
          break;
        case 62:
          this.$ = yy.lineType.DOTTED_LINE;
          break;
        case 63:
        case 69:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 1], $$[$0]);
          break;
        case 64:
        case 70:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1]);
          yy.setTooltip($$[$0 - 2], $$[$0]);
          break;
        case 65:
        case 73:
          this.$ = $$[$0 - 2];
          yy.setLink($$[$0 - 1], $$[$0]);
          break;
        case 66:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 67:
        case 75:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 2], $$[$0 - 1]);
          yy.setTooltip($$[$0 - 2], $$[$0]);
          break;
        case 68:
        case 76:
          this.$ = $$[$0 - 4];
          yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);
          yy.setTooltip($$[$0 - 3], $$[$0 - 1]);
          break;
        case 71:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 72:
          this.$ = $$[$0 - 4];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);
          yy.setTooltip($$[$0 - 3], $$[$0]);
          break;
        case 74:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 77:
          yy.setCssClass($$[$0 - 1], $$[$0]);
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: $V0, 6: 4, 7: 5, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 12: 6, 13: 11, 19: $V5, 23: $V6 }, { 1: [3] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 3: 14, 4: 2, 5: $V0, 6: 4, 7: 5, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 12: 6, 13: 11, 19: $V5, 23: $V6 }, { 1: [2, 9] }, o($V7, [2, 5]), o($V7, [2, 6]), o($V7, [2, 7]), o($V7, [2, 8]), { 14: 15, 20: [1, 16] }, { 16: [1, 17] }, { 20: [2, 12] }, { 1: [2, 4] }, { 15: 18, 17: [1, 19], 22: $V8 }, o([17, 22], [2, 13]), { 6: 30, 7: 29, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 13: 11, 19: $V5, 24: 21, 26: 22, 27: 34, 28: 43, 29: 44, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: $V9, 40: $Va, 42: $Vb, 43: $Vc, 48: $Vd, 50: $Ve, 51: $Vf, 63: $Vg, 64: $Vh, 66: $Vi, 70: $Vj, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 16: [1, 49] }, { 18: 50, 21: [1, 51] }, { 16: [2, 15] }, { 25: [1, 52] }, { 16: [1, 53], 25: [2, 17] }, o($Vo, [2, 25], { 32: [1, 54] }), o($Vo, [2, 27]), o($Vo, [2, 28]), o($Vo, [2, 29]), o($Vo, [2, 30]), o($Vo, [2, 31]), o($Vo, [2, 32]), o($Vo, [2, 33]), { 39: [1, 55] }, { 41: [1, 56] }, o($Vo, [2, 36]), o($Vo, [2, 44], { 52: 57, 54: 60, 55: 61, 32: [1, 59], 53: [1, 58], 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv }), { 27: 69, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 46]), o($Vo, [2, 47]), { 28: 70, 84: $Vk, 85: $Vl, 86: $Vm }, { 27: 71, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 72, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 73, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 53: [1, 74] }, o($Vw, [2, 20], { 28: 43, 29: 44, 27: 75, 30: [1, 76], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }), o($Vw, [2, 21], { 30: [1, 77] }), o($Vx, [2, 91]), o($Vx, [2, 92]), o($Vx, [2, 93]), o([16, 25, 30, 32, 44, 45, 53, 56, 57, 58, 59, 60, 61, 62, 67, 69], [2, 94]), o($Vy, [2, 10]), { 15: 78, 22: $V8 }, { 22: [2, 14] }, { 1: [2, 16] }, { 6: 30, 7: 29, 8: $V1, 9: $V2, 10: $V3, 11: $V4, 13: 11, 19: $V5, 24: 79, 25: [2, 18], 26: 22, 27: 34, 28: 43, 29: 44, 31: 23, 33: 24, 34: 25, 35: 26, 36: 27, 37: 28, 38: $V9, 40: $Va, 42: $Vb, 43: $Vc, 48: $Vd, 50: $Ve, 51: $Vf, 63: $Vg, 64: $Vh, 66: $Vi, 70: $Vj, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 26]), o($Vo, [2, 34]), o($Vo, [2, 35]), { 27: 80, 28: 43, 29: 44, 53: [1, 81], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 52: 82, 54: 60, 55: 61, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt, 61: $Vu, 62: $Vv }, o($Vo, [2, 45]), { 55: 83, 61: $Vu, 62: $Vv }, o($Vz, [2, 55], { 54: 84, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt }), o($VA, [2, 56]), o($VA, [2, 57]), o($VA, [2, 58]), o($VA, [2, 59]), o($VA, [2, 60]), o($VB, [2, 61]), o($VB, [2, 62]), o($Vo, [2, 37], { 44: [1, 85], 45: [1, 86] }), { 49: [1, 87] }, { 53: [1, 88] }, { 53: [1, 89] }, { 67: [1, 90], 69: [1, 91] }, { 28: 92, 84: $Vk, 85: $Vl, 86: $Vm }, o($Vw, [2, 22]), o($Vw, [2, 23]), o($Vw, [2, 24]), { 16: [1, 93] }, { 25: [2, 19] }, o($VC, [2, 48]), { 27: 94, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, { 27: 95, 28: 43, 29: 44, 53: [1, 96], 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vz, [2, 54], { 54: 97, 56: $Vp, 57: $Vq, 58: $Vr, 59: $Vs, 60: $Vt }), o($Vz, [2, 53]), { 28: 98, 84: $Vk, 85: $Vl, 86: $Vm }, { 46: 99, 50: $VD }, { 27: 101, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vo, [2, 63], { 53: [1, 102] }), o($Vo, [2, 65], { 53: [1, 104], 65: [1, 103] }), o($Vo, [2, 69], { 53: [1, 105], 68: [1, 106] }), o($Vo, [2, 73], { 53: [1, 108], 65: [1, 107] }), o($Vo, [2, 77]), o($Vy, [2, 11]), o($VC, [2, 50]), o($VC, [2, 49]), { 27: 109, 28: 43, 29: 44, 84: $Vk, 85: $Vl, 86: $Vm, 87: $Vn }, o($Vz, [2, 52]), o($Vo, [2, 38], { 45: [1, 110] }), { 47: [1, 111] }, { 46: 112, 47: [2, 42], 50: $VD }, o($Vo, [2, 41]), o($Vo, [2, 64]), o($Vo, [2, 66]), o($Vo, [2, 67], { 65: [1, 113] }), o($Vo, [2, 70]), o($Vo, [2, 71], { 53: [1, 114] }), o($Vo, [2, 74]), o($Vo, [2, 75], { 65: [1, 115] }), o($VC, [2, 51]), { 46: 116, 50: $VD }, o($Vo, [2, 39]), { 47: [2, 43] }, o($Vo, [2, 68]), o($Vo, [2, 72]), o($Vo, [2, 76]), { 47: [1, 117] }, o($Vo, [2, 40])],
    defaultActions: { 2: [2, 1], 3: [2, 2], 4: [2, 3], 6: [2, 9], 13: [2, 12], 14: [2, 4], 20: [2, 15], 51: [2, 14], 52: [2, 16], 79: [2, 19], 112: [2, 43] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 19;
          case 1:
            return 8;
          case 2:
            return 9;
          case 3:
            return 10;
          case 4:
            return 11;
          case 5:
            this.begin("type_directive");
            return 20;
          case 6:
            this.popState();
            this.begin("arg_directive");
            return 17;
          case 7:
            this.popState();
            this.popState();
            return 22;
          case 8:
            return 21;
          case 9:
            break;
          case 10:
            break;
          case 11:
            this.begin("acc_title");
            return 38;
          case 12:
            this.popState();
            return "acc_title_value";
          case 13:
            this.begin("acc_descr");
            return 40;
          case 14:
            this.popState();
            return "acc_descr_value";
          case 15:
            this.begin("acc_descr_multiline");
            break;
          case 16:
            this.popState();
            break;
          case 17:
            return "acc_descr_multiline_value";
          case 18:
            return 16;
          case 19:
            break;
          case 20:
            return 23;
          case 21:
            return 23;
          case 22:
            this.begin("struct");
            return 45;
          case 23:
            return "EDGE_STATE";
          case 24:
            return "EOF_IN_STRUCT";
          case 25:
            return "OPEN_IN_STRUCT";
          case 26:
            this.popState();
            return 47;
          case 27:
            break;
          case 28:
            return "MEMBER";
          case 29:
            return 43;
          case 30:
            return 70;
          case 31:
            return 63;
          case 32:
            return 64;
          case 33:
            return 66;
          case 34:
            return 48;
          case 35:
            return 49;
          case 36:
            this.begin("generic");
            break;
          case 37:
            this.popState();
            break;
          case 38:
            return "GENERICTYPE";
          case 39:
            this.begin("string");
            break;
          case 40:
            this.popState();
            break;
          case 41:
            return "STR";
          case 42:
            this.begin("bqstring");
            break;
          case 43:
            this.popState();
            break;
          case 44:
            return "BQUOTE_STR";
          case 45:
            this.begin("href");
            break;
          case 46:
            this.popState();
            break;
          case 47:
            return 69;
          case 48:
            this.begin("callback_name");
            break;
          case 49:
            this.popState();
            break;
          case 50:
            this.popState();
            this.begin("callback_args");
            break;
          case 51:
            return 67;
          case 52:
            this.popState();
            break;
          case 53:
            return 68;
          case 54:
            return 65;
          case 55:
            return 65;
          case 56:
            return 65;
          case 57:
            return 65;
          case 58:
            return 57;
          case 59:
            return 57;
          case 60:
            return 59;
          case 61:
            return 59;
          case 62:
            return 58;
          case 63:
            return 56;
          case 64:
            return 60;
          case 65:
            return 61;
          case 66:
            return 62;
          case 67:
            return 32;
          case 68:
            return 44;
          case 69:
            return 82;
          case 70:
            return "DOT";
          case 71:
            return "PLUS";
          case 72:
            return 79;
          case 73:
            return "EQUALS";
          case 74:
            return "EQUALS";
          case 75:
            return 86;
          case 76:
            return "PUNCTUATION";
          case 77:
            return 85;
          case 78:
            return 84;
          case 79:
            return 81;
          case 80:
            return 25;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/, /^(?:%%[^\n]*(\r?\n)*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:\s*(\r?\n)+)/, /^(?:\s+)/, /^(?:classDiagram-v2\b)/, /^(?:classDiagram\b)/, /^(?:[{])/, /^(?:\[\*\])/, /^(?:$)/, /^(?:[{])/, /^(?:[}])/, /^(?:[\n])/, /^(?:[^{}\n]*)/, /^(?:class\b)/, /^(?:cssClass\b)/, /^(?:callback\b)/, /^(?:link\b)/, /^(?:click\b)/, /^(?:<<)/, /^(?:>>)/, /^(?:[~])/, /^(?:[~])/, /^(?:[^~]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:[`])/, /^(?:[`])/, /^(?:[^`]+)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:\s*<\|)/, /^(?:\s*\|>)/, /^(?:\s*>)/, /^(?:\s*<)/, /^(?:\s*\*)/, /^(?:\s*o\b)/, /^(?:\s*\(\))/, /^(?:--)/, /^(?:\.\.)/, /^(?::{1}[^:\n;]+)/, /^(?::{3})/, /^(?:-)/, /^(?:\.)/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:\w+)/, /^(?:[!"#$%&'*+,-.`?\\/])/, /^(?:[0-9]+)/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\s)/, /^(?:$)/],
      conditions: { "acc_descr_multiline": { "rules": [16, 17], "inclusive": false }, "acc_descr": { "rules": [14], "inclusive": false }, "acc_title": { "rules": [12], "inclusive": false }, "arg_directive": { "rules": [7, 8], "inclusive": false }, "type_directive": { "rules": [6, 7], "inclusive": false }, "open_directive": { "rules": [5], "inclusive": false }, "callback_args": { "rules": [52, 53], "inclusive": false }, "callback_name": { "rules": [49, 50, 51], "inclusive": false }, "href": { "rules": [46, 47], "inclusive": false }, "struct": { "rules": [23, 24, 25, 26, 27, 28], "inclusive": false }, "generic": { "rules": [37, 38], "inclusive": false }, "bqstring": { "rules": [43, 44], "inclusive": false }, "string": { "rules": [40, 41], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 13, 15, 18, 19, 20, 21, 22, 23, 29, 30, 31, 32, 33, 34, 35, 36, 39, 42, 45, 48, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$9.parser = parser$9;
const classDetector = (txt, config2) => {
  var _a;
  if (((_a = config2 == null ? void 0 : config2.class) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
    return false;
  return txt.match(/^\s*classDiagram/) !== null;
};
const classDetectorV2 = (txt, config2) => {
  var _a;
  if (txt.match(/^\s*classDiagram/) !== null && ((_a = config2 == null ? void 0 : config2.class) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
    return true;
  return txt.match(/^\s*classDiagram-v2/) !== null;
};
const MERMAID_DOM_ID_PREFIX$1 = "classid-";
let relations$1 = [];
let classes$2 = {};
let classCounter = 0;
let funs$2 = [];
const sanitizeText$2 = (txt) => common.sanitizeText(txt, getConfig$1());
const parseDirective$9 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const splitClassNameAndType = function(id2) {
  let genericType = "";
  let className = id2;
  if (id2.indexOf("~") > 0) {
    let split = id2.split("~");
    className = split[0];
    genericType = common.sanitizeText(split[1], getConfig$1());
  }
  return { className, type: genericType };
};
const addClass$1 = function(id2) {
  let classId = splitClassNameAndType(id2);
  if (typeof classes$2[classId.className] !== "undefined")
    return;
  classes$2[classId.className] = {
    id: classId.className,
    type: classId.type,
    cssClasses: [],
    methods: [],
    members: [],
    annotations: [],
    domId: MERMAID_DOM_ID_PREFIX$1 + classId.className + "-" + classCounter
  };
  classCounter++;
};
const lookUpDomId$1 = function(id2) {
  const classKeys = Object.keys(classes$2);
  for (let i = 0; i < classKeys.length; i++) {
    if (classes$2[classKeys[i]].id === id2) {
      return classes$2[classKeys[i]].domId;
    }
  }
};
const clear$c = function() {
  relations$1 = [];
  classes$2 = {};
  funs$2 = [];
  funs$2.push(setupToolTips$1);
  clear$g();
};
const getClass = function(id2) {
  return classes$2[id2];
};
const getClasses$5 = function() {
  return classes$2;
};
const getRelations$1 = function() {
  return relations$1;
};
const addRelation$1 = function(relation) {
  log$1.debug("Adding relation: " + JSON.stringify(relation));
  addClass$1(relation.id1);
  addClass$1(relation.id2);
  relation.id1 = splitClassNameAndType(relation.id1).className;
  relation.id2 = splitClassNameAndType(relation.id2).className;
  relation.relationTitle1 = common.sanitizeText(
    relation.relationTitle1.trim(),
    getConfig$1()
  );
  relation.relationTitle2 = common.sanitizeText(
    relation.relationTitle2.trim(),
    getConfig$1()
  );
  relations$1.push(relation);
};
const addAnnotation = function(className, annotation) {
  const validatedClassName = splitClassNameAndType(className).className;
  classes$2[validatedClassName].annotations.push(annotation);
};
const addMember = function(className, member) {
  const validatedClassName = splitClassNameAndType(className).className;
  const theClass = classes$2[validatedClassName];
  if (typeof member === "string") {
    const memberString = member.trim();
    if (memberString.startsWith("<<") && memberString.endsWith(">>")) {
      theClass.annotations.push(sanitizeText$2(memberString.substring(2, memberString.length - 2)));
    } else if (memberString.indexOf(")") > 0) {
      theClass.methods.push(sanitizeText$2(memberString));
    } else if (memberString) {
      theClass.members.push(sanitizeText$2(memberString));
    }
  }
};
const addMembers = function(className, members) {
  if (Array.isArray(members)) {
    members.reverse();
    members.forEach((member) => addMember(className, member));
  }
};
const cleanupLabel$1 = function(label) {
  if (label.substring(0, 1) === ":") {
    return common.sanitizeText(label.substr(1).trim(), getConfig$1());
  } else {
    return sanitizeText$2(label.trim());
  }
};
const setCssClass = function(ids, className) {
  ids.split(",").forEach(function(_id) {
    let id2 = _id;
    if (_id[0].match(/\d/))
      id2 = MERMAID_DOM_ID_PREFIX$1 + id2;
    if (typeof classes$2[id2] !== "undefined") {
      classes$2[id2].cssClasses.push(className);
    }
  });
};
const setTooltip$1 = function(ids, tooltip) {
  const config2 = getConfig$1();
  ids.split(",").forEach(function(id2) {
    if (typeof tooltip !== "undefined") {
      classes$2[id2].tooltip = common.sanitizeText(tooltip, config2);
    }
  });
};
const getTooltip$1 = function(id2) {
  return classes$2[id2].tooltip;
};
const setLink$2 = function(ids, linkStr, target) {
  const config2 = getConfig$1();
  ids.split(",").forEach(function(_id) {
    let id2 = _id;
    if (_id[0].match(/\d/))
      id2 = MERMAID_DOM_ID_PREFIX$1 + id2;
    if (typeof classes$2[id2] !== "undefined") {
      classes$2[id2].link = utils.formatUrl(linkStr, config2);
      if (config2.securityLevel === "sandbox") {
        classes$2[id2].linkTarget = "_top";
      } else if (typeof target === "string") {
        classes$2[id2].linkTarget = sanitizeText$2(target);
      } else {
        classes$2[id2].linkTarget = "_blank";
      }
    }
  });
  setCssClass(ids, "clickable");
};
const setClickEvent$2 = function(ids, functionName, functionArgs) {
  ids.split(",").forEach(function(id2) {
    setClickFunc(id2, functionName, functionArgs);
    classes$2[id2].haveCallback = true;
  });
  setCssClass(ids, "clickable");
};
const setClickFunc = function(domId, functionName, functionArgs) {
  const config2 = getConfig$1();
  let id2 = domId;
  let elemId = lookUpDomId$1(id2);
  if (config2.securityLevel !== "loose") {
    return;
  }
  if (typeof functionName === "undefined") {
    return;
  }
  if (typeof classes$2[id2] !== "undefined") {
    let argList = [];
    if (typeof functionArgs === "string") {
      argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
      for (let i = 0; i < argList.length; i++) {
        let item = argList[i].trim();
        if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
          item = item.substr(1, item.length - 2);
        }
        argList[i] = item;
      }
    }
    if (argList.length === 0) {
      argList.push(elemId);
    }
    funs$2.push(function() {
      const elem = document.querySelector(`[id="${elemId}"]`);
      if (elem !== null) {
        elem.addEventListener(
          "click",
          function() {
            utils.runFunc(functionName, ...argList);
          },
          false
        );
      }
    });
  }
};
const bindFunctions$2 = function(element) {
  funs$2.forEach(function(fun) {
    fun(element);
  });
};
const lineType$1 = {
  LINE: 0,
  DOTTED_LINE: 1
};
const relationType$1 = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3,
  LOLLIPOP: 4
};
const setupToolTips$1 = function(element) {
  let tooltipElem = select$1(".mermaidTooltip");
  if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
    tooltipElem = select$1("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0);
  }
  const svg2 = select$1(element).select("svg");
  const nodes = svg2.selectAll("g.node");
  nodes.on("mouseover", function() {
    const el = select$1(this);
    const title2 = el.attr("title");
    if (title2 === null) {
      return;
    }
    const rect2 = this.getBoundingClientRect();
    tooltipElem.transition().duration(200).style("opacity", ".9");
    tooltipElem.text(el.attr("title")).style("left", window.scrollX + rect2.left + (rect2.right - rect2.left) / 2 + "px").style("top", window.scrollY + rect2.top - 14 + document.body.scrollTop + "px");
    tooltipElem.html(tooltipElem.html().replace(/&lt;br\/&gt;/g, "<br/>"));
    el.classed("hover", true);
  }).on("mouseout", function() {
    tooltipElem.transition().duration(500).style("opacity", 0);
    const el = select$1(this);
    el.classed("hover", false);
  });
};
funs$2.push(setupToolTips$1);
let direction$2 = "TB";
const getDirection$2 = () => direction$2;
const setDirection$2 = (dir) => {
  direction$2 = dir;
};
const classDb = {
  parseDirective: parseDirective$9,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  getConfig: () => getConfig$1().class,
  addClass: addClass$1,
  bindFunctions: bindFunctions$2,
  clear: clear$c,
  getClass,
  getClasses: getClasses$5,
  addAnnotation,
  getRelations: getRelations$1,
  addRelation: addRelation$1,
  getDirection: getDirection$2,
  setDirection: setDirection$2,
  addMember,
  addMembers,
  cleanupLabel: cleanupLabel$1,
  lineType: lineType$1,
  relationType: relationType$1,
  setClickEvent: setClickEvent$2,
  setCssClass,
  setLink: setLink$2,
  getTooltip: getTooltip$1,
  setTooltip: setTooltip$1,
  lookUpDomId: lookUpDomId$1
};
let edgeCount$1 = 0;
const drawEdge$1 = function(elem, path2, relation, conf2, diagObj) {
  const getRelationType = function(type2) {
    switch (type2) {
      case diagObj.db.relationType.AGGREGATION:
        return "aggregation";
      case diagObj.db.EXTENSION:
        return "extension";
      case diagObj.db.COMPOSITION:
        return "composition";
      case diagObj.db.DEPENDENCY:
        return "dependency";
      case diagObj.db.LOLLIPOP:
        return "lollipop";
    }
  };
  path2.points = path2.points.filter((p) => !Number.isNaN(p.y));
  const lineData = path2.points;
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curveBasis);
  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", "edge" + edgeCount$1).attr("class", "relation");
  let url = "";
  if (conf2.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  if (relation.relation.lineType == 1) {
    svgPath.attr("class", "relation dashed-line");
  }
  if (relation.relation.type1 !== "none") {
    svgPath.attr(
      "marker-start",
      "url(" + url + "#" + getRelationType(relation.relation.type1) + "Start)"
    );
  }
  if (relation.relation.type2 !== "none") {
    svgPath.attr(
      "marker-end",
      "url(" + url + "#" + getRelationType(relation.relation.type2) + "End)"
    );
  }
  let x2, y2;
  const l = path2.points.length;
  let labelPosition = utils.calcLabelPosition(path2.points);
  x2 = labelPosition.x;
  y2 = labelPosition.y;
  let p1_card_x, p1_card_y;
  let p2_card_x, p2_card_y;
  if (l % 2 !== 0 && l > 1) {
    let cardinality_1_point = utils.calcCardinalityPosition(
      relation.relation.type1 !== "none",
      path2.points,
      path2.points[0]
    );
    let cardinality_2_point = utils.calcCardinalityPosition(
      relation.relation.type2 !== "none",
      path2.points,
      path2.points[l - 1]
    );
    log$1.debug("cardinality_1_point " + JSON.stringify(cardinality_1_point));
    log$1.debug("cardinality_2_point " + JSON.stringify(cardinality_2_point));
    p1_card_x = cardinality_1_point.x;
    p1_card_y = cardinality_1_point.y;
    p2_card_x = cardinality_2_point.x;
    p2_card_y = cardinality_2_point.y;
  }
  if (typeof relation.title !== "undefined") {
    const g = elem.append("g").attr("class", "classLabel");
    const label = g.append("text").attr("class", "label").attr("x", x2).attr("y", y2).attr("fill", "red").attr("text-anchor", "middle").text(relation.title);
    window.label = label;
    const bounds2 = label.node().getBBox();
    g.insert("rect", ":first-child").attr("class", "box").attr("x", bounds2.x - conf2.padding / 2).attr("y", bounds2.y - conf2.padding / 2).attr("width", bounds2.width + conf2.padding).attr("height", bounds2.height + conf2.padding);
  }
  log$1.info("Rendering relation " + JSON.stringify(relation));
  if (typeof relation.relationTitle1 !== "undefined" && relation.relationTitle1 !== "none") {
    const g = elem.append("g").attr("class", "cardinality");
    g.append("text").attr("class", "type1").attr("x", p1_card_x).attr("y", p1_card_y).attr("fill", "black").attr("font-size", "6").text(relation.relationTitle1);
  }
  if (typeof relation.relationTitle2 !== "undefined" && relation.relationTitle2 !== "none") {
    const g = elem.append("g").attr("class", "cardinality");
    g.append("text").attr("class", "type2").attr("x", p2_card_x).attr("y", p2_card_y).attr("fill", "black").attr("font-size", "6").text(relation.relationTitle2);
  }
  edgeCount$1++;
};
const drawClass = function(elem, classDef, conf2, diagObj) {
  log$1.debug("Rendering class ", classDef, conf2);
  const id2 = classDef.id;
  const classInfo = {
    id: id2,
    label: classDef.id,
    width: 0,
    height: 0
  };
  const g = elem.append("g").attr("id", diagObj.db.lookUpDomId(id2)).attr("class", "classGroup");
  let title2;
  if (classDef.link) {
    title2 = g.append("svg:a").attr("xlink:href", classDef.link).attr("target", classDef.linkTarget).append("text").attr("y", conf2.textHeight + conf2.padding).attr("x", 0);
  } else {
    title2 = g.append("text").attr("y", conf2.textHeight + conf2.padding).attr("x", 0);
  }
  let isFirst = true;
  classDef.annotations.forEach(function(member) {
    const titleText2 = title2.append("tspan").text("\xAB" + member + "\xBB");
    if (!isFirst)
      titleText2.attr("dy", conf2.textHeight);
    isFirst = false;
  });
  let classTitleString = classDef.id;
  if (classDef.type !== void 0 && classDef.type !== "") {
    classTitleString += "<" + classDef.type + ">";
  }
  const classTitle = title2.append("tspan").text(classTitleString).attr("class", "title");
  if (!isFirst)
    classTitle.attr("dy", conf2.textHeight);
  const titleHeight = title2.node().getBBox().height;
  const membersLine = g.append("line").attr("x1", 0).attr("y1", conf2.padding + titleHeight + conf2.dividerMargin / 2).attr("y2", conf2.padding + titleHeight + conf2.dividerMargin / 2);
  const members = g.append("text").attr("x", conf2.padding).attr("y", titleHeight + conf2.dividerMargin + conf2.textHeight).attr("fill", "white").attr("class", "classText");
  isFirst = true;
  classDef.members.forEach(function(member) {
    addTspan(members, member, isFirst, conf2);
    isFirst = false;
  });
  const membersBox = members.node().getBBox();
  const methodsLine = g.append("line").attr("x1", 0).attr("y1", conf2.padding + titleHeight + conf2.dividerMargin + membersBox.height).attr("y2", conf2.padding + titleHeight + conf2.dividerMargin + membersBox.height);
  const methods = g.append("text").attr("x", conf2.padding).attr("y", titleHeight + 2 * conf2.dividerMargin + membersBox.height + conf2.textHeight).attr("fill", "white").attr("class", "classText");
  isFirst = true;
  classDef.methods.forEach(function(method) {
    addTspan(methods, method, isFirst, conf2);
    isFirst = false;
  });
  const classBox = g.node().getBBox();
  var cssClassStr = " ";
  if (classDef.cssClasses.length > 0) {
    cssClassStr = cssClassStr + classDef.cssClasses.join(" ");
  }
  const rect2 = g.insert("rect", ":first-child").attr("x", 0).attr("y", 0).attr("width", classBox.width + 2 * conf2.padding).attr("height", classBox.height + conf2.padding + 0.5 * conf2.dividerMargin).attr("class", cssClassStr);
  const rectWidth = rect2.node().getBBox().width;
  title2.node().childNodes.forEach(function(x2) {
    x2.setAttribute("x", (rectWidth - x2.getBBox().width) / 2);
  });
  if (classDef.tooltip) {
    title2.insert("title").text(classDef.tooltip);
  }
  membersLine.attr("x2", rectWidth);
  methodsLine.attr("x2", rectWidth);
  classInfo.width = rectWidth;
  classInfo.height = classBox.height + conf2.padding + 0.5 * conf2.dividerMargin;
  return classInfo;
};
const parseMember = function(text2) {
  const fieldRegEx = /^(\+|-|~|#)?(\w+)(~\w+~|\[\])?\s+(\w+) *(\*|\$)?$/;
  const methodRegEx = /^([+|\-|~|#])?(\w+) *\( *(.*)\) *(\*|\$)? *(\w*[~|[\]]*\s*\w*~?)$/;
  let fieldMatch = text2.match(fieldRegEx);
  let methodMatch = text2.match(methodRegEx);
  if (fieldMatch && !methodMatch) {
    return buildFieldDisplay(fieldMatch);
  } else if (methodMatch) {
    return buildMethodDisplay(methodMatch);
  } else {
    return buildLegacyDisplay(text2);
  }
};
const buildFieldDisplay = function(parsedText) {
  let cssStyle = "";
  let displayText = "";
  try {
    let visibility = parsedText[1] ? parsedText[1].trim() : "";
    let fieldType = parsedText[2] ? parsedText[2].trim() : "";
    let genericType = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : "";
    let fieldName = parsedText[4] ? parsedText[4].trim() : "";
    let classifier = parsedText[5] ? parsedText[5].trim() : "";
    displayText = visibility + fieldType + genericType + " " + fieldName;
    cssStyle = parseClassifier(classifier);
  } catch (err) {
    displayText = parsedText;
  }
  return {
    displayText,
    cssStyle
  };
};
const buildMethodDisplay = function(parsedText) {
  let cssStyle = "";
  let displayText = "";
  try {
    let visibility = parsedText[1] ? parsedText[1].trim() : "";
    let methodName = parsedText[2] ? parsedText[2].trim() : "";
    let parameters = parsedText[3] ? parseGenericTypes(parsedText[3].trim()) : "";
    let classifier = parsedText[4] ? parsedText[4].trim() : "";
    let returnType = parsedText[5] ? " : " + parseGenericTypes(parsedText[5]).trim() : "";
    displayText = visibility + methodName + "(" + parameters + ")" + returnType;
    cssStyle = parseClassifier(classifier);
  } catch (err) {
    displayText = parsedText;
  }
  return {
    displayText,
    cssStyle
  };
};
const buildLegacyDisplay = function(text2) {
  let displayText = "";
  let cssStyle = "";
  let returnType = "";
  let methodStart = text2.indexOf("(");
  let methodEnd = text2.indexOf(")");
  if (methodStart > 1 && methodEnd > methodStart && methodEnd <= text2.length) {
    let visibility = "";
    let methodName = "";
    let firstChar = text2.substring(0, 1);
    if (firstChar.match(/\w/)) {
      methodName = text2.substring(0, methodStart).trim();
    } else {
      if (firstChar.match(/\+|-|~|#/)) {
        visibility = firstChar;
      }
      methodName = text2.substring(1, methodStart).trim();
    }
    const parameters = text2.substring(methodStart + 1, methodEnd);
    text2.substring(methodEnd + 1, 1);
    cssStyle = parseClassifier(text2.substring(methodEnd + 1, methodEnd + 2));
    displayText = visibility + methodName + "(" + parseGenericTypes(parameters.trim()) + ")";
    if (methodEnd < text2.length) {
      returnType = text2.substring(methodEnd + 2).trim();
      if (returnType !== "") {
        returnType = " : " + parseGenericTypes(returnType);
        displayText += returnType;
      }
    }
  } else {
    displayText = parseGenericTypes(text2);
  }
  return {
    displayText,
    cssStyle
  };
};
const addTspan = function(textEl, txt, isFirst, conf2) {
  let member = parseMember(txt);
  const tSpan = textEl.append("tspan").attr("x", conf2.padding).text(member.displayText);
  if (member.cssStyle !== "") {
    tSpan.attr("style", member.cssStyle);
  }
  if (!isFirst) {
    tSpan.attr("dy", conf2.textHeight);
  }
};
const parseClassifier = function(classifier) {
  switch (classifier) {
    case "*":
      return "font-style:italic;";
    case "$":
      return "text-decoration:underline;";
    default:
      return "";
  }
};
const svgDraw$2 = {
  drawClass,
  drawEdge: drawEdge$1,
  parseMember
};
let idCache = {};
const padding = 20;
const getGraphId = function(label) {
  const foundEntry = Object.entries(idCache).find((entry) => entry[1].label === label);
  if (foundEntry) {
    return foundEntry[0];
  }
};
const insertMarkers$3 = function(elem) {
  elem.append("defs").append("marker").attr("id", "extensionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
  elem.append("defs").append("marker").attr("id", "extensionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
  elem.append("defs").append("marker").attr("id", "compositionStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "compositionEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "aggregationStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "aggregationEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "dependencyStart").attr("class", "extension").attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const draw$d = function(text2, id2, _version, diagObj) {
  const conf2 = getConfig$1().class;
  idCache = {};
  log$1.info("Rendering diagram " + text2);
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const diagram = root2.select(`[id='${id2}']`);
  insertMarkers$3(diagram);
  const g = new graphlib$2.Graph({
    multigraph: true
  });
  g.setGraph({
    isMultiGraph: true
  });
  g.setDefaultEdgeLabel(function() {
    return {};
  });
  const classes2 = diagObj.db.getClasses();
  const keys2 = Object.keys(classes2);
  for (let i = 0; i < keys2.length; i++) {
    const classDef = classes2[keys2[i]];
    const node2 = svgDraw$2.drawClass(diagram, classDef, conf2, diagObj);
    idCache[node2.id] = node2;
    g.setNode(node2.id, node2);
    log$1.info("Org height: " + node2.height);
  }
  const relations2 = diagObj.db.getRelations();
  relations2.forEach(function(relation) {
    log$1.info(
      "tjoho" + getGraphId(relation.id1) + getGraphId(relation.id2) + JSON.stringify(relation)
    );
    g.setEdge(
      getGraphId(relation.id1),
      getGraphId(relation.id2),
      {
        relation
      },
      relation.title || "DEFAULT"
    );
  });
  dagre$1.layout(g);
  g.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof g.node(v) !== "undefined") {
      log$1.debug("Node " + v + ": " + JSON.stringify(g.node(v)));
      root2.select("#" + diagObj.db.lookUpDomId(v)).attr(
        "transform",
        "translate(" + (g.node(v).x - g.node(v).width / 2) + "," + (g.node(v).y - g.node(v).height / 2) + " )"
      );
    }
  });
  g.edges().forEach(function(e) {
    if (typeof e !== "undefined" && typeof g.edge(e) !== "undefined") {
      log$1.debug("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(g.edge(e)));
      svgDraw$2.drawEdge(diagram, g.edge(e), g.edge(e).relation, conf2, diagObj);
    }
  });
  const svgBounds = diagram.node().getBBox();
  const width2 = svgBounds.width + padding * 2;
  const height2 = svgBounds.height + padding * 2;
  configureSvgSize(diagram, height2, width2, conf2.useMaxWidth);
  const vBox = `${svgBounds.x - padding} ${svgBounds.y - padding} ${width2} ${height2}`;
  log$1.debug(`viewBox ${vBox}`);
  diagram.attr("viewBox", vBox);
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
};
const classRenderer = {
  draw: draw$d
};
const insertMarkers$2 = (elem, markerArray, type2, id2) => {
  markerArray.forEach((markerName) => {
    markers$1[markerName](elem, type2, id2);
  });
};
const extension = (elem, type2, id2) => {
  log$1.trace("Making markers for ", id2);
  elem.append("defs").append("marker").attr("id", type2 + "-extensionStart").attr("class", "marker extension " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-extensionEnd").attr("class", "marker extension " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
};
const composition = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-compositionStart").attr("class", "marker composition " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-compositionEnd").attr("class", "marker composition " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
};
const aggregation = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-aggregationStart").attr("class", "marker aggregation " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-aggregationEnd").attr("class", "marker aggregation " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
};
const dependency = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-dependencyStart").attr("class", "marker dependency " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", type2 + "-dependencyEnd").attr("class", "marker dependency " + type2).attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const lollipop = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-lollipopStart").attr("class", "marker lollipop " + type2).attr("refX", 0).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "white").attr("cx", 6).attr("cy", 7).attr("r", 6);
};
const point = (elem, type2) => {
  elem.append("marker").attr("id", type2 + "-pointEnd").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 10).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", type2 + "-pointStart").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 0).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
};
const circle$1 = (elem, type2) => {
  elem.append("marker").attr("id", type2 + "-circleEnd").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", type2 + "-circleStart").attr("class", "marker " + type2).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
};
const cross = (elem, type2) => {
  elem.append("marker").attr("id", type2 + "-crossEnd").attr("class", "marker cross " + type2).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", type2 + "-crossStart").attr("class", "marker cross " + type2).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
};
const barb = (elem, type2) => {
  elem.append("defs").append("marker").attr("id", type2 + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "strokeWidth").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
};
const markers$1 = {
  extension,
  composition,
  aggregation,
  dependency,
  lollipop,
  point,
  circle: circle$1,
  cross,
  barb
};
function applyStyle$1(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
function addHtmlLabel$1(node2) {
  const fo = select$1(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"));
  const div = fo.append("xhtml:div");
  const label = node2.label;
  const labelClass = node2.isNode ? "nodeLabel" : "edgeLabel";
  div.html(
    '<span class="' + labelClass + '" ' + (node2.labelStyle ? 'style="' + node2.labelStyle + '"' : "") + ">" + label + "</span>"
  );
  applyStyle$1(div, node2.labelStyle);
  div.style("display", "inline-block");
  div.style("white-space", "nowrap");
  div.attr("xmlns", "http://www.w3.org/1999/xhtml");
  return fo.node();
}
const createLabel = (_vertexText, style, isTitle, isNode) => {
  let vertexText = _vertexText || "";
  if (typeof vertexText === "object")
    vertexText = vertexText[0];
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    vertexText = vertexText.replace(/\\n|\n/g, "<br />");
    log$1.info("vertexText" + vertexText);
    const node2 = {
      isNode,
      label: decodeEntities(vertexText).replace(
        /fa[lrsb]?:fa-[\w-]+/g,
        (s2) => `<i class='${s2.replace(":", " ")}'></i>`
      ),
      labelStyle: style.replace("fill:", "color:")
    };
    let vertexNode = addHtmlLabel$1(node2);
    return vertexNode;
  } else {
    const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    svgLabel.setAttribute("style", style.replace("color:", "fill:"));
    let rows = [];
    if (typeof vertexText === "string") {
      rows = vertexText.split(/\\n|\n|<br\s*\/?>/gi);
    } else if (Array.isArray(vertexText)) {
      rows = vertexText;
    } else {
      rows = [];
    }
    for (let j = 0; j < rows.length; j++) {
      const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
      tspan.setAttribute("dy", "1em");
      tspan.setAttribute("x", "0");
      if (isTitle) {
        tspan.setAttribute("class", "title-row");
      } else {
        tspan.setAttribute("class", "row");
      }
      tspan.textContent = rows[j].trim();
      svgLabel.appendChild(tspan);
    }
    return svgLabel;
  }
};
const labelHelper = (parent, node2, _classes, isNode) => {
  let classes2;
  if (!_classes) {
    classes2 = "node default";
  } else {
    classes2 = _classes;
  }
  const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
  const label = shapeSvg.insert("g").attr("class", "label").attr("style", node2.labelStyle);
  let labelText;
  if (typeof node2.labelText === "undefined") {
    labelText = "";
  } else {
    labelText = typeof node2.labelText === "string" ? node2.labelText : node2.labelText[0];
  }
  const text2 = label.node().appendChild(
    createLabel(
      sanitizeText$5(decodeEntities(labelText), getConfig$1()),
      node2.labelStyle,
      false,
      isNode
    )
  );
  let bbox = text2.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select$1(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const halfPadding = node2.padding / 2;
  label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  return { shapeSvg, bbox, halfPadding, label };
};
const updateNodeBounds = (node2, element) => {
  const bbox = element.node().getBBox();
  node2.width = bbox.width;
  node2.height = bbox.height;
};
function insertPolygonShape$1(parent, w2, h, points) {
  return parent.insert("polygon", ":first-child").attr(
    "points",
    points.map(function(d) {
      return d.x + "," + d.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -w2 / 2 + "," + h / 2 + ")");
}
let clusterDb = {};
let decendants = {};
let parents = {};
const clear$b = () => {
  decendants = {};
  parents = {};
  clusterDb = {};
};
const isDecendant = (id2, ancenstorId) => {
  log$1.trace(
    "In isDecendant",
    ancenstorId,
    " ",
    id2,
    " = ",
    decendants[ancenstorId].indexOf(id2) >= 0
  );
  if (decendants[ancenstorId].indexOf(id2) >= 0)
    return true;
  return false;
};
const edgeInCluster = (edge, clusterId) => {
  log$1.info("Decendants of ", clusterId, " is ", decendants[clusterId]);
  log$1.info("Edge is ", edge);
  if (edge.v === clusterId)
    return false;
  if (edge.w === clusterId)
    return false;
  if (!decendants[clusterId]) {
    log$1.debug("Tilt, ", clusterId, ",not in decendants");
    return false;
  }
  if (decendants[clusterId].indexOf(edge.v) >= 0)
    return true;
  if (isDecendant(edge.v, clusterId))
    return true;
  if (isDecendant(edge.w, clusterId))
    return true;
  if (decendants[clusterId].indexOf(edge.w) >= 0)
    return true;
  return false;
};
const copy = (clusterId, graph2, newGraph, rootId) => {
  log$1.warn(
    "Copying children of ",
    clusterId,
    "root",
    rootId,
    "data",
    graph2.node(clusterId),
    rootId
  );
  const nodes = graph2.children(clusterId) || [];
  if (clusterId !== rootId) {
    nodes.push(clusterId);
  }
  log$1.warn("Copying (nodes) clusterId", clusterId, "nodes", nodes);
  nodes.forEach((node2) => {
    if (graph2.children(node2).length > 0) {
      copy(node2, graph2, newGraph, rootId);
    } else {
      const data = graph2.node(node2);
      log$1.info("cp ", node2, " to ", rootId, " with parent ", clusterId);
      newGraph.setNode(node2, data);
      if (rootId !== graph2.parent(node2)) {
        log$1.warn("Setting parent", node2, graph2.parent(node2));
        newGraph.setParent(node2, graph2.parent(node2));
      }
      if (clusterId !== rootId && node2 !== clusterId) {
        log$1.debug("Setting parent", node2, clusterId);
        newGraph.setParent(node2, clusterId);
      } else {
        log$1.info("In copy ", clusterId, "root", rootId, "data", graph2.node(clusterId), rootId);
        log$1.debug(
          "Not Setting parent for node=",
          node2,
          "cluster!==rootId",
          clusterId !== rootId,
          "node!==clusterId",
          node2 !== clusterId
        );
      }
      const edges2 = graph2.edges(node2);
      log$1.debug("Copying Edges", edges2);
      edges2.forEach((edge) => {
        log$1.info("Edge", edge);
        const data2 = graph2.edge(edge.v, edge.w, edge.name);
        log$1.info("Edge data", data2, rootId);
        try {
          if (edgeInCluster(edge, rootId)) {
            log$1.info("Copying as ", edge.v, edge.w, data2, edge.name);
            newGraph.setEdge(edge.v, edge.w, data2, edge.name);
            log$1.info("newGraph edges ", newGraph.edges(), newGraph.edge(newGraph.edges()[0]));
          } else {
            log$1.info(
              "Skipping copy of edge ",
              edge.v,
              "-->",
              edge.w,
              " rootId: ",
              rootId,
              " clusterId:",
              clusterId
            );
          }
        } catch (e) {
          log$1.error(e);
        }
      });
    }
    log$1.debug("Removing node", node2);
    graph2.removeNode(node2);
  });
};
const extractDecendants = (id2, graph2) => {
  const children = graph2.children(id2);
  let res = [].concat(children);
  for (let i = 0; i < children.length; i++) {
    parents[children[i]] = id2;
    res = res.concat(extractDecendants(children[i], graph2));
  }
  return res;
};
const findNonClusterChild = (id2, graph2) => {
  log$1.trace("Searching", id2);
  const children = graph2.children(id2);
  log$1.trace("Searching children of id ", id2, children);
  if (children.length < 1) {
    log$1.trace("This is a valid node", id2);
    return id2;
  }
  for (let i = 0; i < children.length; i++) {
    const _id = findNonClusterChild(children[i], graph2);
    if (_id) {
      log$1.trace("Found replacement for", id2, " => ", _id);
      return _id;
    }
  }
};
const getAnchorId = (id2) => {
  if (!clusterDb[id2]) {
    return id2;
  }
  if (!clusterDb[id2].externalConnections) {
    return id2;
  }
  if (clusterDb[id2]) {
    return clusterDb[id2].id;
  }
  return id2;
};
const adjustClustersAndEdges = (graph2, depth) => {
  if (!graph2 || depth > 10) {
    log$1.debug("Opting out, no graph ");
    return;
  } else {
    log$1.debug("Opting in, graph ");
  }
  graph2.nodes().forEach(function(id2) {
    const children = graph2.children(id2);
    if (children.length > 0) {
      log$1.warn(
        "Cluster identified",
        id2,
        " Replacement id in edges: ",
        findNonClusterChild(id2, graph2)
      );
      decendants[id2] = extractDecendants(id2, graph2);
      clusterDb[id2] = { id: findNonClusterChild(id2, graph2), clusterData: graph2.node(id2) };
    }
  });
  graph2.nodes().forEach(function(id2) {
    const children = graph2.children(id2);
    const edges2 = graph2.edges();
    if (children.length > 0) {
      log$1.debug("Cluster identified", id2, decendants);
      edges2.forEach((edge) => {
        if (edge.v !== id2 && edge.w !== id2) {
          const d1 = isDecendant(edge.v, id2);
          const d2 = isDecendant(edge.w, id2);
          if (d1 ^ d2) {
            log$1.warn("Edge: ", edge, " leaves cluster ", id2);
            log$1.warn("Decendants of XXX ", id2, ": ", decendants[id2]);
            clusterDb[id2].externalConnections = true;
          }
        }
      });
    } else {
      log$1.debug("Not a cluster ", id2, decendants);
    }
  });
  graph2.edges().forEach(function(e) {
    const edge = graph2.edge(e);
    log$1.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    log$1.warn("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph2.edge(e)));
    let v = e.v;
    let w2 = e.w;
    log$1.warn(
      "Fix XXX",
      clusterDb,
      "ids:",
      e.v,
      e.w,
      "Translateing: ",
      clusterDb[e.v],
      " --- ",
      clusterDb[e.w]
    );
    if (clusterDb[e.v] && clusterDb[e.w] && clusterDb[e.v] === clusterDb[e.w]) {
      log$1.warn("Fixing and trixing link to self - removing XXX", e.v, e.w, e.name);
      log$1.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
      v = getAnchorId(e.v);
      w2 = getAnchorId(e.w);
      graph2.removeEdge(e.v, e.w, e.name);
      const specialId = e.w + "---" + e.v;
      graph2.setNode(specialId, {
        domId: specialId,
        id: specialId,
        labelStyle: "",
        labelText: edge.label,
        padding: 0,
        shape: "labelRect",
        style: ""
      });
      const edge1 = JSON.parse(JSON.stringify(edge));
      const edge2 = JSON.parse(JSON.stringify(edge));
      edge1.label = "";
      edge1.arrowTypeEnd = "none";
      edge2.label = "";
      edge1.fromCluster = e.v;
      edge2.toCluster = e.v;
      graph2.setEdge(v, specialId, edge1, e.name + "-cyclic-special");
      graph2.setEdge(specialId, w2, edge2, e.name + "-cyclic-special");
    } else if (clusterDb[e.v] || clusterDb[e.w]) {
      log$1.warn("Fixing and trixing - removing XXX", e.v, e.w, e.name);
      v = getAnchorId(e.v);
      w2 = getAnchorId(e.w);
      graph2.removeEdge(e.v, e.w, e.name);
      if (v !== e.v)
        edge.fromCluster = e.v;
      if (w2 !== e.w)
        edge.toCluster = e.w;
      log$1.warn("Fix Replacing with XXX", v, w2, e.name);
      graph2.setEdge(v, w2, edge, e.name);
    }
  });
  log$1.warn("Adjusted Graph", graphlib$2.json.write(graph2));
  extractor(graph2, 0);
  log$1.trace(clusterDb);
};
const extractor = (graph2, depth) => {
  log$1.warn("extractor - ", depth, graphlib$2.json.write(graph2), graph2.children("D"));
  if (depth > 10) {
    log$1.error("Bailing out");
    return;
  }
  let nodes = graph2.nodes();
  let hasChildren = false;
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    const children = graph2.children(node2);
    hasChildren = hasChildren || children.length > 0;
  }
  if (!hasChildren) {
    log$1.debug("Done, no node has children", graph2.nodes());
    return;
  }
  log$1.debug("Nodes = ", nodes, depth);
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    log$1.debug(
      "Extracting node",
      node2,
      clusterDb,
      clusterDb[node2] && !clusterDb[node2].externalConnections,
      !graph2.parent(node2),
      graph2.node(node2),
      graph2.children("D"),
      " Depth ",
      depth
    );
    if (!clusterDb[node2]) {
      log$1.debug("Not a cluster", node2, depth);
    } else if (!clusterDb[node2].externalConnections && graph2.children(node2) && graph2.children(node2).length > 0) {
      log$1.warn(
        "Cluster without external connections, without a parent and with children",
        node2,
        depth
      );
      const graphSettings = graph2.graph();
      let dir = graphSettings.rankdir === "TB" ? "LR" : "TB";
      if (clusterDb[node2]) {
        if (clusterDb[node2].clusterData && clusterDb[node2].clusterData.dir) {
          dir = clusterDb[node2].clusterData.dir;
          log$1.warn("Fixing dir", clusterDb[node2].clusterData.dir, dir);
        }
      }
      const clusterGraph = new graphlib$2.Graph({
        multigraph: true,
        compound: true
      }).setGraph({
        rankdir: dir,
        nodesep: 50,
        ranksep: 50,
        marginx: 8,
        marginy: 8
      }).setDefaultEdgeLabel(function() {
        return {};
      });
      log$1.warn("Old graph before copy", graphlib$2.json.write(graph2));
      copy(node2, graph2, clusterGraph, node2);
      graph2.setNode(node2, {
        clusterNode: true,
        id: node2,
        clusterData: clusterDb[node2].clusterData,
        labelText: clusterDb[node2].labelText,
        graph: clusterGraph
      });
      log$1.warn("New graph after copy node: (", node2, ")", graphlib$2.json.write(clusterGraph));
      log$1.debug("Old graph after copy", graphlib$2.json.write(graph2));
    } else {
      log$1.warn(
        "Cluster ** ",
        node2,
        " **not meeting the criteria !externalConnections:",
        !clusterDb[node2].externalConnections,
        " no parent: ",
        !graph2.parent(node2),
        " children ",
        graph2.children(node2) && graph2.children(node2).length > 0,
        graph2.children("D"),
        depth
      );
      log$1.debug(clusterDb);
    }
  }
  nodes = graph2.nodes();
  log$1.warn("New list of nodes", nodes);
  for (let i = 0; i < nodes.length; i++) {
    const node2 = nodes[i];
    const data = graph2.node(node2);
    log$1.warn(" Now next level", node2, data);
    if (data.clusterNode) {
      extractor(data.graph, depth + 1);
    }
  }
};
const sorter = (graph2, nodes) => {
  if (nodes.length === 0)
    return [];
  let result = Object.assign(nodes);
  nodes.forEach((node2) => {
    const children = graph2.children(node2);
    const sorted = sorter(graph2, children);
    result = result.concat(sorted);
  });
  return result;
};
const sortNodesByHierarchy = (graph2) => sorter(graph2, graph2.children());
function intersectNode(node2, point2) {
  return node2.intersect(point2);
}
function intersectEllipse(node2, rx, ry, point2) {
  var cx = node2.x;
  var cy = node2.y;
  var px = cx - point2.x;
  var py = cy - point2.y;
  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
  var dx = Math.abs(rx * ry * px / det);
  if (point2.x < cx) {
    dx = -dx;
  }
  var dy = Math.abs(rx * ry * py / det);
  if (point2.y < cy) {
    dy = -dy;
  }
  return { x: cx + dx, y: cy + dy };
}
function intersectCircle(node2, rx, point2) {
  return intersectEllipse(node2, rx, rx, point2);
}
function intersectLine(p1, p2, q1, q2) {
  var a1, a2, b12, b22, c1, c2;
  var r1, r2, r3, r4;
  var denom, offset, num;
  var x2, y2;
  a1 = p2.y - p1.y;
  b12 = p1.x - p2.x;
  c1 = p2.x * p1.y - p1.x * p2.y;
  r3 = a1 * q1.x + b12 * q1.y + c1;
  r4 = a1 * q2.x + b12 * q2.y + c1;
  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
    return;
  }
  a2 = q2.y - q1.y;
  b22 = q1.x - q2.x;
  c2 = q2.x * q1.y - q1.x * q2.y;
  r1 = a2 * p1.x + b22 * p1.y + c2;
  r2 = a2 * p2.x + b22 * p2.y + c2;
  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
    return;
  }
  denom = a1 * b22 - a2 * b12;
  if (denom === 0) {
    return;
  }
  offset = Math.abs(denom / 2);
  num = b12 * c2 - b22 * c1;
  x2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  num = a2 * c1 - a1 * c2;
  y2 = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  return { x: x2, y: y2 };
}
function sameSign(r1, r2) {
  return r1 * r2 > 0;
}
function intersectPolygon(node2, polyPoints, point2) {
  var x12 = node2.x;
  var y12 = node2.y;
  var intersections = [];
  var minX = Number.POSITIVE_INFINITY;
  var minY = Number.POSITIVE_INFINITY;
  if (typeof polyPoints.forEach === "function") {
    polyPoints.forEach(function(entry) {
      minX = Math.min(minX, entry.x);
      minY = Math.min(minY, entry.y);
    });
  } else {
    minX = Math.min(minX, polyPoints.x);
    minY = Math.min(minY, polyPoints.y);
  }
  var left2 = x12 - node2.width / 2 - minX;
  var top2 = y12 - node2.height / 2 - minY;
  for (var i = 0; i < polyPoints.length; i++) {
    var p1 = polyPoints[i];
    var p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
    var intersect2 = intersectLine(
      node2,
      point2,
      { x: left2 + p1.x, y: top2 + p1.y },
      { x: left2 + p2.x, y: top2 + p2.y }
    );
    if (intersect2) {
      intersections.push(intersect2);
    }
  }
  if (!intersections.length) {
    return node2;
  }
  if (intersections.length > 1) {
    intersections.sort(function(p, q) {
      var pdx = p.x - point2.x;
      var pdy = p.y - point2.y;
      var distp = Math.sqrt(pdx * pdx + pdy * pdy);
      var qdx = q.x - point2.x;
      var qdy = q.y - point2.y;
      var distq = Math.sqrt(qdx * qdx + qdy * qdy);
      return distp < distq ? -1 : distp === distq ? 0 : 1;
    });
  }
  return intersections[0];
}
const intersectRect = (node2, point2) => {
  var x2 = node2.x;
  var y2 = node2.y;
  var dx = point2.x - x2;
  var dy = point2.y - y2;
  var w2 = node2.width / 2;
  var h = node2.height / 2;
  var sx, sy;
  if (Math.abs(dy) * w2 > Math.abs(dx) * h) {
    if (dy < 0) {
      h = -h;
    }
    sx = dy === 0 ? 0 : h * dx / dy;
    sy = h;
  } else {
    if (dx < 0) {
      w2 = -w2;
    }
    sx = w2;
    sy = dx === 0 ? 0 : w2 * dy / dx;
  }
  return { x: x2 + sx, y: y2 + sy };
};
const intersect = {
  node: intersectNode,
  circle: intersectCircle,
  ellipse: intersectEllipse,
  polygon: intersectPolygon,
  rect: intersectRect
};
const note = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, "node " + node2.classes, true);
  log$1.info("Classes = ", node2.classes);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  rect2.attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const question$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const s2 = w2 + h;
  const points = [
    { x: s2 / 2, y: 0 },
    { x: s2, y: -s2 / 2 },
    { x: s2 / 2, y: -s2 },
    { x: 0, y: -s2 / 2 }
  ];
  log$1.info("Question main (Circle)");
  const questionElem = insertPolygonShape$1(shapeSvg, s2, s2, points);
  questionElem.attr("style", node2.style);
  updateNodeBounds(node2, questionElem);
  node2.intersect = function(point2) {
    log$1.warn("Intersect called");
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const choice = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  const s2 = 28;
  const points = [
    { x: 0, y: s2 / 2 },
    { x: s2 / 2, y: 0 },
    { x: 0, y: -s2 / 2 },
    { x: -s2 / 2, y: 0 }
  ];
  const choice2 = shapeSvg.insert("polygon", ":first-child").attr(
    "points",
    points.map(function(d) {
      return d.x + "," + d.y;
    }).join(" ")
  );
  choice2.attr("class", "state-start").attr("r", 7).attr("width", 28).attr("height", 28);
  node2.width = 28;
  node2.height = 28;
  node2.intersect = function(point2) {
    return intersect.circle(node2, 14, point2);
  };
  return shapeSvg;
};
const hexagon$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const f = 4;
  const h = bbox.height + node2.padding;
  const m = h / f;
  const w2 = bbox.width + 2 * m + node2.padding;
  const points = [
    { x: m, y: 0 },
    { x: w2 - m, y: 0 },
    { x: w2, y: -h / 2 },
    { x: w2 - m, y: -h },
    { x: m, y: -h },
    { x: 0, y: -h / 2 }
  ];
  const hex2 = insertPolygonShape$1(shapeSvg, w2, h, points);
  hex2.attr("style", node2.style);
  updateNodeBounds(node2, hex2);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const rect_left_inv_arrow$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const points = [
    { x: -h / 2, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h },
    { x: -h / 2, y: -h },
    { x: 0, y: -h / 2 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h, points);
  el.attr("style", node2.style);
  node2.width = w2 + h;
  node2.height = h;
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const lean_right$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const points = [
    { x: -2 * h / 6, y: 0 },
    { x: w2 - h / 6, y: 0 },
    { x: w2 + 2 * h / 6, y: -h },
    { x: h / 6, y: -h }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const lean_left$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const points = [
    { x: 2 * h / 6, y: 0 },
    { x: w2 + h / 6, y: 0 },
    { x: w2 - 2 * h / 6, y: -h },
    { x: -h / 6, y: -h }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const trapezoid$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const points = [
    { x: -2 * h / 6, y: 0 },
    { x: w2 + 2 * h / 6, y: 0 },
    { x: w2 - h / 6, y: -h },
    { x: h / 6, y: -h }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const inv_trapezoid$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const points = [
    { x: h / 6, y: 0 },
    { x: w2 - h / 6, y: 0 },
    { x: w2 + 2 * h / 6, y: -h },
    { x: -2 * h / 6, y: -h }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const rect_right_inv_arrow$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const points = [
    { x: 0, y: 0 },
    { x: w2 + h / 2, y: 0 },
    { x: w2, y: -h / 2 },
    { x: w2 + h / 2, y: -h },
    { x: 0, y: -h }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const cylinder$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const rx = w2 / 2;
  const ry = rx / (2.5 + w2 / 50);
  const h = bbox.height + ry + node2.padding;
  const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 a " + rx + "," + ry + " 0,0,0 " + -w2 + " 0 l 0," + h + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 l 0," + -h;
  const el = shapeSvg.attr("label-offset-y", ry).insert("path", ":first-child").attr("style", node2.style).attr("d", shape).attr("transform", "translate(" + -w2 / 2 + "," + -(h / 2 + ry) + ")");
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    const pos = intersect.rect(node2, point2);
    const x2 = pos.x - node2.x;
    if (rx != 0 && (Math.abs(x2) < node2.width / 2 || Math.abs(x2) == node2.width / 2 && Math.abs(pos.y - node2.y) > node2.height / 2 - ry)) {
      let y2 = ry * ry * (1 - x2 * x2 / (rx * rx));
      if (y2 != 0)
        y2 = Math.sqrt(y2);
      y2 = ry - y2;
      if (point2.y - node2.y > 0)
        y2 = -y2;
      pos.y += y2;
    }
    return pos;
  };
  return shapeSvg;
};
const rect$1 = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, "node " + node2.classes, true);
  log$1.trace("Classes = ", node2.classes);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const totalWidth = bbox.width + node2.padding;
  const totalHeight = bbox.height + node2.padding;
  rect2.attr("class", "basic label-container").attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", totalWidth).attr("height", totalHeight);
  if (node2.props) {
    const propKeys = new Set(Object.keys(node2.props));
    if (node2.props.borders) {
      applyNodePropertyBorders(rect2, node2.props.borders, totalWidth, totalHeight);
      propKeys.delete("borders");
    }
    propKeys.forEach((propKey) => {
      log$1.warn(`Unknown node property ${propKey}`);
    });
  }
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const labelRect = (parent, node2) => {
  const { shapeSvg } = labelHelper(parent, node2, "label", true);
  log$1.trace("Classes = ", node2.classes);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const totalWidth = 0;
  const totalHeight = 0;
  rect2.attr("width", totalWidth).attr("height", totalHeight);
  shapeSvg.attr("class", "label edgeLabel");
  if (node2.props) {
    const propKeys = new Set(Object.keys(node2.props));
    if (node2.props.borders) {
      applyNodePropertyBorders(rect2, node2.props.borders, totalWidth, totalHeight);
      propKeys.delete("borders");
    }
    propKeys.forEach((propKey) => {
      log$1.warn(`Unknown node property ${propKey}`);
    });
  }
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
function applyNodePropertyBorders(rect2, borders, totalWidth, totalHeight) {
  const strokeDashArray = [];
  const addBorder = (length2) => {
    strokeDashArray.push(length2);
    strokeDashArray.push(0);
  };
  const skipBorder = (length2) => {
    strokeDashArray.push(0);
    strokeDashArray.push(length2);
  };
  if (borders.includes("t")) {
    log$1.debug("add top border");
    addBorder(totalWidth);
  } else {
    skipBorder(totalWidth);
  }
  if (borders.includes("r")) {
    log$1.debug("add right border");
    addBorder(totalHeight);
  } else {
    skipBorder(totalHeight);
  }
  if (borders.includes("b")) {
    log$1.debug("add bottom border");
    addBorder(totalWidth);
  } else {
    skipBorder(totalWidth);
  }
  if (borders.includes("l")) {
    log$1.debug("add left border");
    addBorder(totalHeight);
  } else {
    skipBorder(totalHeight);
  }
  rect2.attr("stroke-dasharray", strokeDashArray.join(" "));
}
const rectWithTitle = (parent, node2) => {
  let classes2;
  if (!node2.classes) {
    classes2 = "node default";
  } else {
    classes2 = "node " + node2.classes;
  }
  const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const innerLine = shapeSvg.insert("line");
  const label = shapeSvg.insert("g").attr("class", "label");
  const text2 = node2.labelText.flat ? node2.labelText.flat() : node2.labelText;
  let title2 = "";
  if (typeof text2 === "object") {
    title2 = text2[0];
  } else {
    title2 = text2;
  }
  log$1.info("Label text abc79", title2, text2, typeof text2 === "object");
  const text3 = label.node().appendChild(createLabel(title2, node2.labelStyle, true, true));
  let bbox = { width: 0, height: 0 };
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text3.children[0];
    const dv = select$1(text3);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  log$1.info("Text 2", text2);
  const textRows = text2.slice(1, text2.length);
  let titleBox = text3.getBBox();
  const descr = label.node().appendChild(
    createLabel(textRows.join ? textRows.join("<br/>") : textRows, node2.labelStyle, true, true)
  );
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = descr.children[0];
    const dv = select$1(descr);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const halfPadding = node2.padding / 2;
  select$1(descr).attr(
    "transform",
    "translate( " + (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ", " + (titleBox.height + halfPadding + 5) + ")"
  );
  select$1(text3).attr(
    "transform",
    "translate( " + (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ", " + 0 + ")"
  );
  bbox = label.node().getBBox();
  label.attr(
    "transform",
    "translate(" + -bbox.width / 2 + ", " + (-bbox.height / 2 - halfPadding + 3) + ")"
  );
  rect2.attr("class", "outer title-state").attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  innerLine.attr("class", "divider").attr("x1", -bbox.width / 2 - halfPadding).attr("x2", bbox.width / 2 + halfPadding).attr("y1", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr("y2", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const stadium$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const h = bbox.height + node2.padding;
  const w2 = bbox.width + h / 4 + node2.padding;
  const rect2 = shapeSvg.insert("rect", ":first-child").attr("style", node2.style).attr("rx", h / 2).attr("ry", h / 2).attr("x", -w2 / 2).attr("y", -h / 2).attr("width", w2).attr("height", h);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const circle = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, void 0, true);
  const circle2 = shapeSvg.insert("circle", ":first-child");
  circle2.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  log$1.info("Circle main");
  updateNodeBounds(node2, circle2);
  node2.intersect = function(point2) {
    log$1.info("Circle intersect", node2, bbox.width / 2 + halfPadding, point2);
    return intersect.circle(node2, bbox.width / 2 + halfPadding, point2);
  };
  return shapeSvg;
};
const doublecircle = (parent, node2) => {
  const { shapeSvg, bbox, halfPadding } = labelHelper(parent, node2, void 0, true);
  const gap = 5;
  const circleGroup = shapeSvg.insert("g", ":first-child");
  const outerCircle = circleGroup.insert("circle");
  const innerCircle = circleGroup.insert("circle");
  outerCircle.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding + gap).attr("width", bbox.width + node2.padding + gap * 2).attr("height", bbox.height + node2.padding + gap * 2);
  innerCircle.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("r", bbox.width / 2 + halfPadding).attr("width", bbox.width + node2.padding).attr("height", bbox.height + node2.padding);
  log$1.info("DoubleCircle main");
  updateNodeBounds(node2, outerCircle);
  node2.intersect = function(point2) {
    log$1.info("DoubleCircle intersect", node2, bbox.width / 2 + halfPadding + gap, point2);
    return intersect.circle(node2, bbox.width / 2 + halfPadding + gap, point2);
  };
  return shapeSvg;
};
const subroutine$1 = (parent, node2) => {
  const { shapeSvg, bbox } = labelHelper(parent, node2, void 0, true);
  const w2 = bbox.width + node2.padding;
  const h = bbox.height + node2.padding;
  const points = [
    { x: 0, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h },
    { x: 0, y: -h },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: w2 + 8, y: 0 },
    { x: w2 + 8, y: -h },
    { x: -8, y: -h },
    { x: -8, y: 0 }
  ];
  const el = insertPolygonShape$1(shapeSvg, w2, h, points);
  el.attr("style", node2.style);
  updateNodeBounds(node2, el);
  node2.intersect = function(point2) {
    return intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
};
const start = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  const circle2 = shapeSvg.insert("circle", ":first-child");
  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  updateNodeBounds(node2, circle2);
  node2.intersect = function(point2) {
    return intersect.circle(node2, 7, point2);
  };
  return shapeSvg;
};
const forkJoin = (parent, node2, dir) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  let width2 = 70;
  let height2 = 10;
  if (dir === "LR") {
    width2 = 10;
    height2 = 70;
  }
  const shape = shapeSvg.append("rect").attr("x", -1 * width2 / 2).attr("y", -1 * height2 / 2).attr("width", width2).attr("height", height2).attr("class", "fork-join");
  updateNodeBounds(node2, shape);
  node2.height = node2.height + node2.padding / 2;
  node2.width = node2.width + node2.padding / 2;
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const end = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node2.domId || node2.id);
  const innerCircle = shapeSvg.insert("circle", ":first-child");
  const circle2 = shapeSvg.insert("circle", ":first-child");
  circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  innerCircle.attr("class", "state-end").attr("r", 5).attr("width", 10).attr("height", 10);
  updateNodeBounds(node2, circle2);
  node2.intersect = function(point2) {
    return intersect.circle(node2, 7, point2);
  };
  return shapeSvg;
};
const class_box = (parent, node2) => {
  const halfPadding = node2.padding / 2;
  const rowPadding = 4;
  const lineHeight = 8;
  let classes2;
  if (!node2.classes) {
    classes2 = "node default";
  } else {
    classes2 = "node " + node2.classes;
  }
  const shapeSvg = parent.insert("g").attr("class", classes2).attr("id", node2.domId || node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const topLine = shapeSvg.insert("line");
  const bottomLine = shapeSvg.insert("line");
  let maxWidth = 0;
  let maxHeight = rowPadding;
  const labelContainer = shapeSvg.insert("g").attr("class", "label");
  let verticalPos = 0;
  const hasInterface = node2.classData.annotations && node2.classData.annotations[0];
  const interfaceLabelText = node2.classData.annotations[0] ? "\xAB" + node2.classData.annotations[0] + "\xBB" : "";
  const interfaceLabel = labelContainer.node().appendChild(createLabel(interfaceLabelText, node2.labelStyle, true, true));
  let interfaceBBox = interfaceLabel.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = interfaceLabel.children[0];
    const dv = select$1(interfaceLabel);
    interfaceBBox = div.getBoundingClientRect();
    dv.attr("width", interfaceBBox.width);
    dv.attr("height", interfaceBBox.height);
  }
  if (node2.classData.annotations[0]) {
    maxHeight += interfaceBBox.height + rowPadding;
    maxWidth += interfaceBBox.width;
  }
  let classTitleString = node2.classData.id;
  if (node2.classData.type !== void 0 && node2.classData.type !== "") {
    if (getConfig$1().flowchart.htmlLabels) {
      classTitleString += "&lt;" + node2.classData.type + "&gt;";
    } else {
      classTitleString += "<" + node2.classData.type + ">";
    }
  }
  const classTitleLabel = labelContainer.node().appendChild(createLabel(classTitleString, node2.labelStyle, true, true));
  select$1(classTitleLabel).attr("class", "classTitle");
  let classTitleBBox = classTitleLabel.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = classTitleLabel.children[0];
    const dv = select$1(classTitleLabel);
    classTitleBBox = div.getBoundingClientRect();
    dv.attr("width", classTitleBBox.width);
    dv.attr("height", classTitleBBox.height);
  }
  maxHeight += classTitleBBox.height + rowPadding;
  if (classTitleBBox.width > maxWidth) {
    maxWidth = classTitleBBox.width;
  }
  const classAttributes = [];
  node2.classData.members.forEach((str) => {
    const parsedInfo = parseMember(str);
    let parsedText = parsedInfo.displayText;
    if (getConfig$1().flowchart.htmlLabels) {
      parsedText = parsedText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    const lbl = labelContainer.node().appendChild(
      createLabel(
        parsedText,
        parsedInfo.cssStyle ? parsedInfo.cssStyle : node2.labelStyle,
        true,
        true
      )
    );
    let bbox = lbl.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = lbl.children[0];
      const dv = select$1(lbl);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    if (bbox.width > maxWidth) {
      maxWidth = bbox.width;
    }
    maxHeight += bbox.height + rowPadding;
    classAttributes.push(lbl);
  });
  maxHeight += lineHeight;
  const classMethods = [];
  node2.classData.methods.forEach((str) => {
    const parsedInfo = parseMember(str);
    let displayText = parsedInfo.displayText;
    if (getConfig$1().flowchart.htmlLabels) {
      displayText = displayText.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    const lbl = labelContainer.node().appendChild(
      createLabel(
        displayText,
        parsedInfo.cssStyle ? parsedInfo.cssStyle : node2.labelStyle,
        true,
        true
      )
    );
    let bbox = lbl.getBBox();
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const div = lbl.children[0];
      const dv = select$1(lbl);
      bbox = div.getBoundingClientRect();
      dv.attr("width", bbox.width);
      dv.attr("height", bbox.height);
    }
    if (bbox.width > maxWidth) {
      maxWidth = bbox.width;
    }
    maxHeight += bbox.height + rowPadding;
    classMethods.push(lbl);
  });
  maxHeight += lineHeight;
  if (hasInterface) {
    let diffX2 = (maxWidth - interfaceBBox.width) / 2;
    select$1(interfaceLabel).attr(
      "transform",
      "translate( " + (-1 * maxWidth / 2 + diffX2) + ", " + -1 * maxHeight / 2 + ")"
    );
    verticalPos = interfaceBBox.height + rowPadding;
  }
  let diffX = (maxWidth - classTitleBBox.width) / 2;
  select$1(classTitleLabel).attr(
    "transform",
    "translate( " + (-1 * maxWidth / 2 + diffX) + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"
  );
  verticalPos += classTitleBBox.height + rowPadding;
  topLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
  verticalPos += lineHeight;
  classAttributes.forEach((lbl) => {
    select$1(lbl).attr(
      "transform",
      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos + lineHeight / 2) + ")"
    );
    verticalPos += classTitleBBox.height + rowPadding;
  });
  verticalPos += lineHeight;
  bottomLine.attr("class", "divider").attr("x1", -maxWidth / 2 - halfPadding).attr("x2", maxWidth / 2 + halfPadding).attr("y1", -maxHeight / 2 - halfPadding + lineHeight + verticalPos).attr("y2", -maxHeight / 2 - halfPadding + lineHeight + verticalPos);
  verticalPos += lineHeight;
  classMethods.forEach((lbl) => {
    select$1(lbl).attr(
      "transform",
      "translate( " + -maxWidth / 2 + ", " + (-1 * maxHeight / 2 + verticalPos) + ")"
    );
    verticalPos += classTitleBBox.height + rowPadding;
  });
  rect2.attr("class", "outer title-state").attr("x", -maxWidth / 2 - halfPadding).attr("y", -(maxHeight / 2) - halfPadding).attr("width", maxWidth + node2.padding).attr("height", maxHeight + node2.padding);
  updateNodeBounds(node2, rect2);
  node2.intersect = function(point2) {
    return intersect.rect(node2, point2);
  };
  return shapeSvg;
};
const shapes$1 = {
  question: question$1,
  rect: rect$1,
  labelRect,
  rectWithTitle,
  choice,
  circle,
  doublecircle,
  stadium: stadium$1,
  hexagon: hexagon$1,
  rect_left_inv_arrow: rect_left_inv_arrow$1,
  lean_right: lean_right$1,
  lean_left: lean_left$1,
  trapezoid: trapezoid$1,
  inv_trapezoid: inv_trapezoid$1,
  rect_right_inv_arrow: rect_right_inv_arrow$1,
  cylinder: cylinder$1,
  start,
  end,
  note,
  subroutine: subroutine$1,
  fork: forkJoin,
  join: forkJoin,
  class_box
};
let nodeElems = {};
const insertNode = (elem, node2, dir) => {
  let newEl;
  let el;
  if (node2.link) {
    let target;
    if (getConfig$1().securityLevel === "sandbox") {
      target = "_top";
    } else if (node2.linkTarget) {
      target = node2.linkTarget || "_blank";
    }
    newEl = elem.insert("svg:a").attr("xlink:href", node2.link).attr("target", target);
    el = shapes$1[node2.shape](newEl, node2, dir);
  } else {
    el = shapes$1[node2.shape](elem, node2, dir);
    newEl = el;
  }
  if (node2.tooltip) {
    el.attr("title", node2.tooltip);
  }
  if (node2.class) {
    el.attr("class", "node default " + node2.class);
  }
  nodeElems[node2.id] = newEl;
  if (node2.haveCallback) {
    nodeElems[node2.id].attr("class", nodeElems[node2.id].attr("class") + " clickable");
  }
};
const setNodeElem = (elem, node2) => {
  nodeElems[node2.id] = elem;
};
const clear$a = () => {
  nodeElems = {};
};
const positionNode = (node2) => {
  const el = nodeElems[node2.id];
  log$1.trace(
    "Transforming node",
    node2.diff,
    node2,
    "translate(" + (node2.x - node2.width / 2 - 5) + ", " + node2.width / 2 + ")"
  );
  const padding2 = 8;
  const diff = node2.diff || 0;
  if (node2.clusterNode) {
    el.attr(
      "transform",
      "translate(" + (node2.x + diff - node2.width / 2) + ", " + (node2.y - node2.height / 2 - padding2) + ")"
    );
  } else {
    el.attr("transform", "translate(" + node2.x + ", " + node2.y + ")");
  }
  return diff;
};
const rect = (parent, node2) => {
  log$1.trace("Creating subgraph rect for ", node2.id, node2);
  const shapeSvg = parent.insert("g").attr("class", "cluster" + (node2.class ? " " + node2.class : "")).attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const label = shapeSvg.insert("g").attr("class", "cluster-label");
  const text2 = label.node().appendChild(createLabel(node2.labelText, node2.labelStyle, void 0, true));
  let bbox = text2.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select$1(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  const width2 = node2.width <= bbox.width + padding2 ? bbox.width + padding2 : node2.width;
  if (node2.width <= bbox.width + padding2) {
    node2.diff = (bbox.width - node2.width) / 2 - node2.padding / 2;
  } else {
    node2.diff = -node2.padding / 2;
  }
  log$1.trace("Data ", node2, JSON.stringify(node2));
  rect2.attr("style", node2.style).attr("rx", node2.rx).attr("ry", node2.ry).attr("x", node2.x - width2 / 2).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", width2).attr("height", node2.height + padding2);
  label.attr(
    "transform",
    "translate(" + (node2.x - bbox.width / 2) + ", " + (node2.y - node2.height / 2 + node2.padding / 3) + ")"
  );
  const rectBox = rect2.node().getBBox();
  node2.width = rectBox.width;
  node2.height = rectBox.height;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const noteGroup = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", "note-cluster").attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  rect2.attr("rx", node2.rx).attr("ry", node2.ry).attr("x", node2.x - node2.width / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", node2.width + padding2).attr("height", node2.height + padding2).attr("fill", "none");
  const rectBox = rect2.node().getBBox();
  node2.width = rectBox.width;
  node2.height = rectBox.height;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const roundedWithTitle = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", node2.classes).attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const label = shapeSvg.insert("g").attr("class", "cluster-label");
  const innerRect = shapeSvg.append("rect");
  const text2 = label.node().appendChild(createLabel(node2.labelText, node2.labelStyle, void 0, true));
  let bbox = text2.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select$1(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  bbox = text2.getBBox();
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  const width2 = node2.width <= bbox.width + node2.padding ? bbox.width + node2.padding : node2.width;
  if (node2.width <= bbox.width + node2.padding) {
    node2.diff = (bbox.width + node2.padding * 0 - node2.width) / 2;
  } else {
    node2.diff = -node2.padding / 2;
  }
  rect2.attr("class", "outer").attr("x", node2.x - width2 / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding).attr("width", width2 + padding2).attr("height", node2.height + padding2);
  innerRect.attr("class", "inner").attr("x", node2.x - width2 / 2 - halfPadding).attr("y", node2.y - node2.height / 2 - halfPadding + bbox.height - 1).attr("width", width2 + padding2).attr("height", node2.height + padding2 - bbox.height - 3);
  label.attr(
    "transform",
    "translate(" + (node2.x - bbox.width / 2) + ", " + (node2.y - node2.height / 2 - node2.padding / 3 + (evaluate(getConfig$1().flowchart.htmlLabels) ? 5 : 3)) + ")"
  );
  const rectBox = rect2.node().getBBox();
  node2.height = rectBox.height;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const divider = (parent, node2) => {
  const shapeSvg = parent.insert("g").attr("class", node2.classes).attr("id", node2.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const padding2 = 0 * node2.padding;
  const halfPadding = padding2 / 2;
  rect2.attr("class", "divider").attr("x", node2.x - node2.width / 2 - halfPadding).attr("y", node2.y - node2.height / 2).attr("width", node2.width + padding2).attr("height", node2.height + padding2);
  const rectBox = rect2.node().getBBox();
  node2.width = rectBox.width;
  node2.height = rectBox.height;
  node2.diff = -node2.padding / 2;
  node2.intersect = function(point2) {
    return intersectRect(node2, point2);
  };
  return shapeSvg;
};
const shapes = { rect, roundedWithTitle, noteGroup, divider };
let clusterElems = {};
const insertCluster = (elem, node2) => {
  log$1.trace("Inserting cluster");
  const shape = node2.shape || "rect";
  clusterElems[node2.id] = shapes[shape](elem, node2);
};
const clear$9 = () => {
  clusterElems = {};
};
let edgeLabels = {};
let terminalLabels = {};
const clear$8 = () => {
  edgeLabels = {};
  terminalLabels = {};
};
const insertEdgeLabel = (elem, edge) => {
  const labelElement = createLabel(edge.label, edge.labelStyle);
  const edgeLabel = elem.insert("g").attr("class", "edgeLabel");
  const label = edgeLabel.insert("g").attr("class", "label");
  label.node().appendChild(labelElement);
  let bbox = labelElement.getBBox();
  if (evaluate(getConfig$1().flowchart.htmlLabels)) {
    const div = labelElement.children[0];
    const dv = select$1(labelElement);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  edgeLabels[edge.id] = edgeLabel;
  edge.width = bbox.width;
  edge.height = bbox.height;
  let fo;
  if (edge.startLabelLeft) {
    const startLabelElement = createLabel(edge.startLabelLeft, edge.labelStyle);
    const startEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
    const inner = startEdgeLabelLeft.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(startLabelElement);
    const slBox = startLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].startLeft = startEdgeLabelLeft;
    setTerminalWidth(fo, edge.startLabelLeft);
  }
  if (edge.startLabelRight) {
    const startLabelElement = createLabel(edge.startLabelRight, edge.labelStyle);
    const startEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
    const inner = startEdgeLabelRight.insert("g").attr("class", "inner");
    fo = startEdgeLabelRight.node().appendChild(startLabelElement);
    inner.node().appendChild(startLabelElement);
    const slBox = startLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].startRight = startEdgeLabelRight;
    setTerminalWidth(fo, edge.startLabelRight);
  }
  if (edge.endLabelLeft) {
    const endLabelElement = createLabel(edge.endLabelLeft, edge.labelStyle);
    const endEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
    const inner = endEdgeLabelLeft.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(endLabelElement);
    const slBox = endLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    endEdgeLabelLeft.node().appendChild(endLabelElement);
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].endLeft = endEdgeLabelLeft;
    setTerminalWidth(fo, edge.endLabelLeft);
  }
  if (edge.endLabelRight) {
    const endLabelElement = createLabel(edge.endLabelRight, edge.labelStyle);
    const endEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
    const inner = endEdgeLabelRight.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(endLabelElement);
    const slBox = endLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    endEdgeLabelRight.node().appendChild(endLabelElement);
    if (!terminalLabels[edge.id]) {
      terminalLabels[edge.id] = {};
    }
    terminalLabels[edge.id].endRight = endEdgeLabelRight;
    setTerminalWidth(fo, edge.endLabelRight);
  }
};
function setTerminalWidth(fo, value) {
  if (getConfig$1().flowchart.htmlLabels && fo) {
    fo.style.width = value.length * 9 + "px";
    fo.style.height = "12px";
  }
}
const positionEdgeLabel = (edge, paths) => {
  log$1.info("Moving label abc78 ", edge.id, edge.label, edgeLabels[edge.id]);
  let path2 = paths.updatedPath ? paths.updatedPath : paths.originalPath;
  if (edge.label) {
    const el = edgeLabels[edge.id];
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcLabelPosition(path2);
      log$1.info("Moving label from (", x2, ",", y2, ") to (", pos.x, ",", pos.y, ") abc78");
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.startLabelLeft) {
    const el = terminalLabels[edge.id].startLeft;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_left", path2);
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.startLabelRight) {
    const el = terminalLabels[edge.id].startRight;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(
        edge.arrowTypeStart ? 10 : 0,
        "start_right",
        path2
      );
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.endLabelLeft) {
    const el = terminalLabels[edge.id].endLeft;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_left", path2);
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
  if (edge.endLabelRight) {
    const el = terminalLabels[edge.id].endRight;
    let x2 = edge.x;
    let y2 = edge.y;
    if (path2) {
      const pos = utils.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_right", path2);
      x2 = pos.x;
      y2 = pos.y;
    }
    el.attr("transform", "translate(" + x2 + ", " + y2 + ")");
  }
};
const outsideNode = (node2, point2) => {
  const x2 = node2.x;
  const y2 = node2.y;
  const dx = Math.abs(point2.x - x2);
  const dy = Math.abs(point2.y - y2);
  const w2 = node2.width / 2;
  const h = node2.height / 2;
  if (dx >= w2 || dy >= h) {
    return true;
  }
  return false;
};
const intersection = (node2, outsidePoint, insidePoint) => {
  log$1.warn(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(outsidePoint)}
  insidePoint : ${JSON.stringify(insidePoint)}
  node        : x:${node2.x} y:${node2.y} w:${node2.width} h:${node2.height}`);
  const x2 = node2.x;
  const y2 = node2.y;
  const dx = Math.abs(x2 - insidePoint.x);
  const w2 = node2.width / 2;
  let r = insidePoint.x < outsidePoint.x ? w2 - dx : w2 + dx;
  const h = node2.height / 2;
  const Q = Math.abs(outsidePoint.y - insidePoint.y);
  const R = Math.abs(outsidePoint.x - insidePoint.x);
  if (Math.abs(y2 - outsidePoint.y) * w2 > Math.abs(x2 - outsidePoint.x) * h) {
    let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y2 : y2 - h - outsidePoint.y;
    r = R * q / Q;
    const res = {
      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,
      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q
    };
    if (r === 0) {
      res.x = outsidePoint.x;
      res.y = outsidePoint.y;
    }
    if (R === 0) {
      res.x = outsidePoint.x;
    }
    if (Q === 0) {
      res.y = outsidePoint.y;
    }
    log$1.warn(`abc89 topp/bott calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);
    return res;
  } else {
    if (insidePoint.x < outsidePoint.x) {
      r = outsidePoint.x - w2 - x2;
    } else {
      r = x2 - w2 - outsidePoint.x;
    }
    let q = Q * r / R;
    let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;
    let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;
    log$1.warn(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, { _x, _y });
    if (r === 0) {
      _x = outsidePoint.x;
      _y = outsidePoint.y;
    }
    if (R === 0) {
      _x = outsidePoint.x;
    }
    if (Q === 0) {
      _y = outsidePoint.y;
    }
    return { x: _x, y: _y };
  }
};
const cutPathAtIntersect = (_points, boundryNode) => {
  log$1.warn("abc88 cutPathAtIntersect", _points, boundryNode);
  let points = [];
  let lastPointOutside = _points[0];
  let isInside = false;
  _points.forEach((point2) => {
    log$1.info("abc88 checking point", point2, boundryNode);
    if (!outsideNode(boundryNode, point2) && !isInside) {
      const inter = intersection(boundryNode, lastPointOutside, point2);
      log$1.warn("abc88 inside", point2, lastPointOutside, inter);
      log$1.warn("abc88 intersection", inter);
      let pointPresent = false;
      points.forEach((p) => {
        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;
      });
      if (!points.find((e) => e.x === inter.x && e.y === inter.y)) {
        points.push(inter);
      } else {
        log$1.warn("abc88 no intersect", inter, points);
      }
      isInside = true;
    } else {
      log$1.warn("abc88 outside", point2, lastPointOutside);
      lastPointOutside = point2;
      if (!isInside)
        points.push(point2);
    }
  });
  log$1.warn("abc88 returning points", points);
  return points;
};
const insertEdge = function(elem, e, edge, clusterDb2, diagramType, graph2) {
  let points = edge.points;
  let pointsHasChanged = false;
  const tail = graph2.node(e.v);
  var head2 = graph2.node(e.w);
  log$1.info("abc88 InsertEdge: ", edge);
  if (head2.intersect && tail.intersect) {
    points = points.slice(1, edge.points.length - 1);
    points.unshift(tail.intersect(points[0]));
    log$1.info(
      "Last point",
      points[points.length - 1],
      head2,
      head2.intersect(points[points.length - 1])
    );
    points.push(head2.intersect(points[points.length - 1]));
  }
  if (edge.toCluster) {
    log$1.info("to cluster abc88", clusterDb2[edge.toCluster]);
    points = cutPathAtIntersect(edge.points, clusterDb2[edge.toCluster].node);
    pointsHasChanged = true;
  }
  if (edge.fromCluster) {
    log$1.info("from cluster abc88", clusterDb2[edge.fromCluster]);
    points = cutPathAtIntersect(points.reverse(), clusterDb2[edge.fromCluster].node).reverse();
    pointsHasChanged = true;
  }
  const lineData = points.filter((p) => !Number.isNaN(p.y));
  let curve;
  if (diagramType === "graph" || diagramType === "flowchart") {
    curve = edge.curve || curveBasis;
  } else {
    curve = curveBasis;
  }
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curve);
  let strokeClasses;
  switch (edge.thickness) {
    case "normal":
      strokeClasses = "edge-thickness-normal";
      break;
    case "thick":
      strokeClasses = "edge-thickness-thick";
      break;
    case "invisible":
      strokeClasses = "edge-thickness-thick";
      break;
    default:
      strokeClasses = "";
  }
  switch (edge.pattern) {
    case "solid":
      strokeClasses += " edge-pattern-solid";
      break;
    case "dotted":
      strokeClasses += " edge-pattern-dotted";
      break;
    case "dashed":
      strokeClasses += " edge-pattern-dashed";
      break;
  }
  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", edge.id).attr("class", " " + strokeClasses + (edge.classes ? " " + edge.classes : "")).attr("style", edge.style);
  let url = "";
  if (getConfig$1().flowchart.arrowMarkerAbsolute || getConfig$1().state.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  log$1.info("arrowTypeStart", edge.arrowTypeStart);
  log$1.info("arrowTypeEnd", edge.arrowTypeEnd);
  switch (edge.arrowTypeStart) {
    case "arrow_cross":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-crossStart)");
      break;
    case "arrow_point":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-pointStart)");
      break;
    case "arrow_barb":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-barbStart)");
      break;
    case "arrow_circle":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-circleStart)");
      break;
    case "aggregation":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-aggregationStart)");
      break;
    case "extension":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-extensionStart)");
      break;
    case "composition":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-compositionStart)");
      break;
    case "dependency":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-dependencyStart)");
      break;
    case "lollipop":
      svgPath.attr("marker-start", "url(" + url + "#" + diagramType + "-lollipopStart)");
      break;
  }
  switch (edge.arrowTypeEnd) {
    case "arrow_cross":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-crossEnd)");
      break;
    case "arrow_point":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-pointEnd)");
      break;
    case "arrow_barb":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-barbEnd)");
      break;
    case "arrow_circle":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-circleEnd)");
      break;
    case "aggregation":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-aggregationEnd)");
      break;
    case "extension":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-extensionEnd)");
      break;
    case "composition":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-compositionEnd)");
      break;
    case "dependency":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-dependencyEnd)");
      break;
    case "lollipop":
      svgPath.attr("marker-end", "url(" + url + "#" + diagramType + "-lollipopEnd)");
      break;
  }
  let paths = {};
  if (pointsHasChanged) {
    paths.updatedPath = points;
  }
  paths.originalPath = edge.points;
  return paths;
};
const recursiveRender = (_elem, graph2, diagramtype, parentCluster) => {
  log$1.info("Graph in recursive render: XXX", graphlib$2.json.write(graph2), parentCluster);
  const dir = graph2.graph().rankdir;
  log$1.trace("Dir in recursive render - dir:", dir);
  const elem = _elem.insert("g").attr("class", "root");
  if (!graph2.nodes()) {
    log$1.info("No nodes found for", graph2);
  } else {
    log$1.info("Recursive render XXX", graph2.nodes());
  }
  if (graph2.edges().length > 0) {
    log$1.trace("Recursive edges", graph2.edge(graph2.edges()[0]));
  }
  const clusters = elem.insert("g").attr("class", "clusters");
  const edgePaths = elem.insert("g").attr("class", "edgePaths");
  const edgeLabels2 = elem.insert("g").attr("class", "edgeLabels");
  const nodes = elem.insert("g").attr("class", "nodes");
  graph2.nodes().forEach(function(v) {
    const node2 = graph2.node(v);
    if (typeof parentCluster !== "undefined") {
      const data = JSON.parse(JSON.stringify(parentCluster.clusterData));
      log$1.info("Setting data for cluster XXX (", v, ") ", data, parentCluster);
      graph2.setNode(parentCluster.id, data);
      if (!graph2.parent(v)) {
        log$1.trace("Setting parent", v, parentCluster.id);
        graph2.setParent(v, parentCluster.id, data);
      }
    }
    log$1.info("(Insert) Node XXX" + v + ": " + JSON.stringify(graph2.node(v)));
    if (node2 && node2.clusterNode) {
      log$1.info("Cluster identified", v, node2.width, graph2.node(v));
      const o = recursiveRender(nodes, node2.graph, diagramtype, graph2.node(v));
      const newEl = o.elem;
      updateNodeBounds(node2, newEl);
      node2.diff = o.diff || 0;
      log$1.info("Node bounds (abc123)", v, node2, node2.width, node2.x, node2.y);
      setNodeElem(newEl, node2);
      log$1.warn("Recursive render complete ", newEl, node2);
    } else {
      if (graph2.children(v).length > 0) {
        log$1.info("Cluster - the non recursive path XXX", v, node2.id, node2, graph2);
        log$1.info(findNonClusterChild(node2.id, graph2));
        clusterDb[node2.id] = { id: findNonClusterChild(node2.id, graph2), node: node2 };
      } else {
        log$1.info("Node - the non recursive path", v, node2.id, node2);
        insertNode(nodes, graph2.node(v), dir);
      }
    }
  });
  graph2.edges().forEach(function(e) {
    const edge = graph2.edge(e.v, e.w, e.name);
    log$1.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
    log$1.info("Edge " + e.v + " -> " + e.w + ": ", e, " ", JSON.stringify(graph2.edge(e)));
    log$1.info("Fix", clusterDb, "ids:", e.v, e.w, "Translateing: ", clusterDb[e.v], clusterDb[e.w]);
    insertEdgeLabel(edgeLabels2, edge);
  });
  graph2.edges().forEach(function(e) {
    log$1.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(e));
  });
  log$1.info("#############################################");
  log$1.info("###                Layout                 ###");
  log$1.info("#############################################");
  log$1.info(graph2);
  dagre$1.layout(graph2);
  log$1.info("Graph after layout:", graphlib$2.json.write(graph2));
  let diff = 0;
  sortNodesByHierarchy(graph2).forEach(function(v) {
    const node2 = graph2.node(v);
    log$1.info("Position " + v + ": " + JSON.stringify(graph2.node(v)));
    log$1.info(
      "Position " + v + ": (" + node2.x,
      "," + node2.y,
      ") width: ",
      node2.width,
      " height: ",
      node2.height
    );
    if (node2 && node2.clusterNode) {
      positionNode(node2);
    } else {
      if (graph2.children(v).length > 0) {
        insertCluster(clusters, node2);
        clusterDb[node2.id].node = node2;
      } else {
        positionNode(node2);
      }
    }
  });
  graph2.edges().forEach(function(e) {
    const edge = graph2.edge(e);
    log$1.info("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(edge), edge);
    const paths = insertEdge(edgePaths, e, edge, clusterDb, diagramtype, graph2);
    positionEdgeLabel(edge, paths);
  });
  graph2.nodes().forEach(function(v) {
    const n = graph2.node(v);
    log$1.info(v, n.type, n.diff);
    if (n.type === "group") {
      diff = n.diff;
    }
  });
  return { elem, diff };
};
const render$1 = (elem, graph2, markers2, diagramtype, id2) => {
  insertMarkers$2(elem, markers2, diagramtype, id2);
  clear$a();
  clear$8();
  clear$9();
  clear$b();
  log$1.warn("Graph at first:", graphlib$2.json.write(graph2));
  adjustClustersAndEdges(graph2);
  log$1.warn("Graph after:", graphlib$2.json.write(graph2));
  recursiveRender(elem, graph2, diagramtype);
};
const sanitizeText$1 = (txt) => common.sanitizeText(txt, getConfig$1());
const addClasses = function(classes2, g, _id, diagObj) {
  const keys2 = Object.keys(classes2);
  log$1.info("keys:", keys2);
  log$1.info(classes2);
  keys2.forEach(function(id2) {
    const vertex = classes2[id2];
    let cssClassStr = "";
    if (vertex.cssClasses.length > 0) {
      cssClassStr = cssClassStr + " " + vertex.cssClasses.join(" ");
    }
    const styles = { labelStyle: "" };
    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
    let radious = 0;
    let _shape = "";
    switch (vertex.type) {
      case "class":
        _shape = "class_box";
        break;
      default:
        _shape = "class_box";
    }
    g.setNode(vertex.id, {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: sanitizeText$1(vertexText),
      classData: vertex,
      rx: radious,
      ry: radious,
      class: cssClassStr,
      style: styles.style,
      id: vertex.id,
      domId: vertex.domId,
      tooltip: diagObj.db.getTooltip(vertex.id) || "",
      haveCallback: vertex.haveCallback,
      link: vertex.link,
      width: vertex.type === "group" ? 500 : void 0,
      type: vertex.type,
      padding: getConfig$1().flowchart.padding
    });
    log$1.info("setNode", {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: cssClassStr,
      style: styles.style,
      id: vertex.id,
      width: vertex.type === "group" ? 500 : void 0,
      type: vertex.type,
      padding: getConfig$1().flowchart.padding
    });
  });
};
const addRelations = function(relations2, g) {
  const conf2 = getConfig$1().flowchart;
  let cnt2 = 0;
  relations2.forEach(function(edge) {
    cnt2++;
    const edgeData = {};
    edgeData.classes = "relation";
    edgeData.pattern = edge.relation.lineType == 1 ? "dashed" : "solid";
    edgeData.id = "id" + cnt2;
    if (edge.type === "arrow_open") {
      edgeData.arrowhead = "none";
    } else {
      edgeData.arrowhead = "normal";
    }
    log$1.info(edgeData, edge);
    edgeData.startLabelRight = edge.relationTitle1 === "none" ? "" : edge.relationTitle1;
    edgeData.endLabelLeft = edge.relationTitle2 === "none" ? "" : edge.relationTitle2;
    edgeData.arrowTypeStart = getArrowMarker(edge.relation.type1);
    edgeData.arrowTypeEnd = getArrowMarker(edge.relation.type2);
    let style = "";
    let labelStyle = "";
    if (typeof edge.style !== "undefined") {
      const styles = getStylesFromArray(edge.style);
      style = styles.style;
      labelStyle = styles.labelStyle;
    } else {
      style = "fill:none";
    }
    edgeData.style = style;
    edgeData.labelStyle = labelStyle;
    if (typeof edge.interpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear$1);
    } else if (typeof relations2.defaultInterpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(relations2.defaultInterpolate, curveLinear$1);
    } else {
      edgeData.curve = interpolateToCurve(conf2.curve, curveLinear$1);
    }
    edge.text = edge.title;
    if (typeof edge.text === "undefined") {
      if (typeof edge.style !== "undefined") {
        edgeData.arrowheadStyle = "fill: #333";
      }
    } else {
      edgeData.arrowheadStyle = "fill: #333";
      edgeData.labelpos = "c";
      if (getConfig$1().flowchart.htmlLabels) {
        edgeData.labelType = "html";
        edgeData.label = '<span class="edgeLabel">' + edge.text + "</span>";
      } else {
        edgeData.labelType = "text";
        edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
        if (typeof edge.style === "undefined") {
          edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none";
        }
        edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
      }
    }
    g.setEdge(edge.id1, edge.id2, edgeData, cnt2);
  });
};
const setConf$9 = function(cnf) {
  const keys2 = Object.keys(cnf);
  keys2.forEach(function(key) {
    cnf[key];
  });
};
const draw$c = function(text2, id2, _version, diagObj) {
  log$1.info("Drawing class - ", id2);
  const conf2 = getConfig$1().flowchart;
  const securityLevel = getConfig$1().securityLevel;
  log$1.info("config:", conf2);
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  const g = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: diagObj.db.getDirection(),
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const classes2 = diagObj.db.getClasses();
  const relations2 = diagObj.db.getRelations();
  log$1.info(relations2);
  addClasses(classes2, g, id2, diagObj);
  addRelations(relations2, g);
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id="${id2}"]`);
  const element = root2.select("#" + id2 + " g");
  render$1(
    element,
    g,
    ["aggregation", "extension", "composition", "dependency", "lollipop"],
    "classDiagram",
    id2
  );
  setupGraphViewbox$1(g, svg2, conf2.diagramPadding, conf2.useMaxWidth);
  if (!conf2.htmlLabels) {
    const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    const labels = doc.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
    for (let k2 = 0; k2 < labels.length; k2++) {
      const label = labels[k2];
      const dim = label.getBBox();
      const rect2 = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", 0);
      rect2.setAttribute("ry", 0);
      rect2.setAttribute("width", dim.width);
      rect2.setAttribute("height", dim.height);
      label.insertBefore(rect2, label.firstChild);
    }
  }
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
};
function getArrowMarker(type2) {
  let marker;
  switch (type2) {
    case 0:
      marker = "aggregation";
      break;
    case 1:
      marker = "extension";
      break;
    case 2:
      marker = "composition";
      break;
    case 3:
      marker = "dependency";
      break;
    case 4:
      marker = "lollipop";
      break;
    default:
      marker = "none";
  }
  return marker;
}
const classRendererV2 = {
  setConf: setConf$9,
  draw: draw$c
};
var parser$8 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 5], $V2 = [6, 9, 11, 23, 25, 27, 29, 30, 31, 49], $V3 = [1, 17], $V4 = [1, 18], $V5 = [1, 19], $V6 = [1, 20], $V7 = [1, 21], $V8 = [1, 22], $V9 = [1, 25], $Va = [1, 30], $Vb = [1, 31], $Vc = [1, 32], $Vd = [1, 33], $Ve = [6, 9, 11, 15, 20, 23, 25, 27, 29, 30, 31, 42, 43, 44, 45, 49], $Vf = [1, 45], $Vg = [30, 31, 46, 47], $Vh = [4, 6, 9, 11, 23, 25, 27, 29, 30, 31, 49], $Vi = [42, 43, 44, 45], $Vj = [22, 37], $Vk = [1, 64];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "ER_DIAGRAM": 4, "document": 5, "EOF": 6, "directive": 7, "line": 8, "SPACE": 9, "statement": 10, "NEWLINE": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, ":": 15, "argDirective": 16, "entityName": 17, "relSpec": 18, "role": 19, "BLOCK_START": 20, "attributes": 21, "BLOCK_STOP": 22, "title": 23, "title_value": 24, "acc_title": 25, "acc_title_value": 26, "acc_descr": 27, "acc_descr_value": 28, "acc_descr_multiline_value": 29, "ALPHANUM": 30, "ENTITY_NAME": 31, "attribute": 32, "attributeType": 33, "attributeName": 34, "attributeKeyType": 35, "attributeComment": 36, "ATTRIBUTE_WORD": 37, "ATTRIBUTE_KEY": 38, "COMMENT": 39, "cardinality": 40, "relType": 41, "ZERO_OR_ONE": 42, "ZERO_OR_MORE": 43, "ONE_OR_MORE": 44, "ONLY_ONE": 45, "NON_IDENTIFYING": 46, "IDENTIFYING": 47, "WORD": 48, "open_directive": 49, "type_directive": 50, "arg_directive": 51, "close_directive": 52, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "ER_DIAGRAM", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 20: "BLOCK_START", 22: "BLOCK_STOP", 23: "title", 24: "title_value", 25: "acc_title", 26: "acc_title_value", 27: "acc_descr", 28: "acc_descr_value", 29: "acc_descr_multiline_value", 30: "ALPHANUM", 31: "ENTITY_NAME", 37: "ATTRIBUTE_WORD", 38: "ATTRIBUTE_KEY", 39: "COMMENT", 42: "ZERO_OR_ONE", 43: "ZERO_OR_MORE", 44: "ONE_OR_MORE", 45: "ONLY_ONE", 46: "NON_IDENTIFYING", 47: "IDENTIFYING", 48: "WORD", 49: "open_directive", 50: "type_directive", 51: "arg_directive", 52: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 5], [10, 4], [10, 3], [10, 1], [10, 2], [10, 2], [10, 2], [10, 1], [17, 1], [17, 1], [21, 1], [21, 2], [32, 2], [32, 3], [32, 3], [32, 4], [33, 1], [34, 1], [35, 1], [36, 1], [18, 3], [40, 1], [40, 1], [40, 1], [40, 1], [41, 1], [41, 1], [19, 1], [19, 1], [19, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          break;
        case 3:
          this.$ = [];
          break;
        case 4:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 5:
        case 6:
          this.$ = $$[$0];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 12:
          yy.addEntity($$[$0 - 4]);
          yy.addEntity($$[$0 - 2]);
          yy.addRelationship($$[$0 - 4], $$[$0], $$[$0 - 2], $$[$0 - 3]);
          break;
        case 13:
          yy.addEntity($$[$0 - 3]);
          yy.addAttributes($$[$0 - 3], $$[$0 - 1]);
          break;
        case 14:
          yy.addEntity($$[$0 - 2]);
          break;
        case 15:
          yy.addEntity($$[$0]);
          break;
        case 16:
        case 17:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 20:
        case 41:
          this.$ = $$[$0];
          break;
        case 21:
        case 39:
        case 40:
          this.$ = $$[$0].replace(/"/g, "");
          break;
        case 22:
          this.$ = [$$[$0]];
          break;
        case 23:
          $$[$0].push($$[$0 - 1]);
          this.$ = $$[$0];
          break;
        case 24:
          this.$ = { attributeType: $$[$0 - 1], attributeName: $$[$0] };
          break;
        case 25:
          this.$ = { attributeType: $$[$0 - 2], attributeName: $$[$0 - 1], attributeKeyType: $$[$0] };
          break;
        case 26:
          this.$ = { attributeType: $$[$0 - 2], attributeName: $$[$0 - 1], attributeComment: $$[$0] };
          break;
        case 27:
          this.$ = { attributeType: $$[$0 - 3], attributeName: $$[$0 - 2], attributeKeyType: $$[$0 - 1], attributeComment: $$[$0] };
          break;
        case 28:
        case 29:
        case 30:
          this.$ = $$[$0];
          break;
        case 31:
          this.$ = $$[$0].replace(/"/g, "");
          break;
        case 32:
          this.$ = { cardA: $$[$0], relType: $$[$0 - 1], cardB: $$[$0 - 2] };
          break;
        case 33:
          this.$ = yy.Cardinality.ZERO_OR_ONE;
          break;
        case 34:
          this.$ = yy.Cardinality.ZERO_OR_MORE;
          break;
        case 35:
          this.$ = yy.Cardinality.ONE_OR_MORE;
          break;
        case 36:
          this.$ = yy.Cardinality.ONLY_ONE;
          break;
        case 37:
          this.$ = yy.Identification.NON_IDENTIFYING;
          break;
        case 38:
          this.$ = yy.Identification.IDENTIFYING;
          break;
        case 42:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 43:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 44:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 45:
          yy.parseDirective("}%%", "close_directive", "er");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 7: 3, 12: 4, 49: $V1 }, { 1: [3] }, o($V2, [2, 3], { 5: 6 }), { 3: 7, 4: $V0, 7: 3, 12: 4, 49: $V1 }, { 13: 8, 50: [1, 9] }, { 50: [2, 42] }, { 6: [1, 10], 7: 15, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: 16, 23: $V3, 25: $V4, 27: $V5, 29: $V6, 30: $V7, 31: $V8, 49: $V1 }, { 1: [2, 2] }, { 14: 23, 15: [1, 24], 52: $V9 }, o([15, 52], [2, 43]), o($V2, [2, 8], { 1: [2, 1] }), o($V2, [2, 4]), { 7: 15, 10: 26, 12: 4, 17: 16, 23: $V3, 25: $V4, 27: $V5, 29: $V6, 30: $V7, 31: $V8, 49: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 11]), o($V2, [2, 15], { 18: 27, 40: 29, 20: [1, 28], 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd }), { 24: [1, 34] }, { 26: [1, 35] }, { 28: [1, 36] }, o($V2, [2, 19]), o($Ve, [2, 20]), o($Ve, [2, 21]), { 11: [1, 37] }, { 16: 38, 51: [1, 39] }, { 11: [2, 45] }, o($V2, [2, 5]), { 17: 40, 30: $V7, 31: $V8 }, { 21: 41, 22: [1, 42], 32: 43, 33: 44, 37: $Vf }, { 41: 46, 46: [1, 47], 47: [1, 48] }, o($Vg, [2, 33]), o($Vg, [2, 34]), o($Vg, [2, 35]), o($Vg, [2, 36]), o($V2, [2, 16]), o($V2, [2, 17]), o($V2, [2, 18]), o($Vh, [2, 9]), { 14: 49, 52: $V9 }, { 52: [2, 44] }, { 15: [1, 50] }, { 22: [1, 51] }, o($V2, [2, 14]), { 21: 52, 22: [2, 22], 32: 43, 33: 44, 37: $Vf }, { 34: 53, 37: [1, 54] }, { 37: [2, 28] }, { 40: 55, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd }, o($Vi, [2, 37]), o($Vi, [2, 38]), { 11: [1, 56] }, { 19: 57, 30: [1, 60], 31: [1, 59], 48: [1, 58] }, o($V2, [2, 13]), { 22: [2, 23] }, o($Vj, [2, 24], { 35: 61, 36: 62, 38: [1, 63], 39: $Vk }), o([22, 37, 38, 39], [2, 29]), o([30, 31], [2, 32]), o($Vh, [2, 10]), o($V2, [2, 12]), o($V2, [2, 39]), o($V2, [2, 40]), o($V2, [2, 41]), o($Vj, [2, 25], { 36: 65, 39: $Vk }), o($Vj, [2, 26]), o([22, 37, 39], [2, 30]), o($Vj, [2, 31]), o($Vj, [2, 27])],
    defaultActions: { 5: [2, 42], 7: [2, 2], 25: [2, 45], 39: [2, 44], 45: [2, 28], 52: [2, 23] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("acc_title");
            return 25;
          case 1:
            this.popState();
            return "acc_title_value";
          case 2:
            this.begin("acc_descr");
            return 27;
          case 3:
            this.popState();
            return "acc_descr_value";
          case 4:
            this.begin("acc_descr_multiline");
            break;
          case 5:
            this.popState();
            break;
          case 6:
            return "acc_descr_multiline_value";
          case 7:
            this.begin("open_directive");
            return 49;
          case 8:
            this.begin("type_directive");
            return 50;
          case 9:
            this.popState();
            this.begin("arg_directive");
            return 15;
          case 10:
            this.popState();
            this.popState();
            return 52;
          case 11:
            return 51;
          case 12:
            break;
          case 13:
            break;
          case 14:
            return 11;
          case 15:
            break;
          case 16:
            return 9;
          case 17:
            return 31;
          case 18:
            return 48;
          case 19:
            return 4;
          case 20:
            this.begin("block");
            return 20;
          case 21:
            break;
          case 22:
            return 38;
          case 23:
            return 37;
          case 24:
            return 37;
          case 25:
            return 39;
          case 26:
            break;
          case 27:
            this.popState();
            return 22;
          case 28:
            return yy_.yytext[0];
          case 29:
            return 42;
          case 30:
            return 43;
          case 31:
            return 44;
          case 32:
            return 45;
          case 33:
            return 42;
          case 34:
            return 43;
          case 35:
            return 44;
          case 36:
            return 46;
          case 37:
            return 47;
          case 38:
            return 46;
          case 39:
            return 46;
          case 40:
            return 30;
          case 41:
            return yy_.yytext[0];
          case 42:
            return 6;
        }
      },
      rules: [/^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:[\s]+)/i, /^(?:"[^"%\r\n\v\b\\]+")/i, /^(?:"[^"]*")/i, /^(?:erDiagram\b)/i, /^(?:\{)/i, /^(?:\s+)/i, /^(?:\b((?:PK)|(?:FK))\b)/i, /^(?:(.*?)[~](.*?)*[~])/i, /^(?:[A-Za-z][A-Za-z0-9\-_\[\]]*)/i, /^(?:"[^"]*")/i, /^(?:[\n]+)/i, /^(?:\})/i, /^(?:.)/i, /^(?:\|o\b)/i, /^(?:\}o\b)/i, /^(?:\}\|)/i, /^(?:\|\|)/i, /^(?:o\|)/i, /^(?:o\{)/i, /^(?:\|\{)/i, /^(?:\.\.)/i, /^(?:--)/i, /^(?:\.-)/i, /^(?:-\.)/i, /^(?:[A-Za-z][A-Za-z0-9\-_]*)/i, /^(?:.)/i, /^(?:$)/i],
      conditions: { "acc_descr_multiline": { "rules": [5, 6], "inclusive": false }, "acc_descr": { "rules": [3], "inclusive": false }, "acc_title": { "rules": [1], "inclusive": false }, "open_directive": { "rules": [8], "inclusive": false }, "type_directive": { "rules": [9, 10], "inclusive": false }, "arg_directive": { "rules": [10, 11], "inclusive": false }, "block": { "rules": [21, 22, 23, 24, 25, 26, 27, 28], "inclusive": false }, "INITIAL": { "rules": [0, 2, 4, 7, 12, 13, 14, 15, 16, 17, 18, 19, 20, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$8.parser = parser$8;
const erDetector = (txt) => {
  return txt.match(/^\s*erDiagram/) !== null;
};
let entities = {};
let relationships = [];
const Cardinality = {
  ZERO_OR_ONE: "ZERO_OR_ONE",
  ZERO_OR_MORE: "ZERO_OR_MORE",
  ONE_OR_MORE: "ONE_OR_MORE",
  ONLY_ONE: "ONLY_ONE"
};
const Identification = {
  NON_IDENTIFYING: "NON_IDENTIFYING",
  IDENTIFYING: "IDENTIFYING"
};
const parseDirective$8 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addEntity = function(name2) {
  if (typeof entities[name2] === "undefined") {
    entities[name2] = { attributes: [] };
    log$1.info("Added new entity :", name2);
  }
  return entities[name2];
};
const getEntities = () => entities;
const addAttributes = function(entityName, attribs) {
  let entity = addEntity(entityName);
  let i;
  for (i = attribs.length - 1; i >= 0; i--) {
    entity.attributes.push(attribs[i]);
    log$1.debug("Added attribute ", attribs[i].attributeName);
  }
};
const addRelationship$1 = function(entA, rolA, entB, rSpec) {
  let rel = {
    entityA: entA,
    roleA: rolA,
    entityB: entB,
    relSpec: rSpec
  };
  relationships.push(rel);
  log$1.debug("Added new relationship :", rel);
};
const getRelationships$1 = () => relationships;
const clear$7 = function() {
  entities = {};
  relationships = [];
  clear$g();
};
const erDb = {
  Cardinality,
  Identification,
  parseDirective: parseDirective$8,
  getConfig: () => getConfig$1().er,
  addEntity,
  addAttributes,
  getEntities,
  addRelationship: addRelationship$1,
  getRelationships: getRelationships$1,
  clear: clear$7,
  setAccTitle,
  getAccTitle,
  setAccDescription,
  getAccDescription
};
const ERMarkers = {
  ONLY_ONE_START: "ONLY_ONE_START",
  ONLY_ONE_END: "ONLY_ONE_END",
  ZERO_OR_ONE_START: "ZERO_OR_ONE_START",
  ZERO_OR_ONE_END: "ZERO_OR_ONE_END",
  ONE_OR_MORE_START: "ONE_OR_MORE_START",
  ONE_OR_MORE_END: "ONE_OR_MORE_END",
  ZERO_OR_MORE_START: "ZERO_OR_MORE_START",
  ZERO_OR_MORE_END: "ZERO_OR_MORE_END"
};
const insertMarkers$1 = function(elem, conf2) {
  let marker;
  elem.append("defs").append("marker").attr("id", ERMarkers.ONLY_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M9,0 L9,18 M15,0 L15,18");
  elem.append("defs").append("marker").attr("id", ERMarkers.ONLY_ONE_END).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M3,0 L3,18 M9,0 L9,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_ONE_START).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M9,0 L9,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_ONE_END).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M21,0 L21,18");
  elem.append("defs").append("marker").attr("id", ERMarkers.ONE_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27");
  elem.append("defs").append("marker").attr("id", ERMarkers.ONE_OR_MORE_END).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_MORE_START).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  marker = elem.append("defs").append("marker").attr("id", ERMarkers.ZERO_OR_MORE_END).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  marker.append("circle").attr("stroke", conf2.stroke).attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6);
  marker.append("path").attr("stroke", conf2.stroke).attr("fill", "none").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
  return;
};
const erMarkers = {
  ERMarkers,
  insertMarkers: insertMarkers$1
};
const BAD_ID_CHARS_REGEXP = /[^A-Za-z0-9]([\W])*/g;
let conf$9 = {};
let entityNameIds = /* @__PURE__ */ new Map();
const setConf$8 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$9[keys2[i]] = cnf[keys2[i]];
  }
};
const drawAttributes = (groupNode, entityTextNode, attributes) => {
  const heightPadding = conf$9.entityPadding / 3;
  const widthPadding = conf$9.entityPadding / 3;
  const attrFontSize = conf$9.fontSize * 0.85;
  const labelBBox = entityTextNode.node().getBBox();
  const attributeNodes = [];
  let hasKeyType = false;
  let hasComment = false;
  let maxTypeWidth = 0;
  let maxNameWidth = 0;
  let maxKeyWidth = 0;
  let maxCommentWidth = 0;
  let cumulativeHeight = labelBBox.height + heightPadding * 2;
  let attrNum = 1;
  attributes.forEach((item) => {
    if (item.attributeKeyType !== void 0) {
      hasKeyType = true;
    }
    if (item.attributeComment !== void 0) {
      hasComment = true;
    }
  });
  attributes.forEach((item) => {
    const attrPrefix = `${entityTextNode.node().id}-attr-${attrNum}`;
    let nodeHeight = 0;
    const attributeType = parseGenericTypes(item.attributeType);
    const typeNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-type`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
      "style",
      "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
    ).text(attributeType);
    const nameNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-name`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
      "style",
      "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
    ).text(item.attributeName);
    const attributeNode = {};
    attributeNode.tn = typeNode;
    attributeNode.nn = nameNode;
    const typeBBox = typeNode.node().getBBox();
    const nameBBox = nameNode.node().getBBox();
    maxTypeWidth = Math.max(maxTypeWidth, typeBBox.width);
    maxNameWidth = Math.max(maxNameWidth, nameBBox.width);
    nodeHeight = Math.max(typeBBox.height, nameBBox.height);
    if (hasKeyType) {
      const keyTypeNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-key`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
        "style",
        "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
      ).text(item.attributeKeyType || "");
      attributeNode.kn = keyTypeNode;
      const keyTypeBBox = keyTypeNode.node().getBBox();
      maxKeyWidth = Math.max(maxKeyWidth, keyTypeBBox.width);
      nodeHeight = Math.max(nodeHeight, keyTypeBBox.height);
    }
    if (hasComment) {
      const commentNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", `${attrPrefix}-comment`).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "left").attr(
        "style",
        "font-family: " + getConfig$1().fontFamily + "; font-size: " + attrFontSize + "px"
      ).text(item.attributeComment || "");
      attributeNode.cn = commentNode;
      const commentNodeBBox = commentNode.node().getBBox();
      maxCommentWidth = Math.max(maxCommentWidth, commentNodeBBox.width);
      nodeHeight = Math.max(nodeHeight, commentNodeBBox.height);
    }
    attributeNode.height = nodeHeight;
    attributeNodes.push(attributeNode);
    cumulativeHeight += nodeHeight + heightPadding * 2;
    attrNum += 1;
  });
  let widthPaddingFactor = 4;
  if (hasKeyType) {
    widthPaddingFactor += 2;
  }
  if (hasComment) {
    widthPaddingFactor += 2;
  }
  const maxWidth = maxTypeWidth + maxNameWidth + maxKeyWidth + maxCommentWidth;
  const bBox = {
    width: Math.max(
      conf$9.minEntityWidth,
      Math.max(
        labelBBox.width + conf$9.entityPadding * 2,
        maxWidth + widthPadding * widthPaddingFactor
      )
    ),
    height: attributes.length > 0 ? cumulativeHeight : Math.max(conf$9.minEntityHeight, labelBBox.height + conf$9.entityPadding * 2)
  };
  if (attributes.length > 0) {
    const spareColumnWidth = Math.max(
      0,
      (bBox.width - maxWidth - widthPadding * widthPaddingFactor) / (widthPaddingFactor / 2)
    );
    entityTextNode.attr(
      "transform",
      "translate(" + bBox.width / 2 + "," + (heightPadding + labelBBox.height / 2) + ")"
    );
    let heightOffset = labelBBox.height + heightPadding * 2;
    let attribStyle = "attributeBoxOdd";
    attributeNodes.forEach((attributeNode) => {
      const alignY = heightOffset + heightPadding + attributeNode.height / 2;
      attributeNode.tn.attr("transform", "translate(" + widthPadding + "," + alignY + ")");
      const typeRect = groupNode.insert("rect", "#" + attributeNode.tn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", 0).attr("y", heightOffset).attr("width", maxTypeWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
      const nameXOffset = parseFloat(typeRect.attr("x")) + parseFloat(typeRect.attr("width"));
      attributeNode.nn.attr(
        "transform",
        "translate(" + (nameXOffset + widthPadding) + "," + alignY + ")"
      );
      const nameRect = groupNode.insert("rect", "#" + attributeNode.nn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", nameXOffset).attr("y", heightOffset).attr("width", maxNameWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
      let keyTypeAndCommentXOffset = parseFloat(nameRect.attr("x")) + parseFloat(nameRect.attr("width"));
      if (hasKeyType) {
        attributeNode.kn.attr(
          "transform",
          "translate(" + (keyTypeAndCommentXOffset + widthPadding) + "," + alignY + ")"
        );
        const keyTypeRect = groupNode.insert("rect", "#" + attributeNode.kn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", keyTypeAndCommentXOffset).attr("y", heightOffset).attr("width", maxKeyWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
        keyTypeAndCommentXOffset = parseFloat(keyTypeRect.attr("x")) + parseFloat(keyTypeRect.attr("width"));
      }
      if (hasComment) {
        attributeNode.cn.attr(
          "transform",
          "translate(" + (keyTypeAndCommentXOffset + widthPadding) + "," + alignY + ")"
        );
        groupNode.insert("rect", "#" + attributeNode.cn.node().id).attr("class", `er ${attribStyle}`).attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", keyTypeAndCommentXOffset).attr("y", heightOffset).attr("width", maxCommentWidth + widthPadding * 2 + spareColumnWidth).attr("height", attributeNode.height + heightPadding * 2);
      }
      heightOffset += attributeNode.height + heightPadding * 2;
      attribStyle = attribStyle === "attributeBoxOdd" ? "attributeBoxEven" : "attributeBoxOdd";
    });
  } else {
    bBox.height = Math.max(conf$9.minEntityHeight, cumulativeHeight);
    entityTextNode.attr("transform", "translate(" + bBox.width / 2 + "," + bBox.height / 2 + ")");
  }
  return bBox;
};
const drawEntities = function(svgNode2, entities2, graph2) {
  const keys2 = Object.keys(entities2);
  let firstOne;
  keys2.forEach(function(entityName) {
    const entityId = generateId(entityName, "entity");
    entityNameIds.set(entityName, entityId);
    const groupNode = svgNode2.append("g").attr("id", entityId);
    firstOne = firstOne === void 0 ? entityId : firstOne;
    const textId = "text-" + entityId;
    const textNode = groupNode.append("text").attr("class", "er entityLabel").attr("id", textId).attr("x", 0).attr("y", 0).attr("dominant-baseline", "middle").attr("text-anchor", "middle").attr(
      "style",
      "font-family: " + getConfig$1().fontFamily + "; font-size: " + conf$9.fontSize + "px"
    ).text(entityName);
    const { width: entityWidth, height: entityHeight } = drawAttributes(
      groupNode,
      textNode,
      entities2[entityName].attributes
    );
    const rectNode = groupNode.insert("rect", "#" + textId).attr("class", "er entityBox").attr("fill", conf$9.fill).attr("fill-opacity", "100%").attr("stroke", conf$9.stroke).attr("x", 0).attr("y", 0).attr("width", entityWidth).attr("height", entityHeight);
    const rectBBox = rectNode.node().getBBox();
    graph2.setNode(entityId, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: "rect",
      id: entityId
    });
  });
  return firstOne;
};
const adjustEntities$1 = function(svgNode2, graph2) {
  graph2.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
      svgNode2.select("#" + v).attr(
        "transform",
        "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y - graph2.node(v).height / 2) + " )"
      );
    }
  });
};
const getEdgeName = function(rel) {
  return (rel.entityA + rel.roleA + rel.entityB).replace(/\s/g, "");
};
const addRelationships$1 = function(relationships2, g) {
  relationships2.forEach(function(r) {
    g.setEdge(
      entityNameIds.get(r.entityA),
      entityNameIds.get(r.entityB),
      { relationship: r },
      getEdgeName(r)
    );
  });
  return relationships2;
};
let relCnt$1 = 0;
const drawRelationshipFromLayout$1 = function(svg2, rel, g, insert, diagObj) {
  relCnt$1++;
  const edge = g.edge(
    entityNameIds.get(rel.entityA),
    entityNameIds.get(rel.entityB),
    getEdgeName(rel)
  );
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curveBasis);
  const svgPath = svg2.insert("path", "#" + insert).attr("class", "er relationshipLine").attr("d", lineFunction(edge.points)).attr("stroke", conf$9.stroke).attr("fill", "none");
  if (rel.relSpec.relType === diagObj.db.Identification.NON_IDENTIFYING) {
    svgPath.attr("stroke-dasharray", "8,8");
  }
  let url = "";
  if (conf$9.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  switch (rel.relSpec.cardA) {
    case diagObj.db.Cardinality.ZERO_OR_ONE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_ONE_END + ")");
      break;
    case diagObj.db.Cardinality.ZERO_OR_MORE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_MORE_END + ")");
      break;
    case diagObj.db.Cardinality.ONE_OR_MORE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ONE_OR_MORE_END + ")");
      break;
    case diagObj.db.Cardinality.ONLY_ONE:
      svgPath.attr("marker-end", "url(" + url + "#" + erMarkers.ERMarkers.ONLY_ONE_END + ")");
      break;
  }
  switch (rel.relSpec.cardB) {
    case diagObj.db.Cardinality.ZERO_OR_ONE:
      svgPath.attr(
        "marker-start",
        "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_ONE_START + ")"
      );
      break;
    case diagObj.db.Cardinality.ZERO_OR_MORE:
      svgPath.attr(
        "marker-start",
        "url(" + url + "#" + erMarkers.ERMarkers.ZERO_OR_MORE_START + ")"
      );
      break;
    case diagObj.db.Cardinality.ONE_OR_MORE:
      svgPath.attr(
        "marker-start",
        "url(" + url + "#" + erMarkers.ERMarkers.ONE_OR_MORE_START + ")"
      );
      break;
    case diagObj.db.Cardinality.ONLY_ONE:
      svgPath.attr("marker-start", "url(" + url + "#" + erMarkers.ERMarkers.ONLY_ONE_START + ")");
      break;
  }
  const len = svgPath.node().getTotalLength();
  const labelPoint = svgPath.node().getPointAtLength(len * 0.5);
  const labelId = "rel" + relCnt$1;
  const labelNode = svg2.append("text").attr("class", "er relationshipLabel").attr("id", labelId).attr("x", labelPoint.x).attr("y", labelPoint.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").attr(
    "style",
    "font-family: " + getConfig$1().fontFamily + "; font-size: " + conf$9.fontSize + "px"
  ).text(rel.roleA);
  const labelBBox = labelNode.node().getBBox();
  svg2.insert("rect", "#" + labelId).attr("class", "er relationshipLabelBox").attr("x", labelPoint.x - labelBBox.width / 2).attr("y", labelPoint.y - labelBBox.height / 2).attr("width", labelBBox.width).attr("height", labelBBox.height).attr("fill", "white").attr("fill-opacity", "85%");
};
const draw$b = function(text2, id2, _version, diagObj) {
  conf$9 = getConfig$1().er;
  log$1.info("Drawing ER diagram");
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id='${id2}']`);
  erMarkers.insertMarkers(svg2, conf$9);
  let g;
  g = new graphlib$2.Graph({
    multigraph: true,
    directed: true,
    compound: false
  }).setGraph({
    rankdir: conf$9.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  const firstEntity = drawEntities(svg2, diagObj.db.getEntities(), g);
  const relationships2 = addRelationships$1(diagObj.db.getRelationships(), g);
  dagre$1.layout(g);
  adjustEntities$1(svg2, g);
  relationships2.forEach(function(rel) {
    drawRelationshipFromLayout$1(svg2, rel, g, firstEntity, diagObj);
  });
  const padding2 = conf$9.diagramPadding;
  const svgBounds = svg2.node().getBBox();
  const width2 = svgBounds.width + padding2 * 2;
  const height2 = svgBounds.height + padding2 * 2;
  configureSvgSize(svg2, height2, width2, conf$9.useMaxWidth);
  svg2.attr("viewBox", `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
};
function generateId(str = "", prefix2 = "") {
  const simplifiedStr = str.replace(BAD_ID_CHARS_REGEXP, "");
  return `${strWithHyphen(prefix2)}${strWithHyphen(simplifiedStr)}${v4()}`;
}
function strWithHyphen(str = "") {
  return str.length > 0 ? `${str}-` : "";
}
const erRenderer = {
  setConf: setConf$8,
  draw: draw$b
};
var parser$7 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 9], $V1 = [1, 7], $V2 = [1, 6], $V3 = [1, 8], $V4 = [1, 20, 21, 22, 23, 38, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $V5 = [2, 10], $V6 = [1, 20], $V7 = [1, 21], $V8 = [1, 22], $V9 = [1, 23], $Va = [1, 30], $Vb = [1, 32], $Vc = [1, 33], $Vd = [1, 34], $Ve = [1, 62], $Vf = [1, 48], $Vg = [1, 52], $Vh = [1, 36], $Vi = [1, 37], $Vj = [1, 38], $Vk = [1, 39], $Vl = [1, 40], $Vm = [1, 56], $Vn = [1, 63], $Vo = [1, 51], $Vp = [1, 53], $Vq = [1, 55], $Vr = [1, 59], $Vs = [1, 60], $Vt = [1, 41], $Vu = [1, 42], $Vv = [1, 43], $Vw = [1, 44], $Vx = [1, 61], $Vy = [1, 50], $Vz = [1, 54], $VA = [1, 57], $VB = [1, 58], $VC = [1, 49], $VD = [1, 66], $VE = [1, 71], $VF = [1, 20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $VG = [1, 75], $VH = [1, 74], $VI = [1, 76], $VJ = [20, 21, 23, 81, 82], $VK = [1, 99], $VL = [1, 104], $VM = [1, 107], $VN = [1, 108], $VO = [1, 101], $VP = [1, 106], $VQ = [1, 109], $VR = [1, 102], $VS = [1, 114], $VT = [1, 113], $VU = [1, 103], $VV = [1, 105], $VW = [1, 110], $VX = [1, 111], $VY = [1, 112], $VZ = [1, 115], $V_ = [20, 21, 22, 23, 81, 82], $V$ = [20, 21, 22, 23, 53, 81, 82], $V01 = [20, 21, 22, 23, 40, 52, 53, 55, 57, 59, 61, 63, 65, 66, 67, 69, 71, 73, 74, 76, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V11 = [20, 21, 23], $V21 = [20, 21, 23, 52, 66, 67, 81, 82, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V31 = [1, 12, 20, 21, 22, 23, 24, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $V41 = [52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $V51 = [1, 149], $V61 = [1, 157], $V71 = [1, 158], $V81 = [1, 159], $V91 = [1, 160], $Va1 = [1, 144], $Vb1 = [1, 145], $Vc1 = [1, 141], $Vd1 = [1, 152], $Ve1 = [1, 153], $Vf1 = [1, 154], $Vg1 = [1, 155], $Vh1 = [1, 156], $Vi1 = [1, 161], $Vj1 = [1, 162], $Vk1 = [1, 147], $Vl1 = [1, 150], $Vm1 = [1, 146], $Vn1 = [1, 143], $Vo1 = [20, 21, 22, 23, 38, 42, 44, 46, 48, 52, 66, 67, 86, 87, 88, 89, 90, 91, 95, 105, 106, 109, 111, 112, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127], $Vp1 = [1, 165], $Vq1 = [20, 21, 22, 23, 26, 52, 66, 67, 91, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], $Vr1 = [20, 21, 22, 23, 24, 26, 38, 40, 41, 42, 52, 56, 58, 60, 62, 64, 66, 67, 68, 70, 72, 73, 75, 77, 81, 82, 86, 87, 88, 89, 90, 91, 92, 95, 105, 106, 109, 111, 112, 113, 114, 122, 123, 124, 125, 126, 127], $Vs1 = [12, 21, 22, 24], $Vt1 = [22, 106], $Vu1 = [1, 250], $Vv1 = [1, 245], $Vw1 = [1, 246], $Vx1 = [1, 254], $Vy1 = [1, 251], $Vz1 = [1, 248], $VA1 = [1, 247], $VB1 = [1, 249], $VC1 = [1, 252], $VD1 = [1, 253], $VE1 = [1, 255], $VF1 = [1, 273], $VG1 = [20, 21, 23, 106], $VH1 = [20, 21, 22, 23, 66, 67, 86, 102, 105, 106, 109, 110, 111, 112, 113];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "mermaidDoc": 4, "directive": 5, "openDirective": 6, "typeDirective": 7, "closeDirective": 8, "separator": 9, ":": 10, "argDirective": 11, "open_directive": 12, "type_directive": 13, "arg_directive": 14, "close_directive": 15, "graphConfig": 16, "document": 17, "line": 18, "statement": 19, "SEMI": 20, "NEWLINE": 21, "SPACE": 22, "EOF": 23, "GRAPH": 24, "NODIR": 25, "DIR": 26, "FirstStmtSeperator": 27, "ending": 28, "endToken": 29, "spaceList": 30, "spaceListNewline": 31, "verticeStatement": 32, "styleStatement": 33, "linkStyleStatement": 34, "classDefStatement": 35, "classStatement": 36, "clickStatement": 37, "subgraph": 38, "text": 39, "SQS": 40, "SQE": 41, "end": 42, "direction": 43, "acc_title": 44, "acc_title_value": 45, "acc_descr": 46, "acc_descr_value": 47, "acc_descr_multiline_value": 48, "link": 49, "node": 50, "vertex": 51, "AMP": 52, "STYLE_SEPARATOR": 53, "idString": 54, "DOUBLECIRCLESTART": 55, "DOUBLECIRCLEEND": 56, "PS": 57, "PE": 58, "(-": 59, "-)": 60, "STADIUMSTART": 61, "STADIUMEND": 62, "SUBROUTINESTART": 63, "SUBROUTINEEND": 64, "VERTEX_WITH_PROPS_START": 65, "ALPHA": 66, "COLON": 67, "PIPE": 68, "CYLINDERSTART": 69, "CYLINDEREND": 70, "DIAMOND_START": 71, "DIAMOND_STOP": 72, "TAGEND": 73, "TRAPSTART": 74, "TRAPEND": 75, "INVTRAPSTART": 76, "INVTRAPEND": 77, "linkStatement": 78, "arrowText": 79, "TESTSTR": 80, "START_LINK": 81, "LINK": 82, "textToken": 83, "STR": 84, "keywords": 85, "STYLE": 86, "LINKSTYLE": 87, "CLASSDEF": 88, "CLASS": 89, "CLICK": 90, "DOWN": 91, "UP": 92, "textNoTags": 93, "textNoTagsToken": 94, "DEFAULT": 95, "stylesOpt": 96, "alphaNum": 97, "CALLBACKNAME": 98, "CALLBACKARGS": 99, "HREF": 100, "LINK_TARGET": 101, "HEX": 102, "numList": 103, "INTERPOLATE": 104, "NUM": 105, "COMMA": 106, "style": 107, "styleComponent": 108, "MINUS": 109, "UNIT": 110, "BRKT": 111, "DOT": 112, "PCT": 113, "TAGSTART": 114, "alphaNumToken": 115, "idStringToken": 116, "alphaNumStatement": 117, "direction_tb": 118, "direction_bt": 119, "direction_rl": 120, "direction_lr": 121, "PUNCTUATION": 122, "UNICODE_TEXT": 123, "PLUS": 124, "EQUALS": 125, "MULT": 126, "UNDERSCORE": 127, "graphCodeTokens": 128, "ARROW_CROSS": 129, "ARROW_POINT": 130, "ARROW_CIRCLE": 131, "ARROW_OPEN": 132, "QUOTE": 133, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 10: ":", 12: "open_directive", 13: "type_directive", 14: "arg_directive", 15: "close_directive", 20: "SEMI", 21: "NEWLINE", 22: "SPACE", 23: "EOF", 24: "GRAPH", 25: "NODIR", 26: "DIR", 38: "subgraph", 40: "SQS", 41: "SQE", 42: "end", 44: "acc_title", 45: "acc_title_value", 46: "acc_descr", 47: "acc_descr_value", 48: "acc_descr_multiline_value", 52: "AMP", 53: "STYLE_SEPARATOR", 55: "DOUBLECIRCLESTART", 56: "DOUBLECIRCLEEND", 57: "PS", 58: "PE", 59: "(-", 60: "-)", 61: "STADIUMSTART", 62: "STADIUMEND", 63: "SUBROUTINESTART", 64: "SUBROUTINEEND", 65: "VERTEX_WITH_PROPS_START", 66: "ALPHA", 67: "COLON", 68: "PIPE", 69: "CYLINDERSTART", 70: "CYLINDEREND", 71: "DIAMOND_START", 72: "DIAMOND_STOP", 73: "TAGEND", 74: "TRAPSTART", 75: "TRAPEND", 76: "INVTRAPSTART", 77: "INVTRAPEND", 80: "TESTSTR", 81: "START_LINK", 82: "LINK", 84: "STR", 86: "STYLE", 87: "LINKSTYLE", 88: "CLASSDEF", 89: "CLASS", 90: "CLICK", 91: "DOWN", 92: "UP", 95: "DEFAULT", 98: "CALLBACKNAME", 99: "CALLBACKARGS", 100: "HREF", 101: "LINK_TARGET", 102: "HEX", 104: "INTERPOLATE", 105: "NUM", 106: "COMMA", 109: "MINUS", 110: "UNIT", 111: "BRKT", 112: "DOT", 113: "PCT", 114: "TAGSTART", 118: "direction_tb", 119: "direction_bt", 120: "direction_rl", 121: "direction_lr", 122: "PUNCTUATION", 123: "UNICODE_TEXT", 124: "PLUS", 125: "EQUALS", 126: "MULT", 127: "UNDERSCORE", 129: "ARROW_CROSS", 130: "ARROW_POINT", 131: "ARROW_CIRCLE", 132: "ARROW_OPEN", 133: "QUOTE" },
    productions_: [0, [3, 1], [3, 2], [5, 4], [5, 6], [6, 1], [7, 1], [11, 1], [8, 1], [4, 2], [17, 0], [17, 2], [18, 1], [18, 1], [18, 1], [18, 1], [18, 1], [16, 2], [16, 2], [16, 2], [16, 3], [28, 2], [28, 1], [29, 1], [29, 1], [29, 1], [27, 1], [27, 1], [27, 2], [31, 2], [31, 2], [31, 1], [31, 1], [30, 2], [30, 1], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 2], [19, 9], [19, 6], [19, 4], [19, 1], [19, 2], [19, 2], [19, 1], [9, 1], [9, 1], [9, 1], [32, 3], [32, 4], [32, 2], [32, 1], [50, 1], [50, 5], [50, 3], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 8], [51, 4], [51, 4], [51, 4], [51, 6], [51, 4], [51, 4], [51, 4], [51, 4], [51, 4], [51, 1], [49, 2], [49, 3], [49, 3], [49, 1], [49, 3], [78, 1], [79, 3], [39, 1], [39, 2], [39, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [85, 1], [93, 1], [93, 2], [35, 5], [35, 5], [36, 5], [37, 2], [37, 4], [37, 3], [37, 5], [37, 2], [37, 4], [37, 4], [37, 6], [37, 2], [37, 4], [37, 2], [37, 4], [37, 4], [37, 6], [33, 5], [33, 5], [34, 5], [34, 5], [34, 9], [34, 9], [34, 7], [34, 7], [103, 1], [103, 3], [96, 1], [96, 3], [107, 1], [107, 2], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [108, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [83, 1], [94, 1], [94, 1], [94, 1], [94, 1], [54, 1], [54, 2], [97, 1], [97, 2], [117, 1], [117, 1], [117, 1], [117, 1], [43, 1], [43, 1], [43, 1], [43, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [115, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [116, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1], [128, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 5:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 6:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 7:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 8:
          yy.parseDirective("}%%", "close_directive", "flowchart");
          break;
        case 10:
          this.$ = [];
          break;
        case 11:
          if (!Array.isArray($$[$0]) || $$[$0].length > 0) {
            $$[$0 - 1].push($$[$0]);
          }
          this.$ = $$[$0 - 1];
          break;
        case 12:
        case 82:
        case 84:
        case 96:
        case 152:
        case 154:
        case 155:
          this.$ = $$[$0];
          break;
        case 19:
          yy.setDirection("TB");
          this.$ = "TB";
          break;
        case 20:
          yy.setDirection($$[$0 - 1]);
          this.$ = $$[$0 - 1];
          break;
        case 35:
          this.$ = $$[$0 - 1].nodes;
          break;
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
          this.$ = [];
          break;
        case 41:
          this.$ = yy.addSubGraph($$[$0 - 6], $$[$0 - 1], $$[$0 - 4]);
          break;
        case 42:
          this.$ = yy.addSubGraph($$[$0 - 3], $$[$0 - 1], $$[$0 - 3]);
          break;
        case 43:
          this.$ = yy.addSubGraph(void 0, $$[$0 - 1], void 0);
          break;
        case 45:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 46:
        case 47:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 51:
          yy.addLink($$[$0 - 2].stmt, $$[$0], $$[$0 - 1]);
          this.$ = { stmt: $$[$0], nodes: $$[$0].concat($$[$0 - 2].nodes) };
          break;
        case 52:
          yy.addLink($$[$0 - 3].stmt, $$[$0 - 1], $$[$0 - 2]);
          this.$ = { stmt: $$[$0 - 1], nodes: $$[$0 - 1].concat($$[$0 - 3].nodes) };
          break;
        case 53:
          this.$ = { stmt: $$[$0 - 1], nodes: $$[$0 - 1] };
          break;
        case 54:
          this.$ = { stmt: $$[$0], nodes: $$[$0] };
          break;
        case 55:
          this.$ = [$$[$0]];
          break;
        case 56:
          this.$ = $$[$0 - 4].concat($$[$0]);
          break;
        case 57:
          this.$ = [$$[$0 - 2]];
          yy.setClass($$[$0 - 2], $$[$0]);
          break;
        case 58:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "square");
          break;
        case 59:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "doublecircle");
          break;
        case 60:
          this.$ = $$[$0 - 5];
          yy.addVertex($$[$0 - 5], $$[$0 - 2], "circle");
          break;
        case 61:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "ellipse");
          break;
        case 62:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "stadium");
          break;
        case 63:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "subroutine");
          break;
        case 64:
          this.$ = $$[$0 - 7];
          yy.addVertex($$[$0 - 7], $$[$0 - 1], "rect", void 0, void 0, void 0, Object.fromEntries([[$$[$0 - 5], $$[$0 - 3]]]));
          break;
        case 65:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "cylinder");
          break;
        case 66:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "round");
          break;
        case 67:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "diamond");
          break;
        case 68:
          this.$ = $$[$0 - 5];
          yy.addVertex($$[$0 - 5], $$[$0 - 2], "hexagon");
          break;
        case 69:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "odd");
          break;
        case 70:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "trapezoid");
          break;
        case 71:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "inv_trapezoid");
          break;
        case 72:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "lean_right");
          break;
        case 73:
          this.$ = $$[$0 - 3];
          yy.addVertex($$[$0 - 3], $$[$0 - 1], "lean_left");
          break;
        case 74:
          this.$ = $$[$0];
          yy.addVertex($$[$0]);
          break;
        case 75:
          $$[$0 - 1].text = $$[$0];
          this.$ = $$[$0 - 1];
          break;
        case 76:
        case 77:
          $$[$0 - 2].text = $$[$0 - 1];
          this.$ = $$[$0 - 2];
          break;
        case 78:
          this.$ = $$[$0];
          break;
        case 79:
          var inf = yy.destructLink($$[$0], $$[$0 - 2]);
          this.$ = { "type": inf.type, "stroke": inf.stroke, "length": inf.length, "text": $$[$0 - 1] };
          break;
        case 80:
          var inf = yy.destructLink($$[$0]);
          this.$ = { "type": inf.type, "stroke": inf.stroke, "length": inf.length };
          break;
        case 81:
          this.$ = $$[$0 - 1];
          break;
        case 83:
        case 97:
        case 153:
          this.$ = $$[$0 - 1] + "" + $$[$0];
          break;
        case 98:
        case 99:
          this.$ = $$[$0 - 4];
          yy.addClass($$[$0 - 2], $$[$0]);
          break;
        case 100:
          this.$ = $$[$0 - 4];
          yy.setClass($$[$0 - 2], $$[$0]);
          break;
        case 101:
        case 109:
          this.$ = $$[$0 - 1];
          yy.setClickEvent($$[$0 - 1], $$[$0]);
          break;
        case 102:
        case 110:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 2]);
          yy.setTooltip($$[$0 - 3], $$[$0]);
          break;
        case 103:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 104:
          this.$ = $$[$0 - 4];
          yy.setClickEvent($$[$0 - 4], $$[$0 - 3], $$[$0 - 2]);
          yy.setTooltip($$[$0 - 4], $$[$0]);
          break;
        case 105:
        case 111:
          this.$ = $$[$0 - 1];
          yy.setLink($$[$0 - 1], $$[$0]);
          break;
        case 106:
        case 112:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 3], $$[$0 - 2]);
          yy.setTooltip($$[$0 - 3], $$[$0]);
          break;
        case 107:
        case 113:
          this.$ = $$[$0 - 3];
          yy.setLink($$[$0 - 3], $$[$0 - 2], $$[$0]);
          break;
        case 108:
        case 114:
          this.$ = $$[$0 - 5];
          yy.setLink($$[$0 - 5], $$[$0 - 4], $$[$0]);
          yy.setTooltip($$[$0 - 5], $$[$0 - 2]);
          break;
        case 115:
          this.$ = $$[$0 - 4];
          yy.addVertex($$[$0 - 2], void 0, void 0, $$[$0]);
          break;
        case 116:
        case 118:
          this.$ = $$[$0 - 4];
          yy.updateLink($$[$0 - 2], $$[$0]);
          break;
        case 117:
          this.$ = $$[$0 - 4];
          yy.updateLink([$$[$0 - 2]], $$[$0]);
          break;
        case 119:
          this.$ = $$[$0 - 8];
          yy.updateLinkInterpolate([$$[$0 - 6]], $$[$0 - 2]);
          yy.updateLink([$$[$0 - 6]], $$[$0]);
          break;
        case 120:
          this.$ = $$[$0 - 8];
          yy.updateLinkInterpolate($$[$0 - 6], $$[$0 - 2]);
          yy.updateLink($$[$0 - 6], $$[$0]);
          break;
        case 121:
          this.$ = $$[$0 - 6];
          yy.updateLinkInterpolate([$$[$0 - 4]], $$[$0]);
          break;
        case 122:
          this.$ = $$[$0 - 6];
          yy.updateLinkInterpolate($$[$0 - 4], $$[$0]);
          break;
        case 123:
        case 125:
          this.$ = [$$[$0]];
          break;
        case 124:
        case 126:
          $$[$0 - 2].push($$[$0]);
          this.$ = $$[$0 - 2];
          break;
        case 128:
          this.$ = $$[$0 - 1] + $$[$0];
          break;
        case 150:
          this.$ = $$[$0];
          break;
        case 151:
          this.$ = $$[$0 - 1] + "" + $$[$0];
          break;
        case 156:
          this.$ = "v";
          break;
        case 157:
          this.$ = "-";
          break;
        case 158:
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 159:
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 160:
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 161:
          this.$ = { stmt: "dir", value: "LR" };
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: 5, 12: $V0, 16: 4, 21: $V1, 22: $V2, 24: $V3 }, { 1: [3] }, { 1: [2, 1] }, { 3: 10, 4: 2, 5: 3, 6: 5, 12: $V0, 16: 4, 21: $V1, 22: $V2, 24: $V3 }, o($V4, $V5, { 17: 11 }), { 7: 12, 13: [1, 13] }, { 16: 14, 21: $V1, 22: $V2, 24: $V3 }, { 16: 15, 21: $V1, 22: $V2, 24: $V3 }, { 25: [1, 16], 26: [1, 17] }, { 13: [2, 5] }, { 1: [2, 2] }, { 1: [2, 9], 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 8: 64, 10: [1, 65], 15: $VD }, o([10, 15], [2, 6]), o($V4, [2, 17]), o($V4, [2, 18]), o($V4, [2, 19]), { 20: [1, 68], 21: [1, 69], 22: $VE, 27: 67, 30: 70 }, o($VF, [2, 11]), o($VF, [2, 12]), o($VF, [2, 13]), o($VF, [2, 14]), o($VF, [2, 15]), o($VF, [2, 16]), { 9: 72, 20: $VG, 21: $VH, 23: $VI, 49: 73, 78: 77, 81: [1, 78], 82: [1, 79] }, { 9: 80, 20: $VG, 21: $VH, 23: $VI }, { 9: 81, 20: $VG, 21: $VH, 23: $VI }, { 9: 82, 20: $VG, 21: $VH, 23: $VI }, { 9: 83, 20: $VG, 21: $VH, 23: $VI }, { 9: 84, 20: $VG, 21: $VH, 23: $VI }, { 9: 86, 20: $VG, 21: $VH, 22: [1, 85], 23: $VI }, o($VF, [2, 44]), { 45: [1, 87] }, { 47: [1, 88] }, o($VF, [2, 47]), o($VJ, [2, 54], { 30: 89, 22: $VE }), { 22: [1, 90] }, { 22: [1, 91] }, { 22: [1, 92] }, { 22: [1, 93] }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 84: [1, 97], 91: $VO, 97: 96, 98: [1, 94], 100: [1, 95], 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($VF, [2, 158]), o($VF, [2, 159]), o($VF, [2, 160]), o($VF, [2, 161]), o($V_, [2, 55], { 53: [1, 116] }), o($V$, [2, 74], { 116: 129, 40: [1, 117], 52: $Ve, 55: [1, 118], 57: [1, 119], 59: [1, 120], 61: [1, 121], 63: [1, 122], 65: [1, 123], 66: $Vf, 67: $Vg, 69: [1, 124], 71: [1, 125], 73: [1, 126], 74: [1, 127], 76: [1, 128], 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }), o($V01, [2, 150]), o($V01, [2, 175]), o($V01, [2, 176]), o($V01, [2, 177]), o($V01, [2, 178]), o($V01, [2, 179]), o($V01, [2, 180]), o($V01, [2, 181]), o($V01, [2, 182]), o($V01, [2, 183]), o($V01, [2, 184]), o($V01, [2, 185]), o($V01, [2, 186]), o($V01, [2, 187]), o($V01, [2, 188]), o($V01, [2, 189]), o($V01, [2, 190]), { 9: 130, 20: $VG, 21: $VH, 23: $VI }, { 11: 131, 14: [1, 132] }, o($V11, [2, 8]), o($V4, [2, 20]), o($V4, [2, 26]), o($V4, [2, 27]), { 21: [1, 133] }, o($V21, [2, 34], { 30: 134, 22: $VE }), o($VF, [2, 35]), { 50: 135, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, o($V31, [2, 48]), o($V31, [2, 49]), o($V31, [2, 50]), o($V41, [2, 78], { 79: 136, 68: [1, 138], 80: [1, 137] }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 139, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o([52, 66, 67, 68, 80, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 80]), o($VF, [2, 36]), o($VF, [2, 37]), o($VF, [2, 38]), o($VF, [2, 39]), o($VF, [2, 40]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 163, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vo1, $V5, { 17: 164 }), o($VF, [2, 45]), o($VF, [2, 46]), o($VJ, [2, 53], { 52: $Vp1 }), { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 166, 102: [1, 167], 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 95: [1, 168], 103: 169, 105: [1, 170] }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 95: [1, 171], 97: 172, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 173, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 101], { 22: [1, 174], 99: [1, 175] }), o($V11, [2, 105], { 22: [1, 176] }), o($V11, [2, 109], { 115: 100, 117: 178, 22: [1, 177], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 111], { 22: [1, 179] }), o($Vq1, [2, 152]), o($Vq1, [2, 154]), o($Vq1, [2, 155]), o($Vq1, [2, 156]), o($Vq1, [2, 157]), o($Vr1, [2, 162]), o($Vr1, [2, 163]), o($Vr1, [2, 164]), o($Vr1, [2, 165]), o($Vr1, [2, 166]), o($Vr1, [2, 167]), o($Vr1, [2, 168]), o($Vr1, [2, 169]), o($Vr1, [2, 170]), o($Vr1, [2, 171]), o($Vr1, [2, 172]), o($Vr1, [2, 173]), o($Vr1, [2, 174]), { 52: $Ve, 54: 180, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 181, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 182, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 184, 42: $V91, 52: $VL, 57: [1, 183], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 185, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 186, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 187, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 66: [1, 188] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 189, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 190, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 71: [1, 191], 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 192, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 193, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 194, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V01, [2, 151]), o($Vs1, [2, 3]), { 8: 195, 15: $VD }, { 15: [2, 7] }, o($V4, [2, 28]), o($V21, [2, 33]), o($VJ, [2, 51], { 30: 196, 22: $VE }), o($V41, [2, 75], { 22: [1, 197] }), { 22: [1, 198] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 199, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 82: [1, 200], 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vr1, [2, 82]), o($Vr1, [2, 84]), o($Vr1, [2, 140]), o($Vr1, [2, 141]), o($Vr1, [2, 142]), o($Vr1, [2, 143]), o($Vr1, [2, 144]), o($Vr1, [2, 145]), o($Vr1, [2, 146]), o($Vr1, [2, 147]), o($Vr1, [2, 148]), o($Vr1, [2, 149]), o($Vr1, [2, 85]), o($Vr1, [2, 86]), o($Vr1, [2, 87]), o($Vr1, [2, 88]), o($Vr1, [2, 89]), o($Vr1, [2, 90]), o($Vr1, [2, 91]), o($Vr1, [2, 92]), o($Vr1, [2, 93]), o($Vr1, [2, 94]), o($Vr1, [2, 95]), { 9: 203, 20: $VG, 21: $VH, 22: $V51, 23: $VI, 24: $V61, 26: $V71, 38: $V81, 40: [1, 202], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 204], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $VE, 30: 205 }, { 22: [1, 206], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: [1, 207] }, { 22: [1, 208] }, { 22: [1, 209], 106: [1, 210] }, o($Vt1, [2, 123]), { 22: [1, 211] }, { 22: [1, 212], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: [1, 213], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 178, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 84: [1, 214] }, o($V11, [2, 103], { 22: [1, 215] }), { 84: [1, 216], 101: [1, 217] }, { 84: [1, 218] }, o($Vq1, [2, 153]), { 84: [1, 219], 101: [1, 220] }, o($V_, [2, 57], { 116: 129, 52: $Ve, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 221], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 56: [1, 222], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 223, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 58: [1, 224], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 60: [1, 225], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 62: [1, 226], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 64: [1, 227], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 67: [1, 228] }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 70: [1, 229], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 72: [1, 230], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 231, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 232], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 75: [1, 233], 77: [1, 234], 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 75: [1, 236], 77: [1, 235], 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 9: 237, 20: $VG, 21: $VH, 23: $VI }, o($VJ, [2, 52], { 52: $Vp1 }), o($V41, [2, 77]), o($V41, [2, 76]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 68: [1, 238], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V41, [2, 79]), o($Vr1, [2, 83]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 239, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($Vo1, $V5, { 17: 240 }), o($VF, [2, 43]), { 51: 241, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 242, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 256, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 257, 102: $Vy1, 104: [1, 258], 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 259, 102: $Vy1, 104: [1, 260], 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 105: [1, 261] }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 262, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 263, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 264, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 102]), { 84: [1, 265] }, o($V11, [2, 106], { 22: [1, 266] }), o($V11, [2, 107]), o($V11, [2, 110]), o($V11, [2, 112], { 22: [1, 267] }), o($V11, [2, 113]), o($V$, [2, 58]), o($V$, [2, 59]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 58: [1, 268], 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 66]), o($V$, [2, 61]), o($V$, [2, 62]), o($V$, [2, 63]), { 66: [1, 269] }, o($V$, [2, 65]), o($V$, [2, 67]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 72: [1, 270], 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 69]), o($V$, [2, 70]), o($V$, [2, 72]), o($V$, [2, 71]), o($V$, [2, 73]), o($Vs1, [2, 4]), o([22, 52, 66, 67, 91, 95, 105, 106, 109, 111, 112, 122, 123, 124, 125, 126, 127], [2, 81]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 271], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 272], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, o($V_, [2, 56]), o($V11, [2, 115], { 106: $VF1 }), o($VG1, [2, 125], { 108: 274, 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }), o($VH1, [2, 127]), o($VH1, [2, 129]), o($VH1, [2, 130]), o($VH1, [2, 131]), o($VH1, [2, 132]), o($VH1, [2, 133]), o($VH1, [2, 134]), o($VH1, [2, 135]), o($VH1, [2, 136]), o($VH1, [2, 137]), o($VH1, [2, 138]), o($VH1, [2, 139]), o($V11, [2, 116], { 106: $VF1 }), o($V11, [2, 117], { 106: $VF1 }), { 22: [1, 275] }, o($V11, [2, 118], { 106: $VF1 }), { 22: [1, 276] }, o($Vt1, [2, 124]), o($V11, [2, 98], { 106: $VF1 }), o($V11, [2, 99], { 106: $VF1 }), o($V11, [2, 100], { 115: 100, 117: 178, 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 104]), { 101: [1, 277] }, { 101: [1, 278] }, { 58: [1, 279] }, { 68: [1, 280] }, { 72: [1, 281] }, { 9: 282, 20: $VG, 21: $VH, 23: $VI }, o($VF, [2, 42]), { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 107: 283, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, o($VH1, [2, 128]), { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 284, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 97: 285, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 115: 100, 117: 98, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V11, [2, 108]), o($V11, [2, 114]), o($V$, [2, 60]), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 39: 286, 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 140, 84: $Vc1, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, o($V$, [2, 68]), o($Vo1, $V5, { 17: 287 }), o($VG1, [2, 126], { 108: 274, 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 102: $Vy1, 105: $Vz1, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }), o($V11, [2, 121], { 115: 100, 117: 178, 22: [1, 288], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), o($V11, [2, 122], { 115: 100, 117: 178, 22: [1, 289], 26: $VK, 52: $VL, 66: $VM, 67: $VN, 91: $VO, 105: $VP, 106: $VQ, 109: $VR, 111: $VS, 112: $VT, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }), { 22: $V51, 24: $V61, 26: $V71, 38: $V81, 41: [1, 290], 42: $V91, 52: $VL, 66: $VM, 67: $VN, 73: $Va1, 81: $Vb1, 83: 201, 85: 151, 86: $Vd1, 87: $Ve1, 88: $Vf1, 89: $Vg1, 90: $Vh1, 91: $Vi1, 92: $Vj1, 94: 142, 95: $Vk1, 105: $VP, 106: $VQ, 109: $Vl1, 111: $VS, 112: $VT, 113: $Vm1, 114: $Vn1, 115: 148, 122: $VU, 123: $VV, 124: $VW, 125: $VX, 126: $VY, 127: $VZ }, { 18: 18, 19: 19, 20: $V6, 21: $V7, 22: $V8, 23: $V9, 32: 24, 33: 25, 34: 26, 35: 27, 36: 28, 37: 29, 38: $Va, 42: [1, 291], 43: 31, 44: $Vb, 46: $Vc, 48: $Vd, 50: 35, 51: 45, 52: $Ve, 54: 46, 66: $Vf, 67: $Vg, 86: $Vh, 87: $Vi, 88: $Vj, 89: $Vk, 90: $Vl, 91: $Vm, 95: $Vn, 105: $Vo, 106: $Vp, 109: $Vq, 111: $Vr, 112: $Vs, 116: 47, 118: $Vt, 119: $Vu, 120: $Vv, 121: $Vw, 122: $Vx, 123: $Vy, 124: $Vz, 125: $VA, 126: $VB, 127: $VC }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 292, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, { 22: $Vu1, 66: $Vv1, 67: $Vw1, 86: $Vx1, 96: 293, 102: $Vy1, 105: $Vz1, 107: 243, 108: 244, 109: $VA1, 110: $VB1, 111: $VC1, 112: $VD1, 113: $VE1 }, o($V$, [2, 64]), o($VF, [2, 41]), o($V11, [2, 119], { 106: $VF1 }), o($V11, [2, 120], { 106: $VF1 })],
    defaultActions: { 2: [2, 1], 9: [2, 5], 10: [2, 2], 132: [2, 7] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: {},
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 12;
          case 1:
            this.begin("type_directive");
            return 13;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 10;
          case 3:
            this.popState();
            this.popState();
            return 15;
          case 4:
            return 14;
          case 5:
            break;
          case 6:
            break;
          case 7:
            this.begin("acc_title");
            return 44;
          case 8:
            this.popState();
            return "acc_title_value";
          case 9:
            this.begin("acc_descr");
            return 46;
          case 10:
            this.popState();
            return "acc_descr_value";
          case 11:
            this.begin("acc_descr_multiline");
            break;
          case 12:
            this.popState();
            break;
          case 13:
            return "acc_descr_multiline_value";
          case 14:
            this.begin("string");
            break;
          case 15:
            this.popState();
            break;
          case 16:
            return "STR";
          case 17:
            return 86;
          case 18:
            return 95;
          case 19:
            return 87;
          case 20:
            return 104;
          case 21:
            return 88;
          case 22:
            return 89;
          case 23:
            this.begin("href");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return 100;
          case 26:
            this.begin("callbackname");
            break;
          case 27:
            this.popState();
            break;
          case 28:
            this.popState();
            this.begin("callbackargs");
            break;
          case 29:
            return 98;
          case 30:
            this.popState();
            break;
          case 31:
            return 99;
          case 32:
            this.begin("click");
            break;
          case 33:
            this.popState();
            break;
          case 34:
            return 90;
          case 35:
            if (yy.lex.firstGraph()) {
              this.begin("dir");
            }
            return 24;
          case 36:
            if (yy.lex.firstGraph()) {
              this.begin("dir");
            }
            return 24;
          case 37:
            return 38;
          case 38:
            return 42;
          case 39:
            return 101;
          case 40:
            return 101;
          case 41:
            return 101;
          case 42:
            return 101;
          case 43:
            this.popState();
            return 25;
          case 44:
            this.popState();
            return 26;
          case 45:
            this.popState();
            return 26;
          case 46:
            this.popState();
            return 26;
          case 47:
            this.popState();
            return 26;
          case 48:
            this.popState();
            return 26;
          case 49:
            this.popState();
            return 26;
          case 50:
            this.popState();
            return 26;
          case 51:
            this.popState();
            return 26;
          case 52:
            this.popState();
            return 26;
          case 53:
            this.popState();
            return 26;
          case 54:
            return 118;
          case 55:
            return 119;
          case 56:
            return 120;
          case 57:
            return 121;
          case 58:
            return 105;
          case 59:
            return 111;
          case 60:
            return 53;
          case 61:
            return 67;
          case 62:
            return 52;
          case 63:
            return 20;
          case 64:
            return 106;
          case 65:
            return 126;
          case 66:
            return 82;
          case 67:
            return 82;
          case 68:
            return 82;
          case 69:
            return 82;
          case 70:
            return 81;
          case 71:
            return 81;
          case 72:
            return 81;
          case 73:
            return 59;
          case 74:
            return 60;
          case 75:
            return 61;
          case 76:
            return 62;
          case 77:
            return 63;
          case 78:
            return 64;
          case 79:
            return 65;
          case 80:
            return 69;
          case 81:
            return 70;
          case 82:
            return 55;
          case 83:
            return 56;
          case 84:
            return 109;
          case 85:
            return 112;
          case 86:
            return 127;
          case 87:
            return 124;
          case 88:
            return 113;
          case 89:
            return 125;
          case 90:
            return 125;
          case 91:
            return 114;
          case 92:
            return 73;
          case 93:
            return 92;
          case 94:
            return "SEP";
          case 95:
            return 91;
          case 96:
            return 66;
          case 97:
            return 75;
          case 98:
            return 74;
          case 99:
            return 77;
          case 100:
            return 76;
          case 101:
            return 122;
          case 102:
            return 123;
          case 103:
            return 68;
          case 104:
            return 57;
          case 105:
            return 58;
          case 106:
            return 40;
          case 107:
            return 41;
          case 108:
            return 71;
          case 109:
            return 72;
          case 110:
            return 133;
          case 111:
            return 21;
          case 112:
            return 22;
          case 113:
            return 23;
        }
      },
      rules: [/^(?:%%\{)/, /^(?:((?:(?!\}%%)[^:.])*))/, /^(?::)/, /^(?:\}%%)/, /^(?:((?:(?!\}%%).|\n)*))/, /^(?:%%(?!\{)[^\n]*)/, /^(?:[^\}]%%[^\n]*)/, /^(?:accTitle\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*:\s*)/, /^(?:(?!\n||)*[^\n]*)/, /^(?:accDescr\s*\{\s*)/, /^(?:[\}])/, /^(?:[^\}]*)/, /^(?:["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:style\b)/, /^(?:default\b)/, /^(?:linkStyle\b)/, /^(?:interpolate\b)/, /^(?:classDef\b)/, /^(?:class\b)/, /^(?:href[\s]+["])/, /^(?:["])/, /^(?:[^"]*)/, /^(?:call[\s]+)/, /^(?:\([\s]*\))/, /^(?:\()/, /^(?:[^(]*)/, /^(?:\))/, /^(?:[^)]*)/, /^(?:click[\s]+)/, /^(?:[\s\n])/, /^(?:[^\s\n]*)/, /^(?:graph\b)/, /^(?:flowchart\b)/, /^(?:subgraph\b)/, /^(?:end\b\s*)/, /^(?:_self\b)/, /^(?:_blank\b)/, /^(?:_parent\b)/, /^(?:_top\b)/, /^(?:(\r?\n)*\s*\n)/, /^(?:\s*LR\b)/, /^(?:\s*RL\b)/, /^(?:\s*TB\b)/, /^(?:\s*BT\b)/, /^(?:\s*TD\b)/, /^(?:\s*BR\b)/, /^(?:\s*<)/, /^(?:\s*>)/, /^(?:\s*\^)/, /^(?:\s*v\b)/, /^(?:.*direction\s+TB[^\n]*)/, /^(?:.*direction\s+BT[^\n]*)/, /^(?:.*direction\s+RL[^\n]*)/, /^(?:.*direction\s+LR[^\n]*)/, /^(?:[0-9]+)/, /^(?:#)/, /^(?::::)/, /^(?::)/, /^(?:&)/, /^(?:;)/, /^(?:,)/, /^(?:\*)/, /^(?:\s*[xo<]?--+[-xo>]\s*)/, /^(?:\s*[xo<]?==+[=xo>]\s*)/, /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/, /^(?:\s*~~[\~]+\s*)/, /^(?:\s*[xo<]?--\s*)/, /^(?:\s*[xo<]?==\s*)/, /^(?:\s*[xo<]?-\.\s*)/, /^(?:\(-)/, /^(?:-\))/, /^(?:\(\[)/, /^(?:\]\))/, /^(?:\[\[)/, /^(?:\]\])/, /^(?:\[\|)/, /^(?:\[\()/, /^(?:\)\])/, /^(?:\(\(\()/, /^(?:\)\)\))/, /^(?:-)/, /^(?:\.)/, /^(?:[\_])/, /^(?:\+)/, /^(?:%)/, /^(?:=)/, /^(?:=)/, /^(?:<)/, /^(?:>)/, /^(?:\^)/, /^(?:\\\|)/, /^(?:v\b)/, /^(?:[A-Za-z]+)/, /^(?:\\\])/, /^(?:\[\/)/, /^(?:\/\])/, /^(?:\[\\)/, /^(?:[!"#$%&'*+,-.`?\\_/])/, /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/, /^(?:\|)/, /^(?:\()/, /^(?:\))/, /^(?:\[)/, /^(?:\])/, /^(?:\{)/, /^(?:\})/, /^(?:")/, /^(?:(\r?\n)+)/, /^(?:\s)/, /^(?:$)/],
      conditions: { "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "callbackargs": { "rules": [30, 31], "inclusive": false }, "callbackname": { "rules": [27, 28, 29], "inclusive": false }, "href": { "rules": [24, 25], "inclusive": false }, "click": { "rules": [33, 34], "inclusive": false }, "vertex": { "rules": [], "inclusive": false }, "dir": { "rules": [43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53], "inclusive": false }, "acc_descr_multiline": { "rules": [12, 13], "inclusive": false }, "acc_descr": { "rules": [10], "inclusive": false }, "acc_title": { "rules": [8], "inclusive": false }, "string": { "rules": [15, 16], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 9, 11, 14, 17, 18, 19, 20, 21, 22, 23, 26, 32, 35, 36, 37, 38, 39, 40, 41, 42, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$7.parser = parser$7;
const flowDetector = (txt, config2) => {
  var _a;
  if (((_a = config2 == null ? void 0 : config2.flowchart) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
    return false;
  return txt.match(/^\s*graph/) !== null;
};
const flowDetectorV2 = (txt, config2) => {
  var _a;
  if (((_a = config2 == null ? void 0 : config2.flowchart) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper" && txt.match(/^\s*graph/) !== null)
    return true;
  return txt.match(/^\s*flowchart/) !== null;
};
const MERMAID_DOM_ID_PREFIX = "flowchart-";
let vertexCounter = 0;
let config = getConfig$1();
let vertices = {};
let edges = [];
let classes$1 = [];
let subGraphs = [];
let subGraphLookup = {};
let tooltips = {};
let subCount = 0;
let firstGraphFlag = true;
let direction$1;
let version;
let funs$1 = [];
const sanitizeText = (txt) => common.sanitizeText(txt, config);
const parseDirective$7 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const lookUpDomId = function(id2) {
  const veritceKeys = Object.keys(vertices);
  for (let i = 0; i < veritceKeys.length; i++) {
    if (vertices[veritceKeys[i]].id === id2) {
      return vertices[veritceKeys[i]].domId;
    }
  }
  return id2;
};
const addVertex = function(_id, text2, type2, style, classes2, dir, props = {}) {
  let txt;
  let id2 = _id;
  if (typeof id2 === "undefined") {
    return;
  }
  if (id2.trim().length === 0) {
    return;
  }
  if (typeof vertices[id2] === "undefined") {
    vertices[id2] = {
      id: id2,
      domId: MERMAID_DOM_ID_PREFIX + id2 + "-" + vertexCounter,
      styles: [],
      classes: []
    };
  }
  vertexCounter++;
  if (typeof text2 !== "undefined") {
    config = getConfig$1();
    txt = sanitizeText(text2.trim());
    if (txt[0] === '"' && txt[txt.length - 1] === '"') {
      txt = txt.substring(1, txt.length - 1);
    }
    vertices[id2].text = txt;
  } else {
    if (typeof vertices[id2].text === "undefined") {
      vertices[id2].text = _id;
    }
  }
  if (typeof type2 !== "undefined") {
    vertices[id2].type = type2;
  }
  if (typeof style !== "undefined") {
    if (style !== null) {
      style.forEach(function(s2) {
        vertices[id2].styles.push(s2);
      });
    }
  }
  if (typeof classes2 !== "undefined") {
    if (classes2 !== null) {
      classes2.forEach(function(s2) {
        vertices[id2].classes.push(s2);
      });
    }
  }
  if (typeof dir !== "undefined") {
    vertices[id2].dir = dir;
  }
  vertices[id2].props = props;
};
const addSingleLink = function(_start, _end, type2, linktext) {
  let start2 = _start;
  let end2 = _end;
  const edge = { start: start2, end: end2, type: void 0, text: "" };
  linktext = type2.text;
  if (typeof linktext !== "undefined") {
    edge.text = sanitizeText(linktext.trim());
    if (edge.text[0] === '"' && edge.text[edge.text.length - 1] === '"') {
      edge.text = edge.text.substring(1, edge.text.length - 1);
    }
  }
  if (typeof type2 !== "undefined") {
    edge.type = type2.type;
    edge.stroke = type2.stroke;
    edge.length = type2.length;
  }
  edges.push(edge);
};
const addLink = function(_start, _end, type2, linktext) {
  let i, j;
  for (i = 0; i < _start.length; i++) {
    for (j = 0; j < _end.length; j++) {
      addSingleLink(_start[i], _end[j], type2, linktext);
    }
  }
};
const updateLinkInterpolate = function(positions, interp) {
  positions.forEach(function(pos) {
    if (pos === "default") {
      edges.defaultInterpolate = interp;
    } else {
      edges[pos].interpolate = interp;
    }
  });
};
const updateLink = function(positions, style) {
  positions.forEach(function(pos) {
    if (pos === "default") {
      edges.defaultStyle = style;
    } else {
      if (utils.isSubstringInArray("fill", style) === -1) {
        style.push("fill:none");
      }
      edges[pos].style = style;
    }
  });
};
const addClass = function(id2, style) {
  if (typeof classes$1[id2] === "undefined") {
    classes$1[id2] = { id: id2, styles: [], textStyles: [] };
  }
  if (typeof style !== "undefined") {
    if (style !== null) {
      style.forEach(function(s2) {
        if (s2.match("color")) {
          const newStyle1 = s2.replace("fill", "bgFill");
          const newStyle2 = newStyle1.replace("color", "fill");
          classes$1[id2].textStyles.push(newStyle2);
        }
        classes$1[id2].styles.push(s2);
      });
    }
  }
};
const setDirection$1 = function(dir) {
  direction$1 = dir;
  if (direction$1.match(/.*</)) {
    direction$1 = "RL";
  }
  if (direction$1.match(/.*\^/)) {
    direction$1 = "BT";
  }
  if (direction$1.match(/.*>/)) {
    direction$1 = "LR";
  }
  if (direction$1.match(/.*v/)) {
    direction$1 = "TB";
  }
};
const setClass$1 = function(ids, className) {
  ids.split(",").forEach(function(_id) {
    let id2 = _id;
    if (typeof vertices[id2] !== "undefined") {
      vertices[id2].classes.push(className);
    }
    if (typeof subGraphLookup[id2] !== "undefined") {
      subGraphLookup[id2].classes.push(className);
    }
  });
};
const setTooltip = function(ids, tooltip) {
  ids.split(",").forEach(function(id2) {
    if (typeof tooltip !== "undefined") {
      tooltips[version === "gen-1" ? lookUpDomId(id2) : id2] = sanitizeText(tooltip);
    }
  });
};
const setClickFun$1 = function(id2, functionName, functionArgs) {
  let domId = lookUpDomId(id2);
  if (getConfig$1().securityLevel !== "loose") {
    return;
  }
  if (typeof functionName === "undefined") {
    return;
  }
  let argList = [];
  if (typeof functionArgs === "string") {
    argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let i = 0; i < argList.length; i++) {
      let item = argList[i].trim();
      if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
        item = item.substr(1, item.length - 2);
      }
      argList[i] = item;
    }
  }
  if (argList.length === 0) {
    argList.push(id2);
  }
  if (typeof vertices[id2] !== "undefined") {
    vertices[id2].haveCallback = true;
    funs$1.push(function() {
      const elem = document.querySelector(`[id="${domId}"]`);
      if (elem !== null) {
        elem.addEventListener(
          "click",
          function() {
            utils.runFunc(functionName, ...argList);
          },
          false
        );
      }
    });
  }
};
const setLink$1 = function(ids, linkStr, target) {
  ids.split(",").forEach(function(id2) {
    if (typeof vertices[id2] !== "undefined") {
      vertices[id2].link = utils.formatUrl(linkStr, config);
      vertices[id2].linkTarget = target;
    }
  });
  setClass$1(ids, "clickable");
};
const getTooltip = function(id2) {
  return tooltips[id2];
};
const setClickEvent$1 = function(ids, functionName, functionArgs) {
  ids.split(",").forEach(function(id2) {
    setClickFun$1(id2, functionName, functionArgs);
  });
  setClass$1(ids, "clickable");
};
const bindFunctions$1 = function(element) {
  funs$1.forEach(function(fun) {
    fun(element);
  });
};
const getDirection$1 = function() {
  return direction$1.trim();
};
const getVertices = function() {
  return vertices;
};
const getEdges = function() {
  return edges;
};
const getClasses$4 = function() {
  return classes$1;
};
const setupToolTips = function(element) {
  let tooltipElem = select$1(".mermaidTooltip");
  if ((tooltipElem._groups || tooltipElem)[0][0] === null) {
    tooltipElem = select$1("body").append("div").attr("class", "mermaidTooltip").style("opacity", 0);
  }
  const svg2 = select$1(element).select("svg");
  const nodes = svg2.selectAll("g.node");
  nodes.on("mouseover", function() {
    const el = select$1(this);
    const title2 = el.attr("title");
    if (title2 === null) {
      return;
    }
    const rect2 = this.getBoundingClientRect();
    tooltipElem.transition().duration(200).style("opacity", ".9");
    tooltipElem.text(el.attr("title")).style("left", window.scrollX + rect2.left + (rect2.right - rect2.left) / 2 + "px").style("top", window.scrollY + rect2.top - 14 + document.body.scrollTop + "px");
    tooltipElem.html(tooltipElem.html().replace(/&lt;br\/&gt;/g, "<br/>"));
    el.classed("hover", true);
  }).on("mouseout", function() {
    tooltipElem.transition().duration(500).style("opacity", 0);
    const el = select$1(this);
    el.classed("hover", false);
  });
};
funs$1.push(setupToolTips);
const clear$6 = function(ver = "gen-1") {
  vertices = {};
  classes$1 = {};
  edges = [];
  funs$1 = [setupToolTips];
  subGraphs = [];
  subGraphLookup = {};
  subCount = 0;
  tooltips = [];
  firstGraphFlag = true;
  version = ver;
  clear$g();
};
const setGen = (ver) => {
  version = ver || "gen-1";
};
const defaultStyle = function() {
  return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
};
const addSubGraph = function(_id, list2, _title) {
  let id2 = _id.trim();
  let title2 = _title.trim();
  if (id2 === title2 && title2.match(/\s/)) {
    id2 = void 0;
  }
  function uniq(a2) {
    const prims = { boolean: {}, number: {}, string: {} };
    const objs = [];
    let dir2;
    const nodeList2 = a2.filter(function(item) {
      const type2 = typeof item;
      if (item.stmt && item.stmt === "dir") {
        dir2 = item.value;
        return false;
      }
      if (item.trim() === "") {
        return false;
      }
      if (type2 in prims) {
        return prims[type2].hasOwnProperty(item) ? false : prims[type2][item] = true;
      } else {
        return objs.indexOf(item) >= 0 ? false : objs.push(item);
      }
    });
    return { nodeList: nodeList2, dir: dir2 };
  }
  let nodeList = [];
  const { nodeList: nl, dir } = uniq(nodeList.concat.apply(nodeList, list2));
  nodeList = nl;
  if (version === "gen-1") {
    for (let i = 0; i < nodeList.length; i++) {
      nodeList[i] = lookUpDomId(nodeList[i]);
    }
  }
  id2 = id2 || "subGraph" + subCount;
  title2 = title2 || "";
  title2 = sanitizeText(title2);
  subCount = subCount + 1;
  const subGraph = { id: id2, nodes: nodeList, title: title2.trim(), classes: [], dir };
  log$1.info("Adding", subGraph.id, subGraph.nodes, subGraph.dir);
  subGraph.nodes = makeUniq(subGraph, subGraphs).nodes;
  subGraphs.push(subGraph);
  subGraphLookup[id2] = subGraph;
  return id2;
};
const getPosForId = function(id2) {
  for (let i = 0; i < subGraphs.length; i++) {
    if (subGraphs[i].id === id2) {
      return i;
    }
  }
  return -1;
};
let secCount = -1;
const posCrossRef = [];
const indexNodes2 = function(id2, pos) {
  const nodes = subGraphs[pos].nodes;
  secCount = secCount + 1;
  if (secCount > 2e3) {
    return;
  }
  posCrossRef[secCount] = pos;
  if (subGraphs[pos].id === id2) {
    return {
      result: true,
      count: 0
    };
  }
  let count2 = 0;
  let posCount = 1;
  while (count2 < nodes.length) {
    const childPos = getPosForId(nodes[count2]);
    if (childPos >= 0) {
      const res = indexNodes2(id2, childPos);
      if (res.result) {
        return {
          result: true,
          count: posCount + res.count
        };
      } else {
        posCount = posCount + res.count;
      }
    }
    count2 = count2 + 1;
  }
  return {
    result: false,
    count: posCount
  };
};
const getDepthFirstPos = function(pos) {
  return posCrossRef[pos];
};
const indexNodes = function() {
  secCount = -1;
  if (subGraphs.length > 0) {
    indexNodes2("none", subGraphs.length - 1);
  }
};
const getSubGraphs = function() {
  return subGraphs;
};
const firstGraph = () => {
  if (firstGraphFlag) {
    firstGraphFlag = false;
    return true;
  }
  return false;
};
const destructStartLink = (_str) => {
  let str = _str.trim();
  let type2 = "arrow_open";
  switch (str[0]) {
    case "<":
      type2 = "arrow_point";
      str = str.slice(1);
      break;
    case "x":
      type2 = "arrow_cross";
      str = str.slice(1);
      break;
    case "o":
      type2 = "arrow_circle";
      str = str.slice(1);
      break;
  }
  let stroke = "normal";
  if (str.indexOf("=") !== -1) {
    stroke = "thick";
  }
  if (str.indexOf(".") !== -1) {
    stroke = "dotted";
  }
  return { type: type2, stroke };
};
const countChar = (char2, str) => {
  const length2 = str.length;
  let count2 = 0;
  for (let i = 0; i < length2; ++i) {
    if (str[i] === char2) {
      ++count2;
    }
  }
  return count2;
};
const destructEndLink = (_str) => {
  const str = _str.trim();
  let line2 = str.slice(0, -1);
  let type2 = "arrow_open";
  switch (str.slice(-1)) {
    case "x":
      type2 = "arrow_cross";
      if (str[0] === "x") {
        type2 = "double_" + type2;
        line2 = line2.slice(1);
      }
      break;
    case ">":
      type2 = "arrow_point";
      if (str[0] === "<") {
        type2 = "double_" + type2;
        line2 = line2.slice(1);
      }
      break;
    case "o":
      type2 = "arrow_circle";
      if (str[0] === "o") {
        type2 = "double_" + type2;
        line2 = line2.slice(1);
      }
      break;
  }
  let stroke = "normal";
  let length2 = line2.length - 1;
  if (line2[0] === "=") {
    stroke = "thick";
  }
  if (line2[0] === "~") {
    stroke = "invisible";
  }
  let dots = countChar(".", line2);
  if (dots) {
    stroke = "dotted";
    length2 = dots;
  }
  return { type: type2, stroke, length: length2 };
};
const destructLink = (_str, _startStr) => {
  const info2 = destructEndLink(_str);
  let startInfo;
  if (_startStr) {
    startInfo = destructStartLink(_startStr);
    if (startInfo.stroke !== info2.stroke) {
      return { type: "INVALID", stroke: "INVALID" };
    }
    if (startInfo.type === "arrow_open") {
      startInfo.type = info2.type;
    } else {
      if (startInfo.type !== info2.type)
        return { type: "INVALID", stroke: "INVALID" };
      startInfo.type = "double_" + startInfo.type;
    }
    if (startInfo.type === "double_arrow") {
      startInfo.type = "double_arrow_point";
    }
    startInfo.length = info2.length;
    return startInfo;
  }
  return info2;
};
const exists = (allSgs, _id) => {
  let res = false;
  allSgs.forEach((sg) => {
    const pos = sg.nodes.indexOf(_id);
    if (pos >= 0) {
      res = true;
    }
  });
  return res;
};
const makeUniq = (sg, allSubgraphs) => {
  const res = [];
  sg.nodes.forEach((_id, pos) => {
    if (!exists(allSubgraphs, _id)) {
      res.push(sg.nodes[pos]);
    }
  });
  return { nodes: res };
};
const flowDb = {
  parseDirective: parseDirective$7,
  defaultConfig: () => defaultConfig.flowchart,
  setAccTitle,
  getAccTitle,
  getAccDescription,
  setAccDescription,
  addVertex,
  lookUpDomId,
  addLink,
  updateLinkInterpolate,
  updateLink,
  addClass,
  setDirection: setDirection$1,
  setClass: setClass$1,
  setTooltip,
  getTooltip,
  setClickEvent: setClickEvent$1,
  setLink: setLink$1,
  bindFunctions: bindFunctions$1,
  getDirection: getDirection$1,
  getVertices,
  getEdges,
  getClasses: getClasses$4,
  clear: clear$6,
  setGen,
  defaultStyle,
  addSubGraph,
  getDepthFirstPos,
  indexNodes,
  getSubGraphs,
  destructLink,
  lex: {
    firstGraph
  },
  exists,
  makeUniq
};
function commonjsRequire(path2) {
  throw new Error('Could not dynamically require "' + path2 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var identity_1;
var hasRequiredIdentity;
function requireIdentity() {
  if (hasRequiredIdentity)
    return identity_1;
  hasRequiredIdentity = 1;
  function identity2(value) {
    return value;
  }
  identity_1 = identity2;
  return identity_1;
}
var _apply;
var hasRequired_apply;
function require_apply() {
  if (hasRequired_apply)
    return _apply;
  hasRequired_apply = 1;
  function apply2(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  _apply = apply2;
  return _apply;
}
var _overRest;
var hasRequired_overRest;
function require_overRest() {
  if (hasRequired_overRest)
    return _overRest;
  hasRequired_overRest = 1;
  var apply2 = require_apply();
  var nativeMax = Math.max;
  function overRest(func, start2, transform2) {
    start2 = nativeMax(start2 === void 0 ? func.length - 1 : start2, 0);
    return function() {
      var args = arguments, index2 = -1, length2 = nativeMax(args.length - start2, 0), array2 = Array(length2);
      while (++index2 < length2) {
        array2[index2] = args[start2 + index2];
      }
      index2 = -1;
      var otherArgs = Array(start2 + 1);
      while (++index2 < start2) {
        otherArgs[index2] = args[index2];
      }
      otherArgs[start2] = transform2(array2);
      return apply2(func, this, otherArgs);
    };
  }
  _overRest = overRest;
  return _overRest;
}
var constant_1;
var hasRequiredConstant;
function requireConstant() {
  if (hasRequiredConstant)
    return constant_1;
  hasRequiredConstant = 1;
  function constant2(value) {
    return function() {
      return value;
    };
  }
  constant_1 = constant2;
  return constant_1;
}
var _defineProperty;
var hasRequired_defineProperty;
function require_defineProperty() {
  if (hasRequired_defineProperty)
    return _defineProperty;
  hasRequired_defineProperty = 1;
  var getNative2 = require_getNative();
  var defineProperty = function() {
    try {
      var func = getNative2(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  _defineProperty = defineProperty;
  return _defineProperty;
}
var _baseSetToString;
var hasRequired_baseSetToString;
function require_baseSetToString() {
  if (hasRequired_baseSetToString)
    return _baseSetToString;
  hasRequired_baseSetToString = 1;
  var constant2 = requireConstant(), defineProperty = require_defineProperty(), identity2 = requireIdentity();
  var baseSetToString = !defineProperty ? identity2 : function(func, string) {
    return defineProperty(func, "toString", {
      "configurable": true,
      "enumerable": false,
      "value": constant2(string),
      "writable": true
    });
  };
  _baseSetToString = baseSetToString;
  return _baseSetToString;
}
var _shortOut;
var hasRequired_shortOut;
function require_shortOut() {
  if (hasRequired_shortOut)
    return _shortOut;
  hasRequired_shortOut = 1;
  var HOT_COUNT = 800, HOT_SPAN = 16;
  var nativeNow = Date.now;
  function shortOut(func) {
    var count2 = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count2 >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count2 = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  _shortOut = shortOut;
  return _shortOut;
}
var _setToString;
var hasRequired_setToString;
function require_setToString() {
  if (hasRequired_setToString)
    return _setToString;
  hasRequired_setToString = 1;
  var baseSetToString = require_baseSetToString(), shortOut = require_shortOut();
  var setToString = shortOut(baseSetToString);
  _setToString = setToString;
  return _setToString;
}
var _baseRest;
var hasRequired_baseRest;
function require_baseRest() {
  if (hasRequired_baseRest)
    return _baseRest;
  hasRequired_baseRest = 1;
  var identity2 = requireIdentity(), overRest = require_overRest(), setToString = require_setToString();
  function baseRest(func, start2) {
    return setToString(overRest(func, start2, identity2), func + "");
  }
  _baseRest = baseRest;
  return _baseRest;
}
var isLength_1;
var hasRequiredIsLength;
function requireIsLength() {
  if (hasRequiredIsLength)
    return isLength_1;
  hasRequiredIsLength = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  isLength_1 = isLength;
  return isLength_1;
}
var isArrayLike_1;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike)
    return isArrayLike_1;
  hasRequiredIsArrayLike = 1;
  var isFunction = requireIsFunction(), isLength = requireIsLength();
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  isArrayLike_1 = isArrayLike;
  return isArrayLike_1;
}
var _isIndex;
var hasRequired_isIndex;
function require_isIndex() {
  if (hasRequired_isIndex)
    return _isIndex;
  hasRequired_isIndex = 1;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  function isIndex(value, length2) {
    var type2 = typeof value;
    length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
    return !!length2 && (type2 == "number" || type2 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
  }
  _isIndex = isIndex;
  return _isIndex;
}
var _isIterateeCall;
var hasRequired_isIterateeCall;
function require_isIterateeCall() {
  if (hasRequired_isIterateeCall)
    return _isIterateeCall;
  hasRequired_isIterateeCall = 1;
  var eq2 = requireEq(), isArrayLike = requireIsArrayLike(), isIndex = require_isIndex(), isObject = requireIsObject();
  function isIterateeCall(value, index2, object2) {
    if (!isObject(object2)) {
      return false;
    }
    var type2 = typeof index2;
    if (type2 == "number" ? isArrayLike(object2) && isIndex(index2, object2.length) : type2 == "string" && index2 in object2) {
      return eq2(object2[index2], value);
    }
    return false;
  }
  _isIterateeCall = isIterateeCall;
  return _isIterateeCall;
}
var _baseTimes;
var hasRequired_baseTimes;
function require_baseTimes() {
  if (hasRequired_baseTimes)
    return _baseTimes;
  hasRequired_baseTimes = 1;
  function baseTimes(n, iteratee) {
    var index2 = -1, result = Array(n);
    while (++index2 < n) {
      result[index2] = iteratee(index2);
    }
    return result;
  }
  _baseTimes = baseTimes;
  return _baseTimes;
}
var isObjectLike_1;
var hasRequiredIsObjectLike;
function requireIsObjectLike() {
  if (hasRequiredIsObjectLike)
    return isObjectLike_1;
  hasRequiredIsObjectLike = 1;
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  isObjectLike_1 = isObjectLike;
  return isObjectLike_1;
}
var _baseIsArguments;
var hasRequired_baseIsArguments;
function require_baseIsArguments() {
  if (hasRequired_baseIsArguments)
    return _baseIsArguments;
  hasRequired_baseIsArguments = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]";
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  _baseIsArguments = baseIsArguments;
  return _baseIsArguments;
}
var isArguments_1;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments_1;
  hasRequiredIsArguments = 1;
  var baseIsArguments = require_baseIsArguments(), isObjectLike = requireIsObjectLike();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var propertyIsEnumerable = objectProto2.propertyIsEnumerable;
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  isArguments_1 = isArguments;
  return isArguments_1;
}
var isArray_1;
var hasRequiredIsArray;
function requireIsArray() {
  if (hasRequiredIsArray)
    return isArray_1;
  hasRequiredIsArray = 1;
  var isArray = Array.isArray;
  isArray_1 = isArray;
  return isArray_1;
}
var isBuffer = { exports: {} };
var stubFalse_1;
var hasRequiredStubFalse;
function requireStubFalse() {
  if (hasRequiredStubFalse)
    return stubFalse_1;
  hasRequiredStubFalse = 1;
  function stubFalse() {
    return false;
  }
  stubFalse_1 = stubFalse;
  return stubFalse_1;
}
var hasRequiredIsBuffer;
function requireIsBuffer() {
  if (hasRequiredIsBuffer)
    return isBuffer.exports;
  hasRequiredIsBuffer = 1;
  (function(module2, exports2) {
    var root2 = require_root(), stubFalse = requireStubFalse();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var Buffer2 = moduleExports ? root2.Buffer : void 0;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer || stubFalse;
    module2.exports = isBuffer2;
  })(isBuffer, isBuffer.exports);
  return isBuffer.exports;
}
var _baseIsTypedArray;
var hasRequired_baseIsTypedArray;
function require_baseIsTypedArray() {
  if (hasRequired_baseIsTypedArray)
    return _baseIsTypedArray;
  hasRequired_baseIsTypedArray = 1;
  var baseGetTag = require_baseGetTag(), isLength = requireIsLength(), isObjectLike = requireIsObjectLike();
  var argsTag = "[object Arguments]", arrayTag = "[object Array]", boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag = "[object Map]", numberTag = "[object Number]", objectTag = "[object Object]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  _baseIsTypedArray = baseIsTypedArray;
  return _baseIsTypedArray;
}
var _baseUnary;
var hasRequired_baseUnary;
function require_baseUnary() {
  if (hasRequired_baseUnary)
    return _baseUnary;
  hasRequired_baseUnary = 1;
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  _baseUnary = baseUnary;
  return _baseUnary;
}
var _nodeUtil = { exports: {} };
var hasRequired_nodeUtil;
function require_nodeUtil() {
  if (hasRequired_nodeUtil)
    return _nodeUtil.exports;
  hasRequired_nodeUtil = 1;
  (function(module2, exports2) {
    var freeGlobal = require_freeGlobal();
    var freeExports = exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    module2.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);
  return _nodeUtil.exports;
}
var isTypedArray_1;
var hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray_1;
  hasRequiredIsTypedArray = 1;
  var baseIsTypedArray = require_baseIsTypedArray(), baseUnary = require_baseUnary(), nodeUtil = require_nodeUtil();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  isTypedArray_1 = isTypedArray;
  return isTypedArray_1;
}
var _arrayLikeKeys;
var hasRequired_arrayLikeKeys;
function require_arrayLikeKeys() {
  if (hasRequired_arrayLikeKeys)
    return _arrayLikeKeys;
  hasRequired_arrayLikeKeys = 1;
  var baseTimes = require_baseTimes(), isArguments = requireIsArguments(), isArray = requireIsArray(), isBuffer2 = requireIsBuffer(), isIndex = require_isIndex(), isTypedArray = requireIsTypedArray();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length2 = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length2)))) {
        result.push(key);
      }
    }
    return result;
  }
  _arrayLikeKeys = arrayLikeKeys;
  return _arrayLikeKeys;
}
var _isPrototype;
var hasRequired_isPrototype;
function require_isPrototype() {
  if (hasRequired_isPrototype)
    return _isPrototype;
  hasRequired_isPrototype = 1;
  var objectProto2 = Object.prototype;
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto2;
    return value === proto2;
  }
  _isPrototype = isPrototype;
  return _isPrototype;
}
var _nativeKeysIn;
var hasRequired_nativeKeysIn;
function require_nativeKeysIn() {
  if (hasRequired_nativeKeysIn)
    return _nativeKeysIn;
  hasRequired_nativeKeysIn = 1;
  function nativeKeysIn(object2) {
    var result = [];
    if (object2 != null) {
      for (var key in Object(object2)) {
        result.push(key);
      }
    }
    return result;
  }
  _nativeKeysIn = nativeKeysIn;
  return _nativeKeysIn;
}
var _baseKeysIn;
var hasRequired_baseKeysIn;
function require_baseKeysIn() {
  if (hasRequired_baseKeysIn)
    return _baseKeysIn;
  hasRequired_baseKeysIn = 1;
  var isObject = requireIsObject(), isPrototype = require_isPrototype(), nativeKeysIn = require_nativeKeysIn();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeysIn(object2) {
    if (!isObject(object2)) {
      return nativeKeysIn(object2);
    }
    var isProto = isPrototype(object2), result = [];
    for (var key in object2) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object2, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeysIn = baseKeysIn;
  return _baseKeysIn;
}
var keysIn_1;
var hasRequiredKeysIn;
function requireKeysIn() {
  if (hasRequiredKeysIn)
    return keysIn_1;
  hasRequiredKeysIn = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeysIn = require_baseKeysIn(), isArrayLike = requireIsArrayLike();
  function keysIn(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2, true) : baseKeysIn(object2);
  }
  keysIn_1 = keysIn;
  return keysIn_1;
}
var defaults_1;
var hasRequiredDefaults;
function requireDefaults() {
  if (hasRequiredDefaults)
    return defaults_1;
  hasRequiredDefaults = 1;
  var baseRest = require_baseRest(), eq2 = requireEq(), isIterateeCall = require_isIterateeCall(), keysIn = requireKeysIn();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var defaults = baseRest(function(object2, sources) {
    object2 = Object(object2);
    var index2 = -1;
    var length2 = sources.length;
    var guard = length2 > 2 ? sources[2] : void 0;
    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      length2 = 1;
    }
    while (++index2 < length2) {
      var source = sources[index2];
      var props = keysIn(source);
      var propsIndex = -1;
      var propsLength = props.length;
      while (++propsIndex < propsLength) {
        var key = props[propsIndex];
        var value = object2[key];
        if (value === void 0 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
          object2[key] = source[key];
        }
      }
    }
    return object2;
  });
  defaults_1 = defaults;
  return defaults_1;
}
var each = { exports: {} };
var _arrayEach;
var hasRequired_arrayEach;
function require_arrayEach() {
  if (hasRequired_arrayEach)
    return _arrayEach;
  hasRequired_arrayEach = 1;
  function arrayEach(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length;
    while (++index2 < length2) {
      if (iteratee(array2[index2], index2, array2) === false) {
        break;
      }
    }
    return array2;
  }
  _arrayEach = arrayEach;
  return _arrayEach;
}
var _createBaseFor;
var hasRequired_createBaseFor;
function require_createBaseFor() {
  if (hasRequired_createBaseFor)
    return _createBaseFor;
  hasRequired_createBaseFor = 1;
  function createBaseFor(fromRight) {
    return function(object2, iteratee, keysFunc) {
      var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length2 = props.length;
      while (length2--) {
        var key = props[fromRight ? length2 : ++index2];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object2;
    };
  }
  _createBaseFor = createBaseFor;
  return _createBaseFor;
}
var _baseFor;
var hasRequired_baseFor;
function require_baseFor() {
  if (hasRequired_baseFor)
    return _baseFor;
  hasRequired_baseFor = 1;
  var createBaseFor = require_createBaseFor();
  var baseFor = createBaseFor();
  _baseFor = baseFor;
  return _baseFor;
}
var _overArg;
var hasRequired_overArg;
function require_overArg() {
  if (hasRequired_overArg)
    return _overArg;
  hasRequired_overArg = 1;
  function overArg(func, transform2) {
    return function(arg) {
      return func(transform2(arg));
    };
  }
  _overArg = overArg;
  return _overArg;
}
var _nativeKeys;
var hasRequired_nativeKeys;
function require_nativeKeys() {
  if (hasRequired_nativeKeys)
    return _nativeKeys;
  hasRequired_nativeKeys = 1;
  var overArg = require_overArg();
  var nativeKeys = overArg(Object.keys, Object);
  _nativeKeys = nativeKeys;
  return _nativeKeys;
}
var _baseKeys;
var hasRequired_baseKeys;
function require_baseKeys() {
  if (hasRequired_baseKeys)
    return _baseKeys;
  hasRequired_baseKeys = 1;
  var isPrototype = require_isPrototype(), nativeKeys = require_nativeKeys();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseKeys(object2) {
    if (!isPrototype(object2)) {
      return nativeKeys(object2);
    }
    var result = [];
    for (var key in Object(object2)) {
      if (hasOwnProperty2.call(object2, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  _baseKeys = baseKeys;
  return _baseKeys;
}
var keys_1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys)
    return keys_1;
  hasRequiredKeys = 1;
  var arrayLikeKeys = require_arrayLikeKeys(), baseKeys = require_baseKeys(), isArrayLike = requireIsArrayLike();
  function keys2(object2) {
    return isArrayLike(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
  }
  keys_1 = keys2;
  return keys_1;
}
var _baseForOwn;
var hasRequired_baseForOwn;
function require_baseForOwn() {
  if (hasRequired_baseForOwn)
    return _baseForOwn;
  hasRequired_baseForOwn = 1;
  var baseFor = require_baseFor(), keys2 = requireKeys();
  function baseForOwn(object2, iteratee) {
    return object2 && baseFor(object2, iteratee, keys2);
  }
  _baseForOwn = baseForOwn;
  return _baseForOwn;
}
var _createBaseEach;
var hasRequired_createBaseEach;
function require_createBaseEach() {
  if (hasRequired_createBaseEach)
    return _createBaseEach;
  hasRequired_createBaseEach = 1;
  var isArrayLike = requireIsArrayLike();
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object(collection);
      while (fromRight ? index2-- : ++index2 < length2) {
        if (iteratee(iterable[index2], index2, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }
  _createBaseEach = createBaseEach;
  return _createBaseEach;
}
var _baseEach;
var hasRequired_baseEach;
function require_baseEach() {
  if (hasRequired_baseEach)
    return _baseEach;
  hasRequired_baseEach = 1;
  var baseForOwn = require_baseForOwn(), createBaseEach = require_createBaseEach();
  var baseEach = createBaseEach(baseForOwn);
  _baseEach = baseEach;
  return _baseEach;
}
var _castFunction;
var hasRequired_castFunction;
function require_castFunction() {
  if (hasRequired_castFunction)
    return _castFunction;
  hasRequired_castFunction = 1;
  var identity2 = requireIdentity();
  function castFunction(value) {
    return typeof value == "function" ? value : identity2;
  }
  _castFunction = castFunction;
  return _castFunction;
}
var forEach_1;
var hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var arrayEach = require_arrayEach(), baseEach = require_baseEach(), castFunction = require_castFunction(), isArray = requireIsArray();
  function forEach(collection, iteratee) {
    var func = isArray(collection) ? arrayEach : baseEach;
    return func(collection, castFunction(iteratee));
  }
  forEach_1 = forEach;
  return forEach_1;
}
var hasRequiredEach;
function requireEach() {
  if (hasRequiredEach)
    return each.exports;
  hasRequiredEach = 1;
  (function(module2) {
    module2.exports = requireForEach();
  })(each);
  return each.exports;
}
var _getPrototype;
var hasRequired_getPrototype;
function require_getPrototype() {
  if (hasRequired_getPrototype)
    return _getPrototype;
  hasRequired_getPrototype = 1;
  var overArg = require_overArg();
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  _getPrototype = getPrototype;
  return _getPrototype;
}
var isPlainObject_1;
var hasRequiredIsPlainObject;
function requireIsPlainObject() {
  if (hasRequiredIsPlainObject)
    return isPlainObject_1;
  hasRequiredIsPlainObject = 1;
  var baseGetTag = require_baseGetTag(), getPrototype = require_getPrototype(), isObjectLike = requireIsObjectLike();
  var objectTag = "[object Object]";
  var funcProto = Function.prototype, objectProto2 = Object.prototype;
  var funcToString = funcProto.toString;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  var objectCtorString = funcToString.call(Object);
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto2 = getPrototype(value);
    if (proto2 === null) {
      return true;
    }
    var Ctor = hasOwnProperty2.call(proto2, "constructor") && proto2.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  isPlainObject_1 = isPlainObject;
  return isPlainObject_1;
}
var isSymbol_1;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol)
    return isSymbol_1;
  hasRequiredIsSymbol = 1;
  var baseGetTag = require_baseGetTag(), isObjectLike = requireIsObjectLike();
  var symbolTag = "[object Symbol]";
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
  }
  isSymbol_1 = isSymbol;
  return isSymbol_1;
}
var _isKey;
var hasRequired_isKey;
function require_isKey() {
  if (hasRequired_isKey)
    return _isKey;
  hasRequired_isKey = 1;
  var isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
  function isKey(value, object2) {
    if (isArray(value)) {
      return false;
    }
    var type2 = typeof value;
    if (type2 == "number" || type2 == "symbol" || type2 == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
  }
  _isKey = isKey;
  return _isKey;
}
var _memoizeCapped;
var hasRequired_memoizeCapped;
function require_memoizeCapped() {
  if (hasRequired_memoizeCapped)
    return _memoizeCapped;
  hasRequired_memoizeCapped = 1;
  var memoize2 = memoize_1;
  var MAX_MEMOIZE_SIZE = 500;
  function memoizeCapped(func) {
    var result = memoize2(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  _memoizeCapped = memoizeCapped;
  return _memoizeCapped;
}
var _stringToPath;
var hasRequired_stringToPath;
function require_stringToPath() {
  if (hasRequired_stringToPath)
    return _stringToPath;
  hasRequired_stringToPath = 1;
  var memoizeCapped = require_memoizeCapped();
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46) {
      result.push("");
    }
    string.replace(rePropName, function(match, number3, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, "$1") : number3 || match);
    });
    return result;
  });
  _stringToPath = stringToPath;
  return _stringToPath;
}
var _arrayMap;
var hasRequired_arrayMap;
function require_arrayMap() {
  if (hasRequired_arrayMap)
    return _arrayMap;
  hasRequired_arrayMap = 1;
  function arrayMap(array2, iteratee) {
    var index2 = -1, length2 = array2 == null ? 0 : array2.length, result = Array(length2);
    while (++index2 < length2) {
      result[index2] = iteratee(array2[index2], index2, array2);
    }
    return result;
  }
  _arrayMap = arrayMap;
  return _arrayMap;
}
var _baseToString;
var hasRequired_baseToString;
function require_baseToString() {
  if (hasRequired_baseToString)
    return _baseToString;
  hasRequired_baseToString = 1;
  var Symbol2 = require_Symbol(), arrayMap = require_arrayMap(), isArray = requireIsArray(), isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0, symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isArray(value)) {
      return arrayMap(value, baseToString) + "";
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _baseToString = baseToString;
  return _baseToString;
}
var toString_1;
var hasRequiredToString;
function requireToString() {
  if (hasRequiredToString)
    return toString_1;
  hasRequiredToString = 1;
  var baseToString = require_baseToString();
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  toString_1 = toString;
  return toString_1;
}
var _castPath;
var hasRequired_castPath;
function require_castPath() {
  if (hasRequired_castPath)
    return _castPath;
  hasRequired_castPath = 1;
  var isArray = requireIsArray(), isKey = require_isKey(), stringToPath = require_stringToPath(), toString = requireToString();
  function castPath(value, object2) {
    if (isArray(value)) {
      return value;
    }
    return isKey(value, object2) ? [value] : stringToPath(toString(value));
  }
  _castPath = castPath;
  return _castPath;
}
var _toKey;
var hasRequired_toKey;
function require_toKey() {
  if (hasRequired_toKey)
    return _toKey;
  hasRequired_toKey = 1;
  var isSymbol = requireIsSymbol();
  var INFINITY = 1 / 0;
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  _toKey = toKey;
  return _toKey;
}
var _baseGet;
var hasRequired_baseGet;
function require_baseGet() {
  if (hasRequired_baseGet)
    return _baseGet;
  hasRequired_baseGet = 1;
  var castPath = require_castPath(), toKey = require_toKey();
  function baseGet(object2, path2) {
    path2 = castPath(path2, object2);
    var index2 = 0, length2 = path2.length;
    while (object2 != null && index2 < length2) {
      object2 = object2[toKey(path2[index2++])];
    }
    return index2 && index2 == length2 ? object2 : void 0;
  }
  _baseGet = baseGet;
  return _baseGet;
}
var _baseAssignValue;
var hasRequired_baseAssignValue;
function require_baseAssignValue() {
  if (hasRequired_baseAssignValue)
    return _baseAssignValue;
  hasRequired_baseAssignValue = 1;
  var defineProperty = require_defineProperty();
  function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object2, key, {
        "configurable": true,
        "enumerable": true,
        "value": value,
        "writable": true
      });
    } else {
      object2[key] = value;
    }
  }
  _baseAssignValue = baseAssignValue;
  return _baseAssignValue;
}
var _assignValue;
var hasRequired_assignValue;
function require_assignValue() {
  if (hasRequired_assignValue)
    return _assignValue;
  hasRequired_assignValue = 1;
  var baseAssignValue = require_baseAssignValue(), eq2 = requireEq();
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty2.call(object2, key) && eq2(objValue, value)) || value === void 0 && !(key in object2)) {
      baseAssignValue(object2, key, value);
    }
  }
  _assignValue = assignValue;
  return _assignValue;
}
var _baseSet;
var hasRequired_baseSet;
function require_baseSet() {
  if (hasRequired_baseSet)
    return _baseSet;
  hasRequired_baseSet = 1;
  var assignValue = require_assignValue(), castPath = require_castPath(), isIndex = require_isIndex(), isObject = requireIsObject(), toKey = require_toKey();
  function baseSet(object2, path2, value, customizer) {
    if (!isObject(object2)) {
      return object2;
    }
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object2;
    while (nested != null && ++index2 < length2) {
      var key = toKey(path2[index2]), newValue = value;
      if (key === "__proto__" || key === "constructor" || key === "prototype") {
        return object2;
      }
      if (index2 != lastIndex) {
        var objValue = nested[key];
        newValue = customizer ? customizer(objValue, key, nested) : void 0;
        if (newValue === void 0) {
          newValue = isObject(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
        }
      }
      assignValue(nested, key, newValue);
      nested = nested[key];
    }
    return object2;
  }
  _baseSet = baseSet;
  return _baseSet;
}
var _basePickBy;
var hasRequired_basePickBy;
function require_basePickBy() {
  if (hasRequired_basePickBy)
    return _basePickBy;
  hasRequired_basePickBy = 1;
  var baseGet = require_baseGet(), baseSet = require_baseSet(), castPath = require_castPath();
  function basePickBy(object2, paths, predicate) {
    var index2 = -1, length2 = paths.length, result = {};
    while (++index2 < length2) {
      var path2 = paths[index2], value = baseGet(object2, path2);
      if (predicate(value, path2)) {
        baseSet(result, castPath(path2, object2), value);
      }
    }
    return result;
  }
  _basePickBy = basePickBy;
  return _basePickBy;
}
var _baseHasIn;
var hasRequired_baseHasIn;
function require_baseHasIn() {
  if (hasRequired_baseHasIn)
    return _baseHasIn;
  hasRequired_baseHasIn = 1;
  function baseHasIn(object2, key) {
    return object2 != null && key in Object(object2);
  }
  _baseHasIn = baseHasIn;
  return _baseHasIn;
}
var _hasPath;
var hasRequired_hasPath;
function require_hasPath() {
  if (hasRequired_hasPath)
    return _hasPath;
  hasRequired_hasPath = 1;
  var castPath = require_castPath(), isArguments = requireIsArguments(), isArray = requireIsArray(), isIndex = require_isIndex(), isLength = requireIsLength(), toKey = require_toKey();
  function hasPath(object2, path2, hasFunc) {
    path2 = castPath(path2, object2);
    var index2 = -1, length2 = path2.length, result = false;
    while (++index2 < length2) {
      var key = toKey(path2[index2]);
      if (!(result = object2 != null && hasFunc(object2, key))) {
        break;
      }
      object2 = object2[key];
    }
    if (result || ++index2 != length2) {
      return result;
    }
    length2 = object2 == null ? 0 : object2.length;
    return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray(object2) || isArguments(object2));
  }
  _hasPath = hasPath;
  return _hasPath;
}
var hasIn_1;
var hasRequiredHasIn;
function requireHasIn() {
  if (hasRequiredHasIn)
    return hasIn_1;
  hasRequiredHasIn = 1;
  var baseHasIn = require_baseHasIn(), hasPath = require_hasPath();
  function hasIn(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHasIn);
  }
  hasIn_1 = hasIn;
  return hasIn_1;
}
var _basePick;
var hasRequired_basePick;
function require_basePick() {
  if (hasRequired_basePick)
    return _basePick;
  hasRequired_basePick = 1;
  var basePickBy = require_basePickBy(), hasIn = requireHasIn();
  function basePick(object2, paths) {
    return basePickBy(object2, paths, function(value, path2) {
      return hasIn(object2, path2);
    });
  }
  _basePick = basePick;
  return _basePick;
}
var _arrayPush;
var hasRequired_arrayPush;
function require_arrayPush() {
  if (hasRequired_arrayPush)
    return _arrayPush;
  hasRequired_arrayPush = 1;
  function arrayPush2(array2, values2) {
    var index2 = -1, length2 = values2.length, offset = array2.length;
    while (++index2 < length2) {
      array2[offset + index2] = values2[index2];
    }
    return array2;
  }
  _arrayPush = arrayPush2;
  return _arrayPush;
}
var _isFlattenable;
var hasRequired_isFlattenable;
function require_isFlattenable() {
  if (hasRequired_isFlattenable)
    return _isFlattenable;
  hasRequired_isFlattenable = 1;
  var Symbol2 = require_Symbol(), isArguments = requireIsArguments(), isArray = requireIsArray();
  var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
  function isFlattenable(value) {
    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
  }
  _isFlattenable = isFlattenable;
  return _isFlattenable;
}
var _baseFlatten;
var hasRequired_baseFlatten;
function require_baseFlatten() {
  if (hasRequired_baseFlatten)
    return _baseFlatten;
  hasRequired_baseFlatten = 1;
  var arrayPush2 = require_arrayPush(), isFlattenable = require_isFlattenable();
  function baseFlatten(array2, depth, predicate, isStrict, result) {
    var index2 = -1, length2 = array2.length;
    predicate || (predicate = isFlattenable);
    result || (result = []);
    while (++index2 < length2) {
      var value = array2[index2];
      if (depth > 0 && predicate(value)) {
        if (depth > 1) {
          baseFlatten(value, depth - 1, predicate, isStrict, result);
        } else {
          arrayPush2(result, value);
        }
      } else if (!isStrict) {
        result[result.length] = value;
      }
    }
    return result;
  }
  _baseFlatten = baseFlatten;
  return _baseFlatten;
}
var flatten_1;
var hasRequiredFlatten;
function requireFlatten() {
  if (hasRequiredFlatten)
    return flatten_1;
  hasRequiredFlatten = 1;
  var baseFlatten = require_baseFlatten();
  function flatten(array2) {
    var length2 = array2 == null ? 0 : array2.length;
    return length2 ? baseFlatten(array2, 1) : [];
  }
  flatten_1 = flatten;
  return flatten_1;
}
var _flatRest;
var hasRequired_flatRest;
function require_flatRest() {
  if (hasRequired_flatRest)
    return _flatRest;
  hasRequired_flatRest = 1;
  var flatten = requireFlatten(), overRest = require_overRest(), setToString = require_setToString();
  function flatRest(func) {
    return setToString(overRest(func, void 0, flatten), func + "");
  }
  _flatRest = flatRest;
  return _flatRest;
}
var pick_1;
var hasRequiredPick;
function requirePick() {
  if (hasRequiredPick)
    return pick_1;
  hasRequiredPick = 1;
  var basePick = require_basePick(), flatRest = require_flatRest();
  var pick = flatRest(function(object2, paths) {
    return object2 == null ? {} : basePick(object2, paths);
  });
  pick_1 = pick;
  return pick_1;
}
var _baseHas;
var hasRequired_baseHas;
function require_baseHas() {
  if (hasRequired_baseHas)
    return _baseHas;
  hasRequired_baseHas = 1;
  var objectProto2 = Object.prototype;
  var hasOwnProperty2 = objectProto2.hasOwnProperty;
  function baseHas(object2, key) {
    return object2 != null && hasOwnProperty2.call(object2, key);
  }
  _baseHas = baseHas;
  return _baseHas;
}
var has_1;
var hasRequiredHas;
function requireHas() {
  if (hasRequiredHas)
    return has_1;
  hasRequiredHas = 1;
  var baseHas = require_baseHas(), hasPath = require_hasPath();
  function has(object2, path2) {
    return object2 != null && hasPath(object2, path2, baseHas);
  }
  has_1 = has;
  return has_1;
}
var _baseRange;
var hasRequired_baseRange;
function require_baseRange() {
  if (hasRequired_baseRange)
    return _baseRange;
  hasRequired_baseRange = 1;
  var nativeCeil = Math.ceil, nativeMax = Math.max;
  function baseRange(start2, end2, step2, fromRight) {
    var index2 = -1, length2 = nativeMax(nativeCeil((end2 - start2) / (step2 || 1)), 0), result = Array(length2);
    while (length2--) {
      result[fromRight ? length2 : ++index2] = start2;
      start2 += step2;
    }
    return result;
  }
  _baseRange = baseRange;
  return _baseRange;
}
var _trimmedEndIndex;
var hasRequired_trimmedEndIndex;
function require_trimmedEndIndex() {
  if (hasRequired_trimmedEndIndex)
    return _trimmedEndIndex;
  hasRequired_trimmedEndIndex = 1;
  var reWhitespace = /\s/;
  function trimmedEndIndex(string) {
    var index2 = string.length;
    while (index2-- && reWhitespace.test(string.charAt(index2))) {
    }
    return index2;
  }
  _trimmedEndIndex = trimmedEndIndex;
  return _trimmedEndIndex;
}
var _baseTrim;
var hasRequired_baseTrim;
function require_baseTrim() {
  if (hasRequired_baseTrim)
    return _baseTrim;
  hasRequired_baseTrim = 1;
  var trimmedEndIndex = require_trimmedEndIndex();
  var reTrimStart = /^\s+/;
  function baseTrim(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
  }
  _baseTrim = baseTrim;
  return _baseTrim;
}
var toNumber_1;
var hasRequiredToNumber;
function requireToNumber() {
  if (hasRequiredToNumber)
    return toNumber_1;
  hasRequiredToNumber = 1;
  var baseTrim = require_baseTrim(), isObject = requireIsObject(), isSymbol = requireIsSymbol();
  var NAN = 0 / 0;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  toNumber_1 = toNumber;
  return toNumber_1;
}
var toFinite_1;
var hasRequiredToFinite;
function requireToFinite() {
  if (hasRequiredToFinite)
    return toFinite_1;
  hasRequiredToFinite = 1;
  var toNumber = requireToNumber();
  var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign2 = value < 0 ? -1 : 1;
      return sign2 * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  toFinite_1 = toFinite;
  return toFinite_1;
}
var _createRange;
var hasRequired_createRange;
function require_createRange() {
  if (hasRequired_createRange)
    return _createRange;
  hasRequired_createRange = 1;
  var baseRange = require_baseRange(), isIterateeCall = require_isIterateeCall(), toFinite = requireToFinite();
  function createRange(fromRight) {
    return function(start2, end2, step2) {
      if (step2 && typeof step2 != "number" && isIterateeCall(start2, end2, step2)) {
        end2 = step2 = void 0;
      }
      start2 = toFinite(start2);
      if (end2 === void 0) {
        end2 = start2;
        start2 = 0;
      } else {
        end2 = toFinite(end2);
      }
      step2 = step2 === void 0 ? start2 < end2 ? 1 : -1 : toFinite(step2);
      return baseRange(start2, end2, step2, fromRight);
    };
  }
  _createRange = createRange;
  return _createRange;
}
var range_1;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange)
    return range_1;
  hasRequiredRange = 1;
  var createRange = require_createRange();
  var range2 = createRange();
  range_1 = range2;
  return range_1;
}
var uniqueId_1;
var hasRequiredUniqueId;
function requireUniqueId() {
  if (hasRequiredUniqueId)
    return uniqueId_1;
  hasRequiredUniqueId = 1;
  var toString = requireToString();
  var idCounter = 0;
  function uniqueId(prefix2) {
    var id2 = ++idCounter;
    return toString(prefix2) + id2;
  }
  uniqueId_1 = uniqueId;
  return uniqueId_1;
}
var lodash;
if (typeof commonjsRequire === "function") {
  try {
    lodash = {
      defaults: requireDefaults(),
      each: requireEach(),
      isFunction: requireIsFunction(),
      isPlainObject: requireIsPlainObject(),
      pick: requirePick(),
      has: requireHas(),
      range: requireRange(),
      uniqueId: requireUniqueId()
    };
  } catch (e) {
  }
}
if (!lodash) {
  lodash = window._;
}
var lodash_1 = lodash;
var _ = lodash_1;
var util$1 = {
  isSubgraph,
  edgeToId,
  applyStyle,
  applyClass,
  applyTransition
};
function isSubgraph(g, v) {
  return !!g.children(v).length;
}
function edgeToId(e) {
  return escapeId(e.v) + ":" + escapeId(e.w) + ":" + escapeId(e.name);
}
var ID_DELIM = /:/g;
function escapeId(str) {
  return str ? String(str).replace(ID_DELIM, "\\:") : "";
}
function applyStyle(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
function applyClass(dom, classFn, otherClasses) {
  if (classFn) {
    dom.attr("class", classFn).attr("class", otherClasses + " " + dom.attr("class"));
  }
}
function applyTransition(selection2, g) {
  var graph2 = g.graph();
  if (_.isPlainObject(graph2)) {
    var transition2 = graph2.transition;
    if (_.isFunction(transition2)) {
      return transition2(selection2);
    }
  }
  return selection2;
}
var util = util$1;
var addHtmlLabel_1 = addHtmlLabel;
function addHtmlLabel(root2, node2) {
  var fo = root2.append("foreignObject").attr("width", "100000");
  var div = fo.append("xhtml:div");
  div.attr("xmlns", "http://www.w3.org/1999/xhtml");
  var label = node2.label;
  switch (typeof label) {
    case "function":
      div.insert(label);
      break;
    case "object":
      div.insert(function() {
        return label;
      });
      break;
    default:
      div.html(label);
  }
  util.applyStyle(div, node2.labelStyle);
  div.style("display", "inline-block");
  div.style("white-space", "nowrap");
  var client = div.node().getBoundingClientRect();
  fo.attr("width", client.width).attr("height", client.height);
  return fo;
}
function question(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const s2 = (w2 + h) * 0.9;
  const points = [
    { x: s2 / 2, y: 0 },
    { x: s2, y: -s2 / 2 },
    { x: s2 / 2, y: -s2 },
    { x: 0, y: -s2 / 2 }
  ];
  const shapeSvg = insertPolygonShape(parent, s2, s2, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function hexagon(parent, bbox, node2) {
  const f = 4;
  const h = bbox.height;
  const m = h / f;
  const w2 = bbox.width + 2 * m;
  const points = [
    { x: m, y: 0 },
    { x: w2 - m, y: 0 },
    { x: w2, y: -h / 2 },
    { x: w2 - m, y: -h },
    { x: m, y: -h },
    { x: 0, y: -h / 2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function rect_left_inv_arrow(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const points = [
    { x: -h / 2, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h },
    { x: -h / 2, y: -h },
    { x: 0, y: -h / 2 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function lean_right(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const points = [
    { x: -2 * h / 6, y: 0 },
    { x: w2 - h / 6, y: 0 },
    { x: w2 + 2 * h / 6, y: -h },
    { x: h / 6, y: -h }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function lean_left(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const points = [
    { x: 2 * h / 6, y: 0 },
    { x: w2 + h / 6, y: 0 },
    { x: w2 - 2 * h / 6, y: -h },
    { x: -h / 6, y: -h }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function trapezoid(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const points = [
    { x: -2 * h / 6, y: 0 },
    { x: w2 + 2 * h / 6, y: 0 },
    { x: w2 - h / 6, y: -h },
    { x: h / 6, y: -h }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function inv_trapezoid(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const points = [
    { x: h / 6, y: 0 },
    { x: w2 - h / 6, y: 0 },
    { x: w2 + 2 * h / 6, y: -h },
    { x: -2 * h / 6, y: -h }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function rect_right_inv_arrow(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const points = [
    { x: 0, y: 0 },
    { x: w2 + h / 2, y: 0 },
    { x: w2, y: -h / 2 },
    { x: w2 + h / 2, y: -h },
    { x: 0, y: -h }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function stadium(parent, bbox, node2) {
  const h = bbox.height;
  const w2 = bbox.width + h / 4;
  const shapeSvg = parent.insert("rect", ":first-child").attr("rx", h / 2).attr("ry", h / 2).attr("x", -w2 / 2).attr("y", -h / 2).attr("width", w2).attr("height", h);
  node2.intersect = function(point2) {
    return dagreD3.intersect.rect(node2, point2);
  };
  return shapeSvg;
}
function subroutine(parent, bbox, node2) {
  const w2 = bbox.width;
  const h = bbox.height;
  const points = [
    { x: 0, y: 0 },
    { x: w2, y: 0 },
    { x: w2, y: -h },
    { x: 0, y: -h },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: w2 + 8, y: 0 },
    { x: w2 + 8, y: -h },
    { x: -8, y: -h },
    { x: -8, y: 0 }
  ];
  const shapeSvg = insertPolygonShape(parent, w2, h, points);
  node2.intersect = function(point2) {
    return dagreD3.intersect.polygon(node2, points, point2);
  };
  return shapeSvg;
}
function cylinder(parent, bbox, node2) {
  const w2 = bbox.width;
  const rx = w2 / 2;
  const ry = rx / (2.5 + w2 / 50);
  const h = bbox.height + ry;
  const shape = "M 0," + ry + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 a " + rx + "," + ry + " 0,0,0 " + -w2 + " 0 l 0," + h + " a " + rx + "," + ry + " 0,0,0 " + w2 + " 0 l 0," + -h;
  const shapeSvg = parent.attr("label-offset-y", ry).insert("path", ":first-child").attr("d", shape).attr("transform", "translate(" + -w2 / 2 + "," + -(h / 2 + ry) + ")");
  node2.intersect = function(point2) {
    const pos = dagreD3.intersect.rect(node2, point2);
    const x2 = pos.x - node2.x;
    if (rx != 0 && (Math.abs(x2) < node2.width / 2 || Math.abs(x2) == node2.width / 2 && Math.abs(pos.y - node2.y) > node2.height / 2 - ry)) {
      let y2 = ry * ry * (1 - x2 * x2 / (rx * rx));
      if (y2 != 0)
        y2 = Math.sqrt(y2);
      y2 = ry - y2;
      if (point2.y - node2.y > 0)
        y2 = -y2;
      pos.y += y2;
    }
    return pos;
  };
  return shapeSvg;
}
function addToRender(render2) {
  render2.shapes().question = question;
  render2.shapes().hexagon = hexagon;
  render2.shapes().stadium = stadium;
  render2.shapes().subroutine = subroutine;
  render2.shapes().cylinder = cylinder;
  render2.shapes().rect_left_inv_arrow = rect_left_inv_arrow;
  render2.shapes().lean_right = lean_right;
  render2.shapes().lean_left = lean_left;
  render2.shapes().trapezoid = trapezoid;
  render2.shapes().inv_trapezoid = inv_trapezoid;
  render2.shapes().rect_right_inv_arrow = rect_right_inv_arrow;
}
function addToRenderV2(addShape) {
  addShape({ question });
  addShape({ hexagon });
  addShape({ stadium });
  addShape({ subroutine });
  addShape({ cylinder });
  addShape({ rect_left_inv_arrow });
  addShape({ lean_right });
  addShape({ lean_left });
  addShape({ trapezoid });
  addShape({ inv_trapezoid });
  addShape({ rect_right_inv_arrow });
}
function insertPolygonShape(parent, w2, h, points) {
  return parent.insert("polygon", ":first-child").attr(
    "points",
    points.map(function(d) {
      return d.x + "," + d.y;
    }).join(" ")
  ).attr("transform", "translate(" + -w2 / 2 + "," + h / 2 + ")");
}
const flowChartShapes = {
  addToRender,
  addToRenderV2
};
const conf$8 = {};
const setConf$7 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$8[keys2[i]] = cnf[keys2[i]];
  }
};
const addVertices$1 = function(vert, g, svgId, root2, _doc, diagObj) {
  const svg2 = !root2 ? select$1(`[id="${svgId}"]`) : root2.select(`[id="${svgId}"]`);
  const doc = !_doc ? document : _doc;
  const keys2 = Object.keys(vert);
  keys2.forEach(function(id2) {
    const vertex = vert[id2];
    let classStr = "default";
    if (vertex.classes.length > 0) {
      classStr = vertex.classes.join(" ");
    }
    const styles = getStylesFromArray(vertex.styles);
    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
    let vertexNode;
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const node2 = {
        label: vertexText.replace(
          /fa[lrsb]?:fa-[\w-]+/g,
          (s2) => `<i class='${s2.replace(":", " ")}'></i>`
        )
      };
      vertexNode = addHtmlLabel_1(svg2, node2).node();
      vertexNode.parentNode.removeChild(vertexNode);
    } else {
      const svgLabel = doc.createElementNS("http://www.w3.org/2000/svg", "text");
      svgLabel.setAttribute("style", styles.labelStyle.replace("color:", "fill:"));
      const rows = vertexText.split(common.lineBreakRegex);
      for (let j = 0; j < rows.length; j++) {
        const tspan = doc.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        tspan.setAttribute("dy", "1em");
        tspan.setAttribute("x", "1");
        tspan.textContent = rows[j];
        svgLabel.appendChild(tspan);
      }
      vertexNode = svgLabel;
    }
    let radious = 0;
    let _shape = "";
    switch (vertex.type) {
      case "round":
        radious = 5;
        _shape = "rect";
        break;
      case "square":
        _shape = "rect";
        break;
      case "diamond":
        _shape = "question";
        break;
      case "hexagon":
        _shape = "hexagon";
        break;
      case "odd":
        _shape = "rect_left_inv_arrow";
        break;
      case "lean_right":
        _shape = "lean_right";
        break;
      case "lean_left":
        _shape = "lean_left";
        break;
      case "trapezoid":
        _shape = "trapezoid";
        break;
      case "inv_trapezoid":
        _shape = "inv_trapezoid";
        break;
      case "odd_right":
        _shape = "rect_left_inv_arrow";
        break;
      case "circle":
        _shape = "circle";
        break;
      case "ellipse":
        _shape = "ellipse";
        break;
      case "stadium":
        _shape = "stadium";
        break;
      case "subroutine":
        _shape = "subroutine";
        break;
      case "cylinder":
        _shape = "cylinder";
        break;
      case "group":
        _shape = "rect";
        break;
      default:
        _shape = "rect";
    }
    log$1.warn("Adding node", vertex.id, vertex.domId);
    g.setNode(diagObj.db.lookUpDomId(vertex.id), {
      labelType: "svg",
      labelStyle: styles.labelStyle,
      shape: _shape,
      label: vertexNode,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: diagObj.db.lookUpDomId(vertex.id)
    });
  });
};
const addEdges$1 = function(edges2, g, diagObj) {
  let cnt2 = 0;
  let defaultStyle2;
  let defaultLabelStyle;
  if (typeof edges2.defaultStyle !== "undefined") {
    const defaultStyles = getStylesFromArray(edges2.defaultStyle);
    defaultStyle2 = defaultStyles.style;
    defaultLabelStyle = defaultStyles.labelStyle;
  }
  edges2.forEach(function(edge) {
    cnt2++;
    var linkId = "L-" + edge.start + "-" + edge.end;
    var linkNameStart = "LS-" + edge.start;
    var linkNameEnd = "LE-" + edge.end;
    const edgeData = {};
    if (edge.type === "arrow_open") {
      edgeData.arrowhead = "none";
    } else {
      edgeData.arrowhead = "normal";
    }
    let style = "";
    let labelStyle = "";
    if (typeof edge.style !== "undefined") {
      const styles = getStylesFromArray(edge.style);
      style = styles.style;
      labelStyle = styles.labelStyle;
    } else {
      switch (edge.stroke) {
        case "normal":
          style = "fill:none";
          if (typeof defaultStyle2 !== "undefined") {
            style = defaultStyle2;
          }
          if (typeof defaultLabelStyle !== "undefined") {
            labelStyle = defaultLabelStyle;
          }
          break;
        case "dotted":
          style = "fill:none;stroke-width:2px;stroke-dasharray:3;";
          break;
        case "thick":
          style = " stroke-width: 3.5px;fill:none";
          break;
      }
    }
    edgeData.style = style;
    edgeData.labelStyle = labelStyle;
    if (typeof edge.interpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear$1);
    } else if (typeof edges2.defaultInterpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edges2.defaultInterpolate, curveLinear$1);
    } else {
      edgeData.curve = interpolateToCurve(conf$8.curve, curveLinear$1);
    }
    if (typeof edge.text === "undefined") {
      if (typeof edge.style !== "undefined") {
        edgeData.arrowheadStyle = "fill: #333";
      }
    } else {
      edgeData.arrowheadStyle = "fill: #333";
      edgeData.labelpos = "c";
      if (evaluate(getConfig$1().flowchart.htmlLabels)) {
        edgeData.labelType = "html";
        edgeData.label = `<span id="L-${linkId}" class="edgeLabel L-${linkNameStart}' L-${linkNameEnd}" style="${edgeData.labelStyle}">${edge.text.replace(
          /fa[lrsb]?:fa-[\w-]+/g,
          (s2) => `<i class='${s2.replace(":", " ")}'></i>`
        )}</span>`;
      } else {
        edgeData.labelType = "text";
        edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
        if (typeof edge.style === "undefined") {
          edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none";
        }
        edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
      }
    }
    edgeData.id = linkId;
    edgeData.class = linkNameStart + " " + linkNameEnd;
    edgeData.minlen = edge.length || 1;
    g.setEdge(diagObj.db.lookUpDomId(edge.start), diagObj.db.lookUpDomId(edge.end), edgeData, cnt2);
  });
};
const getClasses$3 = function(text2, diagObj) {
  log$1.info("Extracting classes");
  diagObj.db.clear();
  try {
    diagObj.parse(text2);
    return diagObj.db.getClasses();
  } catch (e) {
    return;
  }
};
const draw$a = function(text2, id2, _version, diagObj) {
  log$1.info("Drawing flowchart");
  diagObj.db.clear();
  const { securityLevel, flowchart: conf2 } = getConfig$1();
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  try {
    diagObj.parser.parse(text2);
  } catch (err) {
    log$1.debug("Parsing failed");
  }
  let dir = diagObj.db.getDirection();
  if (typeof dir === "undefined") {
    dir = "TD";
  }
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  const g = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: dir,
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let subG;
  const subGraphs2 = diagObj.db.getSubGraphs();
  for (let i2 = subGraphs2.length - 1; i2 >= 0; i2--) {
    subG = subGraphs2[i2];
    diagObj.db.addVertex(subG.id, subG.title, "group", void 0, subG.classes);
  }
  const vert = diagObj.db.getVertices();
  log$1.warn("Get vertices", vert);
  const edges2 = diagObj.db.getEdges();
  let i = 0;
  for (i = subGraphs2.length - 1; i >= 0; i--) {
    subG = subGraphs2[i];
    selectAll$1("cluster").append("text");
    for (let j = 0; j < subG.nodes.length; j++) {
      log$1.warn(
        "Setting subgraph",
        subG.nodes[j],
        diagObj.db.lookUpDomId(subG.nodes[j]),
        diagObj.db.lookUpDomId(subG.id)
      );
      g.setParent(diagObj.db.lookUpDomId(subG.nodes[j]), diagObj.db.lookUpDomId(subG.id));
    }
  }
  addVertices$1(vert, g, id2, root2, doc, diagObj);
  addEdges$1(edges2, g, diagObj);
  const Render = dagreD3.render;
  const render2 = new Render();
  flowChartShapes.addToRender(render2);
  render2.arrows().none = function normal2(parent, id22, edge, type2) {
    const marker = parent.append("marker").attr("id", id22).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    const path2 = marker.append("path").attr("d", "M 0 0 L 0 0 L 0 0 z");
    dagreD3.util.applyStyle(path2, edge[type2 + "Style"]);
  };
  render2.arrows().normal = function normal2(parent, id22) {
    const marker = parent.append("marker").attr("id", id22).attr("viewBox", "0 0 10 10").attr("refX", 9).attr("refY", 5).attr("markerUnits", "strokeWidth").attr("markerWidth", 8).attr("markerHeight", 6).attr("orient", "auto");
    marker.append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowheadPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  };
  const svg2 = root2.select(`[id="${id2}"]`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
  const element = root2.select("#" + id2 + " g");
  render2(element, g);
  element.selectAll("g.node").attr("title", function() {
    return diagObj.db.getTooltip(this.id);
  });
  diagObj.db.indexNodes("subGraph" + i);
  for (i = 0; i < subGraphs2.length; i++) {
    subG = subGraphs2[i];
    if (subG.title !== "undefined") {
      const clusterRects = doc.querySelectorAll(
        "#" + id2 + ' [id="' + diagObj.db.lookUpDomId(subG.id) + '"] rect'
      );
      const clusterEl = doc.querySelectorAll(
        "#" + id2 + ' [id="' + diagObj.db.lookUpDomId(subG.id) + '"]'
      );
      const xPos = clusterRects[0].x.baseVal.value;
      const yPos = clusterRects[0].y.baseVal.value;
      const _width = clusterRects[0].width.baseVal.value;
      const cluster2 = select$1(clusterEl[0]);
      const te = cluster2.select(".label");
      te.attr("transform", `translate(${xPos + _width / 2}, ${yPos + 14})`);
      te.attr("id", id2 + "Text");
      for (let j = 0; j < subG.classes.length; j++) {
        clusterEl[0].classList.add(subG.classes[j]);
      }
    }
  }
  if (!conf2.htmlLabels) {
    const labels = doc.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
    for (let k2 = 0; k2 < labels.length; k2++) {
      const label = labels[k2];
      const dim = label.getBBox();
      const rect2 = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", 0);
      rect2.setAttribute("ry", 0);
      rect2.setAttribute("width", dim.width);
      rect2.setAttribute("height", dim.height);
      label.insertBefore(rect2, label.firstChild);
    }
  }
  setupGraphViewbox$1(g, svg2, conf2.diagramPadding, conf2.useMaxWidth);
  const keys2 = Object.keys(vert);
  keys2.forEach(function(key) {
    const vertex = vert[key];
    if (vertex.link) {
      const node2 = root2.select("#" + id2 + ' [id="' + diagObj.db.lookUpDomId(key) + '"]');
      if (node2) {
        const link2 = doc.createElementNS("http://www.w3.org/2000/svg", "a");
        link2.setAttributeNS("http://www.w3.org/2000/svg", "class", vertex.classes.join(" "));
        link2.setAttributeNS("http://www.w3.org/2000/svg", "href", vertex.link);
        link2.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener");
        if (securityLevel === "sandbox") {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top");
        } else if (vertex.linkTarget) {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", vertex.linkTarget);
        }
        const linkNode = node2.insert(function() {
          return link2;
        }, ":first-child");
        const shape = node2.select(".label-container");
        if (shape) {
          linkNode.append(function() {
            return shape.node();
          });
        }
        const label = node2.select(".label");
        if (label) {
          linkNode.append(function() {
            return label.node();
          });
        }
      }
    }
  });
};
const flowRenderer = {
  setConf: setConf$7,
  addVertices: addVertices$1,
  addEdges: addEdges$1,
  getClasses: getClasses$3,
  draw: draw$a
};
const conf$7 = {};
const setConf$6 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$7[keys2[i]] = cnf[keys2[i]];
  }
};
const addVertices = function(vert, g, svgId, root2, doc, diagObj) {
  const svg2 = root2.select(`[id="${svgId}"]`);
  const keys2 = Object.keys(vert);
  keys2.forEach(function(id2) {
    const vertex = vert[id2];
    let classStr = "default";
    if (vertex.classes.length > 0) {
      classStr = vertex.classes.join(" ");
    }
    const styles = getStylesFromArray(vertex.styles);
    let vertexText = vertex.text !== void 0 ? vertex.text : vertex.id;
    let vertexNode;
    if (evaluate(getConfig$1().flowchart.htmlLabels)) {
      const node2 = {
        label: vertexText.replace(
          /fa[lrsb]?:fa-[\w-]+/g,
          (s2) => `<i class='${s2.replace(":", " ")}'></i>`
        )
      };
      vertexNode = addHtmlLabel_1(svg2, node2).node();
      vertexNode.parentNode.removeChild(vertexNode);
    } else {
      const svgLabel = doc.createElementNS("http://www.w3.org/2000/svg", "text");
      svgLabel.setAttribute("style", styles.labelStyle.replace("color:", "fill:"));
      const rows = vertexText.split(common.lineBreakRegex);
      for (let j = 0; j < rows.length; j++) {
        const tspan = doc.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        tspan.setAttribute("dy", "1em");
        tspan.setAttribute("x", "1");
        tspan.textContent = rows[j];
        svgLabel.appendChild(tspan);
      }
      vertexNode = svgLabel;
    }
    let radious = 0;
    let _shape = "";
    switch (vertex.type) {
      case "round":
        radious = 5;
        _shape = "rect";
        break;
      case "square":
        _shape = "rect";
        break;
      case "diamond":
        _shape = "question";
        break;
      case "hexagon":
        _shape = "hexagon";
        break;
      case "odd":
        _shape = "rect_left_inv_arrow";
        break;
      case "lean_right":
        _shape = "lean_right";
        break;
      case "lean_left":
        _shape = "lean_left";
        break;
      case "trapezoid":
        _shape = "trapezoid";
        break;
      case "inv_trapezoid":
        _shape = "inv_trapezoid";
        break;
      case "odd_right":
        _shape = "rect_left_inv_arrow";
        break;
      case "circle":
        _shape = "circle";
        break;
      case "ellipse":
        _shape = "ellipse";
        break;
      case "stadium":
        _shape = "stadium";
        break;
      case "subroutine":
        _shape = "subroutine";
        break;
      case "cylinder":
        _shape = "cylinder";
        break;
      case "group":
        _shape = "rect";
        break;
      case "doublecircle":
        _shape = "doublecircle";
        break;
      default:
        _shape = "rect";
    }
    g.setNode(vertex.id, {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: vertex.id,
      link: vertex.link,
      linkTarget: vertex.linkTarget,
      tooltip: diagObj.db.getTooltip(vertex.id) || "",
      domId: diagObj.db.lookUpDomId(vertex.id),
      haveCallback: vertex.haveCallback,
      width: vertex.type === "group" ? 500 : void 0,
      dir: vertex.dir,
      type: vertex.type,
      props: vertex.props,
      padding: getConfig$1().flowchart.padding
    });
    log$1.info("setNode", {
      labelStyle: styles.labelStyle,
      shape: _shape,
      labelText: vertexText,
      rx: radious,
      ry: radious,
      class: classStr,
      style: styles.style,
      id: vertex.id,
      domId: diagObj.db.lookUpDomId(vertex.id),
      width: vertex.type === "group" ? 500 : void 0,
      type: vertex.type,
      dir: vertex.dir,
      props: vertex.props,
      padding: getConfig$1().flowchart.padding
    });
  });
};
const addEdges = function(edges2, g, diagObj) {
  log$1.info("abc78 edges = ", edges2);
  let cnt2 = 0;
  let linkIdCnt = {};
  let defaultStyle2;
  let defaultLabelStyle;
  if (typeof edges2.defaultStyle !== "undefined") {
    const defaultStyles = getStylesFromArray(edges2.defaultStyle);
    defaultStyle2 = defaultStyles.style;
    defaultLabelStyle = defaultStyles.labelStyle;
  }
  edges2.forEach(function(edge) {
    cnt2++;
    var linkIdBase = "L-" + edge.start + "-" + edge.end;
    if (typeof linkIdCnt[linkIdBase] === "undefined") {
      linkIdCnt[linkIdBase] = 0;
      log$1.info("abc78 new entry", linkIdBase, linkIdCnt[linkIdBase]);
    } else {
      linkIdCnt[linkIdBase]++;
      log$1.info("abc78 new entry", linkIdBase, linkIdCnt[linkIdBase]);
    }
    let linkId = linkIdBase + "-" + linkIdCnt[linkIdBase];
    log$1.info("abc78 new link id to be used is", linkIdBase, linkId, linkIdCnt[linkIdBase]);
    var linkNameStart = "LS-" + edge.start;
    var linkNameEnd = "LE-" + edge.end;
    const edgeData = { style: "", labelStyle: "" };
    edgeData.minlen = edge.length || 1;
    if (edge.type === "arrow_open") {
      edgeData.arrowhead = "none";
    } else {
      edgeData.arrowhead = "normal";
    }
    edgeData.arrowTypeStart = "arrow_open";
    edgeData.arrowTypeEnd = "arrow_open";
    switch (edge.type) {
      case "double_arrow_cross":
        edgeData.arrowTypeStart = "arrow_cross";
      case "arrow_cross":
        edgeData.arrowTypeEnd = "arrow_cross";
        break;
      case "double_arrow_point":
        edgeData.arrowTypeStart = "arrow_point";
      case "arrow_point":
        edgeData.arrowTypeEnd = "arrow_point";
        break;
      case "double_arrow_circle":
        edgeData.arrowTypeStart = "arrow_circle";
      case "arrow_circle":
        edgeData.arrowTypeEnd = "arrow_circle";
        break;
    }
    let style = "";
    let labelStyle = "";
    switch (edge.stroke) {
      case "normal":
        style = "fill:none;";
        if (typeof defaultStyle2 !== "undefined") {
          style = defaultStyle2;
        }
        if (typeof defaultLabelStyle !== "undefined") {
          labelStyle = defaultLabelStyle;
        }
        edgeData.thickness = "normal";
        edgeData.pattern = "solid";
        break;
      case "dotted":
        edgeData.thickness = "normal";
        edgeData.pattern = "dotted";
        edgeData.style = "fill:none;stroke-width:2px;stroke-dasharray:3;";
        break;
      case "thick":
        edgeData.thickness = "thick";
        edgeData.pattern = "solid";
        edgeData.style = "stroke-width: 3.5px;fill:none;";
        break;
      case "invisible":
        edgeData.thickness = "invisible";
        edgeData.pattern = "solid";
        edgeData.style = "stroke-width: 0;fill:none;";
        break;
    }
    if (typeof edge.style !== "undefined") {
      const styles = getStylesFromArray(edge.style);
      style = styles.style;
      labelStyle = styles.labelStyle;
    }
    edgeData.style = edgeData.style += style;
    edgeData.labelStyle = edgeData.labelStyle += labelStyle;
    if (typeof edge.interpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edge.interpolate, curveLinear$1);
    } else if (typeof edges2.defaultInterpolate !== "undefined") {
      edgeData.curve = interpolateToCurve(edges2.defaultInterpolate, curveLinear$1);
    } else {
      edgeData.curve = interpolateToCurve(conf$7.curve, curveLinear$1);
    }
    if (typeof edge.text === "undefined") {
      if (typeof edge.style !== "undefined") {
        edgeData.arrowheadStyle = "fill: #333";
      }
    } else {
      edgeData.arrowheadStyle = "fill: #333";
      edgeData.labelpos = "c";
    }
    edgeData.labelType = "text";
    edgeData.label = edge.text.replace(common.lineBreakRegex, "\n");
    if (typeof edge.style === "undefined") {
      edgeData.style = edgeData.style || "stroke: #333; stroke-width: 1.5px;fill:none;";
    }
    edgeData.labelStyle = edgeData.labelStyle.replace("color:", "fill:");
    edgeData.id = linkId;
    edgeData.classes = "flowchart-link " + linkNameStart + " " + linkNameEnd;
    g.setEdge(edge.start, edge.end, edgeData, cnt2);
  });
};
const getClasses$2 = function(text2, diagObj) {
  log$1.info("Extracting classes");
  diagObj.db.clear();
  try {
    diagObj.parse(text2);
    return diagObj.db.getClasses();
  } catch (e) {
    return;
  }
};
const draw$9 = function(text2, id2, _version, diagObj) {
  log$1.info("Drawing flowchart");
  diagObj.db.clear();
  flowDb.setGen("gen-2");
  diagObj.parser.parse(text2);
  let dir = diagObj.db.getDirection();
  if (typeof dir === "undefined") {
    dir = "TD";
  }
  const { securityLevel, flowchart: conf2 } = getConfig$1();
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  const g = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: dir,
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 0,
    marginy: 0
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let subG;
  const subGraphs2 = diagObj.db.getSubGraphs();
  log$1.info("Subgraphs - ", subGraphs2);
  for (let i2 = subGraphs2.length - 1; i2 >= 0; i2--) {
    subG = subGraphs2[i2];
    log$1.info("Subgraph - ", subG);
    diagObj.db.addVertex(subG.id, subG.title, "group", void 0, subG.classes, subG.dir);
  }
  const vert = diagObj.db.getVertices();
  const edges2 = diagObj.db.getEdges();
  log$1.info(edges2);
  let i = 0;
  for (i = subGraphs2.length - 1; i >= 0; i--) {
    subG = subGraphs2[i];
    selectAll$1("cluster").append("text");
    for (let j = 0; j < subG.nodes.length; j++) {
      log$1.info("Setting up subgraphs", subG.nodes[j], subG.id);
      g.setParent(subG.nodes[j], subG.id);
    }
  }
  addVertices(vert, g, id2, root2, doc, diagObj);
  addEdges(edges2, g);
  const svg2 = root2.select(`[id="${id2}"]`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
  const element = root2.select("#" + id2 + " g");
  render$1(element, g, ["point", "circle", "cross"], "flowchart", id2);
  setupGraphViewbox$1(g, svg2, conf2.diagramPadding, conf2.useMaxWidth);
  diagObj.db.indexNodes("subGraph" + i);
  if (!conf2.htmlLabels) {
    const labels = doc.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
    for (let k2 = 0; k2 < labels.length; k2++) {
      const label = labels[k2];
      const dim = label.getBBox();
      const rect2 = doc.createElementNS("http://www.w3.org/2000/svg", "rect");
      rect2.setAttribute("rx", 0);
      rect2.setAttribute("ry", 0);
      rect2.setAttribute("width", dim.width);
      rect2.setAttribute("height", dim.height);
      label.insertBefore(rect2, label.firstChild);
    }
  }
  const keys2 = Object.keys(vert);
  keys2.forEach(function(key) {
    const vertex = vert[key];
    if (vertex.link) {
      const node2 = select$1("#" + id2 + ' [id="' + key + '"]');
      if (node2) {
        const link2 = doc.createElementNS("http://www.w3.org/2000/svg", "a");
        link2.setAttributeNS("http://www.w3.org/2000/svg", "class", vertex.classes.join(" "));
        link2.setAttributeNS("http://www.w3.org/2000/svg", "href", vertex.link);
        link2.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener");
        if (securityLevel === "sandbox") {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", "_top");
        } else if (vertex.linkTarget) {
          link2.setAttributeNS("http://www.w3.org/2000/svg", "target", vertex.linkTarget);
        }
        const linkNode = node2.insert(function() {
          return link2;
        }, ":first-child");
        const shape = node2.select(".label-container");
        if (shape) {
          linkNode.append(function() {
            return shape.node();
          });
        }
        const label = node2.select(".label");
        if (label) {
          linkNode.append(function() {
            return label.node();
          });
        }
      }
    }
  });
};
const flowRendererV2 = {
  setConf: setConf$6,
  addVertices,
  addEdges,
  getClasses: getClasses$2,
  draw: draw$9
};
var parser$6 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 3], $V1 = [1, 5], $V2 = [7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 25, 27, 34, 39], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 17], $V6 = [1, 18], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 23], $Vc = [1, 24], $Vd = [1, 25], $Ve = [1, 26], $Vf = [1, 28], $Vg = [1, 30], $Vh = [1, 33], $Vi = [5, 7, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 24, 25, 27, 34, 39];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "directive": 4, "gantt": 5, "document": 6, "EOF": 7, "line": 8, "SPACE": 9, "statement": 10, "NL": 11, "dateFormat": 12, "inclusiveEndDates": 13, "topAxis": 14, "axisFormat": 15, "excludes": 16, "includes": 17, "todayMarker": 18, "title": 19, "acc_title": 20, "acc_title_value": 21, "acc_descr": 22, "acc_descr_value": 23, "acc_descr_multiline_value": 24, "section": 25, "clickStatement": 26, "taskTxt": 27, "taskData": 28, "openDirective": 29, "typeDirective": 30, "closeDirective": 31, ":": 32, "argDirective": 33, "click": 34, "callbackname": 35, "callbackargs": 36, "href": 37, "clickStatementDebug": 38, "open_directive": 39, "type_directive": 40, "arg_directive": 41, "close_directive": 42, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "gantt", 7: "EOF", 9: "SPACE", 11: "NL", 12: "dateFormat", 13: "inclusiveEndDates", 14: "topAxis", 15: "axisFormat", 16: "excludes", 17: "includes", 18: "todayMarker", 19: "title", 20: "acc_title", 21: "acc_title_value", 22: "acc_descr", 23: "acc_descr_value", 24: "acc_descr_multiline_value", 25: "section", 27: "taskTxt", 28: "taskData", 32: ":", 34: "click", 35: "callbackname", 36: "callbackargs", 37: "href", 39: "open_directive", 40: "type_directive", 41: "arg_directive", 42: "close_directive" },
    productions_: [0, [3, 2], [3, 3], [6, 0], [6, 2], [8, 2], [8, 1], [8, 1], [8, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [10, 2], [10, 1], [4, 4], [4, 6], [26, 2], [26, 3], [26, 3], [26, 4], [26, 3], [26, 4], [26, 2], [38, 2], [38, 3], [38, 3], [38, 4], [38, 3], [38, 4], [38, 2], [29, 1], [30, 1], [33, 1], [31, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 2:
          return $$[$0 - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 5:
        case 6:
          this.$ = $$[$0];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 9:
          yy.setDateFormat($$[$0].substr(11));
          this.$ = $$[$0].substr(11);
          break;
        case 10:
          yy.enableInclusiveEndDates();
          this.$ = $$[$0].substr(18);
          break;
        case 11:
          yy.TopAxis();
          this.$ = $$[$0].substr(8);
          break;
        case 12:
          yy.setAxisFormat($$[$0].substr(11));
          this.$ = $$[$0].substr(11);
          break;
        case 13:
          yy.setExcludes($$[$0].substr(9));
          this.$ = $$[$0].substr(9);
          break;
        case 14:
          yy.setIncludes($$[$0].substr(9));
          this.$ = $$[$0].substr(9);
          break;
        case 15:
          yy.setTodayMarker($$[$0].substr(12));
          this.$ = $$[$0].substr(12);
          break;
        case 16:
          yy.setDiagramTitle($$[$0].substr(6));
          this.$ = $$[$0].substr(6);
          break;
        case 17:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 18:
        case 19:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 20:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 22:
          yy.addTask($$[$0 - 1], $$[$0]);
          this.$ = "task";
          break;
        case 26:
          this.$ = $$[$0 - 1];
          yy.setClickEvent($$[$0 - 1], $$[$0], null);
          break;
        case 27:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], $$[$0]);
          break;
        case 28:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0 - 1], null);
          yy.setLink($$[$0 - 2], $$[$0]);
          break;
        case 29:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 2], $$[$0 - 1]);
          yy.setLink($$[$0 - 3], $$[$0]);
          break;
        case 30:
          this.$ = $$[$0 - 2];
          yy.setClickEvent($$[$0 - 2], $$[$0], null);
          yy.setLink($$[$0 - 2], $$[$0 - 1]);
          break;
        case 31:
          this.$ = $$[$0 - 3];
          yy.setClickEvent($$[$0 - 3], $$[$0 - 1], $$[$0]);
          yy.setLink($$[$0 - 3], $$[$0 - 2]);
          break;
        case 32:
          this.$ = $$[$0 - 1];
          yy.setLink($$[$0 - 1], $$[$0]);
          break;
        case 33:
        case 39:
          this.$ = $$[$0 - 1] + " " + $$[$0];
          break;
        case 34:
        case 35:
        case 37:
          this.$ = $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
          break;
        case 36:
        case 38:
          this.$ = $$[$0 - 3] + " " + $$[$0 - 2] + " " + $$[$0 - 1] + " " + $$[$0];
          break;
        case 40:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 41:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 42:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 43:
          yy.parseDirective("}%%", "close_directive", "gantt");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: $V0, 29: 4, 39: $V1 }, { 1: [3] }, { 3: 6, 4: 2, 5: $V0, 29: 4, 39: $V1 }, o($V2, [2, 3], { 6: 7 }), { 30: 8, 40: [1, 9] }, { 40: [2, 40] }, { 1: [2, 1] }, { 4: 29, 7: [1, 10], 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: $V3, 13: $V4, 14: $V5, 15: $V6, 16: $V7, 17: $V8, 18: $V9, 19: $Va, 20: $Vb, 22: $Vc, 24: $Vd, 25: $Ve, 26: 27, 27: $Vf, 29: 4, 34: $Vg, 39: $V1 }, { 31: 31, 32: [1, 32], 42: $Vh }, o([32, 42], [2, 41]), o($V2, [2, 8], { 1: [2, 2] }), o($V2, [2, 4]), { 4: 29, 10: 34, 12: $V3, 13: $V4, 14: $V5, 15: $V6, 16: $V7, 17: $V8, 18: $V9, 19: $Va, 20: $Vb, 22: $Vc, 24: $Vd, 25: $Ve, 26: 27, 27: $Vf, 29: 4, 34: $Vg, 39: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 9]), o($V2, [2, 10]), o($V2, [2, 11]), o($V2, [2, 12]), o($V2, [2, 13]), o($V2, [2, 14]), o($V2, [2, 15]), o($V2, [2, 16]), { 21: [1, 35] }, { 23: [1, 36] }, o($V2, [2, 19]), o($V2, [2, 20]), o($V2, [2, 21]), { 28: [1, 37] }, o($V2, [2, 23]), { 35: [1, 38], 37: [1, 39] }, { 11: [1, 40] }, { 33: 41, 41: [1, 42] }, { 11: [2, 43] }, o($V2, [2, 5]), o($V2, [2, 17]), o($V2, [2, 18]), o($V2, [2, 22]), o($V2, [2, 26], { 36: [1, 43], 37: [1, 44] }), o($V2, [2, 32], { 35: [1, 45] }), o($Vi, [2, 24]), { 31: 46, 42: $Vh }, { 42: [2, 42] }, o($V2, [2, 27], { 37: [1, 47] }), o($V2, [2, 28]), o($V2, [2, 30], { 36: [1, 48] }), { 11: [1, 49] }, o($V2, [2, 29]), o($V2, [2, 31]), o($Vi, [2, 25])],
    defaultActions: { 5: [2, 40], 6: [2, 1], 33: [2, 43], 42: [2, 42] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 39;
          case 1:
            this.begin("type_directive");
            return 40;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 32;
          case 3:
            this.popState();
            this.popState();
            return 42;
          case 4:
            return 41;
          case 5:
            this.begin("acc_title");
            return 20;
          case 6:
            this.popState();
            return "acc_title_value";
          case 7:
            this.begin("acc_descr");
            return 22;
          case 8:
            this.popState();
            return "acc_descr_value";
          case 9:
            this.begin("acc_descr_multiline");
            break;
          case 10:
            this.popState();
            break;
          case 11:
            return "acc_descr_multiline_value";
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            return 11;
          case 16:
            break;
          case 17:
            break;
          case 18:
            break;
          case 19:
            this.begin("href");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return 37;
          case 22:
            this.begin("callbackname");
            break;
          case 23:
            this.popState();
            break;
          case 24:
            this.popState();
            this.begin("callbackargs");
            break;
          case 25:
            return 35;
          case 26:
            this.popState();
            break;
          case 27:
            return 36;
          case 28:
            this.begin("click");
            break;
          case 29:
            this.popState();
            break;
          case 30:
            return 34;
          case 31:
            return 5;
          case 32:
            return 12;
          case 33:
            return 13;
          case 34:
            return 14;
          case 35:
            return 15;
          case 36:
            return 17;
          case 37:
            return 16;
          case 38:
            return 18;
          case 39:
            return "date";
          case 40:
            return 19;
          case 41:
            return "accDescription";
          case 42:
            return 25;
          case 43:
            return 27;
          case 44:
            return 28;
          case 45:
            return 32;
          case 46:
            return 7;
          case 47:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:%%(?!\{)*[^\n]*)/i, /^(?:[^\}]%%*[^\n]*)/i, /^(?:%%*[^\n]*[\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:href[\s]+["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:call[\s]+)/i, /^(?:\([\s]*\))/i, /^(?:\()/i, /^(?:[^(]*)/i, /^(?:\))/i, /^(?:[^)]*)/i, /^(?:click[\s]+)/i, /^(?:[\s\n])/i, /^(?:[^\s\n]*)/i, /^(?:gantt\b)/i, /^(?:dateFormat\s[^#\n;]+)/i, /^(?:inclusiveEndDates\b)/i, /^(?:topAxis\b)/i, /^(?:axisFormat\s[^#\n;]+)/i, /^(?:includes\s[^#\n;]+)/i, /^(?:excludes\s[^#\n;]+)/i, /^(?:todayMarker\s[^\n;]+)/i, /^(?:\d\d\d\d-\d\d-\d\d\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accDescription\s[^#\n;]+)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "acc_descr_multiline": { "rules": [10, 11], "inclusive": false }, "acc_descr": { "rules": [8], "inclusive": false }, "acc_title": { "rules": [6], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "callbackargs": { "rules": [26, 27], "inclusive": false }, "callbackname": { "rules": [23, 24, 25], "inclusive": false }, "href": { "rules": [20, 21], "inclusive": false }, "click": { "rules": [29, 30], "inclusive": false }, "INITIAL": { "rules": [0, 5, 7, 9, 12, 13, 14, 15, 16, 17, 18, 19, 22, 28, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$6.parser = parser$6;
const ganttDetector = (txt) => {
  return txt.match(/^\s*gantt/) !== null;
};
let dateFormat = "";
let axisFormat = "";
let todayMarker = "";
let includes = [];
let excludes = [];
let links = {};
let sections$2 = [];
let tasks$1 = [];
let currentSection$1 = "";
const tags = ["active", "done", "crit", "milestone"];
let funs = [];
let inclusiveEndDates = false;
let topAxis = false;
let lastOrder = 0;
const parseDirective$6 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const clear$5 = function() {
  sections$2 = [];
  tasks$1 = [];
  currentSection$1 = "";
  funs = [];
  taskCnt = 0;
  lastTask = void 0;
  lastTaskID = void 0;
  rawTasks$1 = [];
  dateFormat = "";
  axisFormat = "";
  todayMarker = "";
  includes = [];
  excludes = [];
  inclusiveEndDates = false;
  topAxis = false;
  lastOrder = 0;
  links = {};
  clear$g();
};
const setAxisFormat = function(txt) {
  axisFormat = txt;
};
const getAxisFormat = function() {
  return axisFormat;
};
const setTodayMarker = function(txt) {
  todayMarker = txt;
};
const getTodayMarker = function() {
  return todayMarker;
};
const setDateFormat = function(txt) {
  dateFormat = txt;
};
const enableInclusiveEndDates = function() {
  inclusiveEndDates = true;
};
const endDatesAreInclusive = function() {
  return inclusiveEndDates;
};
const enableTopAxis = function() {
  topAxis = true;
};
const topAxisEnabled = function() {
  return topAxis;
};
const getDateFormat = function() {
  return dateFormat;
};
const setIncludes = function(txt) {
  includes = txt.toLowerCase().split(/[\s,]+/);
};
const getIncludes = function() {
  return includes;
};
const setExcludes = function(txt) {
  excludes = txt.toLowerCase().split(/[\s,]+/);
};
const getExcludes = function() {
  return excludes;
};
const getLinks = function() {
  return links;
};
const addSection$2 = function(txt) {
  currentSection$1 = txt;
  sections$2.push(txt);
};
const getSections$2 = function() {
  return sections$2;
};
const getTasks$1 = function() {
  let allItemsPricessed = compileTasks$1();
  const maxDepth2 = 10;
  let iterationCount = 0;
  while (!allItemsPricessed && iterationCount < maxDepth2) {
    allItemsPricessed = compileTasks$1();
    iterationCount++;
  }
  tasks$1 = rawTasks$1;
  return tasks$1;
};
const isInvalidDate = function(date2, dateFormat2, excludes2, includes2) {
  if (includes2.indexOf(date2.format(dateFormat2.trim())) >= 0) {
    return false;
  }
  if (date2.isoWeekday() >= 6 && excludes2.indexOf("weekends") >= 0) {
    return true;
  }
  if (excludes2.indexOf(date2.format("dddd").toLowerCase()) >= 0) {
    return true;
  }
  return excludes2.indexOf(date2.format(dateFormat2.trim())) >= 0;
};
const checkTaskDates = function(task, dateFormat2, excludes2, includes2) {
  if (!excludes2.length || task.manualEndTime)
    return;
  let startTime = moment(task.startTime, dateFormat2, true);
  startTime.add(1, "d");
  let endTime = moment(task.endTime, dateFormat2, true);
  let renderEndTime = fixTaskDates(startTime, endTime, dateFormat2, excludes2, includes2);
  task.endTime = endTime.toDate();
  task.renderEndTime = renderEndTime;
};
const fixTaskDates = function(startTime, endTime, dateFormat2, excludes2, includes2) {
  let invalid = false;
  let renderEndTime = null;
  while (startTime <= endTime) {
    if (!invalid) {
      renderEndTime = endTime.toDate();
    }
    invalid = isInvalidDate(startTime, dateFormat2, excludes2, includes2);
    if (invalid) {
      endTime.add(1, "d");
    }
    startTime.add(1, "d");
  }
  return renderEndTime;
};
const getStartDate = function(prevTime, dateFormat2, str) {
  str = str.trim();
  const re2 = /^after\s+([\d\w- ]+)/;
  const afterStatement = re2.exec(str.trim());
  if (afterStatement !== null) {
    let latestEndingTask = null;
    afterStatement[1].split(" ").forEach(function(id2) {
      let task = findTaskById(id2);
      if (typeof task !== "undefined") {
        if (!latestEndingTask) {
          latestEndingTask = task;
        } else {
          if (task.endTime > latestEndingTask.endTime) {
            latestEndingTask = task;
          }
        }
      }
    });
    if (!latestEndingTask) {
      const dt = new Date();
      dt.setHours(0, 0, 0, 0);
      return dt;
    } else {
      return latestEndingTask.endTime;
    }
  }
  let mDate = moment(str, dateFormat2.trim(), true);
  if (mDate.isValid()) {
    return mDate.toDate();
  } else {
    log$1.debug("Invalid date:" + str);
    log$1.debug("With date format:" + dateFormat2.trim());
    const d = new Date(str);
    if (typeof d === "undefined" || isNaN(d.getTime())) {
      throw new Error("Invalid date:" + str);
    }
    return d;
  }
};
const parseDuration = function(str) {
  const statement = /^(\d+(?:\.\d+)?)([yMwdhms]|ms)$/.exec(str.trim());
  if (statement !== null) {
    return moment.duration(Number.parseFloat(statement[1]), statement[2]);
  }
  return moment.duration.invalid();
};
const getEndDate = function(prevTime, dateFormat2, str, inclusive) {
  inclusive = inclusive || false;
  str = str.trim();
  let mDate = moment(str, dateFormat2.trim(), true);
  if (mDate.isValid()) {
    if (inclusive) {
      mDate.add(1, "d");
    }
    return mDate.toDate();
  }
  const endTime = moment(prevTime);
  const duration = parseDuration(str);
  if (duration.isValid()) {
    endTime.add(duration);
  }
  return endTime.toDate();
};
let taskCnt = 0;
const parseId = function(idStr) {
  if (typeof idStr === "undefined") {
    taskCnt = taskCnt + 1;
    return "task" + taskCnt;
  }
  return idStr;
};
const compileData = function(prevTask, dataStr) {
  let ds;
  if (dataStr.substr(0, 1) === ":") {
    ds = dataStr.substr(1, dataStr.length);
  } else {
    ds = dataStr;
  }
  const data = ds.split(",");
  const task = {};
  getTaskTags(data, task, tags);
  for (let i = 0; i < data.length; i++) {
    data[i] = data[i].trim();
  }
  let endTimeData = "";
  switch (data.length) {
    case 1:
      task.id = parseId();
      task.startTime = prevTask.endTime;
      endTimeData = data[0];
      break;
    case 2:
      task.id = parseId();
      task.startTime = getStartDate(void 0, dateFormat, data[0]);
      endTimeData = data[1];
      break;
    case 3:
      task.id = parseId(data[0]);
      task.startTime = getStartDate(void 0, dateFormat, data[1]);
      endTimeData = data[2];
      break;
  }
  if (endTimeData) {
    task.endTime = getEndDate(task.startTime, dateFormat, endTimeData, inclusiveEndDates);
    task.manualEndTime = moment(endTimeData, "YYYY-MM-DD", true).isValid();
    checkTaskDates(task, dateFormat, excludes, includes);
  }
  return task;
};
const parseData = function(prevTaskId, dataStr) {
  let ds;
  if (dataStr.substr(0, 1) === ":") {
    ds = dataStr.substr(1, dataStr.length);
  } else {
    ds = dataStr;
  }
  const data = ds.split(",");
  const task = {};
  getTaskTags(data, task, tags);
  for (let i = 0; i < data.length; i++) {
    data[i] = data[i].trim();
  }
  switch (data.length) {
    case 1:
      task.id = parseId();
      task.startTime = {
        type: "prevTaskEnd",
        id: prevTaskId
      };
      task.endTime = {
        data: data[0]
      };
      break;
    case 2:
      task.id = parseId();
      task.startTime = {
        type: "getStartDate",
        startData: data[0]
      };
      task.endTime = {
        data: data[1]
      };
      break;
    case 3:
      task.id = parseId(data[0]);
      task.startTime = {
        type: "getStartDate",
        startData: data[1]
      };
      task.endTime = {
        data: data[2]
      };
      break;
  }
  return task;
};
let lastTask;
let lastTaskID;
let rawTasks$1 = [];
const taskDb = {};
const addTask$1 = function(descr, data) {
  const rawTask = {
    section: currentSection$1,
    type: currentSection$1,
    processed: false,
    manualEndTime: false,
    renderEndTime: null,
    raw: { data },
    task: descr,
    classes: []
  };
  const taskInfo = parseData(lastTaskID, data);
  rawTask.raw.startTime = taskInfo.startTime;
  rawTask.raw.endTime = taskInfo.endTime;
  rawTask.id = taskInfo.id;
  rawTask.prevTaskId = lastTaskID;
  rawTask.active = taskInfo.active;
  rawTask.done = taskInfo.done;
  rawTask.crit = taskInfo.crit;
  rawTask.milestone = taskInfo.milestone;
  rawTask.order = lastOrder;
  lastOrder++;
  const pos = rawTasks$1.push(rawTask);
  lastTaskID = rawTask.id;
  taskDb[rawTask.id] = pos - 1;
};
const findTaskById = function(id2) {
  const pos = taskDb[id2];
  return rawTasks$1[pos];
};
const addTaskOrg$1 = function(descr, data) {
  const newTask = {
    section: currentSection$1,
    type: currentSection$1,
    description: descr,
    task: descr,
    classes: []
  };
  const taskInfo = compileData(lastTask, data);
  newTask.startTime = taskInfo.startTime;
  newTask.endTime = taskInfo.endTime;
  newTask.id = taskInfo.id;
  newTask.active = taskInfo.active;
  newTask.done = taskInfo.done;
  newTask.crit = taskInfo.crit;
  newTask.milestone = taskInfo.milestone;
  lastTask = newTask;
  tasks$1.push(newTask);
};
const compileTasks$1 = function() {
  const compileTask = function(pos) {
    const task = rawTasks$1[pos];
    let startTime = "";
    switch (rawTasks$1[pos].raw.startTime.type) {
      case "prevTaskEnd": {
        const prevTask = findTaskById(task.prevTaskId);
        task.startTime = prevTask.endTime;
        break;
      }
      case "getStartDate":
        startTime = getStartDate(void 0, dateFormat, rawTasks$1[pos].raw.startTime.startData);
        if (startTime) {
          rawTasks$1[pos].startTime = startTime;
        }
        break;
    }
    if (rawTasks$1[pos].startTime) {
      rawTasks$1[pos].endTime = getEndDate(
        rawTasks$1[pos].startTime,
        dateFormat,
        rawTasks$1[pos].raw.endTime.data,
        inclusiveEndDates
      );
      if (rawTasks$1[pos].endTime) {
        rawTasks$1[pos].processed = true;
        rawTasks$1[pos].manualEndTime = moment(
          rawTasks$1[pos].raw.endTime.data,
          "YYYY-MM-DD",
          true
        ).isValid();
        checkTaskDates(rawTasks$1[pos], dateFormat, excludes, includes);
      }
    }
    return rawTasks$1[pos].processed;
  };
  let allProcessed = true;
  for (let i = 0; i < rawTasks$1.length; i++) {
    compileTask(i);
    allProcessed = allProcessed && rawTasks$1[i].processed;
  }
  return allProcessed;
};
const setLink = function(ids, _linkStr) {
  let linkStr = _linkStr;
  if (getConfig$1().securityLevel !== "loose") {
    linkStr = sanitizeUrl_1(_linkStr);
  }
  ids.split(",").forEach(function(id2) {
    let rawTask = findTaskById(id2);
    if (typeof rawTask !== "undefined") {
      pushFun(id2, () => {
        window.open(linkStr, "_self");
      });
      links[id2] = linkStr;
    }
  });
  setClass(ids, "clickable");
};
const setClass = function(ids, className) {
  ids.split(",").forEach(function(id2) {
    let rawTask = findTaskById(id2);
    if (typeof rawTask !== "undefined") {
      rawTask.classes.push(className);
    }
  });
};
const setClickFun = function(id2, functionName, functionArgs) {
  if (getConfig$1().securityLevel !== "loose") {
    return;
  }
  if (typeof functionName === "undefined") {
    return;
  }
  let argList = [];
  if (typeof functionArgs === "string") {
    argList = functionArgs.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
    for (let i = 0; i < argList.length; i++) {
      let item = argList[i].trim();
      if (item.charAt(0) === '"' && item.charAt(item.length - 1) === '"') {
        item = item.substr(1, item.length - 2);
      }
      argList[i] = item;
    }
  }
  if (argList.length === 0) {
    argList.push(id2);
  }
  let rawTask = findTaskById(id2);
  if (typeof rawTask !== "undefined") {
    pushFun(id2, () => {
      utils.runFunc(functionName, ...argList);
    });
  }
};
const pushFun = function(id2, callbackFunction) {
  funs.push(function() {
    const elem = document.querySelector(`[id="${id2}"]`);
    if (elem !== null) {
      elem.addEventListener("click", function() {
        callbackFunction();
      });
    }
  });
  funs.push(function() {
    const elem = document.querySelector(`[id="${id2}-text"]`);
    if (elem !== null) {
      elem.addEventListener("click", function() {
        callbackFunction();
      });
    }
  });
};
const setClickEvent = function(ids, functionName, functionArgs) {
  ids.split(",").forEach(function(id2) {
    setClickFun(id2, functionName, functionArgs);
  });
  setClass(ids, "clickable");
};
const bindFunctions = function(element) {
  funs.forEach(function(fun) {
    fun(element);
  });
};
const ganttDb = {
  parseDirective: parseDirective$6,
  getConfig: () => getConfig$1().gantt,
  clear: clear$5,
  setDateFormat,
  getDateFormat,
  enableInclusiveEndDates,
  endDatesAreInclusive,
  enableTopAxis,
  topAxisEnabled,
  setAxisFormat,
  getAxisFormat,
  setTodayMarker,
  getTodayMarker,
  setAccTitle,
  getAccTitle,
  setDiagramTitle,
  getDiagramTitle,
  setAccDescription,
  getAccDescription,
  addSection: addSection$2,
  getSections: getSections$2,
  getTasks: getTasks$1,
  addTask: addTask$1,
  findTaskById,
  addTaskOrg: addTaskOrg$1,
  setIncludes,
  getIncludes,
  setExcludes,
  getExcludes,
  setClickEvent,
  setLink,
  getLinks,
  bindFunctions,
  parseDuration,
  isInvalidDate
};
function getTaskTags(data, task, tags2) {
  let matchFound = true;
  while (matchFound) {
    matchFound = false;
    tags2.forEach(function(t) {
      const pattern = "^\\s*" + t + "\\s*$";
      const regex = new RegExp(pattern);
      if (data[0].match(regex)) {
        task[t] = true;
        data.shift(1);
        matchFound = true;
      }
    });
  }
}
const setConf$5 = function() {
  log$1.debug("Something is calling, setConf, remove the call");
};
let w;
const draw$8 = function(text2, id2, version2, diagObj) {
  const conf2 = getConfig$1().gantt;
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  const elem = doc.getElementById(id2);
  w = elem.parentElement.offsetWidth;
  if (typeof w === "undefined") {
    w = 1200;
  }
  if (typeof conf2.useWidth !== "undefined") {
    w = conf2.useWidth;
  }
  const taskArray = diagObj.db.getTasks();
  const h = taskArray.length * (conf2.barHeight + conf2.barGap) + 2 * conf2.topPadding;
  elem.setAttribute("viewBox", "0 0 " + w + " " + h);
  const svg2 = root2.select(`[id="${id2}"]`);
  const timeScale = time$2().domain([
    min$3(taskArray, function(d) {
      return d.startTime;
    }),
    max$4(taskArray, function(d) {
      return d.endTime;
    })
  ]).rangeRound([0, w - conf2.leftPadding - conf2.rightPadding]);
  let categories = [];
  for (let i = 0; i < taskArray.length; i++) {
    categories.push(taskArray[i].type);
  }
  const catsUnfiltered = categories;
  categories = checkUnique(categories);
  function taskCompare(a2, b) {
    const taskA = a2.startTime;
    const taskB = b.startTime;
    let result = 0;
    if (taskA > taskB) {
      result = 1;
    } else if (taskA < taskB) {
      result = -1;
    }
    return result;
  }
  taskArray.sort(taskCompare);
  makeGant(taskArray, w, h);
  configureSvgSize(svg2, h, w, conf2.useMaxWidth);
  svg2.append("text").text(diagObj.db.getDiagramTitle()).attr("x", w / 2).attr("y", conf2.titleTopMargin).attr("class", "titleText");
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
  function makeGant(tasks2, pageWidth, pageHeight) {
    const barHeight = conf2.barHeight;
    const gap = barHeight + conf2.barGap;
    const topPadding = conf2.topPadding;
    const leftPadding = conf2.leftPadding;
    const colorScale = linear$3().domain([0, categories.length]).range(["#00B9FA", "#F95002"]).interpolate(interpolateHcl);
    drawExcludeDays(
      gap,
      topPadding,
      leftPadding,
      pageWidth,
      pageHeight,
      tasks2,
      diagObj.db.getExcludes(),
      diagObj.db.getIncludes()
    );
    makeGrid(leftPadding, topPadding, pageWidth, pageHeight);
    drawRects(tasks2, gap, topPadding, leftPadding, barHeight, colorScale, pageWidth);
    vertLabels(gap, topPadding);
    drawToday(leftPadding, topPadding, pageWidth, pageHeight);
  }
  function drawRects(theArray, theGap, theTopPad, theSidePad, theBarHeight, theColorScale, w2) {
    svg2.append("g").selectAll("rect").data(theArray).enter().append("rect").attr("x", 0).attr("y", function(d, i) {
      i = d.order;
      return i * theGap + theTopPad - 2;
    }).attr("width", function() {
      return w2 - conf2.rightPadding / 2;
    }).attr("height", theGap).attr("class", function(d) {
      for (let i = 0; i < categories.length; i++) {
        if (d.type === categories[i]) {
          return "section section" + i % conf2.numberSectionStyles;
        }
      }
      return "section section0";
    });
    const rectangles = svg2.append("g").selectAll("rect").data(theArray).enter();
    const links2 = diagObj.db.getLinks();
    rectangles.append("rect").attr("id", function(d) {
      return d.id;
    }).attr("rx", 3).attr("ry", 3).attr("x", function(d) {
      if (d.milestone) {
        return timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
      }
      return timeScale(d.startTime) + theSidePad;
    }).attr("y", function(d, i) {
      i = d.order;
      return i * theGap + theTopPad;
    }).attr("width", function(d) {
      if (d.milestone) {
        return theBarHeight;
      }
      return timeScale(d.renderEndTime || d.endTime) - timeScale(d.startTime);
    }).attr("height", theBarHeight).attr("transform-origin", function(d, i) {
      i = d.order;
      return (timeScale(d.startTime) + theSidePad + 0.5 * (timeScale(d.endTime) - timeScale(d.startTime))).toString() + "px " + (i * theGap + theTopPad + 0.5 * theBarHeight).toString() + "px";
    }).attr("class", function(d) {
      const res = "task";
      let classStr = "";
      if (d.classes.length > 0) {
        classStr = d.classes.join(" ");
      }
      let secNum = 0;
      for (let i = 0; i < categories.length; i++) {
        if (d.type === categories[i]) {
          secNum = i % conf2.numberSectionStyles;
        }
      }
      let taskClass = "";
      if (d.active) {
        if (d.crit) {
          taskClass += " activeCrit";
        } else {
          taskClass = " active";
        }
      } else if (d.done) {
        if (d.crit) {
          taskClass = " doneCrit";
        } else {
          taskClass = " done";
        }
      } else {
        if (d.crit) {
          taskClass += " crit";
        }
      }
      if (taskClass.length === 0) {
        taskClass = " task";
      }
      if (d.milestone) {
        taskClass = " milestone " + taskClass;
      }
      taskClass += secNum;
      taskClass += " " + classStr;
      return res + taskClass;
    });
    rectangles.append("text").attr("id", function(d) {
      return d.id + "-text";
    }).text(function(d) {
      return d.task;
    }).attr("font-size", conf2.fontSize).attr("x", function(d) {
      let startX = timeScale(d.startTime);
      let endX = timeScale(d.renderEndTime || d.endTime);
      if (d.milestone) {
        startX += 0.5 * (timeScale(d.endTime) - timeScale(d.startTime)) - 0.5 * theBarHeight;
      }
      if (d.milestone) {
        endX = startX + theBarHeight;
      }
      const textWidth = this.getBBox().width;
      if (textWidth > endX - startX) {
        if (endX + textWidth + 1.5 * conf2.leftPadding > w2) {
          return startX + theSidePad - 5;
        } else {
          return endX + theSidePad + 5;
        }
      } else {
        return (endX - startX) / 2 + startX + theSidePad;
      }
    }).attr("y", function(d, i) {
      i = d.order;
      return i * theGap + conf2.barHeight / 2 + (conf2.fontSize / 2 - 2) + theTopPad;
    }).attr("text-height", theBarHeight).attr("class", function(d) {
      const startX = timeScale(d.startTime);
      let endX = timeScale(d.endTime);
      if (d.milestone) {
        endX = startX + theBarHeight;
      }
      const textWidth = this.getBBox().width;
      let classStr = "";
      if (d.classes.length > 0) {
        classStr = d.classes.join(" ");
      }
      let secNum = 0;
      for (let i = 0; i < categories.length; i++) {
        if (d.type === categories[i]) {
          secNum = i % conf2.numberSectionStyles;
        }
      }
      let taskType = "";
      if (d.active) {
        if (d.crit) {
          taskType = "activeCritText" + secNum;
        } else {
          taskType = "activeText" + secNum;
        }
      }
      if (d.done) {
        if (d.crit) {
          taskType = taskType + " doneCritText" + secNum;
        } else {
          taskType = taskType + " doneText" + secNum;
        }
      } else {
        if (d.crit) {
          taskType = taskType + " critText" + secNum;
        }
      }
      if (d.milestone) {
        taskType += " milestoneText";
      }
      if (textWidth > endX - startX) {
        if (endX + textWidth + 1.5 * conf2.leftPadding > w2) {
          return classStr + " taskTextOutsideLeft taskTextOutside" + secNum + " " + taskType;
        } else {
          return classStr + " taskTextOutsideRight taskTextOutside" + secNum + " " + taskType + " width-" + textWidth;
        }
      } else {
        return classStr + " taskText taskText" + secNum + " " + taskType + " width-" + textWidth;
      }
    });
    const securityLevel2 = getConfig$1().securityLevel;
    if (securityLevel2 === "sandbox") {
      let sandboxElement2;
      sandboxElement2 = select$1("#i" + id2);
      const doc2 = sandboxElement2.nodes()[0].contentDocument;
      rectangles.filter(function(d) {
        return typeof links2[d.id] !== "undefined";
      }).each(function(o) {
        var taskRect = doc2.querySelector("#" + o.id);
        var taskText = doc2.querySelector("#" + o.id + "-text");
        const oldParent = taskRect.parentNode;
        var Link = doc2.createElement("a");
        Link.setAttribute("xlink:href", links2[o.id]);
        Link.setAttribute("target", "_top");
        oldParent.appendChild(Link);
        Link.appendChild(taskRect);
        Link.appendChild(taskText);
      });
    }
  }
  function drawExcludeDays(theGap, theTopPad, theSidePad, w2, h2, tasks2, excludes2, includes2) {
    const minTime = tasks2.reduce(
      (min2, { startTime }) => min2 ? Math.min(min2, startTime) : startTime,
      0
    );
    const maxTime = tasks2.reduce((max2, { endTime }) => max2 ? Math.max(max2, endTime) : endTime, 0);
    const dateFormat2 = diagObj.db.getDateFormat();
    if (!minTime || !maxTime)
      return;
    const excludeRanges = [];
    let range2 = null;
    let d = moment(minTime);
    while (d.valueOf() <= maxTime) {
      if (diagObj.db.isInvalidDate(d, dateFormat2, excludes2, includes2)) {
        if (!range2) {
          range2 = {
            start: d.clone(),
            end: d.clone()
          };
        } else {
          range2.end = d.clone();
        }
      } else {
        if (range2) {
          excludeRanges.push(range2);
          range2 = null;
        }
      }
      d.add(1, "d");
    }
    const rectangles = svg2.append("g").selectAll("rect").data(excludeRanges).enter();
    rectangles.append("rect").attr("id", function(d2) {
      return "exclude-" + d2.start.format("YYYY-MM-DD");
    }).attr("x", function(d2) {
      return timeScale(d2.start) + theSidePad;
    }).attr("y", conf2.gridLineStartPadding).attr("width", function(d2) {
      const renderEnd = d2.end.clone().add(1, "day");
      return timeScale(renderEnd) - timeScale(d2.start);
    }).attr("height", h2 - theTopPad - conf2.gridLineStartPadding).attr("transform-origin", function(d2, i) {
      return (timeScale(d2.start) + theSidePad + 0.5 * (timeScale(d2.end) - timeScale(d2.start))).toString() + "px " + (i * theGap + 0.5 * h2).toString() + "px";
    }).attr("class", "exclude-range");
  }
  function makeGrid(theSidePad, theTopPad, w2, h2) {
    let bottomXAxis = axisBottom$1(timeScale).tickSize(-h2 + theTopPad + conf2.gridLineStartPadding).tickFormat(timeFormat$1(diagObj.db.getAxisFormat() || conf2.axisFormat || "%Y-%m-%d"));
    svg2.append("g").attr("class", "grid").attr("transform", "translate(" + theSidePad + ", " + (h2 - 50) + ")").call(bottomXAxis).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10).attr("dy", "1em");
    if (diagObj.db.topAxisEnabled() || conf2.topAxis) {
      let topXAxis = axisTop$1(timeScale).tickSize(-h2 + theTopPad + conf2.gridLineStartPadding).tickFormat(timeFormat$1(diagObj.db.getAxisFormat() || conf2.axisFormat || "%Y-%m-%d"));
      svg2.append("g").attr("class", "grid").attr("transform", "translate(" + theSidePad + ", " + theTopPad + ")").call(topXAxis).selectAll("text").style("text-anchor", "middle").attr("fill", "#000").attr("stroke", "none").attr("font-size", 10);
    }
  }
  function vertLabels(theGap, theTopPad) {
    const numOccurances = [];
    let prevGap = 0;
    for (let i = 0; i < categories.length; i++) {
      numOccurances[i] = [categories[i], getCount(categories[i], catsUnfiltered)];
    }
    svg2.append("g").selectAll("text").data(numOccurances).enter().append(function(d) {
      const rows = d[0].split(common.lineBreakRegex);
      const dy = -(rows.length - 1) / 2;
      const svgLabel = doc.createElementNS("http://www.w3.org/2000/svg", "text");
      svgLabel.setAttribute("dy", dy + "em");
      for (let j = 0; j < rows.length; j++) {
        const tspan = doc.createElementNS("http://www.w3.org/2000/svg", "tspan");
        tspan.setAttribute("alignment-baseline", "central");
        tspan.setAttribute("x", "10");
        if (j > 0)
          tspan.setAttribute("dy", "1em");
        tspan.textContent = rows[j];
        svgLabel.appendChild(tspan);
      }
      return svgLabel;
    }).attr("x", 10).attr("y", function(d, i) {
      if (i > 0) {
        for (let j = 0; j < i; j++) {
          prevGap += numOccurances[i - 1][1];
          return d[1] * theGap / 2 + prevGap * theGap + theTopPad;
        }
      } else {
        return d[1] * theGap / 2 + theTopPad;
      }
    }).attr("font-size", conf2.sectionFontSize).attr("font-size", conf2.sectionFontSize).attr("class", function(d) {
      for (let i = 0; i < categories.length; i++) {
        if (d[0] === categories[i]) {
          return "sectionTitle sectionTitle" + i % conf2.numberSectionStyles;
        }
      }
      return "sectionTitle";
    });
  }
  function drawToday(theSidePad, theTopPad, w2, h2) {
    const todayMarker2 = diagObj.db.getTodayMarker();
    if (todayMarker2 === "off") {
      return;
    }
    const todayG = svg2.append("g").attr("class", "today");
    const today = new Date();
    const todayLine = todayG.append("line");
    todayLine.attr("x1", timeScale(today) + theSidePad).attr("x2", timeScale(today) + theSidePad).attr("y1", conf2.titleTopMargin).attr("y2", h2 - conf2.titleTopMargin).attr("class", "today");
    if (todayMarker2 !== "") {
      todayLine.attr("style", todayMarker2.replace(/,/g, ";"));
    }
  }
  function checkUnique(arr) {
    const hash = {};
    const result = [];
    for (let i = 0, l = arr.length; i < l; ++i) {
      if (!Object.prototype.hasOwnProperty.call(hash, arr[i])) {
        hash[arr[i]] = true;
        result.push(arr[i]);
      }
    }
    return result;
  }
  function getCounts(arr) {
    let i = arr.length;
    const obj = {};
    while (i) {
      obj[arr[--i]] = (obj[arr[i]] || 0) + 1;
    }
    return obj;
  }
  function getCount(word, arr) {
    return getCounts(arr)[word] || 0;
  }
};
const ganttRenderer = {
  setConf: setConf$5,
  draw: draw$8
};
var parser$5 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [6, 9, 10];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "info": 4, "document": 5, "EOF": 6, "line": 7, "statement": 8, "NL": 9, "showInfo": 10, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "info", 6: "EOF", 9: "NL", 10: "showInfo" },
    productions_: [0, [3, 3], [5, 0], [5, 2], [7, 1], [7, 1], [8, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      $$.length - 1;
      switch (yystate) {
        case 1:
          return yy;
        case 4:
          break;
        case 6:
          yy.setInfo(true);
          break;
      }
    },
    table: [{ 3: 1, 4: [1, 2] }, { 1: [3] }, o($V0, [2, 2], { 5: 3 }), { 6: [1, 4], 7: 5, 8: 6, 9: [1, 7], 10: [1, 8] }, { 1: [2, 1] }, o($V0, [2, 3]), o($V0, [2, 4]), o($V0, [2, 5]), o($V0, [2, 6])],
    defaultActions: { 4: [2, 1] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            return 4;
          case 1:
            return 9;
          case 2:
            return "space";
          case 3:
            return 10;
          case 4:
            return 6;
          case 5:
            return "TXT";
        }
      },
      rules: [/^(?:info\b)/i, /^(?:[\s\n\r]+)/i, /^(?:[\s]+)/i, /^(?:showInfo\b)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "INITIAL": { "rules": [0, 1, 2, 3, 4, 5], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$5.parser = parser$5;
var message = "";
var info = false;
const setMessage = (txt) => {
  log$1.debug("Setting message to: " + txt);
  message = txt;
};
const getMessage = () => {
  return message;
};
const setInfo = (inf) => {
  info = inf;
};
const getInfo = () => {
  return info;
};
const infoDb = {
  setMessage,
  getMessage,
  setInfo,
  getInfo,
  clear: clear$g
};
const draw$7 = (text2, id2, version2, diagObj) => {
  try {
    log$1.debug("Rendering info diagram\n" + text2);
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select$1("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
    const svg2 = root2.select("#" + id2);
    const g = svg2.append("g");
    g.append("text").attr("x", 100).attr("y", 40).attr("class", "version").attr("font-size", "32px").style("text-anchor", "middle").text("v " + version2);
    svg2.attr("height", 100);
    svg2.attr("width", 400);
  } catch (e) {
    log$1.error("Error while rendering info diagram");
    log$1.error(e.message);
  }
};
const infoRenderer = {
  draw: draw$7
};
const infoDetector = (txt) => {
  return txt.match(/^\s*info/) !== null;
};
var parser$4 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 4], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 9], $V5 = [1, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], $V6 = [2, 5], $V7 = [1, 6, 11, 13, 15, 17, 19, 20, 26, 27, 28, 29], $V8 = [26, 27, 28], $V9 = [2, 8], $Va = [1, 18], $Vb = [1, 19], $Vc = [1, 20], $Vd = [1, 21], $Ve = [1, 22], $Vf = [1, 23], $Vg = [1, 28], $Vh = [6, 26, 27, 28, 29];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "eol": 4, "directive": 5, "PIE": 6, "document": 7, "showData": 8, "line": 9, "statement": 10, "txt": 11, "value": 12, "title": 13, "title_value": 14, "acc_title": 15, "acc_title_value": 16, "acc_descr": 17, "acc_descr_value": 18, "acc_descr_multiline_value": 19, "section": 20, "openDirective": 21, "typeDirective": 22, "closeDirective": 23, ":": 24, "argDirective": 25, "NEWLINE": 26, ";": 27, "EOF": 28, "open_directive": 29, "type_directive": 30, "arg_directive": 31, "close_directive": 32, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 6: "PIE", 8: "showData", 11: "txt", 12: "value", 13: "title", 14: "title_value", 15: "acc_title", 16: "acc_title_value", 17: "acc_descr", 18: "acc_descr_value", 19: "acc_descr_multiline_value", 20: "section", 24: ":", 26: "NEWLINE", 27: ";", 28: "EOF", 29: "open_directive", 30: "type_directive", 31: "arg_directive", 32: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 3], [7, 0], [7, 2], [9, 2], [10, 0], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 1], [5, 3], [5, 5], [4, 1], [4, 1], [4, 1], [21, 1], [22, 1], [25, 1], [23, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.setShowData(true);
          break;
        case 7:
          this.$ = $$[$0 - 1];
          break;
        case 9:
          yy.addSection($$[$0 - 1], yy.cleanupValue($$[$0]));
          break;
        case 10:
          this.$ = $$[$0].trim();
          yy.setDiagramTitle(this.$);
          break;
        case 11:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 12:
        case 13:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 14:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 21:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 22:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 23:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 24:
          yy.parseDirective("}%%", "close_directive", "pie");
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, { 3: 11, 4: 2, 5: 3, 6: $V0, 21: 8, 26: $V1, 27: $V2, 28: $V3, 29: $V4 }, o($V5, $V6, { 7: 12, 8: [1, 13] }), o($V7, [2, 18]), o($V7, [2, 19]), o($V7, [2, 20]), { 22: 14, 30: [1, 15] }, { 30: [2, 21] }, { 1: [2, 1] }, { 1: [2, 2] }, o($V8, $V9, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 3], 11: $Va, 13: $Vb, 15: $Vc, 17: $Vd, 19: $Ve, 20: $Vf, 29: $V4 }), o($V5, $V6, { 7: 25 }), { 23: 26, 24: [1, 27], 32: $Vg }, o([24, 32], [2, 22]), o($V5, [2, 6]), { 4: 29, 26: $V1, 27: $V2, 28: $V3 }, { 12: [1, 30] }, { 14: [1, 31] }, { 16: [1, 32] }, { 18: [1, 33] }, o($V8, [2, 13]), o($V8, [2, 14]), o($V8, [2, 15]), o($V8, $V9, { 21: 8, 9: 16, 10: 17, 5: 24, 1: [2, 4], 11: $Va, 13: $Vb, 15: $Vc, 17: $Vd, 19: $Ve, 20: $Vf, 29: $V4 }), o($Vh, [2, 16]), { 25: 34, 31: [1, 35] }, o($Vh, [2, 24]), o($V5, [2, 7]), o($V8, [2, 9]), o($V8, [2, 10]), o($V8, [2, 11]), o($V8, [2, 12]), { 23: 36, 32: $Vg }, { 32: [2, 23] }, o($Vh, [2, 17])],
    defaultActions: { 9: [2, 21], 10: [2, 1], 11: [2, 2], 35: [2, 23] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 29;
          case 1:
            this.begin("type_directive");
            return 30;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 24;
          case 3:
            this.popState();
            this.popState();
            return 32;
          case 4:
            return 31;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 26;
          case 8:
            break;
          case 9:
            break;
          case 10:
            this.begin("title");
            return 13;
          case 11:
            this.popState();
            return "title_value";
          case 12:
            this.begin("acc_title");
            return 15;
          case 13:
            this.popState();
            return "acc_title_value";
          case 14:
            this.begin("acc_descr");
            return 17;
          case 15:
            this.popState();
            return "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            this.begin("string");
            break;
          case 20:
            this.popState();
            break;
          case 21:
            return "txt";
          case 22:
            return 6;
          case 23:
            return 8;
          case 24:
            return "value";
          case 25:
            return 28;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n\r]+)/i, /^(?:%%[^\n]*)/i, /^(?:[\s]+)/i, /^(?:title\b)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:pie\b)/i, /^(?:showData\b)/i, /^(?::[\s]*[\d]+(?:\.[\d]+)?)/i, /^(?:$)/i],
      conditions: { "acc_descr_multiline": { "rules": [17, 18], "inclusive": false }, "acc_descr": { "rules": [15], "inclusive": false }, "acc_title": { "rules": [13], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "title": { "rules": [11], "inclusive": false }, "string": { "rules": [20, 21], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 8, 9, 10, 12, 14, 16, 19, 22, 23, 24, 25], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$4.parser = parser$4;
const pieDetector = (txt) => {
  return txt.match(/^\s*pie/) !== null;
};
let sections$1 = {};
let showData = false;
const parseDirective$5 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addSection$1 = function(id2, value) {
  id2 = common.sanitizeText(id2, getConfig$1());
  if (typeof sections$1[id2] === "undefined") {
    sections$1[id2] = value;
    log$1.debug("Added new section :", id2);
  }
};
const getSections$1 = () => sections$1;
const setShowData = function(toggle) {
  showData = toggle;
};
const getShowData = function() {
  return showData;
};
const cleanupValue = function(value) {
  if (value.substring(0, 1) === ":") {
    value = value.substring(1).trim();
    return Number(value.trim());
  } else {
    return Number(value.trim());
  }
};
const clear$4 = function() {
  sections$1 = {};
  showData = false;
  clear$g();
};
const pieDb = {
  parseDirective: parseDirective$5,
  getConfig: () => getConfig$1().pie,
  addSection: addSection$1,
  getSections: getSections$1,
  cleanupValue,
  clear: clear$4,
  setAccTitle,
  getAccTitle,
  setDiagramTitle,
  getDiagramTitle,
  setShowData,
  getShowData,
  getAccDescription,
  setAccDescription
};
let conf$6 = getConfig$1();
let width;
const height = 450;
const draw$6 = (txt, id2, _version, diagObj) => {
  try {
    conf$6 = getConfig$1();
    log$1.debug("Rendering info diagram\n" + txt);
    const securityLevel = getConfig$1().securityLevel;
    let sandboxElement;
    if (securityLevel === "sandbox") {
      sandboxElement = select$1("#i" + id2);
    }
    const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
    const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
    diagObj.db.clear();
    diagObj.parser.parse(txt);
    log$1.debug("Parsed info diagram");
    const elem = doc.getElementById(id2);
    width = elem.parentElement.offsetWidth;
    if (typeof width === "undefined") {
      width = 1200;
    }
    if (typeof conf$6.useWidth !== "undefined") {
      width = conf$6.useWidth;
    }
    if (typeof conf$6.pie.useWidth !== "undefined") {
      width = conf$6.pie.useWidth;
    }
    const diagram = root2.select("#" + id2);
    configureSvgSize(diagram, height, width, conf$6.pie.useMaxWidth);
    addSVGAccessibilityFields(diagObj.db, diagram, id2);
    elem.setAttribute("viewBox", "0 0 " + width + " " + height);
    var margin = 40;
    var legendRectSize = 18;
    var legendSpacing = 4;
    var radius = Math.min(width, height) / 2 - margin;
    var svg2 = diagram.append("g").attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");
    var data = diagObj.db.getSections();
    var sum2 = 0;
    Object.keys(data).forEach(function(key) {
      sum2 += data[key];
    });
    const themeVariables = conf$6.themeVariables;
    var myGeneratedColors = [
      themeVariables.pie1,
      themeVariables.pie2,
      themeVariables.pie3,
      themeVariables.pie4,
      themeVariables.pie5,
      themeVariables.pie6,
      themeVariables.pie7,
      themeVariables.pie8,
      themeVariables.pie9,
      themeVariables.pie10,
      themeVariables.pie11,
      themeVariables.pie12
    ];
    var color2 = ordinal$1().range(myGeneratedColors);
    var pie$1$1 = pie$1().value(function(d) {
      return d[1];
    });
    var dataReady = pie$1$1(Object.entries(data));
    var arcGenerator = arc$1().innerRadius(0).outerRadius(radius);
    svg2.selectAll("mySlices").data(dataReady).enter().append("path").attr("d", arcGenerator).attr("fill", function(d) {
      return color2(d.data[0]);
    }).attr("class", "pieCircle");
    svg2.selectAll("mySlices").data(dataReady).enter().append("text").text(function(d) {
      return (d.data[1] / sum2 * 100).toFixed(0) + "%";
    }).attr("transform", function(d) {
      return "translate(" + arcGenerator.centroid(d) + ")";
    }).style("text-anchor", "middle").attr("class", "slice");
    svg2.append("text").text(diagObj.db.getDiagramTitle()).attr("x", 0).attr("y", -(height - 50) / 2).attr("class", "pieTitleText");
    var legend = svg2.selectAll(".legend").data(color2.domain()).enter().append("g").attr("class", "legend").attr("transform", function(d, i) {
      var height2 = legendRectSize + legendSpacing;
      var offset = height2 * color2.domain().length / 2;
      var horz = 12 * legendRectSize;
      var vert = i * height2 - offset;
      return "translate(" + horz + "," + vert + ")";
    });
    legend.append("rect").attr("width", legendRectSize).attr("height", legendRectSize).style("fill", color2).style("stroke", color2);
    legend.data(dataReady).append("text").attr("x", legendRectSize + legendSpacing).attr("y", legendRectSize - legendSpacing).text(function(d) {
      if (diagObj.db.getShowData() || conf$6.showData || conf$6.pie.showData) {
        return d.data[0] + " [" + d.data[1] + "]";
      } else {
        return d.data[0];
      }
    });
  } catch (e) {
    log$1.error("Error while rendering info diagram");
    log$1.error(e);
  }
};
const pieRenderer = {
  draw: draw$6
};
var parser$3 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 3], $V1 = [1, 5], $V2 = [1, 6], $V3 = [1, 7], $V4 = [1, 8], $V5 = [5, 6, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72], $V6 = [1, 22], $V7 = [2, 13], $V8 = [1, 26], $V9 = [1, 27], $Va = [1, 28], $Vb = [1, 29], $Vc = [1, 30], $Vd = [1, 31], $Ve = [1, 24], $Vf = [1, 32], $Vg = [1, 33], $Vh = [1, 36], $Vi = [71, 72], $Vj = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 60, 62, 71, 72], $Vk = [1, 56], $Vl = [1, 57], $Vm = [1, 58], $Vn = [1, 59], $Vo = [1, 60], $Vp = [1, 61], $Vq = [1, 62], $Vr = [62, 63], $Vs = [1, 74], $Vt = [1, 70], $Vu = [1, 71], $Vv = [1, 72], $Vw = [1, 73], $Vx = [1, 75], $Vy = [1, 79], $Vz = [1, 80], $VA = [1, 77], $VB = [1, 78], $VC = [5, 8, 14, 16, 18, 19, 40, 41, 42, 43, 44, 45, 53, 71, 72];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "directive": 4, "NEWLINE": 5, "RD": 6, "diagram": 7, "EOF": 8, "openDirective": 9, "typeDirective": 10, "closeDirective": 11, ":": 12, "argDirective": 13, "acc_title": 14, "acc_title_value": 15, "acc_descr": 16, "acc_descr_value": 17, "acc_descr_multiline_value": 18, "open_directive": 19, "type_directive": 20, "arg_directive": 21, "close_directive": 22, "requirementDef": 23, "elementDef": 24, "relationshipDef": 25, "requirementType": 26, "requirementName": 27, "STRUCT_START": 28, "requirementBody": 29, "ID": 30, "COLONSEP": 31, "id": 32, "TEXT": 33, "text": 34, "RISK": 35, "riskLevel": 36, "VERIFYMTHD": 37, "verifyType": 38, "STRUCT_STOP": 39, "REQUIREMENT": 40, "FUNCTIONAL_REQUIREMENT": 41, "INTERFACE_REQUIREMENT": 42, "PERFORMANCE_REQUIREMENT": 43, "PHYSICAL_REQUIREMENT": 44, "DESIGN_CONSTRAINT": 45, "LOW_RISK": 46, "MED_RISK": 47, "HIGH_RISK": 48, "VERIFY_ANALYSIS": 49, "VERIFY_DEMONSTRATION": 50, "VERIFY_INSPECTION": 51, "VERIFY_TEST": 52, "ELEMENT": 53, "elementName": 54, "elementBody": 55, "TYPE": 56, "type": 57, "DOCREF": 58, "ref": 59, "END_ARROW_L": 60, "relationship": 61, "LINE": 62, "END_ARROW_R": 63, "CONTAINS": 64, "COPIES": 65, "DERIVES": 66, "SATISFIES": 67, "VERIFIES": 68, "REFINES": 69, "TRACES": 70, "unqString": 71, "qString": 72, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 5: "NEWLINE", 6: "RD", 8: "EOF", 12: ":", 14: "acc_title", 15: "acc_title_value", 16: "acc_descr", 17: "acc_descr_value", 18: "acc_descr_multiline_value", 19: "open_directive", 20: "type_directive", 21: "arg_directive", 22: "close_directive", 28: "STRUCT_START", 30: "ID", 31: "COLONSEP", 33: "TEXT", 35: "RISK", 37: "VERIFYMTHD", 39: "STRUCT_STOP", 40: "REQUIREMENT", 41: "FUNCTIONAL_REQUIREMENT", 42: "INTERFACE_REQUIREMENT", 43: "PERFORMANCE_REQUIREMENT", 44: "PHYSICAL_REQUIREMENT", 45: "DESIGN_CONSTRAINT", 46: "LOW_RISK", 47: "MED_RISK", 48: "HIGH_RISK", 49: "VERIFY_ANALYSIS", 50: "VERIFY_DEMONSTRATION", 51: "VERIFY_INSPECTION", 52: "VERIFY_TEST", 53: "ELEMENT", 56: "TYPE", 58: "DOCREF", 60: "END_ARROW_L", 62: "LINE", 63: "END_ARROW_R", 64: "CONTAINS", 65: "COPIES", 66: "DERIVES", 67: "SATISFIES", 68: "VERIFIES", 69: "REFINES", 70: "TRACES", 71: "unqString", 72: "qString" },
    productions_: [0, [3, 3], [3, 2], [3, 4], [4, 3], [4, 5], [4, 2], [4, 2], [4, 1], [9, 1], [10, 1], [13, 1], [11, 1], [7, 0], [7, 2], [7, 2], [7, 2], [7, 2], [7, 2], [23, 5], [29, 5], [29, 5], [29, 5], [29, 5], [29, 2], [29, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [26, 1], [36, 1], [36, 1], [36, 1], [38, 1], [38, 1], [38, 1], [38, 1], [24, 5], [55, 5], [55, 5], [55, 2], [55, 1], [25, 5], [25, 5], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [61, 1], [27, 1], [27, 1], [32, 1], [32, 1], [34, 1], [34, 1], [54, 1], [54, 1], [57, 1], [57, 1], [59, 1], [59, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 6:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 7:
        case 8:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 9:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 10:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 11:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 12:
          yy.parseDirective("}%%", "close_directive", "pie");
          break;
        case 13:
          this.$ = [];
          break;
        case 19:
          yy.addRequirement($$[$0 - 3], $$[$0 - 4]);
          break;
        case 20:
          yy.setNewReqId($$[$0 - 2]);
          break;
        case 21:
          yy.setNewReqText($$[$0 - 2]);
          break;
        case 22:
          yy.setNewReqRisk($$[$0 - 2]);
          break;
        case 23:
          yy.setNewReqVerifyMethod($$[$0 - 2]);
          break;
        case 26:
          this.$ = yy.RequirementType.REQUIREMENT;
          break;
        case 27:
          this.$ = yy.RequirementType.FUNCTIONAL_REQUIREMENT;
          break;
        case 28:
          this.$ = yy.RequirementType.INTERFACE_REQUIREMENT;
          break;
        case 29:
          this.$ = yy.RequirementType.PERFORMANCE_REQUIREMENT;
          break;
        case 30:
          this.$ = yy.RequirementType.PHYSICAL_REQUIREMENT;
          break;
        case 31:
          this.$ = yy.RequirementType.DESIGN_CONSTRAINT;
          break;
        case 32:
          this.$ = yy.RiskLevel.LOW_RISK;
          break;
        case 33:
          this.$ = yy.RiskLevel.MED_RISK;
          break;
        case 34:
          this.$ = yy.RiskLevel.HIGH_RISK;
          break;
        case 35:
          this.$ = yy.VerifyType.VERIFY_ANALYSIS;
          break;
        case 36:
          this.$ = yy.VerifyType.VERIFY_DEMONSTRATION;
          break;
        case 37:
          this.$ = yy.VerifyType.VERIFY_INSPECTION;
          break;
        case 38:
          this.$ = yy.VerifyType.VERIFY_TEST;
          break;
        case 39:
          yy.addElement($$[$0 - 3]);
          break;
        case 40:
          yy.setNewElementType($$[$0 - 2]);
          break;
        case 41:
          yy.setNewElementDocRef($$[$0 - 2]);
          break;
        case 44:
          yy.addRelationship($$[$0 - 2], $$[$0], $$[$0 - 4]);
          break;
        case 45:
          yy.addRelationship($$[$0 - 2], $$[$0 - 4], $$[$0]);
          break;
        case 46:
          this.$ = yy.Relationships.CONTAINS;
          break;
        case 47:
          this.$ = yy.Relationships.COPIES;
          break;
        case 48:
          this.$ = yy.Relationships.DERIVES;
          break;
        case 49:
          this.$ = yy.Relationships.SATISFIES;
          break;
        case 50:
          this.$ = yy.Relationships.VERIFIES;
          break;
        case 51:
          this.$ = yy.Relationships.REFINES;
          break;
        case 52:
          this.$ = yy.Relationships.TRACES;
          break;
      }
    },
    table: [{ 3: 1, 4: 2, 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 1: [3] }, { 3: 10, 4: 2, 5: [1, 9], 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 5: [1, 11] }, { 10: 12, 20: [1, 13] }, { 15: [1, 14] }, { 17: [1, 15] }, o($V5, [2, 8]), { 20: [2, 9] }, { 3: 16, 4: 2, 6: $V0, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4 }, { 1: [2, 2] }, { 4: 21, 5: $V6, 7: 17, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 11: 34, 12: [1, 35], 22: $Vh }, o([12, 22], [2, 10]), o($V5, [2, 6]), o($V5, [2, 7]), { 1: [2, 1] }, { 8: [1, 37] }, { 4: 21, 5: $V6, 7: 38, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 39, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 40, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 41, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 4: 21, 5: $V6, 7: 42, 8: $V7, 9: 4, 14: $V1, 16: $V2, 18: $V3, 19: $V4, 23: 18, 24: 19, 25: 20, 26: 23, 32: 25, 40: $V8, 41: $V9, 42: $Va, 43: $Vb, 44: $Vc, 45: $Vd, 53: $Ve, 71: $Vf, 72: $Vg }, { 27: 43, 71: [1, 44], 72: [1, 45] }, { 54: 46, 71: [1, 47], 72: [1, 48] }, { 60: [1, 49], 62: [1, 50] }, o($Vi, [2, 26]), o($Vi, [2, 27]), o($Vi, [2, 28]), o($Vi, [2, 29]), o($Vi, [2, 30]), o($Vi, [2, 31]), o($Vj, [2, 55]), o($Vj, [2, 56]), o($V5, [2, 4]), { 13: 51, 21: [1, 52] }, o($V5, [2, 12]), { 1: [2, 3] }, { 8: [2, 14] }, { 8: [2, 15] }, { 8: [2, 16] }, { 8: [2, 17] }, { 8: [2, 18] }, { 28: [1, 53] }, { 28: [2, 53] }, { 28: [2, 54] }, { 28: [1, 54] }, { 28: [2, 59] }, { 28: [2, 60] }, { 61: 55, 64: $Vk, 65: $Vl, 66: $Vm, 67: $Vn, 68: $Vo, 69: $Vp, 70: $Vq }, { 61: 63, 64: $Vk, 65: $Vl, 66: $Vm, 67: $Vn, 68: $Vo, 69: $Vp, 70: $Vq }, { 11: 64, 22: $Vh }, { 22: [2, 11] }, { 5: [1, 65] }, { 5: [1, 66] }, { 62: [1, 67] }, o($Vr, [2, 46]), o($Vr, [2, 47]), o($Vr, [2, 48]), o($Vr, [2, 49]), o($Vr, [2, 50]), o($Vr, [2, 51]), o($Vr, [2, 52]), { 63: [1, 68] }, o($V5, [2, 5]), { 5: $Vs, 29: 69, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vy, 39: $Vz, 55: 76, 56: $VA, 58: $VB }, { 32: 81, 71: $Vf, 72: $Vg }, { 32: 82, 71: $Vf, 72: $Vg }, o($VC, [2, 19]), { 31: [1, 83] }, { 31: [1, 84] }, { 31: [1, 85] }, { 31: [1, 86] }, { 5: $Vs, 29: 87, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, o($VC, [2, 25]), o($VC, [2, 39]), { 31: [1, 88] }, { 31: [1, 89] }, { 5: $Vy, 39: $Vz, 55: 90, 56: $VA, 58: $VB }, o($VC, [2, 43]), o($VC, [2, 44]), o($VC, [2, 45]), { 32: 91, 71: $Vf, 72: $Vg }, { 34: 92, 71: [1, 93], 72: [1, 94] }, { 36: 95, 46: [1, 96], 47: [1, 97], 48: [1, 98] }, { 38: 99, 49: [1, 100], 50: [1, 101], 51: [1, 102], 52: [1, 103] }, o($VC, [2, 24]), { 57: 104, 71: [1, 105], 72: [1, 106] }, { 59: 107, 71: [1, 108], 72: [1, 109] }, o($VC, [2, 42]), { 5: [1, 110] }, { 5: [1, 111] }, { 5: [2, 57] }, { 5: [2, 58] }, { 5: [1, 112] }, { 5: [2, 32] }, { 5: [2, 33] }, { 5: [2, 34] }, { 5: [1, 113] }, { 5: [2, 35] }, { 5: [2, 36] }, { 5: [2, 37] }, { 5: [2, 38] }, { 5: [1, 114] }, { 5: [2, 61] }, { 5: [2, 62] }, { 5: [1, 115] }, { 5: [2, 63] }, { 5: [2, 64] }, { 5: $Vs, 29: 116, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 117, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 118, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vs, 29: 119, 30: $Vt, 33: $Vu, 35: $Vv, 37: $Vw, 39: $Vx }, { 5: $Vy, 39: $Vz, 55: 120, 56: $VA, 58: $VB }, { 5: $Vy, 39: $Vz, 55: 121, 56: $VA, 58: $VB }, o($VC, [2, 20]), o($VC, [2, 21]), o($VC, [2, 22]), o($VC, [2, 23]), o($VC, [2, 40]), o($VC, [2, 41])],
    defaultActions: { 8: [2, 9], 10: [2, 2], 16: [2, 1], 37: [2, 3], 38: [2, 14], 39: [2, 15], 40: [2, 16], 41: [2, 17], 42: [2, 18], 44: [2, 53], 45: [2, 54], 47: [2, 59], 48: [2, 60], 52: [2, 11], 93: [2, 57], 94: [2, 58], 96: [2, 32], 97: [2, 33], 98: [2, 34], 100: [2, 35], 101: [2, 36], 102: [2, 37], 103: [2, 38], 105: [2, 61], 106: [2, 62], 108: [2, 63], 109: [2, 64] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 19;
          case 1:
            this.begin("type_directive");
            return 20;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 12;
          case 3:
            this.popState();
            this.popState();
            return 22;
          case 4:
            return 21;
          case 5:
            return "title";
          case 6:
            this.begin("acc_title");
            return 14;
          case 7:
            this.popState();
            return "acc_title_value";
          case 8:
            this.begin("acc_descr");
            return 16;
          case 9:
            this.popState();
            return "acc_descr_value";
          case 10:
            this.begin("acc_descr_multiline");
            break;
          case 11:
            this.popState();
            break;
          case 12:
            return "acc_descr_multiline_value";
          case 13:
            return 5;
          case 14:
            break;
          case 15:
            break;
          case 16:
            break;
          case 17:
            return 8;
          case 18:
            return 6;
          case 19:
            return 28;
          case 20:
            return 39;
          case 21:
            return 31;
          case 22:
            return 30;
          case 23:
            return 33;
          case 24:
            return 35;
          case 25:
            return 37;
          case 26:
            return 40;
          case 27:
            return 41;
          case 28:
            return 42;
          case 29:
            return 43;
          case 30:
            return 44;
          case 31:
            return 45;
          case 32:
            return 46;
          case 33:
            return 47;
          case 34:
            return 48;
          case 35:
            return 49;
          case 36:
            return 50;
          case 37:
            return 51;
          case 38:
            return 52;
          case 39:
            return 53;
          case 40:
            return 64;
          case 41:
            return 65;
          case 42:
            return 66;
          case 43:
            return 67;
          case 44:
            return 68;
          case 45:
            return 69;
          case 46:
            return 70;
          case 47:
            return 56;
          case 48:
            return 58;
          case 49:
            return 60;
          case 50:
            return 63;
          case 51:
            return 62;
          case 52:
            this.begin("string");
            break;
          case 53:
            this.popState();
            break;
          case 54:
            return "qString";
          case 55:
            yy_.yytext = yy_.yytext.trim();
            return 71;
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:(\r?\n)+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:$)/i, /^(?:requirementDiagram\b)/i, /^(?:\{)/i, /^(?:\})/i, /^(?::)/i, /^(?:id\b)/i, /^(?:text\b)/i, /^(?:risk\b)/i, /^(?:verifyMethod\b)/i, /^(?:requirement\b)/i, /^(?:functionalRequirement\b)/i, /^(?:interfaceRequirement\b)/i, /^(?:performanceRequirement\b)/i, /^(?:physicalRequirement\b)/i, /^(?:designConstraint\b)/i, /^(?:low\b)/i, /^(?:medium\b)/i, /^(?:high\b)/i, /^(?:analysis\b)/i, /^(?:demonstration\b)/i, /^(?:inspection\b)/i, /^(?:test\b)/i, /^(?:element\b)/i, /^(?:contains\b)/i, /^(?:copies\b)/i, /^(?:derives\b)/i, /^(?:satisfies\b)/i, /^(?:verifies\b)/i, /^(?:refines\b)/i, /^(?:traces\b)/i, /^(?:type\b)/i, /^(?:docref\b)/i, /^(?:<-)/i, /^(?:->)/i, /^(?:-)/i, /^(?:["])/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[\w][^\r\n\{\<\>\-\=]*)/i],
      conditions: { "acc_descr_multiline": { "rules": [11, 12], "inclusive": false }, "acc_descr": { "rules": [9], "inclusive": false }, "acc_title": { "rules": [7], "inclusive": false }, "close_directive": { "rules": [], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "open_directive": { "rules": [1], "inclusive": false }, "unqString": { "rules": [], "inclusive": false }, "token": { "rules": [], "inclusive": false }, "string": { "rules": [53, 54], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 55], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$3.parser = parser$3;
const requirementDetector = (txt) => {
  return txt.match(/^\s*requirement(Diagram)?/) !== null;
};
let relations = [];
let latestRequirement = {};
let requirements = {};
let latestElement = {};
let elements = {};
const RequirementType = {
  REQUIREMENT: "Requirement",
  FUNCTIONAL_REQUIREMENT: "Functional Requirement",
  INTERFACE_REQUIREMENT: "Interface Requirement",
  PERFORMANCE_REQUIREMENT: "Performance Requirement",
  PHYSICAL_REQUIREMENT: "Physical Requirement",
  DESIGN_CONSTRAINT: "Design Constraint"
};
const RiskLevel = {
  LOW_RISK: "Low",
  MED_RISK: "Medium",
  HIGH_RISK: "High"
};
const VerifyType = {
  VERIFY_ANALYSIS: "Analysis",
  VERIFY_DEMONSTRATION: "Demonstration",
  VERIFY_INSPECTION: "Inspection",
  VERIFY_TEST: "Test"
};
const Relationships = {
  CONTAINS: "contains",
  COPIES: "copies",
  DERIVES: "derives",
  SATISFIES: "satisfies",
  VERIFIES: "verifies",
  REFINES: "refines",
  TRACES: "traces"
};
const parseDirective$4 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addRequirement = (name2, type2) => {
  if (typeof requirements[name2] === "undefined") {
    requirements[name2] = {
      name: name2,
      type: type2,
      id: latestRequirement.id,
      text: latestRequirement.text,
      risk: latestRequirement.risk,
      verifyMethod: latestRequirement.verifyMethod
    };
  }
  latestRequirement = {};
  return requirements[name2];
};
const getRequirements = () => requirements;
const setNewReqId = (id2) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.id = id2;
  }
};
const setNewReqText = (text2) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.text = text2;
  }
};
const setNewReqRisk = (risk) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.risk = risk;
  }
};
const setNewReqVerifyMethod = (verifyMethod) => {
  if (typeof latestRequirement != "undefined") {
    latestRequirement.verifyMethod = verifyMethod;
  }
};
const addElement = (name2) => {
  if (typeof elements[name2] === "undefined") {
    elements[name2] = {
      name: name2,
      type: latestElement.type,
      docRef: latestElement.docRef
    };
    log$1.info("Added new requirement: ", name2);
  }
  latestElement = {};
  return elements[name2];
};
const getElements = () => elements;
const setNewElementType = (type2) => {
  if (typeof latestElement != "undefined") {
    latestElement.type = type2;
  }
};
const setNewElementDocRef = (docRef) => {
  if (typeof latestElement != "undefined") {
    latestElement.docRef = docRef;
  }
};
const addRelationship = (type2, src, dst) => {
  relations.push({
    type: type2,
    src,
    dst
  });
};
const getRelationships = () => relations;
const clear$3 = () => {
  relations = [];
  latestRequirement = {};
  requirements = {};
  latestElement = {};
  elements = {};
  clear$g();
};
const requirementDb = {
  RequirementType,
  RiskLevel,
  VerifyType,
  Relationships,
  parseDirective: parseDirective$4,
  getConfig: () => getConfig$1().req,
  addRequirement,
  getRequirements,
  setNewReqId,
  setNewReqText,
  setNewReqRisk,
  setNewReqVerifyMethod,
  setAccTitle,
  getAccTitle,
  setAccDescription,
  getAccDescription,
  addElement,
  getElements,
  setNewElementType,
  setNewElementDocRef,
  addRelationship,
  getRelationships,
  clear: clear$3
};
const ReqMarkers = {
  CONTAINS: "contains",
  ARROW: "arrow"
};
const insertLineEndings = (parentNode, conf2) => {
  let containsNode = parentNode.append("defs").append("marker").attr("id", ReqMarkers.CONTAINS + "_line_ending").attr("refX", 0).attr("refY", conf2.line_height / 2).attr("markerWidth", conf2.line_height).attr("markerHeight", conf2.line_height).attr("orient", "auto").append("g");
  containsNode.append("circle").attr("cx", conf2.line_height / 2).attr("cy", conf2.line_height / 2).attr("r", conf2.line_height / 2).attr("fill", "none");
  containsNode.append("line").attr("x1", 0).attr("x2", conf2.line_height).attr("y1", conf2.line_height / 2).attr("y2", conf2.line_height / 2).attr("stroke-width", 1);
  containsNode.append("line").attr("y1", 0).attr("y2", conf2.line_height).attr("x1", conf2.line_height / 2).attr("x2", conf2.line_height / 2).attr("stroke-width", 1);
  parentNode.append("defs").append("marker").attr("id", ReqMarkers.ARROW + "_line_ending").attr("refX", conf2.line_height).attr("refY", 0.5 * conf2.line_height).attr("markerWidth", conf2.line_height).attr("markerHeight", conf2.line_height).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L${conf2.line_height},${conf2.line_height / 2}
      M${conf2.line_height},${conf2.line_height / 2}
      L0,${conf2.line_height}`
  ).attr("stroke-width", 1);
};
const markers = {
  ReqMarkers,
  insertLineEndings
};
let conf$5 = {};
let relCnt = 0;
const newRectNode = (parentNode, id2) => {
  return parentNode.insert("rect", "#" + id2).attr("class", "req reqBox").attr("x", 0).attr("y", 0).attr("width", conf$5.rect_min_width + "px").attr("height", conf$5.rect_min_height + "px");
};
const newTitleNode = (parentNode, id2, txts) => {
  let x2 = conf$5.rect_min_width / 2;
  let title2 = parentNode.append("text").attr("class", "req reqLabel reqTitle").attr("id", id2).attr("x", x2).attr("y", conf$5.rect_padding).attr("dominant-baseline", "hanging");
  let i = 0;
  txts.forEach((textStr) => {
    if (i == 0) {
      title2.append("tspan").attr("text-anchor", "middle").attr("x", conf$5.rect_min_width / 2).attr("dy", 0).text(textStr);
    } else {
      title2.append("tspan").attr("text-anchor", "middle").attr("x", conf$5.rect_min_width / 2).attr("dy", conf$5.line_height * 0.75).text(textStr);
    }
    i++;
  });
  let yPadding = 1.5 * conf$5.rect_padding;
  let linePadding = i * conf$5.line_height * 0.75;
  let totalY = yPadding + linePadding;
  parentNode.append("line").attr("class", "req-title-line").attr("x1", "0").attr("x2", conf$5.rect_min_width).attr("y1", totalY).attr("y2", totalY);
  return {
    titleNode: title2,
    y: totalY
  };
};
const newBodyNode = (parentNode, id2, txts, yStart) => {
  let body = parentNode.append("text").attr("class", "req reqLabel").attr("id", id2).attr("x", conf$5.rect_padding).attr("y", yStart).attr("dominant-baseline", "hanging");
  let currentRow = 0;
  const charLimit = 30;
  let wrappedTxts = [];
  txts.forEach((textStr) => {
    let currentTextLen = textStr.length;
    while (currentTextLen > charLimit && currentRow < 3) {
      let firstPart = textStr.substring(0, charLimit);
      textStr = textStr.substring(charLimit, textStr.length);
      currentTextLen = textStr.length;
      wrappedTxts[wrappedTxts.length] = firstPart;
      currentRow++;
    }
    if (currentRow == 3) {
      let lastStr = wrappedTxts[wrappedTxts.length - 1];
      wrappedTxts[wrappedTxts.length - 1] = lastStr.substring(0, lastStr.length - 4) + "...";
    } else {
      wrappedTxts[wrappedTxts.length] = textStr;
    }
    currentRow = 0;
  });
  wrappedTxts.forEach((textStr) => {
    body.append("tspan").attr("x", conf$5.rect_padding).attr("dy", conf$5.line_height).text(textStr);
  });
  return body;
};
const addEdgeLabel = (parentNode, svgPath, conf2, txt) => {
  const len = svgPath.node().getTotalLength();
  const labelPoint = svgPath.node().getPointAtLength(len * 0.5);
  const labelId = "rel" + relCnt;
  relCnt++;
  const labelNode = parentNode.append("text").attr("class", "req relationshipLabel").attr("id", labelId).attr("x", labelPoint.x).attr("y", labelPoint.y).attr("text-anchor", "middle").attr("dominant-baseline", "middle").text(txt);
  const labelBBox = labelNode.node().getBBox();
  parentNode.insert("rect", "#" + labelId).attr("class", "req reqLabelBox").attr("x", labelPoint.x - labelBBox.width / 2).attr("y", labelPoint.y - labelBBox.height / 2).attr("width", labelBBox.width).attr("height", labelBBox.height).attr("fill", "white").attr("fill-opacity", "85%");
};
const drawRelationshipFromLayout = function(svg2, rel, g, insert, diagObj) {
  const edge = g.edge(elementString(rel.src), elementString(rel.dst));
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  });
  const svgPath = svg2.insert("path", "#" + insert).attr("class", "er relationshipLine").attr("d", lineFunction(edge.points)).attr("fill", "none");
  if (rel.type == diagObj.db.Relationships.CONTAINS) {
    svgPath.attr(
      "marker-start",
      "url(" + common.getUrl(conf$5.arrowMarkerAbsolute) + "#" + rel.type + "_line_ending)"
    );
  } else {
    svgPath.attr("stroke-dasharray", "10,7");
    svgPath.attr(
      "marker-end",
      "url(" + common.getUrl(conf$5.arrowMarkerAbsolute) + "#" + markers.ReqMarkers.ARROW + "_line_ending)"
    );
  }
  addEdgeLabel(svg2, svgPath, conf$5, `<<${rel.type}>>`);
  return;
};
const drawReqs = (reqs, graph2, svgNode2) => {
  Object.keys(reqs).forEach((reqName) => {
    let req = reqs[reqName];
    reqName = elementString(reqName);
    log$1.info("Added new requirement: ", reqName);
    const groupNode = svgNode2.append("g").attr("id", reqName);
    const textId = "req-" + reqName;
    const rectNode = newRectNode(groupNode, textId);
    let titleNodeInfo = newTitleNode(groupNode, reqName + "_title", [
      `<<${req.type}>>`,
      `${req.name}`
    ]);
    newBodyNode(
      groupNode,
      reqName + "_body",
      [
        `Id: ${req.id}`,
        `Text: ${req.text}`,
        `Risk: ${req.risk}`,
        `Verification: ${req.verifyMethod}`
      ],
      titleNodeInfo.y
    );
    const rectBBox = rectNode.node().getBBox();
    graph2.setNode(reqName, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: "rect",
      id: reqName
    });
  });
};
const drawElements = (els, graph2, svgNode2) => {
  Object.keys(els).forEach((elName) => {
    let el = els[elName];
    const id2 = elementString(elName);
    const groupNode = svgNode2.append("g").attr("id", id2);
    const textId = "element-" + id2;
    const rectNode = newRectNode(groupNode, textId);
    let titleNodeInfo = newTitleNode(groupNode, textId + "_title", [`<<Element>>`, `${elName}`]);
    newBodyNode(
      groupNode,
      textId + "_body",
      [`Type: ${el.type || "Not Specified"}`, `Doc Ref: ${el.docRef || "None"}`],
      titleNodeInfo.y
    );
    const rectBBox = rectNode.node().getBBox();
    graph2.setNode(id2, {
      width: rectBBox.width,
      height: rectBBox.height,
      shape: "rect",
      id: id2
    });
  });
};
const addRelationships = (relationships2, g) => {
  relationships2.forEach(function(r) {
    let src = elementString(r.src);
    let dst = elementString(r.dst);
    g.setEdge(src, dst, { relationship: r });
  });
  return relationships2;
};
const adjustEntities = function(svgNode2, graph2) {
  graph2.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
      svgNode2.select("#" + v);
      svgNode2.select("#" + v).attr(
        "transform",
        "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y - graph2.node(v).height / 2) + " )"
      );
    }
  });
  return;
};
const elementString = (str) => {
  return str.replace(/\s/g, "").replace(/\./g, "_");
};
const draw$5 = (text2, id2, _version, diagObj) => {
  conf$5 = getConfig$1().requirement;
  diagObj.db.clear();
  diagObj.parser.parse(text2);
  const securityLevel = conf$5.securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id='${id2}']`);
  markers.insertLineEndings(svg2, conf$5);
  const g = new graphlib$2.Graph({
    multigraph: false,
    compound: false,
    directed: true
  }).setGraph({
    rankdir: conf$5.layoutDirection,
    marginx: 20,
    marginy: 20,
    nodesep: 100,
    edgesep: 100,
    ranksep: 100
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  let requirements2 = diagObj.db.getRequirements();
  let elements2 = diagObj.db.getElements();
  let relationships2 = diagObj.db.getRelationships();
  drawReqs(requirements2, g, svg2);
  drawElements(elements2, g, svg2);
  addRelationships(relationships2, g);
  dagre$1.layout(g);
  adjustEntities(svg2, g);
  relationships2.forEach(function(rel) {
    drawRelationshipFromLayout(svg2, rel, g, id2, diagObj);
  });
  const padding2 = conf$5.rect_padding;
  const svgBounds = svg2.node().getBBox();
  const width2 = svgBounds.width + padding2 * 2;
  const height2 = svgBounds.height + padding2 * 2;
  configureSvgSize(svg2, height2, width2, conf$5.useMaxWidth);
  svg2.attr("viewBox", `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`);
  addSVGAccessibilityFields(diagObj.db, svg2, id2);
};
const requirementRenderer = {
  draw: draw$5
};
var parser$2 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 5], $V3 = [1, 7], $V4 = [2, 5], $V5 = [1, 15], $V6 = [1, 17], $V7 = [1, 18], $V8 = [1, 19], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 23], $Vc = [1, 29], $Vd = [1, 30], $Ve = [1, 31], $Vf = [1, 32], $Vg = [1, 33], $Vh = [1, 34], $Vi = [1, 35], $Vj = [1, 36], $Vk = [1, 37], $Vl = [1, 38], $Vm = [1, 39], $Vn = [1, 40], $Vo = [1, 43], $Vp = [1, 44], $Vq = [1, 45], $Vr = [1, 46], $Vs = [1, 47], $Vt = [1, 48], $Vu = [1, 51], $Vv = [1, 4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 51, 52, 53, 58, 59, 60, 61, 69, 79], $Vw = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 53, 58, 59, 60, 61, 69, 79], $Vx = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 52, 53, 58, 59, 60, 61, 69, 79], $Vy = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 51, 53, 58, 59, 60, 61, 69, 79], $Vz = [4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 53, 58, 59, 60, 61, 69, 79], $VA = [67, 68, 69], $VB = [1, 121], $VC = [1, 4, 5, 7, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 40, 41, 42, 43, 45, 47, 49, 50, 51, 52, 53, 58, 59, 60, 61, 69, 79];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "SPACE": 4, "NEWLINE": 5, "directive": 6, "SD": 7, "document": 8, "line": 9, "statement": 10, "openDirective": 11, "typeDirective": 12, "closeDirective": 13, ":": 14, "argDirective": 15, "participant": 16, "actor": 17, "AS": 18, "restOfLine": 19, "participant_actor": 20, "signal": 21, "autonumber": 22, "NUM": 23, "off": 24, "activate": 25, "deactivate": 26, "note_statement": 27, "links_statement": 28, "link_statement": 29, "properties_statement": 30, "details_statement": 31, "title": 32, "legacy_title": 33, "acc_title": 34, "acc_title_value": 35, "acc_descr": 36, "acc_descr_value": 37, "acc_descr_multiline_value": 38, "loop": 39, "end": 40, "rect": 41, "opt": 42, "alt": 43, "else_sections": 44, "par": 45, "par_sections": 46, "critical": 47, "option_sections": 48, "break": 49, "option": 50, "and": 51, "else": 52, "note": 53, "placement": 54, "text2": 55, "over": 56, "actor_pair": 57, "links": 58, "link": 59, "properties": 60, "details": 61, "spaceList": 62, ",": 63, "left_of": 64, "right_of": 65, "signaltype": 66, "+": 67, "-": 68, "ACTOR": 69, "SOLID_OPEN_ARROW": 70, "DOTTED_OPEN_ARROW": 71, "SOLID_ARROW": 72, "DOTTED_ARROW": 73, "SOLID_CROSS": 74, "DOTTED_CROSS": 75, "SOLID_POINT": 76, "DOTTED_POINT": 77, "TXT": 78, "open_directive": 79, "type_directive": 80, "arg_directive": 81, "close_directive": 82, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NEWLINE", 7: "SD", 14: ":", 16: "participant", 18: "AS", 19: "restOfLine", 20: "participant_actor", 22: "autonumber", 23: "NUM", 24: "off", 25: "activate", 26: "deactivate", 32: "title", 33: "legacy_title", 34: "acc_title", 35: "acc_title_value", 36: "acc_descr", 37: "acc_descr_value", 38: "acc_descr_multiline_value", 39: "loop", 40: "end", 41: "rect", 42: "opt", 43: "alt", 45: "par", 47: "critical", 49: "break", 50: "option", 51: "and", 52: "else", 53: "note", 56: "over", 58: "links", 59: "link", 60: "properties", 61: "details", 63: ",", 64: "left_of", 65: "right_of", 67: "+", 68: "-", 69: "ACTOR", 70: "SOLID_OPEN_ARROW", 71: "DOTTED_OPEN_ARROW", 72: "SOLID_ARROW", 73: "DOTTED_ARROW", 74: "SOLID_CROSS", 75: "DOTTED_CROSS", 76: "SOLID_POINT", 77: "DOTTED_POINT", 78: "TXT", 79: "open_directive", 80: "type_directive", 81: "arg_directive", 82: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [6, 4], [6, 6], [10, 5], [10, 3], [10, 5], [10, 3], [10, 2], [10, 4], [10, 3], [10, 3], [10, 2], [10, 3], [10, 3], [10, 2], [10, 2], [10, 2], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 4], [10, 1], [48, 1], [48, 4], [46, 1], [46, 4], [44, 1], [44, 4], [27, 4], [27, 4], [28, 3], [29, 3], [30, 3], [31, 3], [62, 2], [62, 1], [57, 3], [57, 1], [54, 1], [54, 1], [21, 5], [21, 5], [21, 4], [17, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [66, 1], [55, 1], [11, 1], [12, 1], [15, 1], [13, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.apply($$[$0]);
          return $$[$0];
        case 5:
          this.$ = [];
          break;
        case 6:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 7:
        case 8:
          this.$ = $$[$0];
          break;
        case 9:
          this.$ = [];
          break;
        case 12:
          $$[$0 - 3].type = "addParticipant";
          $$[$0 - 3].description = yy.parseMessage($$[$0 - 1]);
          this.$ = $$[$0 - 3];
          break;
        case 13:
          $$[$0 - 1].type = "addParticipant";
          this.$ = $$[$0 - 1];
          break;
        case 14:
          $$[$0 - 3].type = "addActor";
          $$[$0 - 3].description = yy.parseMessage($$[$0 - 1]);
          this.$ = $$[$0 - 3];
          break;
        case 15:
          $$[$0 - 1].type = "addActor";
          this.$ = $$[$0 - 1];
          break;
        case 17:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number($$[$0 - 2]), sequenceIndexStep: Number($$[$0 - 1]), sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 18:
          this.$ = { type: "sequenceIndex", sequenceIndex: Number($$[$0 - 1]), sequenceIndexStep: 1, sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 19:
          this.$ = { type: "sequenceIndex", sequenceVisible: false, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 20:
          this.$ = { type: "sequenceIndex", sequenceVisible: true, signalType: yy.LINETYPE.AUTONUMBER };
          break;
        case 21:
          this.$ = { type: "activeStart", signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0 - 1] };
          break;
        case 22:
          this.$ = { type: "activeEnd", signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0 - 1] };
          break;
        case 28:
          yy.setDiagramTitle($$[$0].substring(6));
          this.$ = $$[$0].substring(6);
          break;
        case 29:
          yy.setDiagramTitle($$[$0].substring(7));
          this.$ = $$[$0].substring(7);
          break;
        case 30:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 31:
        case 32:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 33:
          $$[$0 - 1].unshift({ type: "loopStart", loopText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.LOOP_START });
          $$[$0 - 1].push({ type: "loopEnd", loopText: $$[$0 - 2], signalType: yy.LINETYPE.LOOP_END });
          this.$ = $$[$0 - 1];
          break;
        case 34:
          $$[$0 - 1].unshift({ type: "rectStart", color: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.RECT_START });
          $$[$0 - 1].push({ type: "rectEnd", color: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.RECT_END });
          this.$ = $$[$0 - 1];
          break;
        case 35:
          $$[$0 - 1].unshift({ type: "optStart", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.OPT_START });
          $$[$0 - 1].push({ type: "optEnd", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.OPT_END });
          this.$ = $$[$0 - 1];
          break;
        case 36:
          $$[$0 - 1].unshift({ type: "altStart", altText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.ALT_START });
          $$[$0 - 1].push({ type: "altEnd", signalType: yy.LINETYPE.ALT_END });
          this.$ = $$[$0 - 1];
          break;
        case 37:
          $$[$0 - 1].unshift({ type: "parStart", parText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.PAR_START });
          $$[$0 - 1].push({ type: "parEnd", signalType: yy.LINETYPE.PAR_END });
          this.$ = $$[$0 - 1];
          break;
        case 38:
          $$[$0 - 1].unshift({ type: "criticalStart", criticalText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.CRITICAL_START });
          $$[$0 - 1].push({ type: "criticalEnd", signalType: yy.LINETYPE.CRITICAL_END });
          this.$ = $$[$0 - 1];
          break;
        case 39:
          $$[$0 - 1].unshift({ type: "breakStart", breakText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.BREAK_START });
          $$[$0 - 1].push({ type: "breakEnd", optText: yy.parseMessage($$[$0 - 2]), signalType: yy.LINETYPE.BREAK_END });
          this.$ = $$[$0 - 1];
          break;
        case 42:
          this.$ = $$[$0 - 3].concat([{ type: "option", optionText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.CRITICAL_OPTION }, $$[$0]]);
          break;
        case 44:
          this.$ = $$[$0 - 3].concat([{ type: "and", parText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.PAR_AND }, $$[$0]]);
          break;
        case 46:
          this.$ = $$[$0 - 3].concat([{ type: "else", altText: yy.parseMessage($$[$0 - 1]), signalType: yy.LINETYPE.ALT_ELSE }, $$[$0]]);
          break;
        case 47:
          this.$ = [$$[$0 - 1], { type: "addNote", placement: $$[$0 - 2], actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 48:
          $$[$0 - 2] = [].concat($$[$0 - 1], $$[$0 - 1]).slice(0, 2);
          $$[$0 - 2][0] = $$[$0 - 2][0].actor;
          $$[$0 - 2][1] = $$[$0 - 2][1].actor;
          this.$ = [$$[$0 - 1], { type: "addNote", placement: yy.PLACEMENT.OVER, actor: $$[$0 - 2].slice(0, 2), text: $$[$0] }];
          break;
        case 49:
          this.$ = [$$[$0 - 1], { type: "addLinks", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 50:
          this.$ = [$$[$0 - 1], { type: "addALink", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 51:
          this.$ = [$$[$0 - 1], { type: "addProperties", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 52:
          this.$ = [$$[$0 - 1], { type: "addDetails", actor: $$[$0 - 1].actor, text: $$[$0] }];
          break;
        case 55:
          this.$ = [$$[$0 - 2], $$[$0]];
          break;
        case 56:
          this.$ = $$[$0];
          break;
        case 57:
          this.$ = yy.PLACEMENT.LEFTOF;
          break;
        case 58:
          this.$ = yy.PLACEMENT.RIGHTOF;
          break;
        case 59:
          this.$ = [
            $$[$0 - 4],
            $$[$0 - 1],
            { type: "addMessage", from: $$[$0 - 4].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 3], msg: $$[$0] },
            { type: "activeStart", signalType: yy.LINETYPE.ACTIVE_START, actor: $$[$0 - 1] }
          ];
          break;
        case 60:
          this.$ = [
            $$[$0 - 4],
            $$[$0 - 1],
            { type: "addMessage", from: $$[$0 - 4].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 3], msg: $$[$0] },
            { type: "activeEnd", signalType: yy.LINETYPE.ACTIVE_END, actor: $$[$0 - 4] }
          ];
          break;
        case 61:
          this.$ = [$$[$0 - 3], $$[$0 - 1], { type: "addMessage", from: $$[$0 - 3].actor, to: $$[$0 - 1].actor, signalType: $$[$0 - 2], msg: $$[$0] }];
          break;
        case 62:
          this.$ = { type: "addParticipant", actor: $$[$0] };
          break;
        case 63:
          this.$ = yy.LINETYPE.SOLID_OPEN;
          break;
        case 64:
          this.$ = yy.LINETYPE.DOTTED_OPEN;
          break;
        case 65:
          this.$ = yy.LINETYPE.SOLID;
          break;
        case 66:
          this.$ = yy.LINETYPE.DOTTED;
          break;
        case 67:
          this.$ = yy.LINETYPE.SOLID_CROSS;
          break;
        case 68:
          this.$ = yy.LINETYPE.DOTTED_CROSS;
          break;
        case 69:
          this.$ = yy.LINETYPE.SOLID_POINT;
          break;
        case 70:
          this.$ = yy.LINETYPE.DOTTED_POINT;
          break;
        case 71:
          this.$ = yy.parseMessage($$[$0].trim().substring(1));
          break;
        case 72:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 73:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 74:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 75:
          yy.parseDirective("}%%", "close_directive", "sequence");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 1: [3] }, { 3: 8, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 3: 9, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, { 3: 10, 4: $V0, 5: $V1, 6: 4, 7: $V2, 11: 6, 79: $V3 }, o([1, 4, 5, 16, 20, 22, 25, 26, 32, 33, 34, 36, 38, 39, 41, 42, 43, 45, 47, 49, 53, 58, 59, 60, 61, 69, 79], $V4, { 8: 11 }), { 12: 12, 80: [1, 13] }, { 80: [2, 72] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 13: 49, 14: [1, 50], 82: $Vu }, o([14, 82], [2, 73]), o($Vv, [2, 6]), { 6: 41, 10: 52, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, o($Vv, [2, 8]), o($Vv, [2, 9]), { 17: 53, 69: $Vt }, { 17: 54, 69: $Vt }, { 5: [1, 55] }, { 5: [1, 58], 23: [1, 56], 24: [1, 57] }, { 17: 59, 69: $Vt }, { 17: 60, 69: $Vt }, { 5: [1, 61] }, { 5: [1, 62] }, { 5: [1, 63] }, { 5: [1, 64] }, { 5: [1, 65] }, o($Vv, [2, 28]), o($Vv, [2, 29]), { 35: [1, 66] }, { 37: [1, 67] }, o($Vv, [2, 32]), { 19: [1, 68] }, { 19: [1, 69] }, { 19: [1, 70] }, { 19: [1, 71] }, { 19: [1, 72] }, { 19: [1, 73] }, { 19: [1, 74] }, o($Vv, [2, 40]), { 66: 75, 70: [1, 76], 71: [1, 77], 72: [1, 78], 73: [1, 79], 74: [1, 80], 75: [1, 81], 76: [1, 82], 77: [1, 83] }, { 54: 84, 56: [1, 85], 64: [1, 86], 65: [1, 87] }, { 17: 88, 69: $Vt }, { 17: 89, 69: $Vt }, { 17: 90, 69: $Vt }, { 17: 91, 69: $Vt }, o([5, 18, 63, 70, 71, 72, 73, 74, 75, 76, 77, 78], [2, 62]), { 5: [1, 92] }, { 15: 93, 81: [1, 94] }, { 5: [2, 75] }, o($Vv, [2, 7]), { 5: [1, 96], 18: [1, 95] }, { 5: [1, 98], 18: [1, 97] }, o($Vv, [2, 16]), { 5: [1, 100], 23: [1, 99] }, { 5: [1, 101] }, o($Vv, [2, 20]), { 5: [1, 102] }, { 5: [1, 103] }, o($Vv, [2, 23]), o($Vv, [2, 24]), o($Vv, [2, 25]), o($Vv, [2, 26]), o($Vv, [2, 27]), o($Vv, [2, 30]), o($Vv, [2, 31]), o($Vw, $V4, { 8: 104 }), o($Vw, $V4, { 8: 105 }), o($Vw, $V4, { 8: 106 }), o($Vx, $V4, { 44: 107, 8: 108 }), o($Vy, $V4, { 46: 109, 8: 110 }), o($Vz, $V4, { 48: 111, 8: 112 }), o($Vw, $V4, { 8: 113 }), { 17: 116, 67: [1, 114], 68: [1, 115], 69: $Vt }, o($VA, [2, 63]), o($VA, [2, 64]), o($VA, [2, 65]), o($VA, [2, 66]), o($VA, [2, 67]), o($VA, [2, 68]), o($VA, [2, 69]), o($VA, [2, 70]), { 17: 117, 69: $Vt }, { 17: 119, 57: 118, 69: $Vt }, { 69: [2, 57] }, { 69: [2, 58] }, { 55: 120, 78: $VB }, { 55: 122, 78: $VB }, { 55: 123, 78: $VB }, { 55: 124, 78: $VB }, o($VC, [2, 10]), { 13: 125, 82: $Vu }, { 82: [2, 74] }, { 19: [1, 126] }, o($Vv, [2, 13]), { 19: [1, 127] }, o($Vv, [2, 15]), { 5: [1, 128] }, o($Vv, [2, 18]), o($Vv, [2, 19]), o($Vv, [2, 21]), o($Vv, [2, 22]), { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 129], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 130], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 131], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 132] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 45], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 52: [1, 133], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 134] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 43], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 51: [1, 135], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 40: [1, 136] }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [2, 41], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 50: [1, 137], 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 4: $V5, 5: $V6, 6: 41, 9: 14, 10: 16, 11: 6, 16: $V7, 17: 42, 20: $V8, 21: 20, 22: $V9, 25: $Va, 26: $Vb, 27: 24, 28: 25, 29: 26, 30: 27, 31: 28, 32: $Vc, 33: $Vd, 34: $Ve, 36: $Vf, 38: $Vg, 39: $Vh, 40: [1, 138], 41: $Vi, 42: $Vj, 43: $Vk, 45: $Vl, 47: $Vm, 49: $Vn, 53: $Vo, 58: $Vp, 59: $Vq, 60: $Vr, 61: $Vs, 69: $Vt, 79: $V3 }, { 17: 139, 69: $Vt }, { 17: 140, 69: $Vt }, { 55: 141, 78: $VB }, { 55: 142, 78: $VB }, { 55: 143, 78: $VB }, { 63: [1, 144], 78: [2, 56] }, { 5: [2, 49] }, { 5: [2, 71] }, { 5: [2, 50] }, { 5: [2, 51] }, { 5: [2, 52] }, { 5: [1, 145] }, { 5: [1, 146] }, { 5: [1, 147] }, o($Vv, [2, 17]), o($Vv, [2, 33]), o($Vv, [2, 34]), o($Vv, [2, 35]), o($Vv, [2, 36]), { 19: [1, 148] }, o($Vv, [2, 37]), { 19: [1, 149] }, o($Vv, [2, 38]), { 19: [1, 150] }, o($Vv, [2, 39]), { 55: 151, 78: $VB }, { 55: 152, 78: $VB }, { 5: [2, 61] }, { 5: [2, 47] }, { 5: [2, 48] }, { 17: 153, 69: $Vt }, o($VC, [2, 11]), o($Vv, [2, 12]), o($Vv, [2, 14]), o($Vx, $V4, { 8: 108, 44: 154 }), o($Vy, $V4, { 8: 110, 46: 155 }), o($Vz, $V4, { 8: 112, 48: 156 }), { 5: [2, 59] }, { 5: [2, 60] }, { 78: [2, 55] }, { 40: [2, 46] }, { 40: [2, 44] }, { 40: [2, 42] }],
    defaultActions: { 7: [2, 72], 8: [2, 1], 9: [2, 2], 10: [2, 3], 51: [2, 75], 86: [2, 57], 87: [2, 58], 94: [2, 74], 120: [2, 49], 121: [2, 71], 122: [2, 50], 123: [2, 51], 124: [2, 52], 141: [2, 61], 142: [2, 47], 143: [2, 48], 151: [2, 59], 152: [2, 60], 153: [2, 55], 154: [2, 46], 155: [2, 44], 156: [2, 42] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 79;
          case 1:
            this.begin("type_directive");
            return 80;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 14;
          case 3:
            this.popState();
            this.popState();
            return 82;
          case 4:
            return 81;
          case 5:
            return 5;
          case 6:
            break;
          case 7:
            break;
          case 8:
            break;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 23;
          case 12:
            this.begin("ID");
            return 16;
          case 13:
            this.begin("ID");
            return 20;
          case 14:
            yy_.yytext = yy_.yytext.trim();
            this.begin("ALIAS");
            return 69;
          case 15:
            this.popState();
            this.popState();
            this.begin("LINE");
            return 18;
          case 16:
            this.popState();
            this.popState();
            return 5;
          case 17:
            this.begin("LINE");
            return 39;
          case 18:
            this.begin("LINE");
            return 41;
          case 19:
            this.begin("LINE");
            return 42;
          case 20:
            this.begin("LINE");
            return 43;
          case 21:
            this.begin("LINE");
            return 52;
          case 22:
            this.begin("LINE");
            return 45;
          case 23:
            this.begin("LINE");
            return 51;
          case 24:
            this.begin("LINE");
            return 47;
          case 25:
            this.begin("LINE");
            return 50;
          case 26:
            this.begin("LINE");
            return 49;
          case 27:
            this.popState();
            return 19;
          case 28:
            return 40;
          case 29:
            return 64;
          case 30:
            return 65;
          case 31:
            return 58;
          case 32:
            return 59;
          case 33:
            return 60;
          case 34:
            return 61;
          case 35:
            return 56;
          case 36:
            return 53;
          case 37:
            this.begin("ID");
            return 25;
          case 38:
            this.begin("ID");
            return 26;
          case 39:
            return 32;
          case 40:
            return 33;
          case 41:
            this.begin("acc_title");
            return 34;
          case 42:
            this.popState();
            return "acc_title_value";
          case 43:
            this.begin("acc_descr");
            return 36;
          case 44:
            this.popState();
            return "acc_descr_value";
          case 45:
            this.begin("acc_descr_multiline");
            break;
          case 46:
            this.popState();
            break;
          case 47:
            return "acc_descr_multiline_value";
          case 48:
            return 7;
          case 49:
            return 22;
          case 50:
            return 24;
          case 51:
            return 63;
          case 52:
            return 5;
          case 53:
            yy_.yytext = yy_.yytext.trim();
            return 69;
          case 54:
            return 72;
          case 55:
            return 73;
          case 56:
            return 70;
          case 57:
            return 71;
          case 58:
            return 74;
          case 59:
            return 75;
          case 60:
            return 76;
          case 61:
            return 77;
          case 62:
            return 78;
          case 63:
            return 67;
          case 64:
            return 68;
          case 65:
            return 5;
          case 66:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[0-9]+(?=[ \n]+))/i, /^(?:participant\b)/i, /^(?:actor\b)/i, /^(?:[^\->:\n,;]+?([\-]*[^\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i, /^(?:as\b)/i, /^(?:(?:))/i, /^(?:loop\b)/i, /^(?:rect\b)/i, /^(?:opt\b)/i, /^(?:alt\b)/i, /^(?:else\b)/i, /^(?:par\b)/i, /^(?:and\b)/i, /^(?:critical\b)/i, /^(?:option\b)/i, /^(?:break\b)/i, /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i, /^(?:end\b)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:links\b)/i, /^(?:link\b)/i, /^(?:properties\b)/i, /^(?:details\b)/i, /^(?:over\b)/i, /^(?:note\b)/i, /^(?:activate\b)/i, /^(?:deactivate\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:title:\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:sequenceDiagram\b)/i, /^(?:autonumber\b)/i, /^(?:off\b)/i, /^(?:,)/i, /^(?:;)/i, /^(?:[^\+\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+\->:\n,;]+)*)/i, /^(?:->>)/i, /^(?:-->>)/i, /^(?:->)/i, /^(?:-->)/i, /^(?:-[x])/i, /^(?:--[x])/i, /^(?:-[\)])/i, /^(?:--[\)])/i, /^(?::(?:(?:no)?wrap)?[^#\n;]+)/i, /^(?:\+)/i, /^(?:-)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "acc_descr_multiline": { "rules": [46, 47], "inclusive": false }, "acc_descr": { "rules": [44], "inclusive": false }, "acc_title": { "rules": [42], "inclusive": false }, "open_directive": { "rules": [1, 8], "inclusive": false }, "type_directive": { "rules": [2, 3, 8], "inclusive": false }, "arg_directive": { "rules": [3, 4, 8], "inclusive": false }, "ID": { "rules": [7, 8, 14], "inclusive": false }, "ALIAS": { "rules": [7, 8, 15, 16], "inclusive": false }, "LINE": { "rules": [7, 8, 27], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 8, 9, 10, 11, 12, 13, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 43, 45, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$2.parser = parser$2;
const sequenceDetector = (txt) => {
  return txt.match(/^\s*sequenceDiagram/) !== null;
};
let prevActor = void 0;
let actors$1 = {};
let messages = [];
let sequenceNumbersEnabled = false;
let wrapEnabled;
const parseDirective$3 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const addActor = function(id2, name2, description2, type2) {
  const old = actors$1[id2];
  if (old && name2 === old.name && description2 == null)
    return;
  if (description2 == null || description2.text == null) {
    description2 = { text: name2, wrap: null, type: type2 };
  }
  if (type2 == null || description2.text == null) {
    description2 = { text: name2, wrap: null, type: type2 };
  }
  actors$1[id2] = {
    name: name2,
    description: description2.text,
    wrap: description2.wrap === void 0 && autoWrap() || !!description2.wrap,
    prevActor,
    links: {},
    properties: {},
    actorCnt: null,
    rectData: null,
    type: type2 || "participant"
  };
  if (prevActor && actors$1[prevActor]) {
    actors$1[prevActor].nextActor = id2;
  }
  prevActor = id2;
};
const activationCount = (part) => {
  let i;
  let count2 = 0;
  for (i = 0; i < messages.length; i++) {
    if (messages[i].type === LINETYPE.ACTIVE_START) {
      if (messages[i].from.actor === part) {
        count2++;
      }
    }
    if (messages[i].type === LINETYPE.ACTIVE_END) {
      if (messages[i].from.actor === part) {
        count2--;
      }
    }
  }
  return count2;
};
const addMessage = function(idFrom, idTo, message2, answer) {
  messages.push({
    from: idFrom,
    to: idTo,
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
    answer
  });
};
const addSignal = function(idFrom, idTo, message2 = { text: void 0, wrap: void 0 }, messageType) {
  if (messageType === LINETYPE.ACTIVE_END) {
    const cnt2 = activationCount(idFrom.actor);
    if (cnt2 < 1) {
      let error = new Error("Trying to inactivate an inactive participant (" + idFrom.actor + ")");
      error.hash = {
        text: "->>-",
        token: "->>-",
        line: "1",
        loc: { first_line: 1, last_line: 1, first_column: 1, last_column: 1 },
        expected: ["'ACTIVE_PARTICIPANT'"]
      };
      throw error;
    }
  }
  messages.push({
    from: idFrom,
    to: idTo,
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
    type: messageType
  });
  return true;
};
const getMessages = function() {
  return messages;
};
const getActors$1 = function() {
  return actors$1;
};
const getActor = function(id2) {
  return actors$1[id2];
};
const getActorKeys = function() {
  return Object.keys(actors$1);
};
const enableSequenceNumbers = function() {
  sequenceNumbersEnabled = true;
};
const disableSequenceNumbers = function() {
  sequenceNumbersEnabled = false;
};
const showSequenceNumbers = () => sequenceNumbersEnabled;
const setWrap = function(wrapSetting) {
  wrapEnabled = wrapSetting;
};
const autoWrap = () => {
  if (typeof wrapEnabled !== "undefined") {
    return wrapEnabled;
  }
  return getConfig$1().sequence.wrap;
};
const clear$2 = function() {
  actors$1 = {};
  messages = [];
  sequenceNumbersEnabled = false;
  clear$g();
};
const parseMessage = function(str) {
  const _str = str.trim();
  const message2 = {
    text: _str.replace(/^[:]?(?:no)?wrap:/, "").trim(),
    wrap: _str.match(/^[:]?wrap:/) !== null ? true : _str.match(/^[:]?nowrap:/) !== null ? false : void 0
  };
  log$1.debug("parseMessage:", message2);
  return message2;
};
const LINETYPE = {
  SOLID: 0,
  DOTTED: 1,
  NOTE: 2,
  SOLID_CROSS: 3,
  DOTTED_CROSS: 4,
  SOLID_OPEN: 5,
  DOTTED_OPEN: 6,
  LOOP_START: 10,
  LOOP_END: 11,
  ALT_START: 12,
  ALT_ELSE: 13,
  ALT_END: 14,
  OPT_START: 15,
  OPT_END: 16,
  ACTIVE_START: 17,
  ACTIVE_END: 18,
  PAR_START: 19,
  PAR_AND: 20,
  PAR_END: 21,
  RECT_START: 22,
  RECT_END: 23,
  SOLID_POINT: 24,
  DOTTED_POINT: 25,
  AUTONUMBER: 26,
  CRITICAL_START: 27,
  CRITICAL_OPTION: 28,
  CRITICAL_END: 29,
  BREAK_START: 30,
  BREAK_END: 31
};
const ARROWTYPE = {
  FILLED: 0,
  OPEN: 1
};
const PLACEMENT = {
  LEFTOF: 0,
  RIGHTOF: 1,
  OVER: 2
};
const addNote = function(actor, placement, message2) {
  ({
    actor,
    placement,
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap
  });
  const actors2 = [].concat(actor, actor);
  messages.push({
    from: actors2[0],
    to: actors2[1],
    message: message2.text,
    wrap: message2.wrap === void 0 && autoWrap() || !!message2.wrap,
    type: LINETYPE.NOTE,
    placement
  });
};
const addLinks = function(actorId, text2) {
  const actor = getActor(actorId);
  try {
    let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
    sanitizedText = sanitizedText.replace(/&amp;/g, "&");
    sanitizedText = sanitizedText.replace(/&equals;/g, "=");
    const links2 = JSON.parse(sanitizedText);
    insertLinks(actor, links2);
  } catch (e) {
    log$1.error("error while parsing actor link text", e);
  }
};
const addALink = function(actorId, text2) {
  const actor = getActor(actorId);
  try {
    const links2 = {};
    let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
    var sep2 = sanitizedText.indexOf("@");
    sanitizedText = sanitizedText.replace(/&amp;/g, "&");
    sanitizedText = sanitizedText.replace(/&equals;/g, "=");
    var label = sanitizedText.slice(0, sep2 - 1).trim();
    var link2 = sanitizedText.slice(sep2 + 1).trim();
    links2[label] = link2;
    insertLinks(actor, links2);
  } catch (e) {
    log$1.error("error while parsing actor link text", e);
  }
};
function insertLinks(actor, links2) {
  if (actor.links == null) {
    actor.links = links2;
  } else {
    for (let key in links2) {
      actor.links[key] = links2[key];
    }
  }
}
const addProperties = function(actorId, text2) {
  const actor = getActor(actorId);
  try {
    let sanitizedText = sanitizeText$5(text2.text, getConfig$1());
    const properties = JSON.parse(sanitizedText);
    insertProperties(actor, properties);
  } catch (e) {
    log$1.error("error while parsing actor properties text", e);
  }
};
function insertProperties(actor, properties) {
  if (actor.properties == null) {
    actor.properties = properties;
  } else {
    for (let key in properties) {
      actor.properties[key] = properties[key];
    }
  }
}
const addDetails = function(actorId, text2) {
  const actor = getActor(actorId);
  const elem = document.getElementById(text2.text);
  try {
    const text22 = elem.innerHTML;
    const details = JSON.parse(text22);
    if (details["properties"]) {
      insertProperties(actor, details["properties"]);
    }
    if (details["links"]) {
      insertLinks(actor, details["links"]);
    }
  } catch (e) {
    log$1.error("error while parsing actor details text", e);
  }
};
const getActorProperty = function(actor, key) {
  if (typeof actor !== "undefined" && typeof actor.properties !== "undefined") {
    return actor.properties[key];
  }
  return void 0;
};
const apply = function(param) {
  if (param instanceof Array) {
    param.forEach(function(item) {
      apply(item);
    });
  } else {
    switch (param.type) {
      case "sequenceIndex":
        messages.push({
          from: void 0,
          to: void 0,
          message: {
            start: param.sequenceIndex,
            step: param.sequenceIndexStep,
            visible: param.sequenceVisible
          },
          wrap: false,
          type: param.signalType
        });
        break;
      case "addParticipant":
        addActor(param.actor, param.actor, param.description, "participant");
        break;
      case "addActor":
        addActor(param.actor, param.actor, param.description, "actor");
        break;
      case "activeStart":
        addSignal(param.actor, void 0, void 0, param.signalType);
        break;
      case "activeEnd":
        addSignal(param.actor, void 0, void 0, param.signalType);
        break;
      case "addNote":
        addNote(param.actor, param.placement, param.text);
        break;
      case "addLinks":
        addLinks(param.actor, param.text);
        break;
      case "addALink":
        addALink(param.actor, param.text);
        break;
      case "addProperties":
        addProperties(param.actor, param.text);
        break;
      case "addDetails":
        addDetails(param.actor, param.text);
        break;
      case "addMessage":
        addSignal(param.from, param.to, param.msg, param.signalType);
        break;
      case "loopStart":
        addSignal(void 0, void 0, param.loopText, param.signalType);
        break;
      case "loopEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "rectStart":
        addSignal(void 0, void 0, param.color, param.signalType);
        break;
      case "rectEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "optStart":
        addSignal(void 0, void 0, param.optText, param.signalType);
        break;
      case "optEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "altStart":
        addSignal(void 0, void 0, param.altText, param.signalType);
        break;
      case "else":
        addSignal(void 0, void 0, param.altText, param.signalType);
        break;
      case "altEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "setAccTitle":
        setAccTitle(param.text);
        break;
      case "parStart":
        addSignal(void 0, void 0, param.parText, param.signalType);
        break;
      case "and":
        addSignal(void 0, void 0, param.parText, param.signalType);
        break;
      case "parEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "criticalStart":
        addSignal(void 0, void 0, param.criticalText, param.signalType);
        break;
      case "option":
        addSignal(void 0, void 0, param.optionText, param.signalType);
        break;
      case "criticalEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
      case "breakStart":
        addSignal(void 0, void 0, param.breakText, param.signalType);
        break;
      case "breakEnd":
        addSignal(void 0, void 0, void 0, param.signalType);
        break;
    }
  }
};
const sequenceDb = {
  addActor,
  addMessage,
  addSignal,
  addLinks,
  addDetails,
  addProperties,
  autoWrap,
  setWrap,
  enableSequenceNumbers,
  disableSequenceNumbers,
  showSequenceNumbers,
  getMessages,
  getActors: getActors$1,
  getActor,
  getActorKeys,
  getActorProperty,
  getAccTitle,
  getDiagramTitle,
  setDiagramTitle,
  parseDirective: parseDirective$3,
  getConfig: () => getConfig$1().sequence,
  clear: clear$2,
  parseMessage,
  LINETYPE,
  ARROWTYPE,
  PLACEMENT,
  addNote,
  setAccTitle,
  apply,
  setAccDescription,
  getAccDescription
};
let interactionFunctions = [];
const addFunction = (func) => {
  interactionFunctions.push(func);
};
const attachFunctions = () => {
  interactionFunctions.forEach((f) => {
    f();
  });
  interactionFunctions = [];
};
const drawRect$1 = function(elem, rectData) {
  const rectElem = elem.append("rect");
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.y);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", rectData.width);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (typeof rectData.class !== "undefined") {
    rectElem.attr("class", rectData.class);
  }
  return rectElem;
};
const addPopupInteraction = (id2, actorCnt2) => {
  addFunction(() => {
    const arr = document.querySelectorAll(id2);
    if (arr.length === 0)
      return;
    arr[0].addEventListener("mouseover", function() {
      popupMenuUpFunc("actor" + actorCnt2 + "_popup");
    });
    arr[0].addEventListener("mouseout", function() {
      popupMenuDownFunc("actor" + actorCnt2 + "_popup");
    });
  });
};
const drawPopup = function(elem, actor, minMenuWidth, textAttrs, forceMenus) {
  if (actor.links === void 0 || actor.links === null || Object.keys(actor.links).length === 0) {
    return { height: 0, width: 0 };
  }
  const links2 = actor.links;
  const actorCnt2 = actor.actorCnt;
  const rectData = actor.rectData;
  var displayValue = "none";
  if (forceMenus) {
    displayValue = "block !important";
  }
  const g = elem.append("g");
  g.attr("id", "actor" + actorCnt2 + "_popup");
  g.attr("class", "actorPopupMenu");
  g.attr("display", displayValue);
  addPopupInteraction("#actor" + actorCnt2 + "_popup", actorCnt2);
  var actorClass = "";
  if (typeof rectData.class !== "undefined") {
    actorClass = " " + rectData.class;
  }
  let menuWidth = rectData.width > minMenuWidth ? rectData.width : minMenuWidth;
  const rectElem = g.append("rect");
  rectElem.attr("class", "actorPopupMenuPanel" + actorClass);
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.height);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", menuWidth);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (links2 != null) {
    var linkY = 20;
    for (let key in links2) {
      var linkElem = g.append("a");
      var sanitizedLink = sanitizeUrl_1(links2[key]);
      linkElem.attr("xlink:href", sanitizedLink);
      linkElem.attr("target", "_blank");
      _drawMenuItemTextCandidateFunc(textAttrs)(
        key,
        linkElem,
        rectData.x + 10,
        rectData.height + linkY,
        menuWidth,
        20,
        { class: "actor" },
        textAttrs
      );
      linkY += 30;
    }
  }
  rectElem.attr("height", linkY);
  return { height: rectData.height + linkY, width: menuWidth };
};
const drawImage = function(elem, x2, y2, link2) {
  const imageElem = elem.append("image");
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  var sanitizedLink = sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", sanitizedLink);
};
const drawEmbeddedImage = function(elem, x2, y2, link2) {
  const imageElem = elem.append("use");
  imageElem.attr("x", x2);
  imageElem.attr("y", y2);
  var sanitizedLink = sanitizeUrl_1(link2);
  imageElem.attr("xlink:href", "#" + sanitizedLink);
};
const popupMenu = function(popid) {
  return "var pu = document.getElementById('" + popid + "'); if (pu != null) { pu.style.display = 'block'; }";
};
const popdownMenu = function(popid) {
  return "var pu = document.getElementById('" + popid + "'); if (pu != null) { pu.style.display = 'none'; }";
};
const popupMenuUpFunc = function(popupId) {
  var pu = document.getElementById(popupId);
  if (pu != null) {
    pu.style.display = "block";
  }
};
const popupMenuDownFunc = function(popupId) {
  var pu = document.getElementById(popupId);
  if (pu != null) {
    pu.style.display = "none";
  }
};
const drawText$1 = function(elem, textData) {
  let prevTextHeight = 0, textHeight = 0;
  const lines = textData.text.split(common.lineBreakRegex);
  let textElems = [];
  let dy = 0;
  let yfunc = () => textData.y;
  if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
    switch (textData.valign) {
      case "top":
      case "start":
        yfunc = () => Math.round(textData.y + textData.textMargin);
        break;
      case "middle":
      case "center":
        yfunc = () => Math.round(textData.y + (prevTextHeight + textHeight + textData.textMargin) / 2);
        break;
      case "bottom":
      case "end":
        yfunc = () => Math.round(
          textData.y + (prevTextHeight + textHeight + 2 * textData.textMargin) - textData.textMargin
        );
        break;
    }
  }
  if (typeof textData.anchor !== "undefined" && typeof textData.textMargin !== "undefined" && typeof textData.width !== "undefined") {
    switch (textData.anchor) {
      case "left":
      case "start":
        textData.x = Math.round(textData.x + textData.textMargin);
        textData.anchor = "start";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
      case "middle":
      case "center":
        textData.x = Math.round(textData.x + textData.width / 2);
        textData.anchor = "middle";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
      case "right":
      case "end":
        textData.x = Math.round(textData.x + textData.width - textData.textMargin);
        textData.anchor = "end";
        textData.dominantBaseline = "middle";
        textData.alignmentBaseline = "middle";
        break;
    }
  }
  for (let i = 0; i < lines.length; i++) {
    let line2 = lines[i];
    if (typeof textData.textMargin !== "undefined" && textData.textMargin === 0 && typeof textData.fontSize !== "undefined") {
      dy = i * textData.fontSize;
    }
    const textElem = elem.append("text");
    textElem.attr("x", textData.x);
    textElem.attr("y", yfunc());
    if (typeof textData.anchor !== "undefined") {
      textElem.attr("text-anchor", textData.anchor).attr("dominant-baseline", textData.dominantBaseline).attr("alignment-baseline", textData.alignmentBaseline);
    }
    if (typeof textData.fontFamily !== "undefined") {
      textElem.style("font-family", textData.fontFamily);
    }
    if (typeof textData.fontSize !== "undefined") {
      textElem.style("font-size", textData.fontSize);
    }
    if (typeof textData.fontWeight !== "undefined") {
      textElem.style("font-weight", textData.fontWeight);
    }
    if (typeof textData.fill !== "undefined") {
      textElem.attr("fill", textData.fill);
    }
    if (typeof textData.class !== "undefined") {
      textElem.attr("class", textData.class);
    }
    if (typeof textData.dy !== "undefined") {
      textElem.attr("dy", textData.dy);
    } else if (dy !== 0) {
      textElem.attr("dy", dy);
    }
    if (textData.tspan) {
      const span = textElem.append("tspan");
      span.attr("x", textData.x);
      if (typeof textData.fill !== "undefined") {
        span.attr("fill", textData.fill);
      }
      span.text(line2);
    } else {
      textElem.text(line2);
    }
    if (typeof textData.valign !== "undefined" && typeof textData.textMargin !== "undefined" && textData.textMargin > 0) {
      textHeight += (textElem._groups || textElem)[0][0].getBBox().height;
      prevTextHeight = textHeight;
    }
    textElems.push(textElem);
  }
  return textElems;
};
const drawLabel$1 = function(elem, txtObject) {
  function genPoints(x2, y2, width2, height2, cut) {
    return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
  }
  const polygon = elem.append("polygon");
  polygon.attr("points", genPoints(txtObject.x, txtObject.y, txtObject.width, txtObject.height, 7));
  polygon.attr("class", "labelBox");
  txtObject.y = txtObject.y + txtObject.height / 2;
  drawText$1(elem, txtObject);
  return polygon;
};
let actorCnt = -1;
const fixLifeLineHeights = (diagram, bounds2) => {
  if (!diagram.selectAll)
    return;
  diagram.selectAll(".actor-line").attr("class", "200").attr("y2", bounds2 - 55);
};
const drawActorTypeParticipant = function(elem, actor, conf2) {
  const center2 = actor.x + actor.width / 2;
  const boxpluslineGroup = elem.append("g");
  var g = boxpluslineGroup;
  if (actor.y === 0) {
    actorCnt++;
    g.append("line").attr("id", "actor" + actorCnt).attr("x1", center2).attr("y1", 5).attr("x2", center2).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999");
    g = boxpluslineGroup.append("g");
    actor.actorCnt = actorCnt;
    if (actor.links != null) {
      g.attr("id", "root-" + actorCnt);
      addPopupInteraction("#root-" + actorCnt, actorCnt);
    }
  }
  const rect2 = getNoteRect$1();
  var cssclass = "actor";
  if (actor.properties != null && actor.properties["class"]) {
    cssclass = actor.properties["class"];
  } else {
    rect2.fill = "#eaeaea";
  }
  rect2.x = actor.x;
  rect2.y = actor.y;
  rect2.width = actor.width;
  rect2.height = actor.height;
  rect2.class = cssclass;
  rect2.rx = 3;
  rect2.ry = 3;
  const rectElem = drawRect$1(g, rect2);
  actor.rectData = rect2;
  if (actor.properties != null && actor.properties["icon"]) {
    const iconSrc = actor.properties["icon"].trim();
    if (iconSrc.charAt(0) === "@") {
      drawEmbeddedImage(g, rect2.x + rect2.width - 20, rect2.y + 10, iconSrc.substr(1));
    } else {
      drawImage(g, rect2.x + rect2.width - 20, rect2.y + 10, iconSrc);
    }
  }
  _drawTextCandidateFunc$1(conf2)(
    actor.description,
    g,
    rect2.x,
    rect2.y,
    rect2.width,
    rect2.height,
    { class: "actor" },
    conf2
  );
  let height2 = actor.height;
  if (rectElem.node) {
    const bounds2 = rectElem.node().getBBox();
    actor.height = bounds2.height;
    height2 = bounds2.height;
  }
  return height2;
};
const drawActorTypeActor = function(elem, actor, conf2) {
  const center2 = actor.x + actor.width / 2;
  if (actor.y === 0) {
    actorCnt++;
    elem.append("line").attr("id", "actor" + actorCnt).attr("x1", center2).attr("y1", 80).attr("x2", center2).attr("y2", 2e3).attr("class", "actor-line").attr("stroke-width", "0.5px").attr("stroke", "#999");
  }
  const actElem = elem.append("g");
  actElem.attr("class", "actor-man");
  const rect2 = getNoteRect$1();
  rect2.x = actor.x;
  rect2.y = actor.y;
  rect2.fill = "#eaeaea";
  rect2.width = actor.width;
  rect2.height = actor.height;
  rect2.class = "actor";
  rect2.rx = 3;
  rect2.ry = 3;
  actElem.append("line").attr("id", "actor-man-torso" + actorCnt).attr("x1", center2).attr("y1", actor.y + 25).attr("x2", center2).attr("y2", actor.y + 45);
  actElem.append("line").attr("id", "actor-man-arms" + actorCnt).attr("x1", center2 - 18).attr("y1", actor.y + 33).attr("x2", center2 + 18).attr("y2", actor.y + 33);
  actElem.append("line").attr("x1", center2 - 18).attr("y1", actor.y + 60).attr("x2", center2).attr("y2", actor.y + 45);
  actElem.append("line").attr("x1", center2).attr("y1", actor.y + 45).attr("x2", center2 + 16).attr("y2", actor.y + 60);
  const circle2 = actElem.append("circle");
  circle2.attr("cx", actor.x + actor.width / 2);
  circle2.attr("cy", actor.y + 10);
  circle2.attr("r", 15);
  circle2.attr("width", actor.width);
  circle2.attr("height", actor.height);
  const bounds2 = actElem.node().getBBox();
  actor.height = bounds2.height;
  _drawTextCandidateFunc$1(conf2)(
    actor.description,
    actElem,
    rect2.x,
    rect2.y + 35,
    rect2.width,
    rect2.height,
    { class: "actor" },
    conf2
  );
  return actor.height;
};
const drawActor = function(elem, actor, conf2) {
  switch (actor.type) {
    case "actor":
      return drawActorTypeActor(elem, actor, conf2);
    case "participant":
      return drawActorTypeParticipant(elem, actor, conf2);
  }
};
const anchorElement = function(elem) {
  return elem.append("g");
};
const drawActivation = function(elem, bounds2, verticalPos, conf2, actorActivations2) {
  const rect2 = getNoteRect$1();
  const g = bounds2.anchored;
  rect2.x = bounds2.startx;
  rect2.y = bounds2.starty;
  rect2.class = "activation" + actorActivations2 % 3;
  rect2.width = bounds2.stopx - bounds2.startx;
  rect2.height = verticalPos - bounds2.starty;
  drawRect$1(g, rect2);
};
const drawLoop = function(elem, loopModel, labelText, conf2) {
  const {
    boxMargin,
    boxTextMargin,
    labelBoxHeight,
    labelBoxWidth,
    messageFontFamily: fontFamily,
    messageFontSize: fontSize,
    messageFontWeight: fontWeight
  } = conf2;
  const g = elem.append("g");
  const drawLoopLine = function(startx, starty, stopx, stopy) {
    return g.append("line").attr("x1", startx).attr("y1", starty).attr("x2", stopx).attr("y2", stopy).attr("class", "loopLine");
  };
  drawLoopLine(loopModel.startx, loopModel.starty, loopModel.stopx, loopModel.starty);
  drawLoopLine(loopModel.stopx, loopModel.starty, loopModel.stopx, loopModel.stopy);
  drawLoopLine(loopModel.startx, loopModel.stopy, loopModel.stopx, loopModel.stopy);
  drawLoopLine(loopModel.startx, loopModel.starty, loopModel.startx, loopModel.stopy);
  if (typeof loopModel.sections !== "undefined") {
    loopModel.sections.forEach(function(item) {
      drawLoopLine(loopModel.startx, item.y, loopModel.stopx, item.y).style(
        "stroke-dasharray",
        "3, 3"
      );
    });
  }
  let txt = getTextObj$1();
  txt.text = labelText;
  txt.x = loopModel.startx;
  txt.y = loopModel.starty;
  txt.fontFamily = fontFamily;
  txt.fontSize = fontSize;
  txt.fontWeight = fontWeight;
  txt.anchor = "middle";
  txt.valign = "middle";
  txt.tspan = false;
  txt.width = labelBoxWidth || 50;
  txt.height = labelBoxHeight || 20;
  txt.textMargin = boxTextMargin;
  txt.class = "labelText";
  drawLabel$1(g, txt);
  txt = getTextObj$1();
  txt.text = loopModel.title;
  txt.x = loopModel.startx + labelBoxWidth / 2 + (loopModel.stopx - loopModel.startx) / 2;
  txt.y = loopModel.starty + boxMargin + boxTextMargin;
  txt.anchor = "middle";
  txt.valign = "middle";
  txt.textMargin = boxTextMargin;
  txt.class = "loopText";
  txt.fontFamily = fontFamily;
  txt.fontSize = fontSize;
  txt.fontWeight = fontWeight;
  txt.wrap = true;
  let textElem = drawText$1(g, txt);
  if (typeof loopModel.sectionTitles !== "undefined") {
    loopModel.sectionTitles.forEach(function(item, idx) {
      if (item.message) {
        txt.text = item.message;
        txt.x = loopModel.startx + (loopModel.stopx - loopModel.startx) / 2;
        txt.y = loopModel.sections[idx].y + boxMargin + boxTextMargin;
        txt.class = "loopText";
        txt.anchor = "middle";
        txt.valign = "middle";
        txt.tspan = false;
        txt.fontFamily = fontFamily;
        txt.fontSize = fontSize;
        txt.fontWeight = fontWeight;
        txt.wrap = loopModel.wrap;
        textElem = drawText$1(g, txt);
        let sectionHeight = Math.round(
          textElem.map((te) => (te._groups || te)[0][0].getBBox().height).reduce((acc, curr) => acc + curr)
        );
        loopModel.sections[idx].height += sectionHeight - (boxMargin + boxTextMargin);
      }
    });
  }
  loopModel.height = Math.round(loopModel.stopy - loopModel.starty);
  return g;
};
const drawBackgroundRect$1 = function(elem, bounds2) {
  const rectElem = drawRect$1(elem, {
    x: bounds2.startx,
    y: bounds2.starty,
    width: bounds2.stopx - bounds2.startx,
    height: bounds2.stopy - bounds2.starty,
    fill: bounds2.fill,
    class: "rect"
  });
  rectElem.lower();
};
const insertDatabaseIcon = function(elem) {
  elem.append("defs").append("symbol").attr("id", "database").attr("fill-rule", "evenodd").attr("clip-rule", "evenodd").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z"
  );
};
const insertComputerIcon = function(elem) {
  elem.append("defs").append("symbol").attr("id", "computer").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z"
  );
};
const insertClockIcon = function(elem) {
  elem.append("defs").append("symbol").attr("id", "clock").attr("width", "24").attr("height", "24").append("path").attr("transform", "scale(.5)").attr(
    "d",
    "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z"
  );
};
const insertArrowHead = function(elem) {
  elem.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 9).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 12).attr("markerHeight", 12).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z");
};
const insertArrowFilledHead = function(elem) {
  elem.append("defs").append("marker").attr("id", "filled-head").attr("refX", 18).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
};
const insertSequenceNumber = function(elem) {
  elem.append("defs").append("marker").attr("id", "sequencenumber").attr("refX", 15).attr("refY", 15).attr("markerWidth", 60).attr("markerHeight", 40).attr("orient", "auto").append("circle").attr("cx", 15).attr("cy", 15).attr("r", 6);
};
const insertArrowCrossHead = function(elem) {
  const defs = elem.append("defs");
  const marker = defs.append("marker").attr("id", "crosshead").attr("markerWidth", 15).attr("markerHeight", 8).attr("orient", "auto").attr("refX", 16).attr("refY", 4);
  marker.append("path").attr("fill", "black").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 9,2 V 6 L16,4 Z");
  marker.append("path").attr("fill", "none").attr("stroke", "#000000").style("stroke-dasharray", "0, 0").attr("stroke-width", "1px").attr("d", "M 0,1 L 6,7 M 6,1 L 0,7");
};
const getTextObj$1 = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: void 0,
    style: "#666",
    width: void 0,
    height: void 0,
    textMargin: 0,
    rx: 0,
    ry: 0,
    tspan: true,
    valign: void 0
  };
};
const getNoteRect$1 = function() {
  return {
    x: 0,
    y: 0,
    fill: "#EDF2AE",
    stroke: "#666",
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
};
const _drawTextCandidateFunc$1 = function() {
  function byText(content, g, x2, y2, width2, height2, textAttrs) {
    const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("text-anchor", "middle").text(content);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2) {
    const { actorFontSize, actorFontFamily, actorFontWeight } = conf2;
    let _actorFontSize = actorFontSize && actorFontSize.replace ? actorFontSize.replace("px", "") : actorFontSize;
    const lines = content.split(common.lineBreakRegex);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * _actorFontSize - _actorFontSize * (lines.length - 1) / 2;
      const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2).style("text-anchor", "middle").style("font-size", actorFontSize).style("font-weight", actorFontWeight).style("font-family", actorFontFamily);
      text2.append("tspan").attr("x", x2 + width2 / 2).attr("dy", dy).text(lines[i]);
      text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
    const s2 = g.append("switch");
    const f = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
    const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
    byTspan(content, s2, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (fromTextAttrsDict.hasOwnProperty(key)) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const _drawMenuItemTextCandidateFunc = function() {
  function byText(content, g, x2, y2, width2, height2, textAttrs) {
    const text2 = g.append("text").attr("x", x2).attr("y", y2).style("text-anchor", "start").text(content);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2) {
    const { actorFontSize, actorFontFamily, actorFontWeight } = conf2;
    const lines = content.split(common.lineBreakRegex);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * actorFontSize - actorFontSize * (lines.length - 1) / 2;
      const text2 = g.append("text").attr("x", x2).attr("y", y2).style("text-anchor", "start").style("font-size", actorFontSize).style("font-weight", actorFontWeight).style("font-family", actorFontFamily);
      text2.append("tspan").attr("x", x2).attr("dy", dy).text(lines[i]);
      text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
    const s2 = g.append("switch");
    const f = s2.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2);
    const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
    byTspan(content, s2, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (fromTextAttrsDict.hasOwnProperty(key)) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const svgDraw$1 = {
  drawRect: drawRect$1,
  drawText: drawText$1,
  drawLabel: drawLabel$1,
  drawActor,
  drawPopup,
  drawImage,
  drawEmbeddedImage,
  anchorElement,
  drawActivation,
  drawLoop,
  drawBackgroundRect: drawBackgroundRect$1,
  insertArrowHead,
  insertArrowFilledHead,
  insertSequenceNumber,
  insertArrowCrossHead,
  insertDatabaseIcon,
  insertComputerIcon,
  insertClockIcon,
  getTextObj: getTextObj$1,
  getNoteRect: getNoteRect$1,
  popupMenu,
  popdownMenu,
  fixLifeLineHeights,
  sanitizeUrl: sanitizeUrl_1
};
let conf$4 = {};
const bounds$1 = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  activations: [],
  models: {
    getHeight: function() {
      return Math.max.apply(
        null,
        this.actors.length === 0 ? [0] : this.actors.map((actor) => actor.height || 0)
      ) + (this.loops.length === 0 ? 0 : this.loops.map((it) => it.height || 0).reduce((acc, h) => acc + h)) + (this.messages.length === 0 ? 0 : this.messages.map((it) => it.height || 0).reduce((acc, h) => acc + h)) + (this.notes.length === 0 ? 0 : this.notes.map((it) => it.height || 0).reduce((acc, h) => acc + h));
    },
    clear: function() {
      this.actors = [];
      this.loops = [];
      this.messages = [];
      this.notes = [];
    },
    addActor: function(actorModel) {
      this.actors.push(actorModel);
    },
    addLoop: function(loopModel) {
      this.loops.push(loopModel);
    },
    addMessage: function(msgModel) {
      this.messages.push(msgModel);
    },
    addNote: function(noteModel) {
      this.notes.push(noteModel);
    },
    lastActor: function() {
      return this.actors[this.actors.length - 1];
    },
    lastLoop: function() {
      return this.loops[this.loops.length - 1];
    },
    lastMessage: function() {
      return this.messages[this.messages.length - 1];
    },
    lastNote: function() {
      return this.notes[this.notes.length - 1];
    },
    actors: [],
    loops: [],
    messages: [],
    notes: []
  },
  init: function() {
    this.sequenceItems = [];
    this.activations = [];
    this.models.clear();
    this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    };
    this.verticalPos = 0;
    setConf$4(getConfig$1());
  },
  updateVal: function(obj, key, val, fun) {
    if (typeof obj[key] === "undefined") {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  },
  updateBounds: function(startx, starty, stopx, stopy) {
    const _self = this;
    let cnt2 = 0;
    function updateFn(type2) {
      return function updateItemBounds(item) {
        cnt2++;
        const n = _self.sequenceItems.length - cnt2 + 1;
        _self.updateVal(item, "starty", starty - n * conf$4.boxMargin, Math.min);
        _self.updateVal(item, "stopy", stopy + n * conf$4.boxMargin, Math.max);
        _self.updateVal(bounds$1.data, "startx", startx - n * conf$4.boxMargin, Math.min);
        _self.updateVal(bounds$1.data, "stopx", stopx + n * conf$4.boxMargin, Math.max);
        if (!(type2 === "activation")) {
          _self.updateVal(item, "startx", startx - n * conf$4.boxMargin, Math.min);
          _self.updateVal(item, "stopx", stopx + n * conf$4.boxMargin, Math.max);
          _self.updateVal(bounds$1.data, "starty", starty - n * conf$4.boxMargin, Math.min);
          _self.updateVal(bounds$1.data, "stopy", stopy + n * conf$4.boxMargin, Math.max);
        }
      };
    }
    this.sequenceItems.forEach(updateFn());
    this.activations.forEach(updateFn("activation"));
  },
  insert: function(startx, starty, stopx, stopy) {
    const _startx = Math.min(startx, stopx);
    const _stopx = Math.max(startx, stopx);
    const _starty = Math.min(starty, stopy);
    const _stopy = Math.max(starty, stopy);
    this.updateVal(bounds$1.data, "startx", _startx, Math.min);
    this.updateVal(bounds$1.data, "starty", _starty, Math.min);
    this.updateVal(bounds$1.data, "stopx", _stopx, Math.max);
    this.updateVal(bounds$1.data, "stopy", _stopy, Math.max);
    this.updateBounds(_startx, _starty, _stopx, _stopy);
  },
  newActivation: function(message2, diagram, actors2) {
    const actorRect = actors2[message2.from.actor];
    const stackedSize = actorActivations(message2.from.actor).length || 0;
    const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf$4.activationWidth / 2;
    this.activations.push({
      startx: x2,
      starty: this.verticalPos + 2,
      stopx: x2 + conf$4.activationWidth,
      stopy: void 0,
      actor: message2.from.actor,
      anchored: svgDraw$1.anchorElement(diagram)
    });
  },
  endActivation: function(message2) {
    const lastActorActivationIdx = this.activations.map(function(activation) {
      return activation.actor;
    }).lastIndexOf(message2.from.actor);
    return this.activations.splice(lastActorActivationIdx, 1)[0];
  },
  createLoop: function(title2 = { message: void 0, wrap: false, width: void 0 }, fill) {
    return {
      startx: void 0,
      starty: this.verticalPos,
      stopx: void 0,
      stopy: void 0,
      title: title2.message,
      wrap: title2.wrap,
      width: title2.width,
      height: 0,
      fill
    };
  },
  newLoop: function(title2 = { message: void 0, wrap: false, width: void 0 }, fill) {
    this.sequenceItems.push(this.createLoop(title2, fill));
  },
  endLoop: function() {
    return this.sequenceItems.pop();
  },
  addSectionToLoop: function(message2) {
    const loop = this.sequenceItems.pop();
    loop.sections = loop.sections || [];
    loop.sectionTitles = loop.sectionTitles || [];
    loop.sections.push({ y: bounds$1.getVerticalPos(), height: 0 });
    loop.sectionTitles.push(message2);
    this.sequenceItems.push(loop);
  },
  bumpVerticalPos: function(bump) {
    this.verticalPos = this.verticalPos + bump;
    this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return { bounds: this.data, models: this.models };
  }
};
const drawNote$1 = function(elem, noteModel) {
  bounds$1.bumpVerticalPos(conf$4.boxMargin);
  noteModel.height = conf$4.boxMargin;
  noteModel.starty = bounds$1.getVerticalPos();
  const rect2 = svgDraw$1.getNoteRect();
  rect2.x = noteModel.startx;
  rect2.y = noteModel.starty;
  rect2.width = noteModel.width || conf$4.width;
  rect2.class = "note";
  const g = elem.append("g");
  const rectElem = svgDraw$1.drawRect(g, rect2);
  const textObj = svgDraw$1.getTextObj();
  textObj.x = noteModel.startx;
  textObj.y = noteModel.starty;
  textObj.width = rect2.width;
  textObj.dy = "1em";
  textObj.text = noteModel.message;
  textObj.class = "noteText";
  textObj.fontFamily = conf$4.noteFontFamily;
  textObj.fontSize = conf$4.noteFontSize;
  textObj.fontWeight = conf$4.noteFontWeight;
  textObj.anchor = conf$4.noteAlign;
  textObj.textMargin = conf$4.noteMargin;
  textObj.valign = "center";
  const textElem = drawText$1(g, textObj);
  const textHeight = Math.round(
    textElem.map((te) => (te._groups || te)[0][0].getBBox().height).reduce((acc, curr) => acc + curr)
  );
  rectElem.attr("height", textHeight + 2 * conf$4.noteMargin);
  noteModel.height += textHeight + 2 * conf$4.noteMargin;
  bounds$1.bumpVerticalPos(textHeight + 2 * conf$4.noteMargin);
  noteModel.stopy = noteModel.starty + textHeight + 2 * conf$4.noteMargin;
  noteModel.stopx = noteModel.startx + rect2.width;
  bounds$1.insert(noteModel.startx, noteModel.starty, noteModel.stopx, noteModel.stopy);
  bounds$1.models.addNote(noteModel);
};
const messageFont = (cnf) => {
  return {
    fontFamily: cnf.messageFontFamily,
    fontSize: cnf.messageFontSize,
    fontWeight: cnf.messageFontWeight
  };
};
const noteFont = (cnf) => {
  return {
    fontFamily: cnf.noteFontFamily,
    fontSize: cnf.noteFontSize,
    fontWeight: cnf.noteFontWeight
  };
};
const actorFont = (cnf) => {
  return {
    fontFamily: cnf.actorFontFamily,
    fontSize: cnf.actorFontSize,
    fontWeight: cnf.actorFontWeight
  };
};
const boundMessage = function(diagram, msgModel) {
  bounds$1.bumpVerticalPos(10);
  const { startx, stopx, message: message2 } = msgModel;
  const lines = common.splitBreaks(message2).length;
  const textDims = utils.calculateTextDimensions(message2, messageFont(conf$4));
  const lineHeight = textDims.height / lines;
  msgModel.height += lineHeight;
  bounds$1.bumpVerticalPos(lineHeight);
  let lineStarty;
  let totalOffset = textDims.height - 10;
  const textWidth = textDims.width;
  if (startx === stopx) {
    lineStarty = bounds$1.getVerticalPos() + totalOffset;
    if (!conf$4.rightAngles) {
      totalOffset += conf$4.boxMargin;
      lineStarty = bounds$1.getVerticalPos() + totalOffset;
    }
    totalOffset += 30;
    const dx = Math.max(textWidth / 2, conf$4.width / 2);
    bounds$1.insert(
      startx - dx,
      bounds$1.getVerticalPos() - 10 + totalOffset,
      stopx + dx,
      bounds$1.getVerticalPos() + 30 + totalOffset
    );
  } else {
    totalOffset += conf$4.boxMargin;
    lineStarty = bounds$1.getVerticalPos() + totalOffset;
    bounds$1.insert(startx, lineStarty - 10, stopx, lineStarty);
  }
  bounds$1.bumpVerticalPos(totalOffset);
  msgModel.height += totalOffset;
  msgModel.stopy = msgModel.starty + msgModel.height;
  bounds$1.insert(msgModel.fromBounds, msgModel.starty, msgModel.toBounds, msgModel.stopy);
  return lineStarty;
};
const drawMessage = function(diagram, msgModel, lineStarty, diagObj) {
  const { startx, stopx, starty, message: message2, type: type2, sequenceIndex, sequenceVisible } = msgModel;
  const textDims = utils.calculateTextDimensions(message2, messageFont(conf$4));
  const textObj = svgDraw$1.getTextObj();
  textObj.x = startx;
  textObj.y = starty + 10;
  textObj.width = stopx - startx;
  textObj.class = "messageText";
  textObj.dy = "1em";
  textObj.text = message2;
  textObj.fontFamily = conf$4.messageFontFamily;
  textObj.fontSize = conf$4.messageFontSize;
  textObj.fontWeight = conf$4.messageFontWeight;
  textObj.anchor = conf$4.messageAlign;
  textObj.valign = "center";
  textObj.textMargin = conf$4.wrapPadding;
  textObj.tspan = false;
  drawText$1(diagram, textObj);
  const textWidth = textDims.width;
  let line2;
  if (startx === stopx) {
    if (conf$4.rightAngles) {
      line2 = diagram.append("path").attr(
        "d",
        `M  ${startx},${lineStarty} H ${startx + Math.max(conf$4.width / 2, textWidth / 2)} V ${lineStarty + 25} H ${startx}`
      );
    } else {
      line2 = diagram.append("path").attr(
        "d",
        "M " + startx + "," + lineStarty + " C " + (startx + 60) + "," + (lineStarty - 10) + " " + (startx + 60) + "," + (lineStarty + 30) + " " + startx + "," + (lineStarty + 20)
      );
    }
  } else {
    line2 = diagram.append("line");
    line2.attr("x1", startx);
    line2.attr("y1", lineStarty);
    line2.attr("x2", stopx);
    line2.attr("y2", lineStarty);
  }
  if (type2 === diagObj.db.LINETYPE.DOTTED || type2 === diagObj.db.LINETYPE.DOTTED_CROSS || type2 === diagObj.db.LINETYPE.DOTTED_POINT || type2 === diagObj.db.LINETYPE.DOTTED_OPEN) {
    line2.style("stroke-dasharray", "3, 3");
    line2.attr("class", "messageLine1");
  } else {
    line2.attr("class", "messageLine0");
  }
  let url = "";
  if (conf$4.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  line2.attr("stroke-width", 2);
  line2.attr("stroke", "none");
  line2.style("fill", "none");
  if (type2 === diagObj.db.LINETYPE.SOLID || type2 === diagObj.db.LINETYPE.DOTTED) {
    line2.attr("marker-end", "url(" + url + "#arrowhead)");
  }
  if (type2 === diagObj.db.LINETYPE.SOLID_POINT || type2 === diagObj.db.LINETYPE.DOTTED_POINT) {
    line2.attr("marker-end", "url(" + url + "#filled-head)");
  }
  if (type2 === diagObj.db.LINETYPE.SOLID_CROSS || type2 === diagObj.db.LINETYPE.DOTTED_CROSS) {
    line2.attr("marker-end", "url(" + url + "#crosshead)");
  }
  if (sequenceVisible || conf$4.showSequenceNumbers) {
    line2.attr("marker-start", "url(" + url + "#sequencenumber)");
    diagram.append("text").attr("x", startx).attr("y", lineStarty + 4).attr("font-family", "sans-serif").attr("font-size", "12px").attr("text-anchor", "middle").attr("class", "sequenceNumber").text(sequenceIndex);
  }
};
const drawActors = function(diagram, actors2, actorKeys, verticalPos, configuration, messages2) {
  if (configuration.hideUnusedParticipants === true) {
    const newActors = /* @__PURE__ */ new Set();
    messages2.forEach((message2) => {
      newActors.add(message2.from);
      newActors.add(message2.to);
    });
    actorKeys = actorKeys.filter((actorKey) => newActors.has(actorKey));
  }
  let prevWidth = 0;
  let prevMargin = 0;
  let maxHeight = 0;
  for (let i = 0; i < actorKeys.length; i++) {
    const actor = actors2[actorKeys[i]];
    actor.width = actor.width || conf$4.width;
    actor.height = Math.max(actor.height || conf$4.height, conf$4.height);
    actor.margin = actor.margin || conf$4.actorMargin;
    actor.x = prevWidth + prevMargin;
    actor.y = verticalPos;
    const height2 = svgDraw$1.drawActor(diagram, actor, conf$4);
    maxHeight = Math.max(maxHeight, height2);
    bounds$1.insert(actor.x, verticalPos, actor.x + actor.width, actor.height);
    prevWidth += actor.width;
    prevMargin += actor.margin;
    bounds$1.models.addActor(actor);
  }
  bounds$1.bumpVerticalPos(maxHeight);
};
const drawActorsPopup = function(diagram, actors2, actorKeys, doc) {
  let maxHeight = 0;
  let maxWidth = 0;
  for (let i = 0; i < actorKeys.length; i++) {
    const actor = actors2[actorKeys[i]];
    const minMenuWidth = getRequiredPopupWidth(actor);
    const menuDimensions = svgDraw$1.drawPopup(
      diagram,
      actor,
      minMenuWidth,
      conf$4,
      conf$4.forceMenus,
      doc
    );
    if (menuDimensions.height > maxHeight) {
      maxHeight = menuDimensions.height;
    }
    if (menuDimensions.width + actor.x > maxWidth) {
      maxWidth = menuDimensions.width + actor.x;
    }
  }
  return { maxHeight, maxWidth };
};
const setConf$4 = function(cnf) {
  assignWithDepth(conf$4, cnf);
  if (cnf.fontFamily) {
    conf$4.actorFontFamily = conf$4.noteFontFamily = conf$4.messageFontFamily = cnf.fontFamily;
  }
  if (cnf.fontSize) {
    conf$4.actorFontSize = conf$4.noteFontSize = conf$4.messageFontSize = cnf.fontSize;
  }
  if (cnf.fontWeight) {
    conf$4.actorFontWeight = conf$4.noteFontWeight = conf$4.messageFontWeight = cnf.fontWeight;
  }
};
const actorActivations = function(actor) {
  return bounds$1.activations.filter(function(activation) {
    return activation.actor === actor;
  });
};
const activationBounds = function(actor, actors2) {
  const actorObj = actors2[actor];
  const activations = actorActivations(actor);
  const left2 = activations.reduce(function(acc, activation) {
    return Math.min(acc, activation.startx);
  }, actorObj.x + actorObj.width / 2);
  const right2 = activations.reduce(function(acc, activation) {
    return Math.max(acc, activation.stopx);
  }, actorObj.x + actorObj.width / 2);
  return [left2, right2];
};
function adjustLoopHeightForWrap(loopWidths, msg, preMargin, postMargin, addLoopFn) {
  bounds$1.bumpVerticalPos(preMargin);
  let heightAdjust = postMargin;
  if (msg.id && msg.message && loopWidths[msg.id]) {
    const loopWidth = loopWidths[msg.id].width;
    const textConf = messageFont(conf$4);
    msg.message = utils.wrapLabel(`[${msg.message}]`, loopWidth - 2 * conf$4.wrapPadding, textConf);
    msg.width = loopWidth;
    msg.wrap = true;
    const textDims = utils.calculateTextDimensions(msg.message, textConf);
    const totalOffset = Math.max(textDims.height, conf$4.labelBoxHeight);
    heightAdjust = postMargin + totalOffset;
    log$1.debug(`${totalOffset} - ${msg.message}`);
  }
  addLoopFn(msg);
  bounds$1.bumpVerticalPos(heightAdjust);
}
const draw$4 = function(_text, id2, _version, diagObj) {
  const { securityLevel, sequence: sequence2 } = getConfig$1();
  conf$4 = sequence2;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  bounds$1.init();
  log$1.debug(diagObj.db);
  const diagram = securityLevel === "sandbox" ? root2.select(`[id="${id2}"]`) : select$1(`[id="${id2}"]`);
  const actors2 = diagObj.db.getActors();
  const actorKeys = diagObj.db.getActorKeys();
  const messages2 = diagObj.db.getMessages();
  const title2 = diagObj.db.getDiagramTitle();
  const maxMessageWidthPerActor = getMaxMessageWidthPerActor(actors2, messages2, diagObj);
  conf$4.height = calculateActorMargins(actors2, maxMessageWidthPerActor);
  svgDraw$1.insertComputerIcon(diagram);
  svgDraw$1.insertDatabaseIcon(diagram);
  svgDraw$1.insertClockIcon(diagram);
  drawActors(diagram, actors2, actorKeys, 0, conf$4, messages2);
  const loopWidths = calculateLoopBounds(messages2, actors2, maxMessageWidthPerActor, diagObj);
  svgDraw$1.insertArrowHead(diagram);
  svgDraw$1.insertArrowCrossHead(diagram);
  svgDraw$1.insertArrowFilledHead(diagram);
  svgDraw$1.insertSequenceNumber(diagram);
  function activeEnd(msg, verticalPos) {
    const activationData = bounds$1.endActivation(msg);
    if (activationData.starty + 18 > verticalPos) {
      activationData.starty = verticalPos - 6;
      verticalPos += 12;
    }
    svgDraw$1.drawActivation(
      diagram,
      activationData,
      verticalPos,
      conf$4,
      actorActivations(msg.from.actor).length
    );
    bounds$1.insert(activationData.startx, verticalPos - 10, activationData.stopx, verticalPos);
  }
  let sequenceIndex = 1;
  let sequenceIndexStep = 1;
  const messagesToDraw = [];
  messages2.forEach(function(msg) {
    let loopModel, noteModel, msgModel;
    switch (msg.type) {
      case diagObj.db.LINETYPE.NOTE:
        noteModel = msg.noteModel;
        drawNote$1(diagram, noteModel);
        break;
      case diagObj.db.LINETYPE.ACTIVE_START:
        bounds$1.newActivation(msg, diagram, actors2);
        break;
      case diagObj.db.LINETYPE.ACTIVE_END:
        activeEnd(msg, bounds$1.getVerticalPos());
        break;
      case diagObj.db.LINETYPE.LOOP_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.LOOP_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "loop", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.RECT_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.newLoop(void 0, message2.message)
        );
        break;
      case diagObj.db.LINETYPE.RECT_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawBackgroundRect(diagram, loopModel);
        bounds$1.models.addLoop(loopModel);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        break;
      case diagObj.db.LINETYPE.OPT_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.OPT_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "opt", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.ALT_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.ALT_ELSE:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin + conf$4.boxTextMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.addSectionToLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.ALT_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "alt", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.PAR_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.PAR_AND:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin + conf$4.boxTextMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.addSectionToLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.PAR_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "par", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.AUTONUMBER:
        sequenceIndex = msg.message.start || sequenceIndex;
        sequenceIndexStep = msg.message.step || sequenceIndexStep;
        if (msg.message.visible)
          diagObj.db.enableSequenceNumbers();
        else
          diagObj.db.disableSequenceNumbers();
        break;
      case diagObj.db.LINETYPE.CRITICAL_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.CRITICAL_OPTION:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin + conf$4.boxTextMargin,
          conf$4.boxMargin,
          (message2) => bounds$1.addSectionToLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.CRITICAL_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "critical", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      case diagObj.db.LINETYPE.BREAK_START:
        adjustLoopHeightForWrap(
          loopWidths,
          msg,
          conf$4.boxMargin,
          conf$4.boxMargin + conf$4.boxTextMargin,
          (message2) => bounds$1.newLoop(message2)
        );
        break;
      case diagObj.db.LINETYPE.BREAK_END:
        loopModel = bounds$1.endLoop();
        svgDraw$1.drawLoop(diagram, loopModel, "break", conf$4);
        bounds$1.bumpVerticalPos(loopModel.stopy - bounds$1.getVerticalPos());
        bounds$1.models.addLoop(loopModel);
        break;
      default:
        try {
          msgModel = msg.msgModel;
          msgModel.starty = bounds$1.getVerticalPos();
          msgModel.sequenceIndex = sequenceIndex;
          msgModel.sequenceVisible = diagObj.db.showSequenceNumbers();
          const lineStarty = boundMessage(diagram, msgModel);
          messagesToDraw.push({ messageModel: msgModel, lineStarty });
          bounds$1.models.addMessage(msgModel);
        } catch (e) {
          log$1.error("error while drawing message", e);
        }
    }
    if ([
      diagObj.db.LINETYPE.SOLID_OPEN,
      diagObj.db.LINETYPE.DOTTED_OPEN,
      diagObj.db.LINETYPE.SOLID,
      diagObj.db.LINETYPE.DOTTED,
      diagObj.db.LINETYPE.SOLID_CROSS,
      diagObj.db.LINETYPE.DOTTED_CROSS,
      diagObj.db.LINETYPE.SOLID_POINT,
      diagObj.db.LINETYPE.DOTTED_POINT
    ].includes(msg.type)) {
      sequenceIndex = sequenceIndex + sequenceIndexStep;
    }
  });
  messagesToDraw.forEach((e) => drawMessage(diagram, e.messageModel, e.lineStarty, diagObj));
  if (conf$4.mirrorActors) {
    bounds$1.bumpVerticalPos(conf$4.boxMargin * 2);
    drawActors(diagram, actors2, actorKeys, bounds$1.getVerticalPos(), conf$4, messages2);
    bounds$1.bumpVerticalPos(conf$4.boxMargin);
    fixLifeLineHeights(diagram, bounds$1.getVerticalPos());
  }
  const requiredBoxSize = drawActorsPopup(diagram, actors2, actorKeys, doc);
  const { bounds: box } = bounds$1.getBounds();
  log$1.debug("For line height fix Querying: #" + id2 + " .actor-line");
  const actorLines = selectAll$1("#" + id2 + " .actor-line");
  actorLines.attr("y2", box.stopy);
  let boxHeight = box.stopy - box.starty;
  if (boxHeight < requiredBoxSize.maxHeight) {
    boxHeight = requiredBoxSize.maxHeight;
  }
  let height2 = boxHeight + 2 * conf$4.diagramMarginY;
  if (conf$4.mirrorActors) {
    height2 = height2 - conf$4.boxMargin + conf$4.bottomMarginAdj;
  }
  let boxWidth = box.stopx - box.startx;
  if (boxWidth < requiredBoxSize.maxWidth) {
    boxWidth = requiredBoxSize.maxWidth;
  }
  const width2 = boxWidth + 2 * conf$4.diagramMarginX;
  if (title2) {
    diagram.append("text").text(title2).attr("x", (box.stopx - box.startx) / 2 - 2 * conf$4.diagramMarginX).attr("y", -25);
  }
  configureSvgSize(diagram, height2, width2, conf$4.useMaxWidth);
  const extraVertForTitle = title2 ? 40 : 0;
  diagram.attr(
    "viewBox",
    box.startx - conf$4.diagramMarginX + " -" + (conf$4.diagramMarginY + extraVertForTitle) + " " + width2 + " " + (height2 + extraVertForTitle)
  );
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
  log$1.debug(`models:`, bounds$1.models);
};
const getMaxMessageWidthPerActor = function(actors2, messages2, diagObj) {
  const maxMessageWidthPerActor = {};
  messages2.forEach(function(msg) {
    if (actors2[msg.to] && actors2[msg.from]) {
      const actor = actors2[msg.to];
      if (msg.placement === diagObj.db.PLACEMENT.LEFTOF && !actor.prevActor) {
        return;
      }
      if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF && !actor.nextActor) {
        return;
      }
      const isNote = msg.placement !== void 0;
      const isMessage = !isNote;
      const textFont = isNote ? noteFont(conf$4) : messageFont(conf$4);
      const wrappedMessage = msg.wrap ? utils.wrapLabel(msg.message, conf$4.width - 2 * conf$4.wrapPadding, textFont) : msg.message;
      const messageDimensions = utils.calculateTextDimensions(wrappedMessage, textFont);
      const messageWidth = messageDimensions.width + 2 * conf$4.wrapPadding;
      if (isMessage && msg.from === actor.nextActor) {
        maxMessageWidthPerActor[msg.to] = Math.max(
          maxMessageWidthPerActor[msg.to] || 0,
          messageWidth
        );
      } else if (isMessage && msg.from === actor.prevActor) {
        maxMessageWidthPerActor[msg.from] = Math.max(
          maxMessageWidthPerActor[msg.from] || 0,
          messageWidth
        );
      } else if (isMessage && msg.from === msg.to) {
        maxMessageWidthPerActor[msg.from] = Math.max(
          maxMessageWidthPerActor[msg.from] || 0,
          messageWidth / 2
        );
        maxMessageWidthPerActor[msg.to] = Math.max(
          maxMessageWidthPerActor[msg.to] || 0,
          messageWidth / 2
        );
      } else if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF) {
        maxMessageWidthPerActor[msg.from] = Math.max(
          maxMessageWidthPerActor[msg.from] || 0,
          messageWidth
        );
      } else if (msg.placement === diagObj.db.PLACEMENT.LEFTOF) {
        maxMessageWidthPerActor[actor.prevActor] = Math.max(
          maxMessageWidthPerActor[actor.prevActor] || 0,
          messageWidth
        );
      } else if (msg.placement === diagObj.db.PLACEMENT.OVER) {
        if (actor.prevActor) {
          maxMessageWidthPerActor[actor.prevActor] = Math.max(
            maxMessageWidthPerActor[actor.prevActor] || 0,
            messageWidth / 2
          );
        }
        if (actor.nextActor) {
          maxMessageWidthPerActor[msg.from] = Math.max(
            maxMessageWidthPerActor[msg.from] || 0,
            messageWidth / 2
          );
        }
      }
    }
  });
  log$1.debug("maxMessageWidthPerActor:", maxMessageWidthPerActor);
  return maxMessageWidthPerActor;
};
const getRequiredPopupWidth = function(actor) {
  let requiredPopupWidth = 0;
  const textFont = actorFont(conf$4);
  for (const key in actor.links) {
    const labelDimensions = utils.calculateTextDimensions(key, textFont);
    const labelWidth = labelDimensions.width + 2 * conf$4.wrapPadding + 2 * conf$4.boxMargin;
    if (requiredPopupWidth < labelWidth) {
      requiredPopupWidth = labelWidth;
    }
  }
  return requiredPopupWidth;
};
const calculateActorMargins = function(actors2, actorToMessageWidth) {
  let maxHeight = 0;
  Object.keys(actors2).forEach((prop) => {
    const actor = actors2[prop];
    if (actor.wrap) {
      actor.description = utils.wrapLabel(
        actor.description,
        conf$4.width - 2 * conf$4.wrapPadding,
        actorFont(conf$4)
      );
    }
    const actDims = utils.calculateTextDimensions(actor.description, actorFont(conf$4));
    actor.width = actor.wrap ? conf$4.width : Math.max(conf$4.width, actDims.width + 2 * conf$4.wrapPadding);
    actor.height = actor.wrap ? Math.max(actDims.height, conf$4.height) : conf$4.height;
    maxHeight = Math.max(maxHeight, actor.height);
  });
  for (const actorKey in actorToMessageWidth) {
    const actor = actors2[actorKey];
    if (!actor) {
      continue;
    }
    const nextActor = actors2[actor.nextActor];
    if (!nextActor) {
      continue;
    }
    const messageWidth = actorToMessageWidth[actorKey];
    const actorWidth = messageWidth + conf$4.actorMargin - actor.width / 2 - nextActor.width / 2;
    actor.margin = Math.max(actorWidth, conf$4.actorMargin);
  }
  return Math.max(maxHeight, conf$4.height);
};
const buildNoteModel = function(msg, actors2, diagObj) {
  const startx = actors2[msg.from].x;
  const stopx = actors2[msg.to].x;
  const shouldWrap = msg.wrap && msg.message;
  let textDimensions = utils.calculateTextDimensions(
    shouldWrap ? utils.wrapLabel(msg.message, conf$4.width, noteFont(conf$4)) : msg.message,
    noteFont(conf$4)
  );
  const noteModel = {
    width: shouldWrap ? conf$4.width : Math.max(conf$4.width, textDimensions.width + 2 * conf$4.noteMargin),
    height: 0,
    startx: actors2[msg.from].x,
    stopx: 0,
    starty: 0,
    stopy: 0,
    message: msg.message
  };
  if (msg.placement === diagObj.db.PLACEMENT.RIGHTOF) {
    noteModel.width = shouldWrap ? Math.max(conf$4.width, textDimensions.width) : Math.max(
      actors2[msg.from].width / 2 + actors2[msg.to].width / 2,
      textDimensions.width + 2 * conf$4.noteMargin
    );
    noteModel.startx = startx + (actors2[msg.from].width + conf$4.actorMargin) / 2;
  } else if (msg.placement === diagObj.db.PLACEMENT.LEFTOF) {
    noteModel.width = shouldWrap ? Math.max(conf$4.width, textDimensions.width + 2 * conf$4.noteMargin) : Math.max(
      actors2[msg.from].width / 2 + actors2[msg.to].width / 2,
      textDimensions.width + 2 * conf$4.noteMargin
    );
    noteModel.startx = startx - noteModel.width + (actors2[msg.from].width - conf$4.actorMargin) / 2;
  } else if (msg.to === msg.from) {
    textDimensions = utils.calculateTextDimensions(
      shouldWrap ? utils.wrapLabel(msg.message, Math.max(conf$4.width, actors2[msg.from].width), noteFont(conf$4)) : msg.message,
      noteFont(conf$4)
    );
    noteModel.width = shouldWrap ? Math.max(conf$4.width, actors2[msg.from].width) : Math.max(actors2[msg.from].width, conf$4.width, textDimensions.width + 2 * conf$4.noteMargin);
    noteModel.startx = startx + (actors2[msg.from].width - noteModel.width) / 2;
  } else {
    noteModel.width = Math.abs(startx + actors2[msg.from].width / 2 - (stopx + actors2[msg.to].width / 2)) + conf$4.actorMargin;
    noteModel.startx = startx < stopx ? startx + actors2[msg.from].width / 2 - conf$4.actorMargin / 2 : stopx + actors2[msg.to].width / 2 - conf$4.actorMargin / 2;
  }
  if (shouldWrap) {
    noteModel.message = utils.wrapLabel(
      msg.message,
      noteModel.width - 2 * conf$4.wrapPadding,
      noteFont(conf$4)
    );
  }
  log$1.debug(
    `NM:[${noteModel.startx},${noteModel.stopx},${noteModel.starty},${noteModel.stopy}:${noteModel.width},${noteModel.height}=${msg.message}]`
  );
  return noteModel;
};
const buildMessageModel = function(msg, actors2, diagObj) {
  let process = false;
  if ([
    diagObj.db.LINETYPE.SOLID_OPEN,
    diagObj.db.LINETYPE.DOTTED_OPEN,
    diagObj.db.LINETYPE.SOLID,
    diagObj.db.LINETYPE.DOTTED,
    diagObj.db.LINETYPE.SOLID_CROSS,
    diagObj.db.LINETYPE.DOTTED_CROSS,
    diagObj.db.LINETYPE.SOLID_POINT,
    diagObj.db.LINETYPE.DOTTED_POINT
  ].includes(msg.type)) {
    process = true;
  }
  if (!process) {
    return {};
  }
  const fromBounds = activationBounds(msg.from, actors2);
  const toBounds = activationBounds(msg.to, actors2);
  const fromIdx = fromBounds[0] <= toBounds[0] ? 1 : 0;
  const toIdx = fromBounds[0] < toBounds[0] ? 0 : 1;
  const allBounds = fromBounds.concat(toBounds);
  const boundedWidth = Math.abs(toBounds[toIdx] - fromBounds[fromIdx]);
  if (msg.wrap && msg.message) {
    msg.message = utils.wrapLabel(
      msg.message,
      Math.max(boundedWidth + 2 * conf$4.wrapPadding, conf$4.width),
      messageFont(conf$4)
    );
  }
  const msgDims = utils.calculateTextDimensions(msg.message, messageFont(conf$4));
  return {
    width: Math.max(
      msg.wrap ? 0 : msgDims.width + 2 * conf$4.wrapPadding,
      boundedWidth + 2 * conf$4.wrapPadding,
      conf$4.width
    ),
    height: 0,
    startx: fromBounds[fromIdx],
    stopx: toBounds[toIdx],
    starty: 0,
    stopy: 0,
    message: msg.message,
    type: msg.type,
    wrap: msg.wrap,
    fromBounds: Math.min.apply(null, allBounds),
    toBounds: Math.max.apply(null, allBounds)
  };
};
const calculateLoopBounds = function(messages2, actors2, _maxWidthPerActor, diagObj) {
  const loops = {};
  const stack2 = [];
  let current, noteModel, msgModel;
  messages2.forEach(function(msg) {
    msg.id = utils.random({ length: 10 });
    switch (msg.type) {
      case diagObj.db.LINETYPE.LOOP_START:
      case diagObj.db.LINETYPE.ALT_START:
      case diagObj.db.LINETYPE.OPT_START:
      case diagObj.db.LINETYPE.PAR_START:
      case diagObj.db.LINETYPE.CRITICAL_START:
      case diagObj.db.LINETYPE.BREAK_START:
        stack2.push({
          id: msg.id,
          msg: msg.message,
          from: Number.MAX_SAFE_INTEGER,
          to: Number.MIN_SAFE_INTEGER,
          width: 0
        });
        break;
      case diagObj.db.LINETYPE.ALT_ELSE:
      case diagObj.db.LINETYPE.PAR_AND:
      case diagObj.db.LINETYPE.CRITICAL_OPTION:
        if (msg.message) {
          current = stack2.pop();
          loops[current.id] = current;
          loops[msg.id] = current;
          stack2.push(current);
        }
        break;
      case diagObj.db.LINETYPE.LOOP_END:
      case diagObj.db.LINETYPE.ALT_END:
      case diagObj.db.LINETYPE.OPT_END:
      case diagObj.db.LINETYPE.PAR_END:
      case diagObj.db.LINETYPE.CRITICAL_END:
      case diagObj.db.LINETYPE.BREAK_END:
        current = stack2.pop();
        loops[current.id] = current;
        break;
      case diagObj.db.LINETYPE.ACTIVE_START:
        {
          const actorRect = actors2[msg.from ? msg.from.actor : msg.to.actor];
          const stackedSize = actorActivations(msg.from ? msg.from.actor : msg.to.actor).length;
          const x2 = actorRect.x + actorRect.width / 2 + (stackedSize - 1) * conf$4.activationWidth / 2;
          const toAdd = {
            startx: x2,
            stopx: x2 + conf$4.activationWidth,
            actor: msg.from.actor,
            enabled: true
          };
          bounds$1.activations.push(toAdd);
        }
        break;
      case diagObj.db.LINETYPE.ACTIVE_END:
        {
          const lastActorActivationIdx = bounds$1.activations.map((a2) => a2.actor).lastIndexOf(msg.from.actor);
          delete bounds$1.activations.splice(lastActorActivationIdx, 1)[0];
        }
        break;
    }
    const isNote = msg.placement !== void 0;
    if (isNote) {
      noteModel = buildNoteModel(msg, actors2, diagObj);
      msg.noteModel = noteModel;
      stack2.forEach((stk) => {
        current = stk;
        current.from = Math.min(current.from, noteModel.startx);
        current.to = Math.max(current.to, noteModel.startx + noteModel.width);
        current.width = Math.max(current.width, Math.abs(current.from - current.to)) - conf$4.labelBoxWidth;
      });
    } else {
      msgModel = buildMessageModel(msg, actors2, diagObj);
      msg.msgModel = msgModel;
      if (msgModel.startx && msgModel.stopx && stack2.length > 0) {
        stack2.forEach((stk) => {
          current = stk;
          if (msgModel.startx === msgModel.stopx) {
            const from2 = actors2[msg.from];
            const to = actors2[msg.to];
            current.from = Math.min(
              from2.x - msgModel.width / 2,
              from2.x - from2.width / 2,
              current.from
            );
            current.to = Math.max(to.x + msgModel.width / 2, to.x + from2.width / 2, current.to);
            current.width = Math.max(current.width, Math.abs(current.to - current.from)) - conf$4.labelBoxWidth;
          } else {
            current.from = Math.min(msgModel.startx, current.from);
            current.to = Math.max(msgModel.stopx, current.to);
            current.width = Math.max(current.width, msgModel.width) - conf$4.labelBoxWidth;
          }
        });
      }
    }
  });
  bounds$1.activations = [];
  log$1.debug("Loop type widths:", loops);
  return loops;
};
const sequenceRenderer = {
  bounds: bounds$1,
  drawActors,
  drawActorsPopup,
  setConf: setConf$4,
  draw: draw$4
};
var parser$1 = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 3], $V2 = [1, 5], $V3 = [1, 7], $V4 = [2, 5], $V5 = [1, 15], $V6 = [1, 17], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 21], $Va = [1, 22], $Vb = [1, 33], $Vc = [1, 23], $Vd = [1, 24], $Ve = [1, 25], $Vf = [1, 26], $Vg = [1, 27], $Vh = [1, 30], $Vi = [1, 31], $Vj = [1, 32], $Vk = [1, 35], $Vl = [1, 36], $Vm = [1, 37], $Vn = [1, 38], $Vo = [1, 34], $Vp = [1, 41], $Vq = [1, 4, 5, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vr = [1, 4, 5, 12, 13, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vs = [1, 4, 5, 7, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $Vt = [4, 5, 14, 15, 17, 19, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "SPACE": 4, "NL": 5, "directive": 6, "SD": 7, "document": 8, "line": 9, "statement": 10, "idStatement": 11, "DESCR": 12, "-->": 13, "HIDE_EMPTY": 14, "scale": 15, "WIDTH": 16, "COMPOSIT_STATE": 17, "STRUCT_START": 18, "STRUCT_STOP": 19, "STATE_DESCR": 20, "AS": 21, "ID": 22, "FORK": 23, "JOIN": 24, "CHOICE": 25, "CONCURRENT": 26, "note": 27, "notePosition": 28, "NOTE_TEXT": 29, "direction": 30, "acc_title": 31, "acc_title_value": 32, "acc_descr": 33, "acc_descr_value": 34, "acc_descr_multiline_value": 35, "openDirective": 36, "typeDirective": 37, "closeDirective": 38, ":": 39, "argDirective": 40, "direction_tb": 41, "direction_bt": 42, "direction_rl": 43, "direction_lr": 44, "eol": 45, ";": 46, "EDGE_STATE": 47, "left_of": 48, "right_of": 49, "open_directive": 50, "type_directive": 51, "arg_directive": 52, "close_directive": 53, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "SPACE", 5: "NL", 7: "SD", 12: "DESCR", 13: "-->", 14: "HIDE_EMPTY", 15: "scale", 16: "WIDTH", 17: "COMPOSIT_STATE", 18: "STRUCT_START", 19: "STRUCT_STOP", 20: "STATE_DESCR", 21: "AS", 22: "ID", 23: "FORK", 24: "JOIN", 25: "CHOICE", 26: "CONCURRENT", 27: "note", 29: "NOTE_TEXT", 31: "acc_title", 32: "acc_title_value", 33: "acc_descr", 34: "acc_descr_value", 35: "acc_descr_multiline_value", 39: ":", 41: "direction_tb", 42: "direction_bt", 43: "direction_rl", 44: "direction_lr", 46: ";", 47: "EDGE_STATE", 48: "left_of", 49: "right_of", 50: "open_directive", 51: "type_directive", 52: "arg_directive", 53: "close_directive" },
    productions_: [0, [3, 2], [3, 2], [3, 2], [3, 2], [8, 0], [8, 2], [9, 2], [9, 1], [9, 1], [10, 1], [10, 2], [10, 3], [10, 4], [10, 1], [10, 2], [10, 1], [10, 4], [10, 3], [10, 6], [10, 1], [10, 1], [10, 1], [10, 1], [10, 4], [10, 4], [10, 1], [10, 1], [10, 2], [10, 2], [10, 1], [6, 3], [6, 5], [30, 1], [30, 1], [30, 1], [30, 1], [45, 1], [45, 1], [11, 1], [11, 1], [28, 1], [28, 1], [36, 1], [37, 1], [40, 1], [38, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 4:
          yy.setRootDoc($$[$0]);
          return $$[$0];
        case 5:
          this.$ = [];
          break;
        case 6:
          if ($$[$0] != "nl") {
            $$[$0 - 1].push($$[$0]);
            this.$ = $$[$0 - 1];
          }
          break;
        case 7:
        case 8:
          this.$ = $$[$0];
          break;
        case 9:
          this.$ = "nl";
          break;
        case 10:
          this.$ = { stmt: "state", id: $$[$0], type: "default", description: "" };
          break;
        case 11:
          this.$ = { stmt: "state", id: $$[$0 - 1], type: "default", description: yy.trimColon($$[$0]) };
          break;
        case 12:
          this.$ = { stmt: "relation", state1: { stmt: "state", id: $$[$0 - 2], type: "default", description: "" }, state2: { stmt: "state", id: $$[$0], type: "default", description: "" } };
          break;
        case 13:
          this.$ = { stmt: "relation", state1: { stmt: "state", id: $$[$0 - 3], type: "default", description: "" }, state2: { stmt: "state", id: $$[$0 - 1], type: "default", description: "" }, description: $$[$0].substr(1).trim() };
          break;
        case 17:
          this.$ = { stmt: "state", id: $$[$0 - 3], type: "default", description: "", doc: $$[$0 - 1] };
          break;
        case 18:
          var id2 = $$[$0];
          var description2 = $$[$0 - 2].trim();
          if ($$[$0].match(":")) {
            var parts = $$[$0].split(":");
            id2 = parts[0];
            description2 = [description2, parts[1]];
          }
          this.$ = { stmt: "state", id: id2, type: "default", description: description2 };
          break;
        case 19:
          this.$ = { stmt: "state", id: $$[$0 - 3], type: "default", description: $$[$0 - 5], doc: $$[$0 - 1] };
          break;
        case 20:
          this.$ = { stmt: "state", id: $$[$0], type: "fork" };
          break;
        case 21:
          this.$ = { stmt: "state", id: $$[$0], type: "join" };
          break;
        case 22:
          this.$ = { stmt: "state", id: $$[$0], type: "choice" };
          break;
        case 23:
          this.$ = { stmt: "state", id: yy.getDividerId(), type: "divider" };
          break;
        case 24:
          this.$ = { stmt: "state", id: $$[$0 - 1].trim(), note: { position: $$[$0 - 2].trim(), text: $$[$0].trim() } };
          break;
        case 28:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 29:
        case 30:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 33:
          yy.setDirection("TB");
          this.$ = { stmt: "dir", value: "TB" };
          break;
        case 34:
          yy.setDirection("BT");
          this.$ = { stmt: "dir", value: "BT" };
          break;
        case 35:
          yy.setDirection("RL");
          this.$ = { stmt: "dir", value: "RL" };
          break;
        case 36:
          yy.setDirection("LR");
          this.$ = { stmt: "dir", value: "LR" };
          break;
        case 39:
        case 40:
          this.$ = $$[$0];
          break;
        case 43:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 44:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 45:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 46:
          yy.parseDirective("}%%", "close_directive", "state");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 1: [3] }, { 3: 8, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 3: 9, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, { 3: 10, 4: $V0, 5: $V1, 6: 4, 7: $V2, 36: 6, 50: $V3 }, o([1, 4, 5, 14, 15, 17, 20, 22, 23, 24, 25, 26, 27, 31, 33, 35, 41, 42, 43, 44, 47, 50], $V4, { 8: 11 }), { 37: 12, 51: [1, 13] }, { 51: [2, 43] }, { 1: [2, 1] }, { 1: [2, 2] }, { 1: [2, 3] }, { 1: [2, 4], 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, { 38: 39, 39: [1, 40], 53: $Vp }, o([39, 53], [2, 44]), o($Vq, [2, 6]), { 6: 28, 10: 42, 11: 18, 14: $V7, 15: $V8, 17: $V9, 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 8]), o($Vq, [2, 9]), o($Vq, [2, 10], { 12: [1, 43], 13: [1, 44] }), o($Vq, [2, 14]), { 16: [1, 45] }, o($Vq, [2, 16], { 18: [1, 46] }), { 21: [1, 47] }, o($Vq, [2, 20]), o($Vq, [2, 21]), o($Vq, [2, 22]), o($Vq, [2, 23]), { 28: 48, 29: [1, 49], 48: [1, 50], 49: [1, 51] }, o($Vq, [2, 26]), o($Vq, [2, 27]), { 32: [1, 52] }, { 34: [1, 53] }, o($Vq, [2, 30]), o($Vr, [2, 39]), o($Vr, [2, 40]), o($Vq, [2, 33]), o($Vq, [2, 34]), o($Vq, [2, 35]), o($Vq, [2, 36]), o($Vs, [2, 31]), { 40: 54, 52: [1, 55] }, o($Vs, [2, 46]), o($Vq, [2, 7]), o($Vq, [2, 11]), { 11: 56, 22: $Vb, 47: $Vo }, o($Vq, [2, 15]), o($Vt, $V4, { 8: 57 }), { 22: [1, 58] }, { 22: [1, 59] }, { 21: [1, 60] }, { 22: [2, 41] }, { 22: [2, 42] }, o($Vq, [2, 28]), o($Vq, [2, 29]), { 38: 61, 53: $Vp }, { 53: [2, 45] }, o($Vq, [2, 12], { 12: [1, 62] }), { 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 19: [1, 63], 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 18], { 18: [1, 64] }), { 29: [1, 65] }, { 22: [1, 66] }, o($Vs, [2, 32]), o($Vq, [2, 13]), o($Vq, [2, 17]), o($Vt, $V4, { 8: 67 }), o($Vq, [2, 24]), o($Vq, [2, 25]), { 4: $V5, 5: $V6, 6: 28, 9: 14, 10: 16, 11: 18, 14: $V7, 15: $V8, 17: $V9, 19: [1, 68], 20: $Va, 22: $Vb, 23: $Vc, 24: $Vd, 25: $Ve, 26: $Vf, 27: $Vg, 30: 29, 31: $Vh, 33: $Vi, 35: $Vj, 36: 6, 41: $Vk, 42: $Vl, 43: $Vm, 44: $Vn, 47: $Vo, 50: $V3 }, o($Vq, [2, 19])],
    defaultActions: { 7: [2, 43], 8: [2, 1], 9: [2, 2], 10: [2, 3], 50: [2, 41], 51: [2, 42], 55: [2, 45] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            return 41;
          case 1:
            return 42;
          case 2:
            return 43;
          case 3:
            return 44;
          case 4:
            this.begin("open_directive");
            return 50;
          case 5:
            this.begin("type_directive");
            return 51;
          case 6:
            this.popState();
            this.begin("arg_directive");
            return 39;
          case 7:
            this.popState();
            this.popState();
            return 53;
          case 8:
            return 52;
          case 9:
            break;
          case 10:
            break;
          case 11:
            return 5;
          case 12:
            break;
          case 13:
            break;
          case 14:
            break;
          case 15:
            break;
          case 16:
            this.pushState("SCALE");
            return 15;
          case 17:
            return 16;
          case 18:
            this.popState();
            break;
          case 19:
            this.begin("acc_title");
            return 31;
          case 20:
            this.popState();
            return "acc_title_value";
          case 21:
            this.begin("acc_descr");
            return 33;
          case 22:
            this.popState();
            return "acc_descr_value";
          case 23:
            this.begin("acc_descr_multiline");
            break;
          case 24:
            this.popState();
            break;
          case 25:
            return "acc_descr_multiline_value";
          case 26:
            this.pushState("STATE");
            break;
          case 27:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 23;
          case 28:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 24;
          case 29:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -10).trim();
            return 25;
          case 30:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 23;
          case 31:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 24;
          case 32:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -10).trim();
            return 25;
          case 33:
            return 41;
          case 34:
            return 42;
          case 35:
            return 43;
          case 36:
            return 44;
          case 37:
            this.begin("STATE_STRING");
            break;
          case 38:
            this.popState();
            this.pushState("STATE_ID");
            return "AS";
          case 39:
            this.popState();
            return "ID";
          case 40:
            this.popState();
            break;
          case 41:
            return "STATE_DESCR";
          case 42:
            return 17;
          case 43:
            this.popState();
            break;
          case 44:
            this.popState();
            this.pushState("struct");
            return 18;
          case 45:
            this.popState();
            return 19;
          case 46:
            break;
          case 47:
            this.begin("NOTE");
            return 27;
          case 48:
            this.popState();
            this.pushState("NOTE_ID");
            return 48;
          case 49:
            this.popState();
            this.pushState("NOTE_ID");
            return 49;
          case 50:
            this.popState();
            this.pushState("FLOATING_NOTE");
            break;
          case 51:
            this.popState();
            this.pushState("FLOATING_NOTE_ID");
            return "AS";
          case 52:
            break;
          case 53:
            return "NOTE_TEXT";
          case 54:
            this.popState();
            return "ID";
          case 55:
            this.popState();
            this.pushState("NOTE_TEXT");
            return 22;
          case 56:
            this.popState();
            yy_.yytext = yy_.yytext.substr(2).trim();
            return 29;
          case 57:
            this.popState();
            yy_.yytext = yy_.yytext.slice(0, -8).trim();
            return 29;
          case 58:
            return 7;
          case 59:
            return 7;
          case 60:
            return 14;
          case 61:
            return 47;
          case 62:
            return 22;
          case 63:
            yy_.yytext = yy_.yytext.trim();
            return 12;
          case 64:
            return 13;
          case 65:
            return 26;
          case 66:
            return 5;
          case 67:
            return "INVALID";
        }
      },
      rules: [/^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:[\s]+)/i, /^(?:((?!\n)\s)+)/i, /^(?:#[^\n]*)/i, /^(?:%[^\n]*)/i, /^(?:scale\s+)/i, /^(?:\d+)/i, /^(?:\s+width\b)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:state\s+)/i, /^(?:.*<<fork>>)/i, /^(?:.*<<join>>)/i, /^(?:.*<<choice>>)/i, /^(?:.*\[\[fork\]\])/i, /^(?:.*\[\[join\]\])/i, /^(?:.*\[\[choice\]\])/i, /^(?:.*direction\s+TB[^\n]*)/i, /^(?:.*direction\s+BT[^\n]*)/i, /^(?:.*direction\s+RL[^\n]*)/i, /^(?:.*direction\s+LR[^\n]*)/i, /^(?:["])/i, /^(?:\s*as\s+)/i, /^(?:[^\n\{]*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n\s\{]+)/i, /^(?:\n)/i, /^(?:\{)/i, /^(?:\})/i, /^(?:[\n])/i, /^(?:note\s+)/i, /^(?:left of\b)/i, /^(?:right of\b)/i, /^(?:")/i, /^(?:\s*as\s*)/i, /^(?:["])/i, /^(?:[^"]*)/i, /^(?:[^\n]*)/i, /^(?:\s*[^:\n\s\-]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:[\s\S]*?end note\b)/i, /^(?:stateDiagram\s+)/i, /^(?:stateDiagram-v2\s+)/i, /^(?:hide empty description\b)/i, /^(?:\[\*\])/i, /^(?:[^:\n\s\-\{]+)/i, /^(?:\s*:[^:\n;]+)/i, /^(?:-->)/i, /^(?:--)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "LINE": { "rules": [13, 14], "inclusive": false }, "close_directive": { "rules": [13, 14], "inclusive": false }, "arg_directive": { "rules": [7, 8, 13, 14], "inclusive": false }, "type_directive": { "rules": [6, 7, 13, 14], "inclusive": false }, "open_directive": { "rules": [5, 13, 14], "inclusive": false }, "struct": { "rules": [13, 14, 26, 33, 34, 35, 36, 45, 46, 47, 61, 62, 63, 64, 65], "inclusive": false }, "FLOATING_NOTE_ID": { "rules": [54], "inclusive": false }, "FLOATING_NOTE": { "rules": [51, 52, 53], "inclusive": false }, "NOTE_TEXT": { "rules": [56, 57], "inclusive": false }, "NOTE_ID": { "rules": [55], "inclusive": false }, "NOTE": { "rules": [48, 49, 50], "inclusive": false }, "acc_descr_multiline": { "rules": [24, 25], "inclusive": false }, "acc_descr": { "rules": [22], "inclusive": false }, "acc_title": { "rules": [20], "inclusive": false }, "SCALE": { "rules": [17, 18], "inclusive": false }, "ALIAS": { "rules": [], "inclusive": false }, "STATE_ID": { "rules": [39], "inclusive": false }, "STATE_STRING": { "rules": [40, 41], "inclusive": false }, "FORK_STATE": { "rules": [], "inclusive": false }, "STATE": { "rules": [13, 14, 27, 28, 29, 30, 31, 32, 37, 38, 42, 43, 44], "inclusive": false }, "ID": { "rules": [13, 14], "inclusive": false }, "INITIAL": { "rules": [0, 1, 2, 3, 4, 9, 10, 11, 12, 14, 15, 16, 19, 21, 23, 26, 44, 47, 58, 59, 60, 61, 62, 63, 64, 66, 67], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser$1.parser = parser$1;
const stateDetector = (txt, config2) => {
  var _a;
  if (((_a = config2 == null ? void 0 : config2.state) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
    return false;
  return txt.match(/^\s*stateDiagram/) !== null;
};
const stateDetectorV2 = (text2, config2) => {
  var _a;
  if (text2.match(/^\s*stateDiagram-v2/) !== null)
    return true;
  if (text2.match(/^\s*stateDiagram/) && ((_a = config2 == null ? void 0 : config2.state) == null ? void 0 : _a.defaultRenderer) === "dagre-wrapper")
    return true;
  return false;
};
const clone = (o) => JSON.parse(JSON.stringify(o));
let rootDoc = [];
const parseDirective$2 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const setRootDoc = (o) => {
  log$1.info("Setting root doc", o);
  rootDoc = o;
};
const getRootDoc = () => rootDoc;
const docTranslator = (parent, node2, first) => {
  if (node2.stmt === "relation") {
    docTranslator(parent, node2.state1, true);
    docTranslator(parent, node2.state2, false);
  } else {
    if (node2.stmt === "state") {
      if (node2.id === "[*]") {
        node2.id = first ? parent.id + "_start" : parent.id + "_end";
        node2.start = first;
      }
    }
    if (node2.doc) {
      const doc = [];
      let i = 0;
      let currentDoc = [];
      for (i = 0; i < node2.doc.length; i++) {
        if (node2.doc[i].type === "divider") {
          const newNode = clone(node2.doc[i]);
          newNode.doc = clone(currentDoc);
          doc.push(newNode);
          currentDoc = [];
        } else {
          currentDoc.push(node2.doc[i]);
        }
      }
      if (doc.length > 0 && currentDoc.length > 0) {
        const newNode = {
          stmt: "state",
          id: generateId$1(),
          type: "divider",
          doc: clone(currentDoc)
        };
        doc.push(clone(newNode));
        node2.doc = doc;
      }
      node2.doc.forEach((docNode) => docTranslator(node2, docNode, true));
    }
  }
};
const getRootDocV2 = () => {
  docTranslator({ id: "root" }, { id: "root", doc: rootDoc }, true);
  return { id: "root", doc: rootDoc };
};
const extract = (_doc) => {
  let doc;
  if (_doc.doc) {
    doc = _doc.doc;
  } else {
    doc = _doc;
  }
  log$1.info(doc);
  clear$1(true);
  log$1.info("Extract", doc);
  doc.forEach((item) => {
    if (item.stmt === "state") {
      addState(item.id, item.type, item.doc, item.description, item.note);
    }
    if (item.stmt === "relation") {
      addRelation(item.state1.id, item.state2.id, item.description);
    }
  });
};
const newDoc = () => {
  return {
    relations: [],
    states: {},
    documents: {}
  };
};
let documents = {
  root: newDoc()
};
let currentDocument = documents.root;
let startCnt = 0;
const addState = function(id2, type2, doc, descr, note2) {
  if (typeof currentDocument.states[id2] === "undefined") {
    currentDocument.states[id2] = {
      id: id2,
      descriptions: [],
      type: type2,
      doc,
      note: note2
    };
  } else {
    if (!currentDocument.states[id2].doc) {
      currentDocument.states[id2].doc = doc;
    }
    if (!currentDocument.states[id2].type) {
      currentDocument.states[id2].type = type2;
    }
  }
  if (descr) {
    log$1.info("Adding state ", id2, descr);
    if (typeof descr === "string")
      addDescription(id2, descr.trim());
    if (typeof descr === "object") {
      descr.forEach((des) => addDescription(id2, des.trim()));
    }
  }
  if (note2) {
    currentDocument.states[id2].note = note2;
    currentDocument.states[id2].note.text = common.sanitizeText(
      currentDocument.states[id2].note.text,
      getConfig$1()
    );
  }
};
const clear$1 = function(saveCommon) {
  documents = {
    root: newDoc()
  };
  currentDocument = documents.root;
  currentDocument = documents.root;
  startCnt = 0;
  classes = [];
  if (!saveCommon) {
    clear$g();
  }
};
const getState = function(id2) {
  return currentDocument.states[id2];
};
const getStates = function() {
  return currentDocument.states;
};
const logDocuments = function() {
  log$1.info("Documents = ", documents);
};
const getRelations = function() {
  return currentDocument.relations;
};
const addRelation = function(_id1, _id2, title2) {
  let id1 = _id1;
  let id2 = _id2;
  let type1 = "default";
  let type2 = "default";
  if (_id1 === "[*]") {
    startCnt++;
    id1 = "start" + startCnt;
    type1 = "start";
  }
  if (_id2 === "[*]") {
    id2 = "end" + startCnt;
    type2 = "end";
  }
  addState(id1, type1);
  addState(id2, type2);
  currentDocument.relations.push({
    id1,
    id2,
    title: common.sanitizeText(title2, getConfig$1())
  });
};
const addDescription = function(id2, _descr) {
  const theState = currentDocument.states[id2];
  let descr = _descr;
  if (descr[0] === ":") {
    descr = descr.substr(1).trim();
  }
  theState.descriptions.push(common.sanitizeText(descr, getConfig$1()));
};
const cleanupLabel = function(label) {
  if (label.substring(0, 1) === ":") {
    return label.substr(2).trim();
  } else {
    return label.trim();
  }
};
const lineType = {
  LINE: 0,
  DOTTED_LINE: 1
};
let dividerCnt = 0;
const getDividerId = () => {
  dividerCnt++;
  return "divider-id-" + dividerCnt;
};
let classes = [];
const getClasses$1 = () => classes;
let direction = "TB";
const getDirection = () => direction;
const setDirection = (dir) => {
  direction = dir;
};
const relationType = {
  AGGREGATION: 0,
  EXTENSION: 1,
  COMPOSITION: 2,
  DEPENDENCY: 3
};
const trimColon = (str) => str && str[0] === ":" ? str.substr(1).trim() : str.trim();
const stateDb = {
  parseDirective: parseDirective$2,
  getConfig: () => getConfig$1().state,
  addState,
  clear: clear$1,
  getState,
  getStates,
  getRelations,
  getClasses: getClasses$1,
  getDirection,
  addRelation,
  getDividerId,
  setDirection,
  cleanupLabel,
  lineType,
  relationType,
  logDocuments,
  getRootDoc,
  setRootDoc,
  getRootDocV2,
  extract,
  trimColon,
  getAccTitle,
  setAccTitle,
  getAccDescription,
  setAccDescription
};
const drawStartState = (g) => g.append("circle").attr("class", "start-state").attr("r", getConfig$1().state.sizeUnit).attr("cx", getConfig$1().state.padding + getConfig$1().state.sizeUnit).attr("cy", getConfig$1().state.padding + getConfig$1().state.sizeUnit);
const drawDivider = (g) => g.append("line").style("stroke", "grey").style("stroke-dasharray", "3").attr("x1", getConfig$1().state.textHeight).attr("class", "divider").attr("x2", getConfig$1().state.textHeight * 2).attr("y1", 0).attr("y2", 0);
const drawSimpleState = (g, stateDef) => {
  const state = g.append("text").attr("x", 2 * getConfig$1().state.padding).attr("y", getConfig$1().state.textHeight + 2 * getConfig$1().state.padding).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.id);
  const classBox = state.node().getBBox();
  g.insert("rect", ":first-child").attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding).attr("width", classBox.width + 2 * getConfig$1().state.padding).attr("height", classBox.height + 2 * getConfig$1().state.padding).attr("rx", getConfig$1().state.radius);
  return state;
};
const drawDescrState = (g, stateDef) => {
  const addTspan2 = function(textEl, txt, isFirst2) {
    const tSpan = textEl.append("tspan").attr("x", 2 * getConfig$1().state.padding).text(txt);
    if (!isFirst2) {
      tSpan.attr("dy", getConfig$1().state.textHeight);
    }
  };
  const title2 = g.append("text").attr("x", 2 * getConfig$1().state.padding).attr("y", getConfig$1().state.textHeight + 1.3 * getConfig$1().state.padding).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.descriptions[0]);
  const titleBox = title2.node().getBBox();
  const titleHeight = titleBox.height;
  const description2 = g.append("text").attr("x", getConfig$1().state.padding).attr(
    "y",
    titleHeight + getConfig$1().state.padding * 0.4 + getConfig$1().state.dividerMargin + getConfig$1().state.textHeight
  ).attr("class", "state-description");
  let isFirst = true;
  let isSecond = true;
  stateDef.descriptions.forEach(function(descr) {
    if (!isFirst) {
      addTspan2(description2, descr, isSecond);
      isSecond = false;
    }
    isFirst = false;
  });
  const descrLine = g.append("line").attr("x1", getConfig$1().state.padding).attr("y1", getConfig$1().state.padding + titleHeight + getConfig$1().state.dividerMargin / 2).attr("y2", getConfig$1().state.padding + titleHeight + getConfig$1().state.dividerMargin / 2).attr("class", "descr-divider");
  const descrBox = description2.node().getBBox();
  const width2 = Math.max(descrBox.width, titleBox.width);
  descrLine.attr("x2", width2 + 3 * getConfig$1().state.padding);
  g.insert("rect", ":first-child").attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding).attr("width", width2 + 2 * getConfig$1().state.padding).attr("height", descrBox.height + titleHeight + 2 * getConfig$1().state.padding).attr("rx", getConfig$1().state.radius);
  return g;
};
const addTitleAndBox = (g, stateDef, altBkg) => {
  const pad2 = getConfig$1().state.padding;
  const dblPad = 2 * getConfig$1().state.padding;
  const orgBox = g.node().getBBox();
  const orgWidth = orgBox.width;
  const orgX = orgBox.x;
  const title2 = g.append("text").attr("x", 0).attr("y", getConfig$1().state.titleShift).attr("font-size", getConfig$1().state.fontSize).attr("class", "state-title").text(stateDef.id);
  const titleBox = title2.node().getBBox();
  const titleWidth = titleBox.width + dblPad;
  let width2 = Math.max(titleWidth, orgWidth);
  if (width2 === orgWidth) {
    width2 = width2 + dblPad;
  }
  let startX;
  const graphBox = g.node().getBBox();
  if (stateDef.doc)
    ;
  startX = orgX - pad2;
  if (titleWidth > orgWidth) {
    startX = (orgWidth - width2) / 2 + pad2;
  }
  if (Math.abs(orgX - graphBox.x) < pad2) {
    if (titleWidth > orgWidth) {
      startX = orgX - (titleWidth - orgWidth) / 2;
    }
  }
  const lineY = 1 - getConfig$1().state.textHeight;
  g.insert("rect", ":first-child").attr("x", startX).attr("y", lineY).attr("class", altBkg ? "alt-composit" : "composit").attr("width", width2).attr(
    "height",
    graphBox.height + getConfig$1().state.textHeight + getConfig$1().state.titleShift + 1
  ).attr("rx", "0");
  title2.attr("x", startX + pad2);
  if (titleWidth <= orgWidth)
    title2.attr("x", orgX + (width2 - dblPad) / 2 - titleWidth / 2 + pad2);
  g.insert("rect", ":first-child").attr("x", startX).attr(
    "y",
    getConfig$1().state.titleShift - getConfig$1().state.textHeight - getConfig$1().state.padding
  ).attr("width", width2).attr("height", getConfig$1().state.textHeight * 3).attr("rx", getConfig$1().state.radius);
  g.insert("rect", ":first-child").attr("x", startX).attr(
    "y",
    getConfig$1().state.titleShift - getConfig$1().state.textHeight - getConfig$1().state.padding
  ).attr("width", width2).attr("height", graphBox.height + 3 + 2 * getConfig$1().state.textHeight).attr("rx", getConfig$1().state.radius);
  return g;
};
const drawEndState = (g) => {
  g.append("circle").attr("class", "end-state-outer").attr("r", getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding).attr(
    "cx",
    getConfig$1().state.padding + getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding
  ).attr(
    "cy",
    getConfig$1().state.padding + getConfig$1().state.sizeUnit + getConfig$1().state.miniPadding
  );
  return g.append("circle").attr("class", "end-state-inner").attr("r", getConfig$1().state.sizeUnit).attr("cx", getConfig$1().state.padding + getConfig$1().state.sizeUnit + 2).attr("cy", getConfig$1().state.padding + getConfig$1().state.sizeUnit + 2);
};
const drawForkJoinState = (g, stateDef) => {
  let width2 = getConfig$1().state.forkWidth;
  let height2 = getConfig$1().state.forkHeight;
  if (stateDef.parentId) {
    let tmp = width2;
    width2 = height2;
    height2 = tmp;
  }
  return g.append("rect").style("stroke", "black").style("fill", "black").attr("width", width2).attr("height", height2).attr("x", getConfig$1().state.padding).attr("y", getConfig$1().state.padding);
};
const _drawLongText = (_text, x2, y2, g) => {
  let textHeight = 0;
  const textElem = g.append("text");
  textElem.style("text-anchor", "start");
  textElem.attr("class", "noteText");
  let text2 = _text.replace(/\r\n/g, "<br/>");
  text2 = text2.replace(/\n/g, "<br/>");
  const lines = text2.split(common.lineBreakRegex);
  let tHeight = 1.25 * getConfig$1().state.noteMargin;
  for (const line2 of lines) {
    const txt = line2.trim();
    if (txt.length > 0) {
      const span = textElem.append("tspan");
      span.text(txt);
      if (tHeight === 0) {
        const textBounds = span.node().getBBox();
        tHeight += textBounds.height;
      }
      textHeight += tHeight;
      span.attr("x", x2 + getConfig$1().state.noteMargin);
      span.attr("y", y2 + textHeight + 1.25 * getConfig$1().state.noteMargin);
    }
  }
  return { textWidth: textElem.node().getBBox().width, textHeight };
};
const drawNote = (text2, g) => {
  g.attr("class", "state-note");
  const note2 = g.append("rect").attr("x", 0).attr("y", getConfig$1().state.padding);
  const rectElem = g.append("g");
  const { textWidth, textHeight } = _drawLongText(text2, 0, 0, rectElem);
  note2.attr("height", textHeight + 2 * getConfig$1().state.noteMargin);
  note2.attr("width", textWidth + getConfig$1().state.noteMargin * 2);
  return note2;
};
const drawState = function(elem, stateDef) {
  const id2 = stateDef.id;
  const stateInfo = {
    id: id2,
    label: stateDef.id,
    width: 0,
    height: 0
  };
  const g = elem.append("g").attr("id", id2).attr("class", "stateGroup");
  if (stateDef.type === "start")
    drawStartState(g);
  if (stateDef.type === "end")
    drawEndState(g);
  if (stateDef.type === "fork" || stateDef.type === "join")
    drawForkJoinState(g, stateDef);
  if (stateDef.type === "note")
    drawNote(stateDef.note.text, g);
  if (stateDef.type === "divider")
    drawDivider(g);
  if (stateDef.type === "default" && stateDef.descriptions.length === 0)
    drawSimpleState(g, stateDef);
  if (stateDef.type === "default" && stateDef.descriptions.length > 0)
    drawDescrState(g, stateDef);
  const stateBox = g.node().getBBox();
  stateInfo.width = stateBox.width + 2 * getConfig$1().state.padding;
  stateInfo.height = stateBox.height + 2 * getConfig$1().state.padding;
  return stateInfo;
};
let edgeCount = 0;
const drawEdge = function(elem, path2, relation) {
  const getRelationType = function(type2) {
    switch (type2) {
      case stateDb.relationType.AGGREGATION:
        return "aggregation";
      case stateDb.relationType.EXTENSION:
        return "extension";
      case stateDb.relationType.COMPOSITION:
        return "composition";
      case stateDb.relationType.DEPENDENCY:
        return "dependency";
    }
  };
  path2.points = path2.points.filter((p) => !Number.isNaN(p.y));
  const lineData = path2.points;
  const lineFunction = line$2().x(function(d) {
    return d.x;
  }).y(function(d) {
    return d.y;
  }).curve(curveBasis);
  const svgPath = elem.append("path").attr("d", lineFunction(lineData)).attr("id", "edge" + edgeCount).attr("class", "transition");
  let url = "";
  if (getConfig$1().state.arrowMarkerAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = url.replace(/\(/g, "\\(");
    url = url.replace(/\)/g, "\\)");
  }
  svgPath.attr(
    "marker-end",
    "url(" + url + "#" + getRelationType(stateDb.relationType.DEPENDENCY) + "End)"
  );
  if (typeof relation.title !== "undefined") {
    const label = elem.append("g").attr("class", "stateLabel");
    const { x: x2, y: y2 } = utils.calcLabelPosition(path2.points);
    const rows = common.getRows(relation.title);
    let titleHeight = 0;
    const titleRows = [];
    let maxWidth = 0;
    let minX = 0;
    for (let i = 0; i <= rows.length; i++) {
      const title2 = label.append("text").attr("text-anchor", "middle").text(rows[i]).attr("x", x2).attr("y", y2 + titleHeight);
      const boundstmp = title2.node().getBBox();
      maxWidth = Math.max(maxWidth, boundstmp.width);
      minX = Math.min(minX, boundstmp.x);
      log$1.info(boundstmp.x, x2, y2 + titleHeight);
      if (titleHeight === 0) {
        const titleBox = title2.node().getBBox();
        titleHeight = titleBox.height;
        log$1.info("Title height", titleHeight, y2);
      }
      titleRows.push(title2);
    }
    let boxHeight = titleHeight * rows.length;
    if (rows.length > 1) {
      const heightAdj = (rows.length - 1) * titleHeight * 0.5;
      titleRows.forEach((title2, i) => title2.attr("y", y2 + i * titleHeight - heightAdj));
      boxHeight = titleHeight * rows.length;
    }
    const bounds2 = label.node().getBBox();
    label.insert("rect", ":first-child").attr("class", "box").attr("x", x2 - maxWidth / 2 - getConfig$1().state.padding / 2).attr("y", y2 - boxHeight / 2 - getConfig$1().state.padding / 2 - 3.5).attr("width", maxWidth + getConfig$1().state.padding).attr("height", boxHeight + getConfig$1().state.padding);
    log$1.info(bounds2);
  }
  edgeCount++;
};
let conf$3;
const transformationLog = {};
const setConf$3 = function() {
};
const insertMarkers = function(elem) {
  elem.append("defs").append("marker").attr("id", "dependencyEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
};
const draw$3 = function(text2, id2, _version, diagObj) {
  conf$3 = getConfig$1().state;
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const doc = securityLevel === "sandbox" ? sandboxElement.nodes()[0].contentDocument : document;
  log$1.debug("Rendering diagram " + text2);
  const diagram = root2.select(`[id='${id2}']`);
  insertMarkers(diagram);
  const graph2 = new graphlib$2.Graph({
    multigraph: true,
    compound: true,
    rankdir: "RL"
  });
  graph2.setDefaultEdgeLabel(function() {
    return {};
  });
  const rootDoc2 = diagObj.db.getRootDoc();
  renderDoc(rootDoc2, diagram, void 0, false, root2, doc, diagObj);
  const padding2 = conf$3.padding;
  const bounds2 = diagram.node().getBBox();
  const width2 = bounds2.width + padding2 * 2;
  const height2 = bounds2.height + padding2 * 2;
  const svgWidth = width2 * 1.75;
  configureSvgSize(diagram, height2, svgWidth, conf$3.useMaxWidth);
  diagram.attr(
    "viewBox",
    `${bounds2.x - conf$3.padding}  ${bounds2.y - conf$3.padding} ` + width2 + " " + height2
  );
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
};
const getLabelWidth = (text2) => {
  return text2 ? text2.length * conf$3.fontSizeFactor : 1;
};
const renderDoc = (doc, diagram, parentId, altBkg, root2, domDocument, diagObj) => {
  const graph2 = new graphlib$2.Graph({
    compound: true,
    multigraph: true
  });
  let i;
  let edgeFreeDoc = true;
  for (i = 0; i < doc.length; i++) {
    if (doc[i].stmt === "relation") {
      edgeFreeDoc = false;
      break;
    }
  }
  if (parentId)
    graph2.setGraph({
      rankdir: "LR",
      multigraph: true,
      compound: true,
      ranker: "tight-tree",
      ranksep: edgeFreeDoc ? 1 : conf$3.edgeLengthFactor,
      nodeSep: edgeFreeDoc ? 1 : 50,
      isMultiGraph: true
    });
  else {
    graph2.setGraph({
      rankdir: "TB",
      multigraph: true,
      compound: true,
      ranksep: edgeFreeDoc ? 1 : conf$3.edgeLengthFactor,
      nodeSep: edgeFreeDoc ? 1 : 50,
      ranker: "tight-tree",
      isMultiGraph: true
    });
  }
  graph2.setDefaultEdgeLabel(function() {
    return {};
  });
  diagObj.db.extract(doc);
  const states = diagObj.db.getStates();
  const relations2 = diagObj.db.getRelations();
  const keys2 = Object.keys(states);
  for (let i2 = 0; i2 < keys2.length; i2++) {
    const stateDef = states[keys2[i2]];
    if (parentId) {
      stateDef.parentId = parentId;
    }
    let node2;
    if (stateDef.doc) {
      let sub = diagram.append("g").attr("id", stateDef.id).attr("class", "stateGroup");
      node2 = renderDoc(stateDef.doc, sub, stateDef.id, !altBkg, root2, domDocument, diagObj);
      {
        sub = addTitleAndBox(sub, stateDef, altBkg);
        let boxBounds = sub.node().getBBox();
        node2.width = boxBounds.width;
        node2.height = boxBounds.height + conf$3.padding / 2;
        transformationLog[stateDef.id] = { y: conf$3.compositTitleSize };
      }
    } else {
      node2 = drawState(diagram, stateDef);
    }
    if (stateDef.note) {
      const noteDef = {
        descriptions: [],
        id: stateDef.id + "-note",
        note: stateDef.note,
        type: "note"
      };
      const note2 = drawState(diagram, noteDef);
      if (stateDef.note.position === "left of") {
        graph2.setNode(node2.id + "-note", note2);
        graph2.setNode(node2.id, node2);
      } else {
        graph2.setNode(node2.id, node2);
        graph2.setNode(node2.id + "-note", note2);
      }
      graph2.setParent(node2.id, node2.id + "-group");
      graph2.setParent(node2.id + "-note", node2.id + "-group");
    } else {
      graph2.setNode(node2.id, node2);
    }
  }
  log$1.debug("Count=", graph2.nodeCount(), graph2);
  let cnt2 = 0;
  relations2.forEach(function(relation) {
    cnt2++;
    log$1.debug("Setting edge", relation);
    graph2.setEdge(
      relation.id1,
      relation.id2,
      {
        relation,
        width: getLabelWidth(relation.title),
        height: conf$3.labelHeight * common.getRows(relation.title).length,
        labelpos: "c"
      },
      "id" + cnt2
    );
  });
  dagre$1.layout(graph2);
  log$1.debug("Graph after layout", graph2.nodes());
  const svgElem = diagram.node();
  graph2.nodes().forEach(function(v) {
    if (typeof v !== "undefined" && typeof graph2.node(v) !== "undefined") {
      log$1.warn("Node " + v + ": " + JSON.stringify(graph2.node(v)));
      root2.select("#" + svgElem.id + " #" + v).attr(
        "transform",
        "translate(" + (graph2.node(v).x - graph2.node(v).width / 2) + "," + (graph2.node(v).y + (transformationLog[v] ? transformationLog[v].y : 0) - graph2.node(v).height / 2) + " )"
      );
      root2.select("#" + svgElem.id + " #" + v).attr("data-x-shift", graph2.node(v).x - graph2.node(v).width / 2);
      const dividers = domDocument.querySelectorAll("#" + svgElem.id + " #" + v + " .divider");
      dividers.forEach((divider2) => {
        const parent = divider2.parentElement;
        let pWidth = 0;
        let pShift = 0;
        if (parent) {
          if (parent.parentElement)
            pWidth = parent.parentElement.getBBox().width;
          pShift = parseInt(parent.getAttribute("data-x-shift"), 10);
          if (Number.isNaN(pShift)) {
            pShift = 0;
          }
        }
        divider2.setAttribute("x1", 0 - pShift + 8);
        divider2.setAttribute("x2", pWidth - pShift - 8);
      });
    } else {
      log$1.debug("No Node " + v + ": " + JSON.stringify(graph2.node(v)));
    }
  });
  let stateBox = svgElem.getBBox();
  graph2.edges().forEach(function(e) {
    if (typeof e !== "undefined" && typeof graph2.edge(e) !== "undefined") {
      log$1.debug("Edge " + e.v + " -> " + e.w + ": " + JSON.stringify(graph2.edge(e)));
      drawEdge(diagram, graph2.edge(e), graph2.edge(e).relation);
    }
  });
  stateBox = svgElem.getBBox();
  const stateInfo = {
    id: parentId ? parentId : "root",
    label: parentId ? parentId : "root",
    width: 0,
    height: 0
  };
  stateInfo.width = stateBox.width + 2 * conf$3.padding;
  stateInfo.height = stateBox.height + 2 * conf$3.padding;
  log$1.debug("Doc rendered", stateInfo, graph2);
  return stateInfo;
};
const stateRenderer = {
  setConf: setConf$3,
  draw: draw$3
};
const conf$2 = {};
const setConf$2 = function(cnf) {
  const keys2 = Object.keys(cnf);
  for (let i = 0; i < keys2.length; i++) {
    conf$2[keys2[i]] = cnf[keys2[i]];
  }
};
let nodeDb = {};
const getClasses = function(text2, diag) {
  log$1.trace("Extracting classes");
  diag.sb.clear();
  diag.parser.parse(text2);
  return diag.sb.getClasses();
};
const setupNode = (g, parent, node2, altFlag) => {
  if (node2.id !== "root") {
    let shape = "rect";
    if (node2.start === true) {
      shape = "start";
    }
    if (node2.start === false) {
      shape = "end";
    }
    if (node2.type !== "default") {
      shape = node2.type;
    }
    if (!nodeDb[node2.id]) {
      nodeDb[node2.id] = {
        id: node2.id,
        shape,
        description: common.sanitizeText(node2.id, getConfig$1()),
        classes: "statediagram-state"
      };
    }
    if (node2.description) {
      if (Array.isArray(nodeDb[node2.id].description)) {
        nodeDb[node2.id].shape = "rectWithTitle";
        nodeDb[node2.id].description.push(node2.description);
      } else {
        if (nodeDb[node2.id].description.length > 0) {
          nodeDb[node2.id].shape = "rectWithTitle";
          if (nodeDb[node2.id].description === node2.id) {
            nodeDb[node2.id].description = [node2.description];
          } else {
            nodeDb[node2.id].description = [nodeDb[node2.id].description, node2.description];
          }
        } else {
          nodeDb[node2.id].shape = "rect";
          nodeDb[node2.id].description = node2.description;
        }
      }
      nodeDb[node2.id].description = common.sanitizeTextOrArray(
        nodeDb[node2.id].description,
        getConfig$1()
      );
    }
    if (nodeDb[node2.id].description.length === 1 && nodeDb[node2.id].shape === "rectWithTitle") {
      nodeDb[node2.id].shape = "rect";
    }
    if (!nodeDb[node2.id].type && node2.doc) {
      log$1.info("Setting cluster for ", node2.id, getDir(node2));
      nodeDb[node2.id].type = "group";
      nodeDb[node2.id].dir = getDir(node2);
      nodeDb[node2.id].shape = node2.type === "divider" ? "divider" : "roundedWithTitle";
      nodeDb[node2.id].classes = nodeDb[node2.id].classes + " " + (altFlag ? "statediagram-cluster statediagram-cluster-alt" : "statediagram-cluster");
    }
    const nodeData = {
      labelStyle: "",
      shape: nodeDb[node2.id].shape,
      labelText: nodeDb[node2.id].description,
      classes: nodeDb[node2.id].classes,
      style: "",
      id: node2.id,
      dir: nodeDb[node2.id].dir,
      domId: "state-" + node2.id + "-" + cnt,
      type: nodeDb[node2.id].type,
      padding: 15
    };
    if (node2.note) {
      const noteData = {
        labelStyle: "",
        shape: "note",
        labelText: node2.note.text,
        classes: "statediagram-note",
        style: "",
        id: node2.id + "----note-" + cnt,
        domId: "state-" + node2.id + "----note-" + cnt,
        type: nodeDb[node2.id].type,
        padding: 15
      };
      const groupData = {
        labelStyle: "",
        shape: "noteGroup",
        labelText: node2.note.text,
        classes: nodeDb[node2.id].classes,
        style: "",
        id: node2.id + "----parent",
        domId: "state-" + node2.id + "----parent-" + cnt,
        type: "group",
        padding: 0
      };
      cnt++;
      g.setNode(node2.id + "----parent", groupData);
      g.setNode(noteData.id, noteData);
      g.setNode(node2.id, nodeData);
      g.setParent(node2.id, node2.id + "----parent");
      g.setParent(noteData.id, node2.id + "----parent");
      let from2 = node2.id;
      let to = noteData.id;
      if (node2.note.position === "left of") {
        from2 = noteData.id;
        to = node2.id;
      }
      g.setEdge(from2, to, {
        arrowhead: "none",
        arrowType: "",
        style: "fill:none",
        labelStyle: "",
        classes: "transition note-edge",
        arrowheadStyle: "fill: #333",
        labelpos: "c",
        labelType: "text",
        thickness: "normal"
      });
    } else {
      g.setNode(node2.id, nodeData);
    }
  }
  if (parent) {
    if (parent.id !== "root") {
      log$1.trace("Setting node ", node2.id, " to be child of its parent ", parent.id);
      g.setParent(node2.id, parent.id);
    }
  }
  if (node2.doc) {
    log$1.trace("Adding nodes children ");
    setupDoc(g, node2, node2.doc, !altFlag);
  }
};
let cnt = 0;
const setupDoc = (g, parent, doc, altFlag) => {
  log$1.trace("items", doc);
  doc.forEach((item) => {
    if (item.stmt === "state" || item.stmt === "default") {
      setupNode(g, parent, item, altFlag);
    } else if (item.stmt === "relation") {
      setupNode(g, parent, item.state1, altFlag);
      setupNode(g, parent, item.state2, altFlag);
      const edgeData = {
        id: "edge" + cnt,
        arrowhead: "normal",
        arrowTypeEnd: "arrow_barb",
        style: "fill:none",
        labelStyle: "",
        label: common.sanitizeText(item.description, getConfig$1()),
        arrowheadStyle: "fill: #333",
        labelpos: "c",
        labelType: "text",
        thickness: "normal",
        classes: "transition"
      };
      let startId = item.state1.id;
      let endId = item.state2.id;
      g.setEdge(startId, endId, edgeData, cnt);
      cnt++;
    }
  });
};
const getDir = (nodes, defaultDir) => {
  let dir = defaultDir || "TB";
  if (nodes.doc) {
    for (let i = 0; i < nodes.doc.length; i++) {
      const node2 = nodes.doc[i];
      if (node2.stmt === "dir") {
        dir = node2.value;
      }
    }
  }
  return dir;
};
const draw$2 = function(text2, id2, _version, diag) {
  log$1.info("Drawing state diagram (v2)", id2);
  nodeDb = {};
  diag.db.getDirection();
  const { securityLevel, state: conf2 } = getConfig$1();
  const nodeSpacing = conf2.nodeSpacing || 50;
  const rankSpacing = conf2.rankSpacing || 50;
  log$1.info(diag.db.getRootDocV2());
  diag.db.extract(diag.db.getRootDocV2());
  log$1.info(diag.db.getRootDocV2());
  const g = new graphlib$2.Graph({
    multigraph: true,
    compound: true
  }).setGraph({
    rankdir: getDir(diag.db.getRootDocV2()),
    nodesep: nodeSpacing,
    ranksep: rankSpacing,
    marginx: 8,
    marginy: 8
  }).setDefaultEdgeLabel(function() {
    return {};
  });
  setupNode(g, void 0, diag.db.getRootDocV2(), true);
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  const svg2 = root2.select(`[id="${id2}"]`);
  const element = root2.select("#" + id2 + " g");
  render$1(element, g, ["barb"], "statediagram", id2);
  const padding2 = 8;
  const bounds2 = svg2.node().getBBox();
  const width2 = bounds2.width + padding2 * 2;
  const height2 = bounds2.height + padding2 * 2;
  svg2.attr("class", "statediagram");
  const svgBounds = svg2.node().getBBox();
  configureSvgSize(svg2, height2, width2, conf2.useMaxWidth);
  const vBox = `${svgBounds.x - padding2} ${svgBounds.y - padding2} ${width2} ${height2}`;
  log$1.debug(`viewBox ${vBox}`);
  svg2.attr("viewBox", vBox);
  const labels = document.querySelectorAll('[id="' + id2 + '"] .edgeLabel .label');
  for (let k2 = 0; k2 < labels.length; k2++) {
    const label = labels[k2];
    const dim = label.getBBox();
    const rect2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
    rect2.setAttribute("rx", 0);
    rect2.setAttribute("ry", 0);
    rect2.setAttribute("width", dim.width);
    rect2.setAttribute("height", dim.height);
    label.insertBefore(rect2, label.firstChild);
  }
  addSVGAccessibilityFields(diag.db, svg2, id2);
};
const stateRendererV2 = {
  setConf: setConf$2,
  getClasses,
  draw: draw$2
};
var parser = function() {
  var o = function(k2, v, o2, l) {
    for (o2 = o2 || {}, l = k2.length; l--; o2[k2[l]] = v)
      ;
    return o2;
  }, $V0 = [1, 2], $V1 = [1, 5], $V2 = [6, 9, 11, 17, 18, 20, 22, 23, 24, 26], $V3 = [1, 15], $V4 = [1, 16], $V5 = [1, 17], $V6 = [1, 18], $V7 = [1, 19], $V8 = [1, 20], $V9 = [1, 24], $Va = [4, 6, 9, 11, 17, 18, 20, 22, 23, 24, 26];
  var parser2 = {
    trace: function trace() {
    },
    yy: {},
    symbols_: { "error": 2, "start": 3, "journey": 4, "document": 5, "EOF": 6, "directive": 7, "line": 8, "SPACE": 9, "statement": 10, "NEWLINE": 11, "openDirective": 12, "typeDirective": 13, "closeDirective": 14, ":": 15, "argDirective": 16, "title": 17, "acc_title": 18, "acc_title_value": 19, "acc_descr": 20, "acc_descr_value": 21, "acc_descr_multiline_value": 22, "section": 23, "taskName": 24, "taskData": 25, "open_directive": 26, "type_directive": 27, "arg_directive": 28, "close_directive": 29, "$accept": 0, "$end": 1 },
    terminals_: { 2: "error", 4: "journey", 6: "EOF", 9: "SPACE", 11: "NEWLINE", 15: ":", 17: "title", 18: "acc_title", 19: "acc_title_value", 20: "acc_descr", 21: "acc_descr_value", 22: "acc_descr_multiline_value", 23: "section", 24: "taskName", 25: "taskData", 26: "open_directive", 27: "type_directive", 28: "arg_directive", 29: "close_directive" },
    productions_: [0, [3, 3], [3, 2], [5, 0], [5, 2], [8, 2], [8, 1], [8, 1], [8, 1], [7, 4], [7, 6], [10, 1], [10, 2], [10, 2], [10, 1], [10, 1], [10, 2], [10, 1], [12, 1], [13, 1], [16, 1], [14, 1]],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
      var $0 = $$.length - 1;
      switch (yystate) {
        case 1:
          return $$[$0 - 1];
        case 3:
          this.$ = [];
          break;
        case 4:
          $$[$0 - 1].push($$[$0]);
          this.$ = $$[$0 - 1];
          break;
        case 5:
        case 6:
          this.$ = $$[$0];
          break;
        case 7:
        case 8:
          this.$ = [];
          break;
        case 11:
          yy.setDiagramTitle($$[$0].substr(6));
          this.$ = $$[$0].substr(6);
          break;
        case 12:
          this.$ = $$[$0].trim();
          yy.setAccTitle(this.$);
          break;
        case 13:
        case 14:
          this.$ = $$[$0].trim();
          yy.setAccDescription(this.$);
          break;
        case 15:
          yy.addSection($$[$0].substr(8));
          this.$ = $$[$0].substr(8);
          break;
        case 16:
          yy.addTask($$[$0 - 1], $$[$0]);
          this.$ = "task";
          break;
        case 18:
          yy.parseDirective("%%{", "open_directive");
          break;
        case 19:
          yy.parseDirective($$[$0], "type_directive");
          break;
        case 20:
          $$[$0] = $$[$0].trim().replace(/'/g, '"');
          yy.parseDirective($$[$0], "arg_directive");
          break;
        case 21:
          yy.parseDirective("}%%", "close_directive", "journey");
          break;
      }
    },
    table: [{ 3: 1, 4: $V0, 7: 3, 12: 4, 26: $V1 }, { 1: [3] }, o($V2, [2, 3], { 5: 6 }), { 3: 7, 4: $V0, 7: 3, 12: 4, 26: $V1 }, { 13: 8, 27: [1, 9] }, { 27: [2, 18] }, { 6: [1, 10], 7: 21, 8: 11, 9: [1, 12], 10: 13, 11: [1, 14], 12: 4, 17: $V3, 18: $V4, 20: $V5, 22: $V6, 23: $V7, 24: $V8, 26: $V1 }, { 1: [2, 2] }, { 14: 22, 15: [1, 23], 29: $V9 }, o([15, 29], [2, 19]), o($V2, [2, 8], { 1: [2, 1] }), o($V2, [2, 4]), { 7: 21, 10: 25, 12: 4, 17: $V3, 18: $V4, 20: $V5, 22: $V6, 23: $V7, 24: $V8, 26: $V1 }, o($V2, [2, 6]), o($V2, [2, 7]), o($V2, [2, 11]), { 19: [1, 26] }, { 21: [1, 27] }, o($V2, [2, 14]), o($V2, [2, 15]), { 25: [1, 28] }, o($V2, [2, 17]), { 11: [1, 29] }, { 16: 30, 28: [1, 31] }, { 11: [2, 21] }, o($V2, [2, 5]), o($V2, [2, 12]), o($V2, [2, 13]), o($V2, [2, 16]), o($Va, [2, 9]), { 14: 32, 29: $V9 }, { 29: [2, 20] }, { 11: [1, 33] }, o($Va, [2, 10])],
    defaultActions: { 5: [2, 18], 7: [2, 2], 24: [2, 21], 31: [2, 20] },
    parseError: function parseError(str, hash) {
      if (hash.recoverable) {
        this.trace(str);
      } else {
        var error = new Error(str);
        error.hash = hash;
        throw error;
      }
    },
    parse: function parse2(input) {
      var self2 = this, stack2 = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, TERROR = 2, EOF2 = 1;
      var args = lstack.slice.call(arguments, 1);
      var lexer2 = Object.create(this.lexer);
      var sharedState = { yy: {} };
      for (var k2 in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k2)) {
          sharedState.yy[k2] = this.yy[k2];
        }
      }
      lexer2.setInput(input, sharedState.yy);
      sharedState.yy.lexer = lexer2;
      sharedState.yy.parser = this;
      if (typeof lexer2.yylloc == "undefined") {
        lexer2.yylloc = {};
      }
      var yyloc = lexer2.yylloc;
      lstack.push(yyloc);
      var ranges2 = lexer2.options && lexer2.options.ranges;
      if (typeof sharedState.yy.parseError === "function") {
        this.parseError = sharedState.yy.parseError;
      } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
      }
      function lex() {
        var token2;
        token2 = tstack.pop() || lexer2.lex() || EOF2;
        if (typeof token2 !== "number") {
          if (token2 instanceof Array) {
            tstack = token2;
            token2 = tstack.pop();
          }
          token2 = self2.symbols_[token2] || token2;
        }
        return token2;
      }
      var symbol2, state, action, r, yyval = {}, p, len, newState, expected;
      while (true) {
        state = stack2[stack2.length - 1];
        if (this.defaultActions[state]) {
          action = this.defaultActions[state];
        } else {
          if (symbol2 === null || typeof symbol2 == "undefined") {
            symbol2 = lex();
          }
          action = table[state] && table[state][symbol2];
        }
        if (typeof action === "undefined" || !action.length || !action[0]) {
          var errStr = "";
          expected = [];
          for (p in table[state]) {
            if (this.terminals_[p] && p > TERROR) {
              expected.push("'" + this.terminals_[p] + "'");
            }
          }
          if (lexer2.showPosition) {
            errStr = "Parse error on line " + (yylineno + 1) + ":\n" + lexer2.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol2] || symbol2) + "'";
          } else {
            errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol2 == EOF2 ? "end of input" : "'" + (this.terminals_[symbol2] || symbol2) + "'");
          }
          this.parseError(errStr, {
            text: lexer2.match,
            token: this.terminals_[symbol2] || symbol2,
            line: lexer2.yylineno,
            loc: yyloc,
            expected
          });
        }
        if (action[0] instanceof Array && action.length > 1) {
          throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol2);
        }
        switch (action[0]) {
          case 1:
            stack2.push(symbol2);
            vstack.push(lexer2.yytext);
            lstack.push(lexer2.yylloc);
            stack2.push(action[1]);
            symbol2 = null;
            {
              yyleng = lexer2.yyleng;
              yytext = lexer2.yytext;
              yylineno = lexer2.yylineno;
              yyloc = lexer2.yylloc;
            }
            break;
          case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
              first_line: lstack[lstack.length - (len || 1)].first_line,
              last_line: lstack[lstack.length - 1].last_line,
              first_column: lstack[lstack.length - (len || 1)].first_column,
              last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges2) {
              yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
              ];
            }
            r = this.performAction.apply(yyval, [
              yytext,
              yyleng,
              yylineno,
              sharedState.yy,
              action[1],
              vstack,
              lstack
            ].concat(args));
            if (typeof r !== "undefined") {
              return r;
            }
            if (len) {
              stack2 = stack2.slice(0, -1 * len * 2);
              vstack = vstack.slice(0, -1 * len);
              lstack = lstack.slice(0, -1 * len);
            }
            stack2.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack2[stack2.length - 2]][stack2[stack2.length - 1]];
            stack2.push(newState);
            break;
          case 3:
            return true;
        }
      }
      return true;
    }
  };
  var lexer = function() {
    var lexer2 = {
      EOF: 1,
      parseError: function parseError(str, hash) {
        if (this.yy.parser) {
          this.yy.parser.parseError(str, hash);
        } else {
          throw new Error(str);
        }
      },
      setInput: function(input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = "";
        this.conditionStack = ["INITIAL"];
        this.yylloc = {
          first_line: 1,
          first_column: 0,
          last_line: 1,
          last_column: 0
        };
        if (this.options.ranges) {
          this.yylloc.range = [0, 0];
        }
        this.offset = 0;
        return this;
      },
      input: function() {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno++;
          this.yylloc.last_line++;
        } else {
          this.yylloc.last_column++;
        }
        if (this.options.ranges) {
          this.yylloc.range[1]++;
        }
        this._input = this._input.slice(1);
        return ch;
      },
      unput: function(ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);
        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);
        if (lines.length - 1) {
          this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;
        this.yylloc = {
          first_line: this.yylloc.first_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.first_column,
          last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
        };
        if (this.options.ranges) {
          this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
      },
      more: function() {
        this._more = true;
        return this;
      },
      reject: function() {
        if (this.options.backtrack_lexer) {
          this._backtrack = true;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
        return this;
      },
      less: function(n) {
        this.unput(this.match.slice(n));
      },
      pastInput: function() {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
      },
      upcomingInput: function() {
        var next2 = this.match;
        if (next2.length < 20) {
          next2 += this._input.substr(0, 20 - next2.length);
        }
        return (next2.substr(0, 20) + (next2.length > 20 ? "..." : "")).replace(/\n/g, "");
      },
      showPosition: function() {
        var pre = this.pastInput();
        var c2 = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c2 + "^";
      },
      test_match: function(match, indexed_rule) {
        var token2, lines, backup;
        if (this.options.backtrack_lexer) {
          backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          };
          if (this.options.ranges) {
            backup.yylloc.range = this.yylloc.range.slice(0);
          }
        }
        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
          this.yylineno += lines.length;
        }
        this.yylloc = {
          first_line: this.yylloc.last_line,
          last_line: this.yylineno + 1,
          first_column: this.yylloc.last_column,
          last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
          this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token2 = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
          this.done = false;
        }
        if (token2) {
          return token2;
        } else if (this._backtrack) {
          for (var k2 in backup) {
            this[k2] = backup[k2];
          }
          return false;
        }
        return false;
      },
      next: function() {
        if (this.done) {
          return this.EOF;
        }
        if (!this._input) {
          this.done = true;
        }
        var token2, match, tempMatch, index2;
        if (!this._more) {
          this.yytext = "";
          this.match = "";
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
          tempMatch = this._input.match(this.rules[rules[i]]);
          if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
            match = tempMatch;
            index2 = i;
            if (this.options.backtrack_lexer) {
              token2 = this.test_match(tempMatch, rules[i]);
              if (token2 !== false) {
                return token2;
              } else if (this._backtrack) {
                match = false;
                continue;
              } else {
                return false;
              }
            } else if (!this.options.flex) {
              break;
            }
          }
        }
        if (match) {
          token2 = this.test_match(match, rules[index2]);
          if (token2 !== false) {
            return token2;
          }
          return false;
        }
        if (this._input === "") {
          return this.EOF;
        } else {
          return this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        }
      },
      lex: function lex() {
        var r = this.next();
        if (r) {
          return r;
        } else {
          return this.lex();
        }
      },
      begin: function begin(condition) {
        this.conditionStack.push(condition);
      },
      popState: function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
          return this.conditionStack.pop();
        } else {
          return this.conditionStack[0];
        }
      },
      _currentRules: function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
          return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
          return this.conditions["INITIAL"].rules;
        }
      },
      topState: function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
          return this.conditionStack[n];
        } else {
          return "INITIAL";
        }
      },
      pushState: function pushState(condition) {
        this.begin(condition);
      },
      stateStackSize: function stateStackSize() {
        return this.conditionStack.length;
      },
      options: { "case-insensitive": true },
      performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
        switch ($avoiding_name_collisions) {
          case 0:
            this.begin("open_directive");
            return 26;
          case 1:
            this.begin("type_directive");
            return 27;
          case 2:
            this.popState();
            this.begin("arg_directive");
            return 15;
          case 3:
            this.popState();
            this.popState();
            return 29;
          case 4:
            return 28;
          case 5:
            break;
          case 6:
            break;
          case 7:
            return 11;
          case 8:
            break;
          case 9:
            break;
          case 10:
            return 4;
          case 11:
            return 17;
          case 12:
            this.begin("acc_title");
            return 18;
          case 13:
            this.popState();
            return "acc_title_value";
          case 14:
            this.begin("acc_descr");
            return 20;
          case 15:
            this.popState();
            return "acc_descr_value";
          case 16:
            this.begin("acc_descr_multiline");
            break;
          case 17:
            this.popState();
            break;
          case 18:
            return "acc_descr_multiline_value";
          case 19:
            return 23;
          case 20:
            return 24;
          case 21:
            return 25;
          case 22:
            return 15;
          case 23:
            return 6;
          case 24:
            return "INVALID";
        }
      },
      rules: [/^(?:%%\{)/i, /^(?:((?:(?!\}%%)[^:.])*))/i, /^(?::)/i, /^(?:\}%%)/i, /^(?:((?:(?!\}%%).|\n)*))/i, /^(?:%(?!\{)[^\n]*)/i, /^(?:[^\}]%%[^\n]*)/i, /^(?:[\n]+)/i, /^(?:\s+)/i, /^(?:#[^\n]*)/i, /^(?:journey\b)/i, /^(?:title\s[^#\n;]+)/i, /^(?:accTitle\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*:\s*)/i, /^(?:(?!\n||)*[^\n]*)/i, /^(?:accDescr\s*\{\s*)/i, /^(?:[\}])/i, /^(?:[^\}]*)/i, /^(?:section\s[^#:\n;]+)/i, /^(?:[^#:\n;]+)/i, /^(?::[^#\n;]+)/i, /^(?::)/i, /^(?:$)/i, /^(?:.)/i],
      conditions: { "open_directive": { "rules": [1], "inclusive": false }, "type_directive": { "rules": [2, 3], "inclusive": false }, "arg_directive": { "rules": [3, 4], "inclusive": false }, "acc_descr_multiline": { "rules": [17, 18], "inclusive": false }, "acc_descr": { "rules": [15], "inclusive": false }, "acc_title": { "rules": [13], "inclusive": false }, "INITIAL": { "rules": [0, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 19, 20, 21, 22, 23, 24], "inclusive": true } }
    };
    return lexer2;
  }();
  parser2.lexer = lexer;
  function Parser() {
    this.yy = {};
  }
  Parser.prototype = parser2;
  parser2.Parser = Parser;
  return new Parser();
}();
parser.parser = parser;
const journeyDetector = (txt) => {
  return txt.match(/^\s*journey/) !== null;
};
let currentSection = "";
const sections = [];
const tasks = [];
const rawTasks = [];
const parseDirective$1 = function(statement, context, type2) {
  mermaidAPI.parseDirective(this, statement, context, type2);
};
const clear = function() {
  sections.length = 0;
  tasks.length = 0;
  currentSection = "";
  rawTasks.length = 0;
  clear$g();
};
const addSection = function(txt) {
  currentSection = txt;
  sections.push(txt);
};
const getSections = function() {
  return sections;
};
const getTasks = function() {
  let allItemsProcessed = compileTasks();
  const maxDepth2 = 100;
  let iterationCount = 0;
  while (!allItemsProcessed && iterationCount < maxDepth2) {
    allItemsProcessed = compileTasks();
    iterationCount++;
  }
  tasks.push(...rawTasks);
  return tasks;
};
const updateActors = function() {
  const tempActors = [];
  tasks.forEach((task) => {
    if (task.people) {
      tempActors.push(...task.people);
    }
  });
  const unique = new Set(tempActors);
  return [...unique].sort();
};
const addTask = function(descr, taskData) {
  const pieces = taskData.substr(1).split(":");
  let score2 = 0;
  let peeps = [];
  if (pieces.length === 1) {
    score2 = Number(pieces[0]);
    peeps = [];
  } else {
    score2 = Number(pieces[0]);
    peeps = pieces[1].split(",");
  }
  const peopleList = peeps.map((s2) => s2.trim());
  const rawTask = {
    section: currentSection,
    type: currentSection,
    people: peopleList,
    task: descr,
    score: score2
  };
  rawTasks.push(rawTask);
};
const addTaskOrg = function(descr) {
  const newTask = {
    section: currentSection,
    type: currentSection,
    description: descr,
    task: descr,
    classes: []
  };
  tasks.push(newTask);
};
const compileTasks = function() {
  const compileTask = function(pos) {
    return rawTasks[pos].processed;
  };
  let allProcessed = true;
  for (let i = 0; i < rawTasks.length; i++) {
    compileTask(i);
    allProcessed = allProcessed && rawTasks[i].processed;
  }
  return allProcessed;
};
const getActors = function() {
  return updateActors();
};
const journeyDb = {
  parseDirective: parseDirective$1,
  getConfig: () => getConfig$1().journey,
  clear,
  setDiagramTitle,
  getDiagramTitle,
  setAccTitle,
  getAccTitle,
  setAccDescription,
  getAccDescription,
  addSection,
  getSections,
  getTasks,
  addTask,
  addTaskOrg,
  getActors
};
const drawRect = function(elem, rectData) {
  const rectElem = elem.append("rect");
  rectElem.attr("x", rectData.x);
  rectElem.attr("y", rectData.y);
  rectElem.attr("fill", rectData.fill);
  rectElem.attr("stroke", rectData.stroke);
  rectElem.attr("width", rectData.width);
  rectElem.attr("height", rectData.height);
  rectElem.attr("rx", rectData.rx);
  rectElem.attr("ry", rectData.ry);
  if (typeof rectData.class !== "undefined") {
    rectElem.attr("class", rectData.class);
  }
  return rectElem;
};
const drawFace = function(element, faceData) {
  const radius = 15;
  const circleElement = element.append("circle").attr("cx", faceData.cx).attr("cy", faceData.cy).attr("class", "face").attr("r", radius).attr("stroke-width", 2).attr("overflow", "visible");
  const face = element.append("g");
  face.append("circle").attr("cx", faceData.cx - radius / 3).attr("cy", faceData.cy - radius / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  face.append("circle").attr("cx", faceData.cx + radius / 3).attr("cy", faceData.cy - radius / 3).attr("r", 1.5).attr("stroke-width", 2).attr("fill", "#666").attr("stroke", "#666");
  function smile(face2) {
    const arc$1$1 = arc$1().startAngle(Math.PI / 2).endAngle(3 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2);
    face2.append("path").attr("class", "mouth").attr("d", arc$1$1).attr("transform", "translate(" + faceData.cx + "," + (faceData.cy + 2) + ")");
  }
  function sad(face2) {
    const arc$1$1 = arc$1().startAngle(3 * Math.PI / 2).endAngle(5 * (Math.PI / 2)).innerRadius(radius / 2).outerRadius(radius / 2.2);
    face2.append("path").attr("class", "mouth").attr("d", arc$1$1).attr("transform", "translate(" + faceData.cx + "," + (faceData.cy + 7) + ")");
  }
  function ambivalent(face2) {
    face2.append("line").attr("class", "mouth").attr("stroke", 2).attr("x1", faceData.cx - 5).attr("y1", faceData.cy + 7).attr("x2", faceData.cx + 5).attr("y2", faceData.cy + 7).attr("class", "mouth").attr("stroke-width", "1px").attr("stroke", "#666");
  }
  if (faceData.score > 3) {
    smile(face);
  } else if (faceData.score < 3) {
    sad(face);
  } else {
    ambivalent(face);
  }
  return circleElement;
};
const drawCircle = function(element, circleData) {
  const circleElement = element.append("circle");
  circleElement.attr("cx", circleData.cx);
  circleElement.attr("cy", circleData.cy);
  circleElement.attr("class", "actor-" + circleData.pos);
  circleElement.attr("fill", circleData.fill);
  circleElement.attr("stroke", circleData.stroke);
  circleElement.attr("r", circleData.r);
  if (typeof circleElement.class !== "undefined") {
    circleElement.attr("class", circleElement.class);
  }
  if (typeof circleData.title !== "undefined") {
    circleElement.append("title").text(circleData.title);
  }
  return circleElement;
};
const drawText = function(elem, textData) {
  const nText = textData.text.replace(/<br\s*\/?>/gi, " ");
  const textElem = elem.append("text");
  textElem.attr("x", textData.x);
  textElem.attr("y", textData.y);
  textElem.attr("class", "legend");
  textElem.style("text-anchor", textData.anchor);
  if (typeof textData.class !== "undefined") {
    textElem.attr("class", textData.class);
  }
  const span = textElem.append("tspan");
  span.attr("x", textData.x + textData.textMargin * 2);
  span.text(nText);
  return textElem;
};
const drawLabel = function(elem, txtObject) {
  function genPoints(x2, y2, width2, height2, cut) {
    return x2 + "," + y2 + " " + (x2 + width2) + "," + y2 + " " + (x2 + width2) + "," + (y2 + height2 - cut) + " " + (x2 + width2 - cut * 1.2) + "," + (y2 + height2) + " " + x2 + "," + (y2 + height2);
  }
  const polygon = elem.append("polygon");
  polygon.attr("points", genPoints(txtObject.x, txtObject.y, 50, 20, 7));
  polygon.attr("class", "labelBox");
  txtObject.y = txtObject.y + txtObject.labelMargin;
  txtObject.x = txtObject.x + 0.5 * txtObject.labelMargin;
  drawText(elem, txtObject);
};
const drawSection = function(elem, section, conf2) {
  const g = elem.append("g");
  const rect2 = getNoteRect();
  rect2.x = section.x;
  rect2.y = section.y;
  rect2.fill = section.fill;
  rect2.width = conf2.width;
  rect2.height = conf2.height;
  rect2.class = "journey-section section-type-" + section.num;
  rect2.rx = 3;
  rect2.ry = 3;
  drawRect(g, rect2);
  _drawTextCandidateFunc(conf2)(
    section.text,
    g,
    rect2.x,
    rect2.y,
    rect2.width,
    rect2.height,
    { class: "journey-section section-type-" + section.num },
    conf2,
    section.colour
  );
};
let taskCount = -1;
const drawTask = function(elem, task, conf2) {
  const center2 = task.x + conf2.width / 2;
  const g = elem.append("g");
  taskCount++;
  const maxHeight = 300 + 5 * 30;
  g.append("line").attr("id", "task" + taskCount).attr("x1", center2).attr("y1", task.y).attr("x2", center2).attr("y2", maxHeight).attr("class", "task-line").attr("stroke-width", "1px").attr("stroke-dasharray", "4 2").attr("stroke", "#666");
  drawFace(g, {
    cx: center2,
    cy: 300 + (5 - task.score) * 30,
    score: task.score
  });
  const rect2 = getNoteRect();
  rect2.x = task.x;
  rect2.y = task.y;
  rect2.fill = task.fill;
  rect2.width = conf2.width;
  rect2.height = conf2.height;
  rect2.class = "task task-type-" + task.num;
  rect2.rx = 3;
  rect2.ry = 3;
  drawRect(g, rect2);
  let xPos = task.x + 14;
  task.people.forEach((person) => {
    const colour = task.actors[person].color;
    const circle2 = {
      cx: xPos,
      cy: task.y,
      r: 7,
      fill: colour,
      stroke: "#000",
      title: person,
      pos: task.actors[person].position
    };
    drawCircle(g, circle2);
    xPos += 10;
  });
  _drawTextCandidateFunc(conf2)(
    task.task,
    g,
    rect2.x,
    rect2.y,
    rect2.width,
    rect2.height,
    { class: "task" },
    conf2,
    task.colour
  );
};
const drawBackgroundRect = function(elem, bounds2) {
  const rectElem = drawRect(elem, {
    x: bounds2.startx,
    y: bounds2.starty,
    width: bounds2.stopx - bounds2.startx,
    height: bounds2.stopy - bounds2.starty,
    fill: bounds2.fill,
    class: "rect"
  });
  rectElem.lower();
};
const getTextObj = function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    "text-anchor": "start",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0
  };
};
const getNoteRect = function() {
  return {
    x: 0,
    y: 0,
    width: 100,
    anchor: "start",
    height: 100,
    rx: 0,
    ry: 0
  };
};
const _drawTextCandidateFunc = function() {
  function byText(content, g, x2, y2, width2, height2, textAttrs, colour) {
    const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2 + height2 / 2 + 5).style("font-color", colour).style("text-anchor", "middle").text(content);
    _setTextAttrs(text2, textAttrs);
  }
  function byTspan(content, g, x2, y2, width2, height2, textAttrs, conf2, colour) {
    const { taskFontSize, taskFontFamily } = conf2;
    const lines = content.split(/<br\s*\/?>/gi);
    for (let i = 0; i < lines.length; i++) {
      const dy = i * taskFontSize - taskFontSize * (lines.length - 1) / 2;
      const text2 = g.append("text").attr("x", x2 + width2 / 2).attr("y", y2).attr("fill", colour).style("text-anchor", "middle").style("font-size", taskFontSize).style("font-family", taskFontFamily);
      text2.append("tspan").attr("x", x2 + width2 / 2).attr("dy", dy).text(lines[i]);
      text2.attr("y", y2 + height2 / 2).attr("dominant-baseline", "central").attr("alignment-baseline", "central");
      _setTextAttrs(text2, textAttrs);
    }
  }
  function byFo(content, g, x2, y2, width2, height2, textAttrs, conf2) {
    const body = g.append("switch");
    const f = body.append("foreignObject").attr("x", x2).attr("y", y2).attr("width", width2).attr("height", height2).attr("position", "fixed");
    const text2 = f.append("xhtml:div").style("display", "table").style("height", "100%").style("width", "100%");
    text2.append("div").attr("class", "label").style("display", "table-cell").style("text-align", "center").style("vertical-align", "middle").text(content);
    byTspan(content, body, x2, y2, width2, height2, textAttrs, conf2);
    _setTextAttrs(text2, textAttrs);
  }
  function _setTextAttrs(toText, fromTextAttrsDict) {
    for (const key in fromTextAttrsDict) {
      if (key in fromTextAttrsDict) {
        toText.attr(key, fromTextAttrsDict[key]);
      }
    }
  }
  return function(conf2) {
    return conf2.textPlacement === "fo" ? byFo : conf2.textPlacement === "old" ? byText : byTspan;
  };
}();
const initGraphics = function(graphics) {
  graphics.append("defs").append("marker").attr("id", "arrowhead").attr("refX", 5).attr("refY", 2).attr("markerWidth", 6).attr("markerHeight", 4).attr("orient", "auto").append("path").attr("d", "M 0,0 V 4 L6,2 Z");
};
const svgDraw = {
  drawRect,
  drawCircle,
  drawSection,
  drawText,
  drawLabel,
  drawTask,
  drawBackgroundRect,
  getTextObj,
  getNoteRect,
  initGraphics
};
const setConf$1 = function(cnf) {
  const keys2 = Object.keys(cnf);
  keys2.forEach(function(key) {
    conf$1[key] = cnf[key];
  });
};
const actors = {};
function drawActorLegend(diagram) {
  const conf2 = getConfig$1().journey;
  let yPos = 60;
  Object.keys(actors).forEach((person) => {
    const colour = actors[person].color;
    const circleData = {
      cx: 20,
      cy: yPos,
      r: 7,
      fill: colour,
      stroke: "#000",
      pos: actors[person].position
    };
    svgDraw.drawCircle(diagram, circleData);
    const labelData = {
      x: 40,
      y: yPos + 7,
      fill: "#666",
      text: person,
      textMargin: conf2.boxTextMargin | 5
    };
    svgDraw.drawText(diagram, labelData);
    yPos += 20;
  });
}
const conf$1 = getConfig$1().journey;
const LEFT_MARGIN = conf$1.leftMargin;
const draw$1 = function(text2, id2, version2, diagObj) {
  const conf2 = getConfig$1().journey;
  diagObj.db.clear();
  diagObj.parser.parse(text2 + "\n");
  const securityLevel = getConfig$1().securityLevel;
  let sandboxElement;
  if (securityLevel === "sandbox") {
    sandboxElement = select$1("#i" + id2);
  }
  const root2 = securityLevel === "sandbox" ? select$1(sandboxElement.nodes()[0].contentDocument.body) : select$1("body");
  bounds.init();
  const diagram = root2.select("#" + id2);
  svgDraw.initGraphics(diagram);
  const tasks2 = diagObj.db.getTasks();
  const title2 = diagObj.db.getDiagramTitle();
  const actorNames = diagObj.db.getActors();
  for (const member in actors)
    delete actors[member];
  let actorPos = 0;
  actorNames.forEach((actorName) => {
    actors[actorName] = {
      color: conf2.actorColours[actorPos % conf2.actorColours.length],
      position: actorPos
    };
    actorPos++;
  });
  drawActorLegend(diagram);
  bounds.insert(0, 0, LEFT_MARGIN, Object.keys(actors).length * 50);
  drawTasks(diagram, tasks2, 0);
  const box = bounds.getBounds();
  if (title2) {
    diagram.append("text").text(title2).attr("x", LEFT_MARGIN).attr("font-size", "4ex").attr("font-weight", "bold").attr("y", 25);
  }
  const height2 = box.stopy - box.starty + 2 * conf2.diagramMarginY;
  const width2 = LEFT_MARGIN + box.stopx + 2 * conf2.diagramMarginX;
  configureSvgSize(diagram, height2, width2, conf2.useMaxWidth);
  diagram.append("line").attr("x1", LEFT_MARGIN).attr("y1", conf2.height * 4).attr("x2", width2 - LEFT_MARGIN - 4).attr("y2", conf2.height * 4).attr("stroke-width", 4).attr("stroke", "black").attr("marker-end", "url(#arrowhead)");
  const extraVertForTitle = title2 ? 70 : 0;
  diagram.attr("viewBox", `${box.startx} -25 ${width2} ${height2 + extraVertForTitle}`);
  diagram.attr("preserveAspectRatio", "xMinYMin meet");
  diagram.attr("height", height2 + extraVertForTitle + 25);
  addSVGAccessibilityFields(diagObj.db, diagram, id2);
};
const bounds = {
  data: {
    startx: void 0,
    stopx: void 0,
    starty: void 0,
    stopy: void 0
  },
  verticalPos: 0,
  sequenceItems: [],
  init: function() {
    this.sequenceItems = [];
    this.data = {
      startx: void 0,
      stopx: void 0,
      starty: void 0,
      stopy: void 0
    };
    this.verticalPos = 0;
  },
  updateVal: function(obj, key, val, fun) {
    if (typeof obj[key] === "undefined") {
      obj[key] = val;
    } else {
      obj[key] = fun(val, obj[key]);
    }
  },
  updateBounds: function(startx, starty, stopx, stopy) {
    const conf2 = getConfig$1().journey;
    const _self = this;
    let cnt2 = 0;
    function updateFn(type2) {
      return function updateItemBounds(item) {
        cnt2++;
        const n = _self.sequenceItems.length - cnt2 + 1;
        _self.updateVal(item, "starty", starty - n * conf2.boxMargin, Math.min);
        _self.updateVal(item, "stopy", stopy + n * conf2.boxMargin, Math.max);
        _self.updateVal(bounds.data, "startx", startx - n * conf2.boxMargin, Math.min);
        _self.updateVal(bounds.data, "stopx", stopx + n * conf2.boxMargin, Math.max);
        if (!(type2 === "activation")) {
          _self.updateVal(item, "startx", startx - n * conf2.boxMargin, Math.min);
          _self.updateVal(item, "stopx", stopx + n * conf2.boxMargin, Math.max);
          _self.updateVal(bounds.data, "starty", starty - n * conf2.boxMargin, Math.min);
          _self.updateVal(bounds.data, "stopy", stopy + n * conf2.boxMargin, Math.max);
        }
      };
    }
    this.sequenceItems.forEach(updateFn());
  },
  insert: function(startx, starty, stopx, stopy) {
    const _startx = Math.min(startx, stopx);
    const _stopx = Math.max(startx, stopx);
    const _starty = Math.min(starty, stopy);
    const _stopy = Math.max(starty, stopy);
    this.updateVal(bounds.data, "startx", _startx, Math.min);
    this.updateVal(bounds.data, "starty", _starty, Math.min);
    this.updateVal(bounds.data, "stopx", _stopx, Math.max);
    this.updateVal(bounds.data, "stopy", _stopy, Math.max);
    this.updateBounds(_startx, _starty, _stopx, _stopy);
  },
  bumpVerticalPos: function(bump) {
    this.verticalPos = this.verticalPos + bump;
    this.data.stopy = this.verticalPos;
  },
  getVerticalPos: function() {
    return this.verticalPos;
  },
  getBounds: function() {
    return this.data;
  }
};
const fills = conf$1.sectionFills;
const textColours = conf$1.sectionColours;
const drawTasks = function(diagram, tasks2, verticalPos) {
  const conf2 = getConfig$1().journey;
  let lastSection = "";
  const sectionVHeight = conf2.height * 2 + conf2.diagramMarginY;
  const taskPos = verticalPos + sectionVHeight;
  let sectionNumber = 0;
  let fill = "#CCC";
  let colour = "black";
  let num = 0;
  for (let i = 0; i < tasks2.length; i++) {
    const task = tasks2[i];
    if (lastSection !== task.section) {
      fill = fills[sectionNumber % fills.length];
      num = sectionNumber % fills.length;
      colour = textColours[sectionNumber % textColours.length];
      const section = {
        x: i * conf2.taskMargin + i * conf2.width + LEFT_MARGIN,
        y: 50,
        text: task.section,
        fill,
        num,
        colour
      };
      svgDraw.drawSection(diagram, section, conf2);
      lastSection = task.section;
      sectionNumber++;
    }
    const taskActors = task.people.reduce((acc, actorName) => {
      if (actors[actorName]) {
        acc[actorName] = actors[actorName];
      }
      return acc;
    }, {});
    task.x = i * conf2.taskMargin + i * conf2.width + LEFT_MARGIN;
    task.y = taskPos;
    task.width = conf2.diagramMarginX;
    task.height = conf2.diagramMarginY;
    task.colour = colour;
    task.fill = fill;
    task.num = num;
    task.actors = taskActors;
    svgDraw.drawTask(diagram, task, conf2);
    bounds.insert(task.x, task.y, task.x + task.width + conf2.taskMargin, 300 + 5 * 30);
  }
};
const journeyRenderer = {
  setConf: setConf$1,
  draw: draw$1
};
let conf = {};
const setConf = function(cnf) {
  conf = { ...conf, ...cnf };
};
const draw = (text2, id2, mermaidVersion) => {
  try {
    log$1.debug("Renering svg for syntax error\n");
    const svg2 = select$1("#" + id2);
    const g = svg2.append("g");
    g.append("path").attr("class", "error-icon").attr(
      "d",
      "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
    );
    g.append("path").attr("class", "error-icon").attr(
      "d",
      "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
    );
    g.append("path").attr("class", "error-icon").attr(
      "d",
      "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
    );
    g.append("path").attr("class", "error-icon").attr(
      "d",
      "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
    );
    g.append("path").attr("class", "error-icon").attr(
      "d",
      "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
    );
    g.append("path").attr("class", "error-icon").attr(
      "d",
      "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
    );
    g.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in graph");
    g.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text("mermaid version " + mermaidVersion);
    svg2.attr("height", 100);
    svg2.attr("width", 500);
    svg2.attr("viewBox", "768 0 912 512");
  } catch (e) {
    log$1.error("Error while rendering info diagram");
    log$1.error(getErrorMessage(e));
  }
};
const errorRenderer = {
  setConf,
  draw
};
let hasLoadedDiagrams = false;
const addDiagrams = () => {
  if (hasLoadedDiagrams) {
    return;
  }
  hasLoadedDiagrams = true;
  registerDiagram(
    "error",
    {
      db: {
        clear: () => {
        }
      },
      styles: getStyles$b,
      renderer: errorRenderer,
      parser: {
        parser: { yy: {} },
        parse: () => {
        }
      },
      init: () => {
      }
    },
    (text2) => text2.toLowerCase().trim() === "error"
  );
  registerDiagram(
    "c4",
    {
      parser: parser$a,
      db: c4Db,
      renderer: c4Renderer,
      styles: getStyles$2,
      init: (cnf) => {
        c4Renderer.setConf(cnf.c4);
      }
    },
    c4Detector
  );
  registerDiagram(
    "class",
    {
      parser: parser$9,
      db: classDb,
      renderer: classRenderer,
      styles: getStyles$d,
      init: (cnf) => {
        if (!cnf.class) {
          cnf.class = {};
        }
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        classDb.clear();
      }
    },
    classDetector
  );
  registerDiagram(
    "classDiagram",
    {
      parser: parser$9,
      db: classDb,
      renderer: classRendererV2,
      styles: getStyles$d,
      init: (cnf) => {
        if (!cnf.class) {
          cnf.class = {};
        }
        cnf.class.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        classDb.clear();
      }
    },
    classDetectorV2
  );
  registerDiagram(
    "er",
    {
      parser: parser$8,
      db: erDb,
      renderer: erRenderer,
      styles: getStyles$c
    },
    erDetector
  );
  registerDiagram(
    "gantt",
    {
      parser: parser$6,
      db: ganttDb,
      renderer: ganttRenderer,
      styles: getStyles$9
    },
    ganttDetector
  );
  registerDiagram(
    "info",
    {
      parser: parser$5,
      db: infoDb,
      renderer: infoRenderer,
      styles: getStyles$8
    },
    infoDetector
  );
  registerDiagram(
    "pie",
    {
      parser: parser$4,
      db: pieDb,
      renderer: pieRenderer,
      styles: getStyles$7
    },
    pieDetector
  );
  registerDiagram(
    "requirement",
    {
      parser: parser$3,
      db: requirementDb,
      renderer: requirementRenderer,
      styles: getStyles$6
    },
    requirementDetector
  );
  registerDiagram(
    "sequence",
    {
      parser: parser$2,
      db: sequenceDb,
      renderer: sequenceRenderer,
      styles: getStyles$5,
      init: (cnf) => {
        if (!cnf.sequence) {
          cnf.sequence = {};
        }
        cnf.sequence.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        if ("sequenceDiagram" in cnf) {
          throw new Error(
            "`mermaid config.sequenceDiagram` has been renamed to `config.sequence`. Please update your mermaid config."
          );
        }
        sequenceDb.setWrap(cnf.wrap);
        sequenceRenderer.setConf(cnf.sequence);
      }
    },
    sequenceDetector
  );
  registerDiagram(
    "state",
    {
      parser: parser$1,
      db: stateDb,
      renderer: stateRenderer,
      styles: getStyles$4,
      init: (cnf) => {
        if (!cnf.state) {
          cnf.state = {};
        }
        cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        stateDb.clear();
      }
    },
    stateDetector
  );
  registerDiagram(
    "stateDiagram",
    {
      parser: parser$1,
      db: stateDb,
      renderer: stateRendererV2,
      styles: getStyles$4,
      init: (cnf) => {
        if (!cnf.state) {
          cnf.state = {};
        }
        cnf.state.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        stateDb.clear();
      }
    },
    stateDetectorV2
  );
  registerDiagram(
    "journey",
    {
      parser,
      db: journeyDb,
      renderer: journeyRenderer,
      styles: getStyles$3,
      init: (cnf) => {
        journeyRenderer.setConf(cnf.journey);
        journeyDb.clear();
      }
    },
    journeyDetector
  );
  registerDiagram(
    "flowchart",
    {
      parser: parser$7,
      db: flowDb,
      renderer: flowRendererV2,
      styles: getStyles$a,
      init: (cnf) => {
        if (!cnf.flowchart) {
          cnf.flowchart = {};
        }
        cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        flowRenderer.setConf(cnf.flowchart);
        flowDb.clear();
        flowDb.setGen("gen-1");
      }
    },
    flowDetector
  );
  registerDiagram(
    "flowchart-v2",
    {
      parser: parser$7,
      db: flowDb,
      renderer: flowRendererV2,
      styles: getStyles$a,
      init: (cnf) => {
        if (!cnf.flowchart) {
          cnf.flowchart = {};
        }
        cnf.flowchart.arrowMarkerAbsolute = cnf.arrowMarkerAbsolute;
        setConfig({ flowchart: { arrowMarkerAbsolute: cnf.arrowMarkerAbsolute } });
        flowRendererV2.setConf(cnf.flowchart);
        flowDb.clear();
        flowDb.setGen("gen-2");
      }
    },
    flowDetectorV2
  );
  registerDiagram(
    "gitGraph",
    { parser: parser$b, db: gitGraphDb, renderer: gitGraphRenderer, styles: getStyles },
    gitGraphDetector
  );
};
class Diagram {
  constructor(txt, parseError) {
    __publicField(this, "type", "graph");
    __publicField(this, "parser");
    __publicField(this, "renderer");
    __publicField(this, "db");
    __publicField(this, "detectTypeFailed", false);
    var _a, _b;
    this.txt = txt;
    const cnf = getConfig$1();
    this.txt = txt;
    try {
      this.type = detectType(txt, cnf);
    } catch (e) {
      this.handleError(e, parseError);
      this.type = "error";
      this.detectTypeFailed = true;
    }
    const diagram = getDiagram(this.type);
    log$1.debug("Type " + this.type);
    this.db = diagram.db;
    (_b = (_a = this.db).clear) == null ? void 0 : _b.call(_a);
    this.renderer = diagram.renderer;
    this.parser = diagram.parser;
    this.parser.parser.yy = this.db;
    if (diagram.init) {
      diagram.init(cnf);
      log$1.debug("Initialized diagram " + this.type, cnf);
    }
    this.txt += "\n";
    this.parse(this.txt, parseError);
  }
  parse(text2, parseError) {
    if (this.detectTypeFailed) {
      return false;
    }
    try {
      text2 = text2 + "\n";
      this.db.clear();
      this.parser.parse(text2);
      return true;
    } catch (error) {
      this.handleError(error, parseError);
    }
    return false;
  }
  handleError(error, parseError) {
    if (parseError) {
      if (isDetailedError(error)) {
        parseError(error.str, error.hash);
      } else {
        parseError(error);
      }
    } else {
      throw error;
    }
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
}
const getDiagramFromText = (txt, parseError) => {
  const type2 = detectType(txt, getConfig$1());
  try {
    getDiagram(type2);
    return new Diagram(txt, parseError);
  } catch (error) {
    if (!(error instanceof DiagramNotFoundError)) {
      log$1.error(error);
      throw error;
    }
    const loader = getDiagramLoader(type2);
    if (!loader) {
      throw new Error(`Loader for ${type2} not found.`);
    }
    return loader().then(({ diagram }) => {
      registerDiagram(type2, diagram, void 0);
      return new Diagram(txt, parseError);
    });
  }
};
function parse$1(text2, parseError) {
  addDiagrams();
  const diagram = new Diagram(text2, parseError);
  return diagram.parse(text2, parseError);
}
async function parseAsync$1(text2, parseError) {
  addDiagrams();
  const diagram = await getDiagramFromText(text2, parseError);
  return diagram.parse(text2, parseError);
}
const encodeEntities = function(text2) {
  let txt = text2;
  txt = txt.replace(/style.*:\S*#.*;/g, function(s2) {
    const innerTxt = s2.substring(0, s2.length - 1);
    return innerTxt;
  });
  txt = txt.replace(/classDef.*:\S*#.*;/g, function(s2) {
    const innerTxt = s2.substring(0, s2.length - 1);
    return innerTxt;
  });
  txt = txt.replace(/#\w+;/g, function(s2) {
    const innerTxt = s2.substring(1, s2.length - 1);
    const isInt = /^\+?\d+$/.test(innerTxt);
    if (isInt) {
      return "\uFB02\xB0\xB0" + innerTxt + "\xB6\xDF";
    } else {
      return "\uFB02\xB0" + innerTxt + "\xB6\xDF";
    }
  });
  return txt;
};
const decodeEntities = function(text2) {
  let txt = text2;
  txt = txt.replace(//g, function() {
    return "&#";
  });
  txt = txt.replace(//g, function() {
    return "&";
  });
  txt = txt.replace(//g, function() {
    return ";";
  });
  return txt;
};
const render = function(id2, text2, cb, container) {
  var _a;
  addDiagrams();
  reset();
  text2 = text2.replace(/\r\n?/g, "\n");
  const graphInit = utils.detectInit(text2);
  if (graphInit) {
    directiveSanitizer(graphInit);
    addDirective(graphInit);
  }
  const cnf = getConfig$1();
  log$1.debug(cnf);
  if (text2.length > cnf.maxTextSize) {
    text2 = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
  }
  let root2 = select$1("body");
  if (typeof container !== "undefined") {
    if (container) {
      container.innerHTML = "";
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1(container).append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1(container);
    }
    root2.append("div").attr("id", "d" + id2).attr("style", "font-family: " + cnf.fontFamily).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").append("g");
  } else {
    const existingSvg = document.getElementById(id2);
    if (existingSvg) {
      existingSvg.remove();
    }
    let element2;
    if (cnf.securityLevel === "sandbox") {
      element2 = document.querySelector("#i" + id2);
    } else {
      element2 = document.querySelector("#d" + id2);
    }
    if (element2) {
      element2.remove();
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1("body").append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1("body");
    }
    root2.append("div").attr("id", "d" + id2).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").append("g");
  }
  text2 = encodeEntities(text2);
  let diag;
  let parseEncounteredException;
  try {
    diag = getDiagramFromText(text2);
    if ("then" in diag) {
      throw new Error("Diagram is a promise");
    }
  } catch (error) {
    diag = new Diagram("error");
    parseEncounteredException = error;
  }
  const element = root2.select("#d" + id2).node();
  const graphType = diag.type;
  const svg2 = element.firstChild;
  const firstChild = svg2.firstChild;
  let userStyles = "";
  if (cnf.themeCSS !== void 0) {
    userStyles += `
${cnf.themeCSS}`;
  }
  if (cnf.fontFamily !== void 0) {
    userStyles += `
:root { --mermaid-font-family: ${cnf.fontFamily}}`;
  }
  if (cnf.altFontFamily !== void 0) {
    userStyles += `
:root { --mermaid-alt-font-family: ${cnf.altFontFamily}}`;
  }
  if (graphType === "flowchart" || graphType === "flowchart-v2" || graphType === "graph") {
    const classes2 = flowRenderer.getClasses(text2, diag);
    const htmlLabels = cnf.htmlLabels || ((_a = cnf.flowchart) == null ? void 0 : _a.htmlLabels);
    for (const className in classes2) {
      if (htmlLabels) {
        userStyles += `
.${className} > * { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} span { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
      } else {
        userStyles += `
.${className} path { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} rect { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} polygon { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} ellipse { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} circle { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        if (classes2[className].textStyles) {
          userStyles += `
.${className} tspan { ${classes2[className].textStyles.join(
            " !important; "
          )} !important; }`;
        }
      }
    }
  }
  const stylis = (selector2, styles) => serialize(compile(`${selector2}{${styles}}`), stringify);
  const rules = stylis(`#${id2}`, getStyles$1(graphType, userStyles, cnf.themeVariables));
  const style1 = document.createElement("style");
  style1.innerHTML = `#${id2} ` + rules;
  svg2.insertBefore(style1, firstChild);
  try {
    diag.renderer.draw(text2, id2, pkg.version, diag);
  } catch (e) {
    errorRenderer.draw(text2, id2, pkg.version);
    throw e;
  }
  root2.select(`[id="${id2}"]`).selectAll("foreignobject > *").attr("xmlns", "http://www.w3.org/1999/xhtml");
  let svgCode = root2.select("#d" + id2).node().innerHTML;
  log$1.debug("cnf.arrowMarkerAbsolute", cnf.arrowMarkerAbsolute);
  if (!evaluate(cnf.arrowMarkerAbsolute) && cnf.securityLevel !== "sandbox") {
    svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', "g");
  }
  svgCode = decodeEntities(svgCode);
  svgCode = svgCode.replace(/<br>/g, "<br/>");
  if (cnf.securityLevel === "sandbox") {
    const svgEl = root2.select("#d" + id2 + " svg").node();
    const width2 = "100%";
    let height2 = "100%";
    if (svgEl) {
      height2 = svgEl.viewBox.baseVal.height + "px";
    }
    svgCode = `<iframe style="width:${width2};height:${height2};border:0;margin:0;" src="data:text/html;base64,${btoa(
      '<body style="margin:0">' + svgCode + "</body>"
    )}" sandbox="allow-top-navigation-by-user-activation allow-popups">
  The \u201Ciframe\u201D tag is not supported by your browser.
</iframe>`;
  } else {
    if (cnf.securityLevel !== "loose") {
      svgCode = purify.sanitize(svgCode, {
        ADD_TAGS: ["foreignobject"],
        ADD_ATTR: ["dominant-baseline"]
      });
    }
  }
  if (typeof cb !== "undefined") {
    switch (graphType) {
      case "flowchart":
      case "flowchart-v2":
        cb(svgCode, flowDb.bindFunctions);
        break;
      case "gantt":
        cb(svgCode, ganttDb.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        cb(svgCode, classDb.bindFunctions);
        break;
      default:
        cb(svgCode);
    }
  } else {
    log$1.debug("CB = undefined!");
  }
  attachFunctions();
  const tmpElementSelector = cnf.securityLevel === "sandbox" ? "#i" + id2 : "#d" + id2;
  const node2 = select$1(tmpElementSelector).node();
  if (node2 && "remove" in node2) {
    node2.remove();
  }
  if (parseEncounteredException) {
    throw parseEncounteredException;
  }
  return svgCode;
};
const renderAsync$1 = async function(id2, text2, cb, container) {
  var _a;
  addDiagrams();
  reset();
  text2 = text2.replace(/\r\n?/g, "\n");
  const graphInit = utils.detectInit(text2);
  if (graphInit) {
    directiveSanitizer(graphInit);
    addDirective(graphInit);
  }
  const cnf = getConfig$1();
  log$1.debug(cnf);
  if (text2.length > cnf.maxTextSize) {
    text2 = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
  }
  let root2 = select$1("body");
  if (typeof container !== "undefined") {
    if (container) {
      container.innerHTML = "";
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1(container).append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1(container);
    }
    root2.append("div").attr("id", "d" + id2).attr("style", "font-family: " + cnf.fontFamily).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").attr("xmlns:xlink", "http://www.w3.org/1999/xlink").append("g");
  } else {
    const existingSvg = document.getElementById(id2);
    if (existingSvg) {
      existingSvg.remove();
    }
    let element2;
    if (cnf.securityLevel === "sandbox") {
      element2 = document.querySelector("#i" + id2);
    } else {
      element2 = document.querySelector("#d" + id2);
    }
    if (element2) {
      element2.remove();
    }
    if (cnf.securityLevel === "sandbox") {
      const iframe = select$1("body").append("iframe").attr("id", "i" + id2).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
      root2 = select$1(iframe.nodes()[0].contentDocument.body);
      root2.node().style.margin = 0;
    } else {
      root2 = select$1("body");
    }
    root2.append("div").attr("id", "d" + id2).append("svg").attr("id", id2).attr("width", "100%").attr("xmlns", "http://www.w3.org/2000/svg").append("g");
  }
  text2 = encodeEntities(text2);
  let diag;
  let parseEncounteredException;
  try {
    diag = await getDiagramFromText(text2);
  } catch (error) {
    diag = new Diagram("error");
    parseEncounteredException = error;
  }
  const element = root2.select("#d" + id2).node();
  const graphType = diag.type;
  const svg2 = element.firstChild;
  const firstChild = svg2.firstChild;
  let userStyles = "";
  if (cnf.themeCSS !== void 0) {
    userStyles += `
${cnf.themeCSS}`;
  }
  if (cnf.fontFamily !== void 0) {
    userStyles += `
:root { --mermaid-font-family: ${cnf.fontFamily}}`;
  }
  if (cnf.altFontFamily !== void 0) {
    userStyles += `
:root { --mermaid-alt-font-family: ${cnf.altFontFamily}}`;
  }
  if (graphType === "flowchart" || graphType === "flowchart-v2" || graphType === "graph") {
    const classes2 = flowRenderer.getClasses(text2, diag);
    const htmlLabels = cnf.htmlLabels || ((_a = cnf.flowchart) == null ? void 0 : _a.htmlLabels);
    for (const className in classes2) {
      if (htmlLabels) {
        userStyles += `
.${className} > * { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} span { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
      } else {
        userStyles += `
.${className} path { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} rect { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} polygon { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} ellipse { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        userStyles += `
.${className} circle { ${classes2[className].styles.join(
          " !important; "
        )} !important; }`;
        if (classes2[className].textStyles) {
          userStyles += `
.${className} tspan { ${classes2[className].textStyles.join(
            " !important; "
          )} !important; }`;
        }
      }
    }
  }
  const stylis = (selector2, styles) => serialize(compile(`${selector2}{${styles}}`), stringify);
  const rules = stylis(`#${id2}`, getStyles$1(graphType, userStyles, cnf.themeVariables));
  const style1 = document.createElement("style");
  style1.innerHTML = `#${id2} ` + rules;
  svg2.insertBefore(style1, firstChild);
  try {
    await diag.renderer.draw(text2, id2, pkg.version, diag);
  } catch (e) {
    errorRenderer.draw(text2, id2, pkg.version);
    throw e;
  }
  root2.select(`[id="${id2}"]`).selectAll("foreignobject > *").attr("xmlns", "http://www.w3.org/1999/xhtml");
  let svgCode = root2.select("#d" + id2).node().innerHTML;
  log$1.debug("cnf.arrowMarkerAbsolute", cnf.arrowMarkerAbsolute);
  if (!evaluate(cnf.arrowMarkerAbsolute) && cnf.securityLevel !== "sandbox") {
    svgCode = svgCode.replace(/marker-end="url\(.*?#/g, 'marker-end="url(#', "g");
  }
  svgCode = decodeEntities(svgCode);
  svgCode = svgCode.replace(/<br>/g, "<br/>");
  if (cnf.securityLevel === "sandbox") {
    const svgEl = root2.select("#d" + id2 + " svg").node();
    const width2 = "100%";
    let height2 = "100%";
    if (svgEl) {
      height2 = svgEl.viewBox.baseVal.height + "px";
    }
    svgCode = `<iframe style="width:${width2};height:${height2};border:0;margin:0;" src="data:text/html;base64,${btoa(
      '<body style="margin:0">' + svgCode + "</body>"
    )}" sandbox="allow-top-navigation-by-user-activation allow-popups">
  The \u201Ciframe\u201D tag is not supported by your browser.
</iframe>`;
  } else {
    if (cnf.securityLevel !== "loose") {
      svgCode = purify.sanitize(svgCode, {
        ADD_TAGS: ["foreignobject"],
        ADD_ATTR: ["dominant-baseline"]
      });
    }
  }
  if (typeof cb !== "undefined") {
    switch (graphType) {
      case "flowchart":
      case "flowchart-v2":
        cb(svgCode, flowDb.bindFunctions);
        break;
      case "gantt":
        cb(svgCode, ganttDb.bindFunctions);
        break;
      case "class":
      case "classDiagram":
        cb(svgCode, classDb.bindFunctions);
        break;
      default:
        cb(svgCode);
    }
  } else {
    log$1.debug("CB = undefined!");
  }
  attachFunctions();
  const tmpElementSelector = cnf.securityLevel === "sandbox" ? "#i" + id2 : "#d" + id2;
  const node2 = select$1(tmpElementSelector).node();
  if (node2 && "remove" in node2) {
    node2.remove();
  }
  if (parseEncounteredException) {
    throw parseEncounteredException;
  }
  return svgCode;
};
let currentDirective = {};
const parseDirective = function(p, statement, context, type2) {
  try {
    if (statement !== void 0) {
      statement = statement.trim();
      switch (context) {
        case "open_directive":
          currentDirective = {};
          break;
        case "type_directive":
          if (!currentDirective)
            throw new Error("currentDirective is undefined");
          currentDirective.type = statement.toLowerCase();
          break;
        case "arg_directive":
          if (!currentDirective)
            throw new Error("currentDirective is undefined");
          currentDirective.args = JSON.parse(statement);
          break;
        case "close_directive":
          handleDirective(p, currentDirective, type2);
          currentDirective = void 0;
          break;
      }
    }
  } catch (error) {
    log$1.error(
      `Error while rendering sequenceDiagram directive: ${statement} jison context: ${context}`
    );
    log$1.error(error.message);
  }
};
const handleDirective = function(p, directive2, type2) {
  log$1.debug(`Directive type=${directive2.type} with args:`, directive2.args);
  switch (directive2.type) {
    case "init":
    case "initialize": {
      ["config"].forEach((prop) => {
        if (typeof directive2.args[prop] !== "undefined") {
          if (type2 === "flowchart-v2") {
            type2 = "flowchart";
          }
          directive2.args[type2] = directive2.args[prop];
          delete directive2.args[prop];
        }
      });
      log$1.debug("sanitize in handleDirective", directive2.args);
      directiveSanitizer(directive2.args);
      log$1.debug("sanitize in handleDirective (done)", directive2.args);
      addDirective(directive2.args);
      break;
    }
    case "wrap":
    case "nowrap":
      if (p && p["setWrap"]) {
        p.setWrap(directive2.type === "wrap");
      }
      break;
    case "themeCss":
      log$1.warn("themeCss encountered");
      break;
    default:
      log$1.warn(
        `Unhandled directive: source: '%%{${directive2.type}: ${JSON.stringify(
          directive2.args ? directive2.args : {}
        )}}%%`,
        directive2
      );
      break;
  }
};
function initialize$1(options2 = {}) {
  if (options2.fontFamily) {
    if (!options2.themeVariables) {
      options2.themeVariables = {};
    }
    options2.themeVariables.fontFamily = options2.fontFamily;
  }
  saveConfigFromInitialize(options2);
  if ((options2 == null ? void 0 : options2.theme) && options2.theme in theme) {
    options2.themeVariables = theme[options2.theme].getThemeVariables(
      options2.themeVariables
    );
  } else if (options2) {
    options2.themeVariables = theme.default.getThemeVariables(options2.themeVariables);
  }
  const config2 = typeof options2 === "object" ? setSiteConfig(options2) : getSiteConfig();
  setLogLevel$1(config2.logLevel);
  addDiagrams();
}
const mermaidAPI = Object.freeze({
  render,
  renderAsync: renderAsync$1,
  parse: parse$1,
  parseAsync: parseAsync$1,
  parseDirective,
  initialize: initialize$1,
  getConfig: getConfig$1,
  setConfig,
  getSiteConfig,
  updateSiteConfig,
  reset: () => {
    reset();
  },
  globalReset: () => {
    reset(defaultConfig);
  },
  defaultConfig
});
setLogLevel$1(getConfig$1().logLevel);
reset(getConfig$1());
let externalDiagramsRegistered = false;
const init = async function(config2, nodes, callback) {
  try {
    if (externalDiagramsRegistered) {
      await initThrowsErrorsAsync(config2, nodes, callback);
    } else {
      initThrowsErrors(config2, nodes, callback);
    }
  } catch (e) {
    log$1.warn("Syntax Error rendering");
    if (isDetailedError(e)) {
      log$1.warn(e.str);
    }
    if (mermaid.parseError) {
      mermaid.parseError(e);
    }
  }
};
const handleError = (error, errors, parseError) => {
  log$1.warn(error);
  if (isDetailedError(error)) {
    if (parseError) {
      parseError(error.str, error.hash);
    }
    errors.push({ ...error, message: error.str, error });
  } else {
    if (parseError) {
      parseError(error);
    }
    if (error instanceof Error) {
      errors.push({
        str: error.message,
        message: error.message,
        hash: error.name,
        error
      });
    }
  }
};
const initThrowsErrors = function(config2, nodes, callback) {
  const conf2 = mermaidAPI.getConfig();
  if (config2) {
    mermaid.sequenceConfig = config2;
  }
  log$1.debug(`${!callback ? "No " : ""}Callback function found`);
  let nodesToProcess;
  if (typeof nodes === "undefined") {
    nodesToProcess = document.querySelectorAll(".mermaid");
  } else if (typeof nodes === "string") {
    nodesToProcess = document.querySelectorAll(nodes);
  } else if (nodes instanceof HTMLElement) {
    nodesToProcess = [nodes];
  } else if (nodes instanceof NodeList) {
    nodesToProcess = nodes;
  } else {
    throw new Error("Invalid argument nodes for mermaid.init");
  }
  log$1.debug(`Found ${nodesToProcess.length} diagrams`);
  if (typeof (config2 == null ? void 0 : config2.startOnLoad) !== "undefined") {
    log$1.debug("Start On Load: " + (config2 == null ? void 0 : config2.startOnLoad));
    mermaidAPI.updateSiteConfig({ startOnLoad: config2 == null ? void 0 : config2.startOnLoad });
  }
  const idGenerator = new utils.initIdGenerator(conf2.deterministicIds, conf2.deterministicIDSeed);
  let txt;
  const errors = [];
  for (const element of Array.from(nodesToProcess)) {
    log$1.info("Rendering diagram: " + element.id);
    /*! Check if previously processed */
    if (element.getAttribute("data-processed")) {
      continue;
    }
    element.setAttribute("data-processed", "true");
    const id2 = `mermaid-${idGenerator.next()}`;
    txt = element.innerHTML;
    txt = utils.entityDecode(txt).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const init2 = utils.detectInit(txt);
    if (init2) {
      log$1.debug("Detected early reinit: ", init2);
    }
    try {
      mermaidAPI.render(
        id2,
        txt,
        (svgCode, bindFunctions2) => {
          element.innerHTML = svgCode;
          if (typeof callback !== "undefined") {
            callback(id2);
          }
          if (bindFunctions2)
            bindFunctions2(element);
        },
        element
      );
    } catch (error) {
      handleError(error, errors, mermaid.parseError);
    }
  }
  if (errors.length > 0) {
    throw errors[0];
  }
};
const registerLazyLoadedDiagrams = (diagrams2) => {
  for (const { id: id2, detector, loader } of diagrams2) {
    addDetector(id2, detector, loader);
  }
};
const loadExternalDiagrams = async (diagrams2) => {
  log$1.debug(`Loading ${diagrams2.length} external diagrams`);
  const results = await Promise.allSettled(
    diagrams2.map(async ({ id: id2, detector, loader }) => {
      const { diagram } = await loader();
      registerDiagram(id2, diagram, detector);
    })
  );
  const failed = results.filter((result) => result.status === "rejected");
  if (failed.length > 0) {
    log$1.error(`Failed to load ${failed.length} external diagrams`);
    for (const res of failed) {
      log$1.error(res);
    }
    throw new Error(`Failed to load ${failed.length} external diagrams`);
  }
};
const initThrowsErrorsAsync = async function(config2, nodes, callback) {
  const conf2 = mermaidAPI.getConfig();
  if (config2) {
    mermaid.sequenceConfig = config2;
  }
  log$1.debug(`${!callback ? "No " : ""}Callback function found`);
  let nodesToProcess;
  if (typeof nodes === "undefined") {
    nodesToProcess = document.querySelectorAll(".mermaid");
  } else if (typeof nodes === "string") {
    nodesToProcess = document.querySelectorAll(nodes);
  } else if (nodes instanceof HTMLElement) {
    nodesToProcess = [nodes];
  } else if (nodes instanceof NodeList) {
    nodesToProcess = nodes;
  } else {
    throw new Error("Invalid argument nodes for mermaid.init");
  }
  log$1.debug(`Found ${nodesToProcess.length} diagrams`);
  if (typeof (config2 == null ? void 0 : config2.startOnLoad) !== "undefined") {
    log$1.debug("Start On Load: " + (config2 == null ? void 0 : config2.startOnLoad));
    mermaidAPI.updateSiteConfig({ startOnLoad: config2 == null ? void 0 : config2.startOnLoad });
  }
  const idGenerator = new utils.initIdGenerator(conf2.deterministicIds, conf2.deterministicIDSeed);
  let txt;
  const errors = [];
  for (const element of Array.from(nodesToProcess)) {
    log$1.info("Rendering diagram: " + element.id);
    /*! Check if previously processed */
    if (element.getAttribute("data-processed")) {
      continue;
    }
    element.setAttribute("data-processed", "true");
    const id2 = `mermaid-${idGenerator.next()}`;
    txt = element.innerHTML;
    txt = utils.entityDecode(txt).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const init2 = utils.detectInit(txt);
    if (init2) {
      log$1.debug("Detected early reinit: ", init2);
    }
    try {
      await mermaidAPI.renderAsync(
        id2,
        txt,
        (svgCode, bindFunctions2) => {
          element.innerHTML = svgCode;
          if (typeof callback !== "undefined") {
            callback(id2);
          }
          if (bindFunctions2)
            bindFunctions2(element);
        },
        element
      );
    } catch (error) {
      handleError(error, errors, mermaid.parseError);
    }
  }
  if (errors.length > 0) {
    throw errors[0];
  }
};
const initialize = function(config2) {
  mermaidAPI.initialize(config2);
};
const registerExternalDiagrams = async (diagrams2, {
  lazyLoad = true
} = {}) => {
  if (lazyLoad) {
    registerLazyLoadedDiagrams(diagrams2);
  } else {
    await loadExternalDiagrams(diagrams2);
  }
  externalDiagramsRegistered = true;
};
const contentLoaded = function() {
  if (mermaid.startOnLoad) {
    const { startOnLoad } = mermaidAPI.getConfig();
    if (startOnLoad) {
      mermaid.init();
    }
  }
};
if (typeof document !== "undefined") {
  /*!
   * Wait for document loaded before starting the execution
   */
  window.addEventListener("load", contentLoaded, false);
}
const setParseErrorHandler = function(newParseErrorHandler) {
  mermaid.parseError = newParseErrorHandler;
};
const parse = (txt) => {
  return mermaidAPI.parse(txt, mermaid.parseError);
};
const executionQueue = [];
let executionQueueRunning = false;
const executeQueue = async () => {
  if (executionQueueRunning) {
    return;
  }
  executionQueueRunning = true;
  while (executionQueue.length > 0) {
    const f = executionQueue.shift();
    if (f) {
      try {
        await f();
      } catch (e) {
        log$1.error("Error executing queue", e);
      }
    }
  }
  executionQueueRunning = false;
};
const parseAsync = (txt) => {
  return new Promise((resolve, reject) => {
    const performCall = () => new Promise((res, rej) => {
      mermaidAPI.parseAsync(txt, mermaid.parseError).then(
        (r) => {
          res(r);
          resolve(r);
        },
        (e) => {
          log$1.error("Error parsing", e);
          rej(e);
          reject(e);
        }
      );
    });
    executionQueue.push(performCall);
    executeQueue();
  });
};
const renderAsync = (id2, text2, cb, container) => {
  return new Promise((resolve, reject) => {
    const performCall = () => new Promise((res, rej) => {
      mermaidAPI.renderAsync(id2, text2, cb, container).then(
        (r) => {
          res(r);
          resolve(r);
        },
        (e) => {
          log$1.error("Error parsing", e);
          rej(e);
          reject(e);
        }
      );
    });
    executionQueue.push(performCall);
    executeQueue();
  });
};
const mermaid = {
  startOnLoad: true,
  diagrams: {},
  mermaidAPI,
  parse,
  parseAsync,
  render: mermaidAPI.render,
  renderAsync,
  init,
  initThrowsErrors,
  initThrowsErrorsAsync,
  registerExternalDiagrams,
  initialize,
  parseError: void 0,
  contentLoaded,
  setParseErrorHandler
};
export {
  mermaid as default
};
//# sourceMappingURL=mermaid.core.9fe297ed.js.map
